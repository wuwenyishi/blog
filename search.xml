<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Seata-server启动闪退问题</title>
    <url>/posts/39AKQ95.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>第一步：查看错误日志</p>
<p>打开cmd</p>
<p><img data-src="https://xuemingde.com/pages/image/others/51f427944a211ae872822076007567e3.png" alt="img"></p>
<p>运行seata-server.bat查看错误信息</p>
<p><img data-src="https://xuemingde.com/pages/image/others/d6aa39237babca365050ee5a2cdaaf1b.png" alt="img"></p>
<p>Error: missing server’ JVl at C:\ Program Files (x86)\ Javaljre1. 8. 0_221\ bin\ server \ jvn. d11<br>Please instal1 or use the TRE or TDK that contains these missing components</p>
<p>找到出错目录</p>
<p><img data-src="https://xuemingde.com/pages/image/others/dd08f00ad0d66c1d03d8a4c13a5cb16b.png" alt="img"></p>
<p>搜索jvm.dll</p>
<p><img data-src="https://xuemingde.com/pages/image/others/cdf348d3c0180b22eb39ccf59338cbcd.png" alt="img"></p>
<p>在bin文件夹新建server，复制jvm.dll黏贴</p>
<p><img data-src="https://xuemingde.com/pages/image/others/5efb1191067265b42c97f139f3a7f6a5.png" alt="img"></p>
<p>返回cmd，重新运行seata-server.bat</p>
<p><img data-src="https://xuemingde.com/pages/image/others/7ef391ac9de4b7b27c4ca1fb5b78ba0d.png" alt="img"></p>
<p>说明我们没有足够的内存去使用，所以我们要降级我们内存的配置</p>
<p>用记事本方式打开seata-server.bat，找到参数设置</p>
<p><img data-src="https://xuemingde.com/pages/image/others/57d754d19a5aa3a373861fadaa01d4d4.png" alt="img"></p>
<p>将其设置为1024,1024，512即可</p>
<p><img data-src="https://xuemingde.com/pages/image/others/bb870c732e5a25d30a14c8aafce72d18.png" alt="img"></p>
<p>然后再次在cmd窗口中运行seata-server.bat</p>
<p><img data-src="https://xuemingde.com/pages/image/others/9540a6fbf3b5bf045543e90fe103cfd8.png" alt="img"></p>
<p>如此解决了seata-server闪退的问题</p>
<p>问题二</p>
<p>启动报下面的错误</p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210312162616878.png" alt="image-20210312162616878"></p>
<p>打开nacos，找到配置</p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210312163932230.png" alt="image-20210312163932230"></p>
<p>在链接后面加上&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC，然后发布，重新执行seata-server.bat</p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210312163953737.png" alt="image-20210312163953737"></p>
<p>启动成功：</p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210312164119600.png" alt="image-20210312164119600"></p>
<blockquote>
<p>参考文章：<span class="exturl" data-url="aHR0cHM6Ly93d3cucGlhbnNoZW4uY29tL2FydGljbGUvOTc3NTEzNjEwODkv">https://www.pianshen.com/article/97751361089/<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
]]></content>
      <categories>
        <category>BUG</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>C</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 打包报错</title>
    <url>/posts/32Z7N4H.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><div style="text-align: center;">
</div><br><span id="more"></span></p>
<p>Hexo g 打包报错：</p>
<p><code>can not read a block mapping entry; a multiline key may not be an implicit key at line 5, column 1</code></p>
<p>是在md文件中使用了 <code>---</code> 作为分割线 的缘故。删除即可。</p>
<p>如果使用分割线，可以使用  <code>***</code></p>
<hr>
]]></content>
      <categories>
        <category>BUG</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>springBoot项目打成的jar包无法获取resources下文件</title>
    <url>/posts/3V4Q1GY.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><div style="text-align: center;">
[Gitee原文](https://gitee.com/meader/hexo-blog/blob/blog/source/_posts/BUG/20220217-springBoot%E9%A1%B9%E7%9B%AE%E6%89%93%E6%88%90%E7%9A%84jar%E5%8C%85%E6%97%A0%E6%B3%95%E8%8E%B7%E5%8F%96resources%E4%B8%8B%E6%96%87%E4%BB%B6.md) 
</div><br><span id="more"></span><br>错误：</p>
<blockquote>
<p>cannot be resolved to absolute file path because it does not reside in the file system: jar:file:/U  </p>
</blockquote>
<p>spring boot项目打成的 jar包无法获取src/main/resources下文件  </p>
<p><img data-src="https://xuemingde.com/pages/image/others/bdDMAq.png" alt="bdDMAq"><br>打成Jar后<br><img data-src="https://xuemingde.com/pages/image/others/yC8St7.png" alt="yC8St7">  </p>
<p>获取resources下的文件<br><img data-src="https://xuemingde.com/pages/image/others/et123k.png" alt="et123k">  </p>
<pre><code class="lang-java"> ClassPathResource classPathResource = new ClassPathResource(&quot;img/tofflon-logo.png&quot;);
 URL url = classPathResource.getURL();
 Image image = Image.getInstance(url);
</code></pre>
]]></content>
      <categories>
        <category>BUG</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>Spring</tag>
        <tag>SpringBoot</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>easypoi导入Excel表格报错</title>
    <url>/posts/HAXCJE.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><div style="text-align: center;">
[Gitee原文](https://gitee.com/meader/hexo-blog/blob/blog/source/_posts/BUG/20220308-easypoi%E5%AF%BC%E5%85%A5Excel%E8%A1%A8%E6%A0%BC%E6%8A%A5%E9%94%99.md) 
</div><br><span id="more"></span></p>
<p>错误信息</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">Handler dispatch failed; nested exception is java.lang.NoSuchMethodError: org.apache.poi.ss.usermodel.Cell.getCellType()Lorg<span class="regexp">/apache/</span>poi<span class="regexp">/ss/u</span>sermodel/CellType;</span><br></pre></td></tr></table></figure>
<p>查看源码，发现这个地方报错</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/08/OfMAOd.png" alt="OfMAOd"></p>
<p>poi版本导致（3.17），到时从easypoi中去除poi，重新引用新版本的poi（5.0.0），还是会加载出3.17版本的，未找到原因，最后的解决方法是，重写了easypoi的Excel导入功能。</p>
<p>重写代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcelUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 *  重写了 easypoi导入，因为easypoi的导入报错</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> inputstream</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> pojoClass</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">importExcelRewrite</span><span class="params">(InputStream inputstream, Class&lt;?&gt; pojoClass, ImportParams params)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ExcelImportServiceImok().importExcelByIss(inputstream, pojoClass, params, <span class="keyword">false</span>).getList();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.afterturn.easypoi.entity.BaseTypeConstants;</span><br><span class="line"><span class="keyword">import</span> cn.afterturn.easypoi.excel.annotation.ExcelTarget;</span><br><span class="line"><span class="keyword">import</span> cn.afterturn.easypoi.excel.entity.ImportParams;</span><br><span class="line"><span class="keyword">import</span> cn.afterturn.easypoi.excel.entity.params.ExcelCollectionParams;</span><br><span class="line"><span class="keyword">import</span> cn.afterturn.easypoi.excel.entity.params.ExcelImportEntity;</span><br><span class="line"><span class="keyword">import</span> cn.afterturn.easypoi.excel.entity.result.ExcelImportResult;</span><br><span class="line"><span class="keyword">import</span> cn.afterturn.easypoi.excel.entity.result.ExcelVerifyHandlerResult;</span><br><span class="line"><span class="keyword">import</span> cn.afterturn.easypoi.excel.imports.ExcelImportService;</span><br><span class="line"><span class="keyword">import</span> cn.afterturn.easypoi.excel.imports.recursive.ExcelImportForkJoinWork;</span><br><span class="line"><span class="keyword">import</span> cn.afterturn.easypoi.exception.excel.ExcelImportException;</span><br><span class="line"><span class="keyword">import</span> cn.afterturn.easypoi.exception.excel.enums.ExcelImportEnum;</span><br><span class="line"><span class="keyword">import</span> cn.afterturn.easypoi.handler.inter.IExcelDataHandler;</span><br><span class="line"><span class="keyword">import</span> cn.afterturn.easypoi.handler.inter.IExcelDataModel;</span><br><span class="line"><span class="keyword">import</span> cn.afterturn.easypoi.handler.inter.IExcelDictHandler;</span><br><span class="line"><span class="keyword">import</span> cn.afterturn.easypoi.handler.inter.IExcelModel;</span><br><span class="line"><span class="keyword">import</span> cn.afterturn.easypoi.util.PoiPublicUtil;</span><br><span class="line"><span class="keyword">import</span> cn.afterturn.easypoi.util.PoiReflectorUtil;</span><br><span class="line"><span class="keyword">import</span> cn.afterturn.easypoi.util.PoiValidationUtil;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.builder.ReflectionToStringBuilder;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.time.DateUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.hssf.usermodel.HSSFSheet;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.hssf.usermodel.HSSFWorkbook;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.ss.formula.functions.T;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.ss.usermodel.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.util.IOUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.xssf.usermodel.XSSFSheet;</span><br><span class="line"><span class="keyword">import</span> org.apache.poi.xssf.usermodel.XSSFWorkbook;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"><span class="keyword">import</span> java.math.BigDecimal;</span><br><span class="line"><span class="keyword">import</span> java.sql.Time;</span><br><span class="line"><span class="keyword">import</span> java.sql.Timestamp;</span><br><span class="line"><span class="keyword">import</span> java.text.ParseException;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.time.ZoneId;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ForkJoinPool;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> X-MD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 重写表格导入</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2022年03月08日 14:56:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExcelImportServiceImok</span> <span class="keyword">extends</span> <span class="title">ExcelImportService</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ExcelImportServiceImok.class);</span><br><span class="line">	<span class="keyword">private</span> List&lt;String&gt; handlerList = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> verifyFail = <span class="keyword">false</span>;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 异常数据styler</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> CellStyle errorCellStyle;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> List&lt;Row&gt; successRow;</span><br><span class="line">	<span class="keyword">private</span> List&lt;Row&gt; failRow;</span><br><span class="line">	<span class="keyword">private</span> List failCollection;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ExcelImportServiceImok</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		successRow = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		failRow = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		failCollection = <span class="keyword">new</span> ArrayList();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/***</span></span><br><span class="line"><span class="comment">	 * 向List里面继续添加元素</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> object</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> param</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> row</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> titlemap</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> targetId</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> pictures</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addListContinues</span><span class="params">(Object object, ExcelCollectionParams param, Row row,</span></span></span><br><span class="line"><span class="function"><span class="params">								 Map&lt;Integer, String&gt; titlemap, String targetId,</span></span></span><br><span class="line"><span class="function"><span class="params">								 Map&lt;String, PictureData&gt; pictures,</span></span></span><br><span class="line"><span class="function"><span class="params">								 ImportParams params, StringBuilder errorMsg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Collection collection = (Collection) PoiReflectorUtil.fromCache(object.getClass())</span><br><span class="line">				.getValue(object, param.getName());</span><br><span class="line">		Object entity = PoiPublicUtil.createObject(param.getType(), targetId);</span><br><span class="line">		<span class="keyword">if</span> (entity <span class="keyword">instanceof</span> IExcelDataModel) &#123;</span><br><span class="line">			((IExcelDataModel) entity).setRowNum(row.getRowNum());</span><br><span class="line">		&#125;</span><br><span class="line">		String picId;</span><br><span class="line">		<span class="comment">// 是否需要加上这个对象</span></span><br><span class="line">		<span class="keyword">boolean</span> isUsed = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = row.getFirstCellNum(); i &lt; titlemap.size(); i++) &#123;</span><br><span class="line">			Cell cell = row.getCell(i);</span><br><span class="line">			String titleString = titlemap.get(i);</span><br><span class="line">			<span class="keyword">if</span> (param.getExcelParams().containsKey(titleString)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (param.getExcelParams().get(titleString).getType() == BaseTypeConstants.IMAGE_TYPE) &#123;</span><br><span class="line">					picId = row.getRowNum() + <span class="string">&quot;_&quot;</span> + i;</span><br><span class="line">					saveImage(entity, picId, param.getExcelParams(), titleString, pictures, params);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						saveFieldValues(params, entity, cell, param.getExcelParams(), titleString, row);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (ExcelImportException e) &#123;</span><br><span class="line">						<span class="comment">// 如果需要去校验就忽略,这个错误,继续执行</span></span><br><span class="line">						<span class="keyword">if</span> (params.isNeedVerify() &amp;&amp; ExcelImportEnum.GET_VALUE_ERROR.equals(e.getType())) &#123;</span><br><span class="line">							errorMsg.append(<span class="string">&quot; &quot;</span>).append(titleString).append(ExcelImportEnum.GET_VALUE_ERROR.getMsg());</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				isUsed = <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (isUsed) &#123;</span><br><span class="line">			collection.add(entity);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取key的值,针对不同类型获取不同的值</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@author</span> JueYue 2013-11-21</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">getKeyValue</span><span class="params">(Cell cell)</span> </span>&#123;</span><br><span class="line">		Object obj = PoiCellUtils.getCellValue(cell);</span><br><span class="line">		<span class="keyword">return</span> obj == <span class="keyword">null</span> ? <span class="keyword">null</span> : obj.toString().trim();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取保存的真实路径</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">getSaveUrl</span><span class="params">(ExcelImportEntity excelImportEntity, Object object)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (ExcelImportEntity.IMG_SAVE_PATH.equals(excelImportEntity.getSaveUrl())) &#123;</span><br><span class="line">			<span class="keyword">if</span> (excelImportEntity.getMethods() != <span class="keyword">null</span></span><br><span class="line">					&amp;&amp; excelImportEntity.getMethods().size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				object = getFieldBySomeMethod(excelImportEntity.getMethods(), object);</span><br><span class="line">			&#125;</span><br><span class="line">			String url = object.getClass().getName()</span><br><span class="line">					.split(<span class="string">&quot;\\.&quot;</span>)[object.getClass().getName().split(<span class="string">&quot;\\.&quot;</span>).length - <span class="number">1</span>];</span><br><span class="line">			<span class="keyword">return</span> excelImportEntity.getSaveUrl() + File.separator + url;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> excelImportEntity.getSaveUrl();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">importExcel</span><span class="params">(Collection&lt;T&gt; result, Sheet sheet, Class&lt;?&gt; pojoClass,</span></span></span><br><span class="line"><span class="function"><span class="params">									ImportParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">									Map&lt;String, PictureData&gt; pictures)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		List collection = <span class="keyword">new</span> ArrayList();</span><br><span class="line">		Map&lt;String, ExcelImportEntity&gt; excelParams = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		List&lt;ExcelCollectionParams&gt; excelCollection = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		String targetId = <span class="keyword">null</span>;</span><br><span class="line">		i18nHandler = params.getI18nHandler();</span><br><span class="line">		<span class="keyword">boolean</span> isMap = Map.class.equals(pojoClass);</span><br><span class="line">		<span class="keyword">if</span> (!isMap) &#123;</span><br><span class="line">			Field[] fileds = PoiPublicUtil.getClassFields(pojoClass);</span><br><span class="line">			ExcelTarget etarget = pojoClass.getAnnotation(ExcelTarget.class);</span><br><span class="line">			<span class="keyword">if</span> (etarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">				targetId = etarget.value();</span><br><span class="line">			&#125;</span><br><span class="line">			getAllExcelField(targetId, fileds, excelParams, excelCollection, pojoClass, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		Iterator&lt;Row&gt; rows = sheet.rowIterator();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; params.getTitleRows(); j++) &#123;</span><br><span class="line">			rows.next();</span><br><span class="line">		&#125;</span><br><span class="line">		Map&lt;Integer, String&gt; titlemap = getTitleMap(rows, params, excelCollection, excelParams);</span><br><span class="line">		checkIsValidTemplate(titlemap, excelParams, params, excelCollection);</span><br><span class="line">		Object object = <span class="keyword">null</span>;</span><br><span class="line">		String picId;</span><br><span class="line">		<span class="keyword">int</span> readRow = <span class="number">1</span>;</span><br><span class="line">		<span class="comment">//跳过无效行</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; params.getStartRows(); i++) &#123;</span><br><span class="line">			rows.next();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//判断index 和集合,集合情况默认为第一列</span></span><br><span class="line">		<span class="keyword">if</span> (excelCollection.size() &gt; <span class="number">0</span> &amp;&amp; params.getKeyIndex() == <span class="keyword">null</span>) &#123;</span><br><span class="line">			params.setKeyIndex(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> endRow = sheet.getLastRowNum() - params.getLastOfInvalidRow();</span><br><span class="line">		<span class="keyword">if</span> (params.getReadRows() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			endRow = Math.min(params.getReadRows(), endRow);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (params.isConcurrentTask()) &#123;</span><br><span class="line">			ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">			ExcelImportForkJoinWork task = <span class="keyword">new</span> ExcelImportForkJoinWork(params.getStartRows() + params.getHeadRows() + params.getTitleRows(), endRow, sheet, params, pojoClass, <span class="keyword">this</span>, targetId, titlemap, excelParams);</span><br><span class="line">			ExcelImportResult forkJoinResult = forkJoinPool.invoke(task);</span><br><span class="line">			collection = forkJoinResult.getList();</span><br><span class="line">			failCollection = forkJoinResult.getFailList();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			StringBuilder errorMsg;</span><br><span class="line">			<span class="keyword">while</span> (rows.hasNext()) &#123;</span><br><span class="line">				Row row = rows.next();</span><br><span class="line">				<span class="comment">// Fix 如果row为无效行时候跳出</span></span><br><span class="line">				<span class="keyword">if</span> (row.getRowNum() &gt; endRow) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">/* 如果当前行的单元格都是无效的，那就继续下一行 */</span></span><br><span class="line">				<span class="keyword">if</span> (row.getLastCellNum() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (isMap &amp;&amp; object != <span class="keyword">null</span>) &#123;</span><br><span class="line">					((Map) object).put(<span class="string">&quot;excelRowNum&quot;</span>, row.getRowNum());</span><br><span class="line">				&#125;</span><br><span class="line">				errorMsg = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">				<span class="comment">// 判断是集合元素还是不是集合元素,如果是就继续加入这个集合,不是就创建新的对象</span></span><br><span class="line">				<span class="comment">// keyIndex 如果为空就不处理,仍然处理这一行</span></span><br><span class="line">				<span class="keyword">if</span> (params.getKeyIndex() != <span class="keyword">null</span></span><br><span class="line">						&amp;&amp; (row.getCell(params.getKeyIndex()) == <span class="keyword">null</span></span><br><span class="line">						|| StringUtils.isEmpty(getKeyValue(row.getCell(params.getKeyIndex()))))</span><br><span class="line">						&amp;&amp; object != <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">for</span> (ExcelCollectionParams param : excelCollection) &#123;</span><br><span class="line">						addListContinues(object, param, row, titlemap, targetId, pictures, params, errorMsg);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					object = PoiPublicUtil.createObject(pojoClass, targetId);</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Set&lt;Integer&gt; keys = titlemap.keySet();</span><br><span class="line">						<span class="keyword">for</span> (Integer cn : keys) &#123;</span><br><span class="line">							Cell cell = row.getCell(cn);</span><br><span class="line">							String titleString = titlemap.get(cn);</span><br><span class="line">							<span class="keyword">if</span> (excelParams.containsKey(titleString) || isMap) &#123;</span><br><span class="line">								<span class="keyword">if</span> (excelParams.get(titleString) != <span class="keyword">null</span></span><br><span class="line">										&amp;&amp; excelParams.get(titleString).getType() == BaseTypeConstants.IMAGE_TYPE) &#123;</span><br><span class="line">									picId = row.getRowNum() + <span class="string">&quot;_&quot;</span> + cn;</span><br><span class="line">									saveImage(object, picId, excelParams, titleString, pictures,</span><br><span class="line">											params);</span><br><span class="line">								&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">									<span class="keyword">try</span> &#123;</span><br><span class="line">										saveFieldValues(params, object, cell, excelParams, titleString, row);</span><br><span class="line">									&#125; <span class="keyword">catch</span> (ExcelImportException e) &#123;</span><br><span class="line">										<span class="comment">// 如果需要去校验就忽略,这个错误,继续执行</span></span><br><span class="line">										<span class="keyword">if</span> (params.isNeedVerify() &amp;&amp; ExcelImportEnum.GET_VALUE_ERROR.equals(e.getType())) &#123;</span><br><span class="line">											errorMsg.append(<span class="string">&quot; &quot;</span>).append(titleString).append(ExcelImportEnum.GET_VALUE_ERROR.getMsg());</span><br><span class="line">										&#125;</span><br><span class="line">									&#125;</span><br><span class="line">								&#125;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line"></span><br><span class="line">						<span class="keyword">if</span> (object <span class="keyword">instanceof</span> IExcelDataModel) &#123;</span><br><span class="line">							((IExcelDataModel) object).setRowNum(row.getRowNum());</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">for</span> (ExcelCollectionParams param : excelCollection) &#123;</span><br><span class="line">							addListContinues(object, param, row, titlemap, targetId, pictures, params, errorMsg);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">if</span> (verifyingDataValiditys(object, row, params, isMap, errorMsg)) &#123;</span><br><span class="line">							collection.add(object);</span><br><span class="line">						&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">							failCollection.add(object);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125; <span class="keyword">catch</span> (ExcelImportException e) &#123;</span><br><span class="line">						LOGGER.error(<span class="string">&quot;excel import error , row num:&#123;&#125;,obj:&#123;&#125;&quot;</span>, readRow, ReflectionToStringBuilder.toString(object));</span><br><span class="line">						<span class="keyword">if</span> (!e.getType().equals(ExcelImportEnum.VERIFY_ERROR)) &#123;</span><br><span class="line">							<span class="keyword">throw</span> <span class="keyword">new</span> ExcelImportException(e.getType(), e);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">						LOGGER.error(<span class="string">&quot;excel import error , row num:&#123;&#125;,obj:&#123;&#125;&quot;</span>, readRow, ReflectionToStringBuilder.toString(object));</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				readRow++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> collection;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 校验数据合法性</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verifyingDataValiditys</span><span class="params">(Object object, Row row, ImportParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">										  <span class="keyword">boolean</span> isMap, StringBuilder fieldErrorMsg)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">boolean</span> isAdd = <span class="keyword">true</span>;</span><br><span class="line">		Cell cell = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (params.isNeedVerify()) &#123;</span><br><span class="line">			String errorMsg = PoiValidationUtil.validation(object, params.getVerifyGroup());</span><br><span class="line">			<span class="keyword">if</span> (StringUtils.isNotEmpty(errorMsg)) &#123;</span><br><span class="line">				cell = row.createCell(row.getLastCellNum());</span><br><span class="line">				cell.setCellValue(errorMsg);</span><br><span class="line">				<span class="keyword">if</span> (object <span class="keyword">instanceof</span> IExcelModel) &#123;</span><br><span class="line">					IExcelModel model = (IExcelModel) object;</span><br><span class="line">					model.setErrorMsg(errorMsg);</span><br><span class="line">				&#125;</span><br><span class="line">				isAdd = <span class="keyword">false</span>;</span><br><span class="line">				verifyFail = <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (params.getVerifyHandler() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			ExcelVerifyHandlerResult result = params.getVerifyHandler().verifyHandler(object);</span><br><span class="line">			<span class="keyword">if</span> (!result.isSuccess()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (cell == <span class="keyword">null</span>) &#123;</span><br><span class="line">					cell = row.createCell(row.getLastCellNum());</span><br><span class="line">				&#125;</span><br><span class="line">				cell.setCellValue((StringUtils.isNoneBlank(cell.getStringCellValue())</span><br><span class="line">						? cell.getStringCellValue() + <span class="string">&quot;,&quot;</span> : <span class="string">&quot;&quot;</span>) + result.getMsg());</span><br><span class="line">				<span class="keyword">if</span> (object <span class="keyword">instanceof</span> IExcelModel) &#123;</span><br><span class="line">					IExcelModel model = (IExcelModel) object;</span><br><span class="line">					model.setErrorMsg((StringUtils.isNoneBlank(model.getErrorMsg())</span><br><span class="line">							? model.getErrorMsg() + <span class="string">&quot;,&quot;</span> : <span class="string">&quot;&quot;</span>) + result.getMsg());</span><br><span class="line">				&#125;</span><br><span class="line">				isAdd = <span class="keyword">false</span>;</span><br><span class="line">				verifyFail = <span class="keyword">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ((params.isNeedVerify() || params.getVerifyHandler() != <span class="keyword">null</span>) &amp;&amp; fieldErrorMsg.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (object <span class="keyword">instanceof</span> IExcelModel) &#123;</span><br><span class="line">				IExcelModel model = (IExcelModel) object;</span><br><span class="line">				model.setErrorMsg((StringUtils.isNoneBlank(model.getErrorMsg())</span><br><span class="line">						? model.getErrorMsg() + <span class="string">&quot;,&quot;</span> : <span class="string">&quot;&quot;</span>) + fieldErrorMsg.toString());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (cell == <span class="keyword">null</span>) &#123;</span><br><span class="line">				cell = row.createCell(row.getLastCellNum());</span><br><span class="line">			&#125;</span><br><span class="line">			cell.setCellValue((StringUtils.isNoneBlank(cell.getStringCellValue())</span><br><span class="line">					? cell.getStringCellValue() + <span class="string">&quot;,&quot;</span> : <span class="string">&quot;&quot;</span>) + fieldErrorMsg.toString());</span><br><span class="line">			isAdd = <span class="keyword">false</span>;</span><br><span class="line">			verifyFail = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cell != <span class="keyword">null</span>) &#123;</span><br><span class="line">			cell.setCellStyle(errorCellStyle);</span><br><span class="line">			failRow.add(row);</span><br><span class="line">			<span class="keyword">if</span> (isMap) &#123;</span><br><span class="line">				((Map) object).put(<span class="string">&quot;excelErrorMsg&quot;</span>, cell.getStringCellValue());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			successRow.add(row);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> isAdd;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取表格字段列名对应信息</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> Map&lt;Integer, String&gt; <span class="title">getTitleMap</span><span class="params">(Iterator&lt;Row&gt; rows, ImportParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">											 List&lt;ExcelCollectionParams&gt; excelCollection,</span></span></span><br><span class="line"><span class="function"><span class="params">											 Map&lt;String, ExcelImportEntity&gt; excelParams)</span> </span>&#123;</span><br><span class="line">		Map&lt;Integer, String&gt; titlemap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">		Iterator&lt;Cell&gt; cellTitle;</span><br><span class="line">		String collectionName = <span class="keyword">null</span>;</span><br><span class="line">		ExcelCollectionParams collectionParams = <span class="keyword">null</span>;</span><br><span class="line">		Row row = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; params.getHeadRows(); j++) &#123;</span><br><span class="line">			row = rows.next();</span><br><span class="line">			<span class="keyword">if</span> (row == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cellTitle = row.cellIterator();</span><br><span class="line">			<span class="keyword">while</span> (cellTitle.hasNext()) &#123;</span><br><span class="line">				Cell cell = cellTitle.next();</span><br><span class="line">				String value = getKeyValue(cell);</span><br><span class="line">				value = value.replace(<span class="string">&quot;\n&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">				<span class="keyword">int</span> i = cell.getColumnIndex();</span><br><span class="line">				<span class="comment">//用以支持重名导入</span></span><br><span class="line">				<span class="keyword">if</span> (StringUtils.isNotEmpty(value)) &#123;</span><br><span class="line">					<span class="keyword">if</span> (titlemap.containsKey(i)) &#123;</span><br><span class="line">						collectionName = titlemap.get(i);</span><br><span class="line">						collectionParams = getCollectionParams(excelCollection, collectionName);</span><br><span class="line">						titlemap.put(i, collectionName + <span class="string">&quot;_&quot;</span> + value);</span><br><span class="line">					&#125; <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.isNotEmpty(collectionName) &amp;&amp; collectionParams != <span class="keyword">null</span></span><br><span class="line">							&amp;&amp; collectionParams.getExcelParams()</span><br><span class="line">							.containsKey(collectionName + <span class="string">&quot;_&quot;</span> + value)) &#123;</span><br><span class="line">						titlemap.put(i, collectionName + <span class="string">&quot;_&quot;</span> + value);</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						collectionName = <span class="keyword">null</span>;</span><br><span class="line">						collectionParams = <span class="keyword">null</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (StringUtils.isEmpty(collectionName)) &#123;</span><br><span class="line">						titlemap.put(i, value);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 处理指定列的情况</span></span><br><span class="line">		Set&lt;String&gt; keys = excelParams.keySet();</span><br><span class="line">		<span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">			<span class="keyword">if</span> (key.startsWith(<span class="string">&quot;FIXED_&quot;</span>)) &#123;</span><br><span class="line">				String[] arr = key.split(<span class="string">&quot;_&quot;</span>);</span><br><span class="line">				titlemap.put(Integer.parseInt(arr[<span class="number">1</span>]), key);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> titlemap;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 获取这个名称对应的集合信息</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> ExcelCollectionParams <span class="title">getCollectionParams</span><span class="params">(List&lt;ExcelCollectionParams&gt; excelCollection,</span></span></span><br><span class="line"><span class="function"><span class="params">													  String collectionName)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (ExcelCollectionParams excelCollectionParams : excelCollection) &#123;</span><br><span class="line">			<span class="keyword">if</span> (collectionName.equals(excelCollectionParams.getExcelName())) &#123;</span><br><span class="line">				<span class="keyword">return</span> excelCollectionParams;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Excel 导入 field 字段类型 Integer,Long,Double,Date,String,Boolean</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ExcelImportResult <span class="title">importExcelByIss</span><span class="params">(InputStream inputstream, Class&lt;?&gt; pojoClass,</span></span></span><br><span class="line"><span class="function"><span class="params">											  ImportParams params, <span class="keyword">boolean</span> needMore)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">			LOGGER.debug(<span class="string">&quot;Excel import start ,class is &#123;&#125;&quot;</span>, pojoClass);</span><br><span class="line">		&#125;</span><br><span class="line">		List&lt;T&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">		ExcelImportResult importResult;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">			<span class="keyword">int</span> len;</span><br><span class="line">			<span class="keyword">while</span> ((len = inputstream.read(buffer)) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">				baos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">			&#125;</span><br><span class="line">			baos.flush();</span><br><span class="line"></span><br><span class="line">			InputStream userIs = <span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">			<span class="keyword">if</span> (LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">				LOGGER.debug(<span class="string">&quot;Excel clone success&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			Workbook book = WorkbookFactory.create(userIs);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">boolean</span> isXSSFWorkbook = !(book <span class="keyword">instanceof</span> HSSFWorkbook);</span><br><span class="line">			<span class="keyword">if</span> (LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">				LOGGER.debug(<span class="string">&quot;Workbook create success&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			importResult = <span class="keyword">new</span> ExcelImportResult();</span><br><span class="line">			createErrorCellStyle(book);</span><br><span class="line">			Map&lt;String, PictureData&gt; pictures;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = params.getStartSheetIndex(); i &lt; params.getStartSheetIndex()</span><br><span class="line">					+ params.getSheetNum(); i++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">					LOGGER.debug(<span class="string">&quot; start to read excel by is ,startTime is &#123;&#125;&quot;</span>, <span class="keyword">new</span> Date());</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (isXSSFWorkbook) &#123;</span><br><span class="line">					pictures = PoiPublicUtil.getSheetPictrues07((XSSFSheet) book.getSheetAt(i),</span><br><span class="line">							(XSSFWorkbook) book);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					pictures = PoiPublicUtil.getSheetPictrues03((HSSFSheet) book.getSheetAt(i),</span><br><span class="line">							(HSSFWorkbook) book);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">					LOGGER.debug(<span class="string">&quot; end to read excel by is ,endTime is &#123;&#125;&quot;</span>, <span class="keyword">new</span> Date());</span><br><span class="line">				&#125;</span><br><span class="line">				result.addAll(importExcel(result, book.getSheetAt(i), pojoClass, params, pictures));</span><br><span class="line">				<span class="keyword">if</span> (LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">					LOGGER.debug(<span class="string">&quot; end to read excel list by sheet ,endTime is &#123;&#125;&quot;</span>, <span class="keyword">new</span> Date());</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (params.isReadSingleCell()) &#123;</span><br><span class="line">					readSingleCell(importResult, book.getSheetAt(i), params);</span><br><span class="line">					<span class="keyword">if</span> (LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">						LOGGER.debug(<span class="string">&quot; read Key-Value ,endTime is &#123;&#125;&quot;</span>, System.currentTimeMillis());</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (params.isNeedSave()) &#123;</span><br><span class="line">				saveThisExcel(params, pojoClass, isXSSFWorkbook, book);</span><br><span class="line">			&#125;</span><br><span class="line">			importResult.setList(result);</span><br><span class="line">			<span class="keyword">if</span> (needMore) &#123;</span><br><span class="line">				InputStream successIs = <span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Workbook successBook = WorkbookFactory.create(successIs);</span><br><span class="line">					<span class="keyword">if</span> (params.isVerifyFileSplit()) &#123;</span><br><span class="line">						importResult.setWorkbook(removeSuperfluousRows(successBook, failRow, params));</span><br><span class="line">						importResult.setFailWorkbook(removeSuperfluousRows(book, successRow, params));</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						importResult.setWorkbook(book);</span><br><span class="line">					&#125;</span><br><span class="line">					importResult.setFailList(failCollection);</span><br><span class="line">					importResult.setVerifyFail(verifyFail);</span><br><span class="line">				&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">					successIs.close();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			IOUtils.closeQuietly(baos);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> importResult;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> Workbook <span class="title">removeSuperfluousRows</span><span class="params">(Workbook book, List&lt;Row&gt; rowList, ImportParams params)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = params.getStartSheetIndex(); i &lt; params.getStartSheetIndex()</span><br><span class="line">				+ params.getSheetNum(); i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = rowList.size() - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">				<span class="keyword">if</span> (rowList.get(j).getRowNum() &lt; rowList.get(j).getSheet().getLastRowNum()) &#123;</span><br><span class="line">					book.getSheetAt(i).shiftRows(rowList.get(j).getRowNum() + <span class="number">1</span>, rowList.get(j).getSheet().getLastRowNum(), -<span class="number">1</span>);</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rowList.get(j).getRowNum() == rowList.get(j).getSheet().getLastRowNum()) &#123;</span><br><span class="line">					book.getSheetAt(i).createRow(rowList.get(j).getRowNum() + <span class="number">1</span>);</span><br><span class="line">					book.getSheetAt(i).shiftRows(rowList.get(j).getRowNum() + <span class="number">1</span>, rowList.get(j).getSheet().getLastRowNum() + <span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> book;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 按照键值对的方式取得Excel里面的数据</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readSingleCell</span><span class="params">(ExcelImportResult result, Sheet sheet, ImportParams params)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (result.getMap() == <span class="keyword">null</span>) &#123;</span><br><span class="line">			result.setMap(<span class="keyword">new</span> HashMap&lt;String, Object&gt;());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; params.getTitleRows() + params.getHeadRows() + params.getStartRows(); i++) &#123;</span><br><span class="line">			getSingleCellValueForRow(result, sheet.getRow(i), params);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = sheet.getLastRowNum() - params.getLastOfInvalidRow(); i &lt; sheet.getLastRowNum(); i++) &#123;</span><br><span class="line">			getSingleCellValueForRow(result, sheet.getRow(i), params);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getSingleCellValueForRow</span><span class="params">(ExcelImportResult result, Row row, ImportParams params)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = row.getFirstCellNum(), le = row.getLastCellNum(); j &lt; le; j++) &#123;</span><br><span class="line">			String text = PoiCellUtils.getCellValue(row.getCell(j));</span><br><span class="line">			<span class="keyword">if</span> (StringUtils.isNoneBlank(text) &amp;&amp; text.endsWith(params.getKeyMark())) &#123;</span><br><span class="line">				<span class="keyword">if</span> (result.getMap().containsKey(text)) &#123;</span><br><span class="line">					<span class="keyword">if</span> (result.getMap().get(text) <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">						List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">						list.add((String) result.getMap().get(text));</span><br><span class="line">						result.getMap().put(text, list);</span><br><span class="line">					&#125;</span><br><span class="line">					((List) result.getMap().get(text)).add(PoiCellUtils.getCellValue(row.getCell(++j)));</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					result.getMap().put(text, PoiCellUtils.getCellValue(row.getCell(++j)));</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 检查是不是合法的模板</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkIsValidTemplate</span><span class="params">(Map&lt;Integer, String&gt; titlemap,</span></span></span><br><span class="line"><span class="function"><span class="params">									  Map&lt;String, ExcelImportEntity&gt; excelParams,</span></span></span><br><span class="line"><span class="function"><span class="params">									  ImportParams params,</span></span></span><br><span class="line"><span class="function"><span class="params">									  List&lt;ExcelCollectionParams&gt; excelCollection)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (params.getImportFields() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 同时校验列顺序</span></span><br><span class="line">			<span class="keyword">if</span> (params.isNeedCheckOrder()) &#123;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (params.getImportFields().length != titlemap.size()) &#123;</span><br><span class="line">					LOGGER.error(<span class="string">&quot;excel列顺序不一致&quot;</span>);</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> ExcelImportException(ExcelImportEnum.IS_NOT_A_VALID_TEMPLATE);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span> (String title : titlemap.values()) &#123;</span><br><span class="line">					<span class="keyword">if</span> (!StringUtils.equals(title, params.getImportFields()[i++])) &#123;</span><br><span class="line">						LOGGER.error(<span class="string">&quot;excel列顺序不一致&quot;</span>);</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> ExcelImportException(ExcelImportEnum.IS_NOT_A_VALID_TEMPLATE);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, le = params.getImportFields().length; i &lt; le; i++) &#123;</span><br><span class="line">					<span class="keyword">if</span> (!titlemap.containsValue(params.getImportFields()[i])) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> ExcelImportException(ExcelImportEnum.IS_NOT_A_VALID_TEMPLATE);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			Collection&lt;ExcelImportEntity&gt; collection = excelParams.values();</span><br><span class="line">			<span class="keyword">for</span> (ExcelImportEntity excelImportEntity : collection) &#123;</span><br><span class="line">				<span class="keyword">if</span> (excelImportEntity.isImportField()</span><br><span class="line">						&amp;&amp; !titlemap.containsValue(excelImportEntity.getName())) &#123;</span><br><span class="line">					LOGGER.error(excelImportEntity.getName() + <span class="string">&quot;必须有,但是没找到&quot;</span>);</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> ExcelImportException(ExcelImportEnum.IS_NOT_A_VALID_TEMPLATE);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, le = excelCollection.size(); i &lt; le; i++) &#123;</span><br><span class="line">				ExcelCollectionParams collectionparams = excelCollection.get(i);</span><br><span class="line">				collection = collectionparams.getExcelParams().values();</span><br><span class="line">				<span class="keyword">for</span> (ExcelImportEntity excelImportEntity : collection) &#123;</span><br><span class="line">					<span class="keyword">if</span> (excelImportEntity.isImportField() &amp;&amp; !titlemap.containsValue(</span><br><span class="line">							collectionparams.getExcelName() + <span class="string">&quot;_&quot;</span> + excelImportEntity.getName())) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> ExcelImportException(ExcelImportEnum.IS_NOT_A_VALID_TEMPLATE);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 保存字段值(获取值,校验值,追加错误信息)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveFieldValues</span><span class="params">(ImportParams params, Object object, Cell cell,</span></span></span><br><span class="line"><span class="function"><span class="params">								Map&lt;String, ExcelImportEntity&gt; excelParams, String titleString,</span></span></span><br><span class="line"><span class="function"><span class="params">								Row row)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Object value = getValues(params.getDataHandler(), object, cell, excelParams,</span><br><span class="line">				titleString, params.getDictHandler());</span><br><span class="line">		<span class="keyword">if</span> (object <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">			<span class="keyword">if</span> (params.getDataHandler() != <span class="keyword">null</span>) &#123;</span><br><span class="line">				params.getDataHandler().setMapValue((Map) object, titleString, value);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				((Map) object).put(titleString, value);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			setValues(excelParams.get(titleString), object, value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">getValues</span><span class="params">(IExcelDataHandler&lt;?&gt; dataHandler, Object object, Object cell,</span></span></span><br><span class="line"><span class="function"><span class="params">							Map&lt;String, ExcelImportEntity&gt; excelParams,</span></span></span><br><span class="line"><span class="function"><span class="params">							String titleString, IExcelDictHandler dictHandler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">		ExcelImportEntity entity = excelParams.get(titleString);</span><br><span class="line">		String classFullName = <span class="string">&quot;class java.lang.Object&quot;</span>;</span><br><span class="line">		Class clazz = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (!(object <span class="keyword">instanceof</span> Map)) &#123;</span><br><span class="line">			Method setMethod = entity.getMethods() != <span class="keyword">null</span> &amp;&amp; entity.getMethods().size() &gt; <span class="number">0</span></span><br><span class="line">					? entity.getMethods().get(entity.getMethods().size() - <span class="number">1</span>) : entity.getMethod();</span><br><span class="line">			Type[] ts = setMethod.getGenericParameterTypes();</span><br><span class="line">			classFullName = ts[<span class="number">0</span>].toString();</span><br><span class="line">			clazz = (Class) ts[<span class="number">0</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		Object result = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (cell <span class="keyword">instanceof</span> Cell) &#123;</span><br><span class="line">			result = getCellValues(classFullName, (Cell) cell, entity);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			result = cell;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (entity != <span class="keyword">null</span>) &#123;</span><br><span class="line">			result = handlerSuffix(entity.getSuffix(), result);</span><br><span class="line">			result = replaceValue(entity.getReplace(), result);</span><br><span class="line">			result = replaceValue(entity.getReplace(), result);</span><br><span class="line">			<span class="keyword">if</span> (dictHandler != <span class="keyword">null</span> &amp;&amp; StringUtils.isNoneBlank(entity.getDict())) &#123;</span><br><span class="line">				result = dictHandler.toValue(entity.getDict(), object, entity.getName(), result);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		result = handlerValue(dataHandler, object, result, titleString);</span><br><span class="line">		<span class="keyword">return</span> getValueByType(classFullName, result, entity, clazz);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> Object <span class="title">getValueByType</span><span class="params">(String classFullName, Object result, ExcelImportEntity entity, Class clazz)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//过滤空和空字符串,如果基本类型null会在上层抛出,这里就不处理了</span></span><br><span class="line">			<span class="keyword">if</span> (result == <span class="keyword">null</span> || StringUtils.isBlank(result.toString())) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (<span class="string">&quot;class java.util.Date&quot;</span>.equals(classFullName) &amp;&amp; result <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">				<span class="keyword">return</span> DateUtils.parseDate(result.toString(), entity.getFormat());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (<span class="string">&quot;class java.lang.Boolean&quot;</span>.equals(classFullName) || <span class="string">&quot;boolean&quot;</span>.equals(classFullName)) &#123;</span><br><span class="line">				<span class="keyword">return</span> Boolean.valueOf(String.valueOf(result));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (<span class="string">&quot;class java.lang.Double&quot;</span>.equals(classFullName) || <span class="string">&quot;double&quot;</span>.equals(classFullName)) &#123;</span><br><span class="line">				<span class="keyword">return</span> Double.valueOf(String.valueOf(result));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (<span class="string">&quot;class java.lang.Long&quot;</span>.equals(classFullName) || <span class="string">&quot;long&quot;</span>.equals(classFullName)) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> Long.valueOf(String.valueOf(result));</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					<span class="comment">//格式错误的时候,就用double,然后获取Int值</span></span><br><span class="line">					<span class="keyword">return</span> Double.valueOf(String.valueOf(result)).longValue();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (<span class="string">&quot;class java.lang.Float&quot;</span>.equals(classFullName) || <span class="string">&quot;float&quot;</span>.equals(classFullName)) &#123;</span><br><span class="line">				<span class="keyword">return</span> Float.valueOf(String.valueOf(result));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (<span class="string">&quot;class java.lang.Integer&quot;</span>.equals(classFullName) || <span class="string">&quot;int&quot;</span>.equals(classFullName)) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> Integer.valueOf(String.valueOf(result));</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					<span class="comment">//格式错误的时候,就用double,然后获取Int值</span></span><br><span class="line">					<span class="keyword">return</span> Double.valueOf(String.valueOf(result)).intValue();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (<span class="string">&quot;class java.math.BigDecimal&quot;</span>.equals(classFullName)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> BigDecimal(String.valueOf(result));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (<span class="string">&quot;class java.lang.String&quot;</span>.equals(classFullName)) &#123;</span><br><span class="line">				<span class="comment">//针对String 类型,但是Excel获取的数据却不是String,比如Double类型,防止科学计数法</span></span><br><span class="line">				<span class="keyword">if</span> (result <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">					<span class="keyword">return</span> result;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// double类型防止科学计数法</span></span><br><span class="line">				<span class="keyword">if</span> (result <span class="keyword">instanceof</span> Double) &#123;</span><br><span class="line">					<span class="keyword">return</span> PoiPublicUtil.doubleToString((Double) result);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> String.valueOf(result);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (clazz != <span class="keyword">null</span> &amp;&amp; clazz.isEnum()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (StringUtils.isNotEmpty(entity.getEnumImportMethod())) &#123;</span><br><span class="line">					<span class="keyword">return</span> PoiReflectorUtil.fromCache(clazz).execEnumStaticMethod(entity.getEnumImportMethod(), result);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> Enum.valueOf(clazz, result.toString());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			LOGGER.error(e.getMessage(), e);</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> ExcelImportException(ExcelImportEnum.GET_VALUE_ERROR);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> Object <span class="title">handlerValue</span><span class="params">(IExcelDataHandler dataHandler, Object object, Object result,</span></span></span><br><span class="line"><span class="function"><span class="params">								String titleString)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (dataHandler == <span class="keyword">null</span> || dataHandler.getNeedHandlerFields() == <span class="keyword">null</span></span><br><span class="line">				|| dataHandler.getNeedHandlerFields().length == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> result;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (handlerList == <span class="keyword">null</span>) &#123;</span><br><span class="line">			handlerList = Arrays.asList(dataHandler.getNeedHandlerFields());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (handlerList.contains(titleString)) &#123;</span><br><span class="line">			<span class="keyword">return</span> dataHandler.importHandler(object, titleString, result);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> Object <span class="title">handlerSuffix</span><span class="params">(String suffix, Object result)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (StringUtils.isNotEmpty(suffix) &amp;&amp; result != <span class="keyword">null</span></span><br><span class="line">				&amp;&amp; result.toString().endsWith(suffix)) &#123;</span><br><span class="line">			String temp = result.toString();</span><br><span class="line">			<span class="keyword">return</span> temp.substring(<span class="number">0</span>, temp.length() - suffix.length());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> Object <span class="title">replaceValue</span><span class="params">(String[] replace, Object result)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (replace != <span class="keyword">null</span> &amp;&amp; replace.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			String temp = String.valueOf(result);</span><br><span class="line">			String[] tempArr;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; replace.length; i++) &#123;</span><br><span class="line">				tempArr = replace[i].split(<span class="string">&quot;_&quot;</span>);</span><br><span class="line">				<span class="keyword">if</span> (temp.equals(tempArr[<span class="number">0</span>])) &#123;</span><br><span class="line">					<span class="keyword">return</span> tempArr[<span class="number">1</span>];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> Object <span class="title">getCellValues</span><span class="params">(String classFullName, Cell cell, ExcelImportEntity entity)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (cell == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		Object result = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (<span class="string">&quot;class java.util.Date&quot;</span>.equals(classFullName)</span><br><span class="line">				|| <span class="string">&quot;class java.sql.Date&quot;</span>.equals(classFullName)</span><br><span class="line">				|| (<span class="string">&quot;class java.sql.Time&quot;</span>).equals(classFullName)</span><br><span class="line">				|| (<span class="string">&quot;class java.time.Instant&quot;</span>).equals(classFullName)</span><br><span class="line">				|| (<span class="string">&quot;class java.time.LocalDate&quot;</span>).equals(classFullName)</span><br><span class="line">				|| (<span class="string">&quot;class java.time.LocalDateTime&quot;</span>).equals(classFullName)</span><br><span class="line">				|| (<span class="string">&quot;class java.sql.Timestamp&quot;</span>).equals(classFullName)) &#123;</span><br><span class="line">			<span class="comment">//FIX: 单元格yyyyMMdd数字时候使用 cell.getDateCellValue() 解析出的日期错误</span></span><br><span class="line">			<span class="keyword">if</span> (CellType.NUMERIC == cell.getCellTypeEnum() &amp;&amp; DateUtil.isCellDateFormatted(cell)) &#123;</span><br><span class="line">				result = DateUtil.getJavaDate(cell.getNumericCellValue());</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				String val = <span class="string">&quot;&quot;</span>;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					val = cell.getStringCellValue();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				result = getDateData(entity, val);</span><br><span class="line">				<span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> ((<span class="string">&quot;class java.time.Instant&quot;</span>).equals(classFullName)) &#123;</span><br><span class="line">				result = ((Date) result).toInstant();</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="string">&quot;class java.time.LocalDate&quot;</span>).equals(classFullName)) &#123;</span><br><span class="line">				result = ((Date) result).toInstant().atZone(ZoneId.systemDefault()).toLocalDate();</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="string">&quot;class java.time.LocalDateTime&quot;</span>).equals(classFullName)) &#123;</span><br><span class="line">				result = ((Date) result).toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="string">&quot;class java.time.OffsetDateTime&quot;</span>).equals(classFullName)) &#123;</span><br><span class="line">				result = ((Date) result).toInstant().atZone(ZoneId.systemDefault()).toOffsetDateTime();</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="string">&quot;class java.time.ZonedDateTime&quot;</span>).equals(classFullName)) &#123;</span><br><span class="line">				result = ((Date) result).toInstant().atZone(ZoneId.systemDefault());</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="string">&quot;class java.sql.Date&quot;</span>).equals(classFullName)) &#123;</span><br><span class="line">				result = <span class="keyword">new</span> java.sql.Date(((Date) result).getTime());</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="string">&quot;class java.sql.Time&quot;</span>).equals(classFullName)) &#123;</span><br><span class="line">				result = <span class="keyword">new</span> Time(((Date) result).getTime());</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((<span class="string">&quot;class java.sql.Timestamp&quot;</span>).equals(classFullName)) &#123;</span><br><span class="line">				result = <span class="keyword">new</span> Timestamp(((Date) result).getTime());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">switch</span> (cell.getCellTypeEnum()) &#123;</span><br><span class="line">				<span class="keyword">case</span> STRING:</span><br><span class="line">					result = cell.getRichStringCellValue() == <span class="keyword">null</span> ? <span class="string">&quot;&quot;</span></span><br><span class="line">							: cell.getRichStringCellValue().getString();</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> NUMERIC:</span><br><span class="line">					<span class="keyword">if</span> (DateUtil.isCellDateFormatted(cell)) &#123;</span><br><span class="line">						<span class="keyword">if</span> (<span class="string">&quot;class java.lang.String&quot;</span>.equals(classFullName)) &#123;</span><br><span class="line">							result = formateDate(entity, cell.getDateCellValue());</span><br><span class="line">						&#125;</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						result = readNumericCell(cell);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> BOOLEAN:</span><br><span class="line">					result = Boolean.toString(cell.getBooleanCellValue());</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> BLANK:</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> ERROR:</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> FORMULA:</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						result = readNumericCell(cell);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (Exception e1) &#123;</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							result = cell.getRichStringCellValue() == <span class="keyword">null</span> ? <span class="string">&quot;&quot;</span></span><br><span class="line">									: cell.getRichStringCellValue().getString();</span><br><span class="line">						&#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">							<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;获取公式类型的单元格失败&quot;</span>, e2);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> Object <span class="title">readNumericCell</span><span class="params">(Cell cell)</span> </span>&#123;</span><br><span class="line">		Object result = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">double</span> value = cell.getNumericCellValue();</span><br><span class="line">		<span class="keyword">if</span> (((<span class="keyword">int</span>) value) == value) &#123;</span><br><span class="line">			result = (<span class="keyword">int</span>) value;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			result = value;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">formateDate</span><span class="params">(ExcelImportEntity entity, Date value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (StringUtils.isNotEmpty(entity.getFormat()) &amp;&amp; value != <span class="keyword">null</span>) &#123;</span><br><span class="line">			SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(entity.getFormat());</span><br><span class="line">			<span class="keyword">return</span> format.format(value);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> Date <span class="title">getDateData</span><span class="params">(ExcelImportEntity entity, String value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (StringUtils.isNotEmpty(entity.getFormat()) &amp;&amp; StringUtils.isNotEmpty(value)) &#123;</span><br><span class="line">			SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(entity.getFormat());</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> format.parse(value);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">return</span> DateUtil.getJavaDate(Double.parseDouble(value));</span><br><span class="line">				&#125; <span class="keyword">catch</span> (NumberFormatException ex) &#123;</span><br><span class="line">					LOGGER.error(<span class="string">&quot;时间格式化失败,格式化:&#123;&#125;,值:&#123;&#125;&quot;</span>, entity.getFormat(), value);</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> ExcelImportException(ExcelImportEnum.GET_VALUE_ERROR);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> object</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> picId</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> excelParams</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> titleString</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> pictures</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveImage</span><span class="params">(Object object, String picId, Map&lt;String, ExcelImportEntity&gt; excelParams,</span></span></span><br><span class="line"><span class="function"><span class="params">						   String titleString, Map&lt;String, PictureData&gt; pictures,</span></span></span><br><span class="line"><span class="function"><span class="params">						   ImportParams params)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (pictures == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		PictureData image = pictures.get(picId);</span><br><span class="line">		<span class="keyword">if</span> (image == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">byte</span>[] data = image.getData();</span><br><span class="line">		String fileName = <span class="string">&quot;pic&quot;</span> + Math.round(Math.random() * <span class="number">100000000000L</span>);</span><br><span class="line">		fileName += <span class="string">&quot;.&quot;</span> + PoiPublicUtil.getFileExtendName(data);</span><br><span class="line">		<span class="keyword">if</span> (excelParams.get(titleString).getSaveType() == <span class="number">1</span>) &#123;</span><br><span class="line">			String path = getSaveUrl(excelParams.get(titleString), object);</span><br><span class="line">			File savefile = <span class="keyword">new</span> File(path);</span><br><span class="line">			<span class="keyword">if</span> (!savefile.exists()) &#123;</span><br><span class="line">				savefile.mkdirs();</span><br><span class="line">			&#125;</span><br><span class="line">			savefile = <span class="keyword">new</span> File(path + File.separator + fileName);</span><br><span class="line">			FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(savefile);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				fos.write(data);</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				IOUtils.closeQuietly(fos);</span><br><span class="line">			&#125;</span><br><span class="line">			setValues(excelParams.get(titleString), object,</span><br><span class="line">					getSaveUrl(excelParams.get(titleString), object) + File.separator + fileName);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			setValues(excelParams.get(titleString), object, data);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createErrorCellStyle</span><span class="params">(Workbook workbook)</span> </span>&#123;</span><br><span class="line">		errorCellStyle = workbook.createCellStyle();</span><br><span class="line">		Font font = workbook.createFont();</span><br><span class="line">		font.setColor(Font.COLOR_RED);</span><br><span class="line">		errorCellStyle.setFont(font);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;导入Excel模板，修改更新数据&quot;)</span></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/importExcelTemplate&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> R <span class="title">importMemberList</span><span class="params">(<span class="meta">@RequestPart(&quot;file&quot;)</span> MultipartFile file)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ImportParams params = <span class="keyword">new</span> ImportParams();</span><br><span class="line">            params.setTitleRows(<span class="number">1</span>);</span><br><span class="line">            params.setHeadRows(<span class="number">1</span>);</span><br><span class="line">            List&lt;TemplateExcelExport&gt; list = ExcelUtils.importExcelRewrite(file.getInputStream(), TemplateExcelExport.class,params);</span><br><span class="line">            List&lt;AlarmSiteInfo&gt; alarmSiteInfos = BeanMapper.INSTANCE.toAlarmSiteInfoList(list);</span><br><span class="line">            <span class="keyword">this</span>.alarmSiteService.updateBatchById(alarmSiteInfos);</span><br><span class="line">            <span class="keyword">return</span> R.ok();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> R.failed(<span class="string">&quot;导入失败！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>BUG</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>bug</tag>
        <tag>sql</tag>
        <tag>集合</tag>
        <tag>GC</tag>
        <tag>const</tag>
      </tags>
  </entry>
  <entry>
    <title>mapstruct使用报错</title>
    <url>/posts/RQ90BT.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><div style="text-align: center;">
[Gitee原文](https://gitee.com/meader/hexo-blog/blob/blog/source/_posts/BUG/20220308-mapstruct%E4%BD%BF%E7%94%A8%E6%8A%A5%E9%94%99.md) 
</div><br><span id="more"></span></p>
<p>使用mapstruct 请求报错</p>
<p>Handler dispatch failed; nested exception is java.lang.NoClassDefFoundError: </p>
<p> <img data-src="https://xuemingde.com/pages/image/2022/03/08/el10mD.png" alt=""></p>
<p>解决：</p>
<p> <img data-src="https://xuemingde.com/pages/image/2022/03/08/mwqlOu.png" alt=""></p>
<p>Mapper 引用的包错误。</p>
<p>错误的：import org.apache.ibatis.annotations.Mapper;</p>
<p>正确的：import org.mapstruct.Mapper;</p>
]]></content>
      <categories>
        <category>BUG</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>moli-opcua向kepware写入值失败</title>
    <url>/posts/303S4Q3.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>写入的代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeNodeValue</span><span class="params">(OpcUaClient client)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//节点</span></span><br><span class="line">        NodeId nodeId = <span class="keyword">new</span> NodeId(<span class="number">2</span>, <span class="string">&quot;PBS.PBS1.g1.a.a_air_control&quot;</span>);</span><br><span class="line">        <span class="comment">//创建数据对象,此处的数据对象一定要定义类型，不然会出现类型错误，导致无法写入</span></span><br><span class="line">        DataValue nowValue = <span class="keyword">new</span> DataValue(<span class="keyword">new</span> Variant(<span class="number">12</span>));</span><br><span class="line">        <span class="comment">//写入节点数据</span></span><br><span class="line">        StatusCode statusCode = client.writeValue(nodeId, nowValue).get();</span><br><span class="line">        System.out.println(<span class="string">&quot;结果：&quot;</span> + statusCode);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>报错信息：<br><code>StatusCode&#123;name=Bad_WriteNotSupported, value=0x80730000, quality=bad&#125;</code></p>
<p>代码改为：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeNodeValue</span><span class="params">(OpcUaClient client)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">       <span class="comment">//节点</span></span><br><span class="line">       NodeId nodeId = <span class="keyword">new</span> NodeId(<span class="number">2</span>, <span class="string">&quot;PBS.PBS1.g1.a.a_air_control&quot;</span>);</span><br><span class="line">       <span class="comment">//创建数据对象,此处的数据对象一定要定义类型，不然会出现类型错误，导致无法写入</span></span><br><span class="line">       DataValue nowValue = <span class="keyword">new</span> DataValue(<span class="keyword">new</span> Variant(<span class="number">12</span>),<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">       <span class="comment">//写入节点数据</span></span><br><span class="line">       StatusCode statusCode = client.writeValue(nodeId, nowValue).get();</span><br><span class="line">       System.out.println(<span class="string">&quot;结果：&quot;</span> + statusCode);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><br>报错信息为：<br><code>StatusCode&#123;name=Bad_TypeMismatch, value=0x80740000, quality=bad&#125;</code></p>
<p>报错解答：<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2VjbGlwc2UvbWlsby9pc3N1ZXMvNDU5">bad_WriteNoSupported · 问题 #459 · eclipse/milo · GitHub<i class="fa fa-external-link-alt"></i></span></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/16/22511655388771.png" alt="22511655388771"><br><img data-src="https://xuemingde.com/pages/image/2022/06/16/22181655388798.png" alt="22181655388798"><br><img data-src="https://xuemingde.com/pages/image/2022/06/16/22361655388816.png" alt="22361655388816"><br><img data-src="https://xuemingde.com/pages/image/2022/06/16/22541655388834.png" alt="22541655388834"><br><img data-src="https://xuemingde.com/pages/image/2022/06/16/22101655388850.png" alt="22101655388850"><br><img data-src="https://xuemingde.com/pages/image/2022/06/16/22431655388883.png" alt="22431655388883"> </p>
<p>代码改为 ：<br><img data-src="https://xuemingde.com/pages/image/2022/06/16/22481655389188.png" alt="22481655389188"> </p>
<p>返回结果：<code>StatusCode&#123;name=Good, value=0x00000000, quality=good&#125;</code></p>
]]></content>
      <categories>
        <category>BUG</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Transactional 注解失效的3种原因及解决办法 </title>
    <url>/posts/HRQWG9.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>原文：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvWnpwN2lKelVZRFJ0cFloWVVaeEZOQQ==">@Transactional 注解失效的3种原因及解决办法<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>讲解@Transactional的三种失效场景及解决办法</p>
<h2 id="Transactional失效场景介绍"><a href="#Transactional失效场景介绍" class="headerlink" title="Transactional失效场景介绍"></a>Transactional失效场景介绍</h2><h3 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h3><p>Transactional注解标注方法修饰符为非public时，<code>@Transactional</code>注解将会不起作用。例如以下代码。</p>
<p>定义一个错误的<code>@Transactional</code>标注实现，修饰一个默认访问符的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhoujy  </span></span><br><span class="line"><span class="comment"> **/</span>  </span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Resource</span>  </span><br><span class="line">    TestMapper testMapper;  </span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Transactional</span>  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertTestWrongModifier</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> re = testMapper.insert(<span class="keyword">new</span> Test(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>));  </span><br><span class="line">        <span class="keyword">if</span> (re &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NeedToInterceptException(<span class="string">&quot;need intercept&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        testMapper.insert(<span class="keyword">new</span> Test(<span class="number">210</span>,<span class="number">20</span>,<span class="number">30</span>));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>在同一个包内，新建调用对象，进行访问。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokcationService</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Resource</span>  </span><br><span class="line">    <span class="keyword">private</span> TestServiceImpl testService;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeInsertTestWrongModifier</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="comment">//调用@Transactional标注的默认访问符方法  </span></span><br><span class="line">        testService.insertTestWrongModifier();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>测试用例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span>  </span><br><span class="line"><span class="meta">@SpringBootTest</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplicationTests</span> </span>&#123;  </span><br><span class="line">   <span class="meta">@Resource</span>  </span><br><span class="line">   InvokcationService invokcationService;  </span><br><span class="line">  </span><br><span class="line">   <span class="meta">@Test</span>  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">testInvoke</span><span class="params">()</span></span>&#123;  </span><br><span class="line">      invokcationService.invokeInsertTestWrongModifier();  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>以上的访问方式，导致事务没开启，因此在方法抛出异常时，<code>testMapper.insert(new Test(10,20,30));</code>操作不会进行回滚。如果<code>TestServiceImpl#insertTestWrongModifier</code>方法改为public的话将会正常开启事务，<code>testMapper.insert(new Test(10,20,30));</code>将会进行回滚。</p>
<h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><p>在类内部调用调用类内部<code>@Transactional</code>标注的方法。这种情况下也会导致事务不开启。示例代码如下。</p>
<p>设置一个内部调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhoujy  </span></span><br><span class="line"><span class="comment"> **/</span>  </span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> <span class="keyword">implements</span> <span class="title">TestService</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Resource</span>  </span><br><span class="line">    TestMapper testMapper;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Transactional</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertTestInnerInvoke</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//正常public修饰符的事务方法  </span></span><br><span class="line">        <span class="keyword">int</span> re = testMapper.insert(<span class="keyword">new</span> Test(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>));  </span><br><span class="line">        <span class="keyword">if</span> (re &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NeedToInterceptException(<span class="string">&quot;need intercept&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        testMapper.insert(<span class="keyword">new</span> Test(<span class="number">210</span>,<span class="number">20</span>,<span class="number">30</span>));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInnerInvoke</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="comment">//类内部调用@Transactional标注的方法。  </span></span><br><span class="line">        insertTestInnerInvoke();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>测试用例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span>  </span><br><span class="line"><span class="meta">@SpringBootTest</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplicationTests</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">   <span class="meta">@Resource</span>  </span><br><span class="line">   TestServiceImpl testService;  </span><br><span class="line">  </span><br><span class="line">   <span class="comment">/**  </span></span><br><span class="line"><span class="comment">    * 测试内部调用<span class="doctag">@Transactional</span>标注方法  </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">   <span class="meta">@Test</span>  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">testInnerInvoke</span><span class="params">()</span></span>&#123;  </span><br><span class="line">       <span class="comment">//测试外部调用事务方法是否正常  </span></span><br><span class="line">      <span class="comment">//testService.insertTestInnerInvoke();  </span></span><br><span class="line">       <span class="comment">//测试内部调用事务方法是否正常  </span></span><br><span class="line">      testService.testInnerInvoke();  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>上面就是使用的测试代码，运行测试知道，外部调用事务方法能够征程开启事务，<code>testMapper.insert(new Test(10,20,30))</code>操作将会被回滚；</p>
<p>然后运行另外一个测试用例，调用一个方法在类内部调用内部被<code>@Transactional</code>标注的事务方法，运行结果是事务不会正常开启，<code>testMapper.insert(new Test(10,20,30))</code>操作将会保存到数据库不会进行回滚。</p>
<h3 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h3><p>事务方法内部捕捉了异常，没有抛出新的异常，导致事务操作不会进行回滚。示例代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhoujy  </span></span><br><span class="line"><span class="comment"> **/</span>  </span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> <span class="keyword">implements</span> <span class="title">TestService</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Resource</span>  </span><br><span class="line">    TestMapper testMapper;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Transactional</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertTestCatchException</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="keyword">int</span> re = testMapper.insert(<span class="keyword">new</span> Test(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>));  </span><br><span class="line">            <span class="keyword">if</span> (re &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                <span class="comment">//运行期间抛异常  </span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NeedToInterceptException(<span class="string">&quot;need intercept&quot;</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            testMapper.insert(<span class="keyword">new</span> Test(<span class="number">210</span>,<span class="number">20</span>,<span class="number">30</span>));  </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;i catch exception&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>测试用例代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span>  </span><br><span class="line"><span class="meta">@SpringBootTest</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplicationTests</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">   <span class="meta">@Resource</span>  </span><br><span class="line">   TestServiceImpl testService;  </span><br><span class="line">  </span><br><span class="line">   <span class="meta">@Test</span>  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCatchException</span><span class="params">()</span></span>&#123;  </span><br><span class="line">      testService.insertTestCatchException();  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>运行测试用例发现，虽然抛出异常，但是异常被捕捉了，没有抛出到方法 外， <code>testMapper.insert(new Test(210,20,30))</code>操作并没有回滚。</p>
<p>以上三种就是<code>@Transactional</code>注解不起作用，<code>@Transactional</code>注解失效的主要原因。下面结合spring中对于<code>@Transactional</code>的注解实现源码分析为何导致<code>@Transactional</code>注解不起作用。</p>
<h2 id="Transactional注解不起作用原理分析"><a href="#Transactional注解不起作用原理分析" class="headerlink" title="@Transactional注解不起作用原理分析"></a>@Transactional注解不起作用原理分析</h2><h3 id="第一种-1"><a href="#第一种-1" class="headerlink" title="第一种"></a>第一种</h3><p><code>@Transactional</code>注解标注方法修饰符为非public时，<code>@Transactional</code>注解将会不起作用。这里分析 的原因是，<code>@Transactional</code>是基于动态代理实现的，<code>@Transactional</code>注解实现原理中分析了实现方法，在bean初始化过程中，对含有<code>@Transactional</code>标注的bean实例创建代理对象，这里就存在一个spring扫描<code>@Transactional</code>注解信息的过程，不幸的是源码中体现，标注<code>@Transactional</code>的方法如果修饰符不是public，那么就默认方法的<code>@Transactional</code>信息为空，那么将不会对bean进行代理对象创建或者不会对方法进行代理调用</p>
<p><code>@Transactional</code>注解实现原理中，介绍了如何判定一个bean是否创建代理对象，大概逻辑是。根据spring创建好一个aop切点<code>BeanFactoryTransactionAttributeSourceAdvisor</code>实例，遍历当前bean的class的方法对象，判断方法上面的注解信息是否包含<code>@Transactional</code>，如果bean任何一个方法包含<code>@Transactional</code>注解信息，那么就是适配这个<code>BeanFactoryTransactionAttributeSourceAdvisor</code>切点。则需要创建代理对象，然后代理逻辑为我们管理事务开闭逻辑。</p>
<p>spring源码中，在拦截bean的创建过程，寻找bean适配的切点时，运用到下面的方法，目的就是寻找方法上面的@<code>Transactional</code>信息，如果有，就表示切点<code>BeanFactoryTransactionAttributeSourceAdvisor</code>能够应用（canApply）到bean中，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AopUtils#canApply(org.springframework.aop.Pointcut, java.lang.Class&lt;?&gt;, boolean)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canApply</span><span class="params">(Pointcut pc, Class&lt;?&gt; targetClass, <span class="keyword">boolean</span> hasIntroductions)</span> </span>&#123;  </span><br><span class="line">   Assert.notNull(pc, <span class="string">&quot;Pointcut must not be null&quot;</span>);  </span><br><span class="line">   <span class="keyword">if</span> (!pc.getClassFilter().matches(targetClass)) &#123;  </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   MethodMatcher methodMatcher = pc.getMethodMatcher();  </span><br><span class="line">   <span class="keyword">if</span> (methodMatcher == MethodMatcher.TRUE) &#123;  </span><br><span class="line">      <span class="comment">// No need to iterate the methods if we&#x27;re matching any method anyway...  </span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   IntroductionAwareMethodMatcher introductionAwareMethodMatcher = <span class="keyword">null</span>;  </span><br><span class="line">   <span class="keyword">if</span> (methodMatcher <span class="keyword">instanceof</span> IntroductionAwareMethodMatcher) &#123;  </span><br><span class="line">      introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//遍历class的方法对象  </span></span><br><span class="line">   Set&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> LinkedHashSet&lt;Class&lt;?&gt;&gt;(ClassUtils.getAllInterfacesForClassAsSet(targetClass));  </span><br><span class="line">   classes.add(targetClass);  </span><br><span class="line">   <span class="keyword">for</span> (Class&lt;?&gt; clazz : classes) &#123;  </span><br><span class="line">      Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);  </span><br><span class="line">      <span class="keyword">for</span> (Method method : methods) &#123;  </span><br><span class="line">         <span class="keyword">if</span> ((introductionAwareMethodMatcher != <span class="keyword">null</span> &amp;&amp;  </span><br><span class="line">               introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||  </span><br><span class="line">             <span class="comment">//适配查询方法上的@Transactional注解信息    </span></span><br><span class="line">             methodMatcher.matches(method, targetClass)) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">         &#125;  </span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>我们可以在上面的方法打断点，一步一步调试跟踪代码，最终上面的代码还会调用如下方法来判断。在下面的方法上断点，回头看看方法调用堆栈也是不错的方式跟踪。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">AbstractFallbackTransactionAttributeSource#getTransactionAttribute</span><br></pre></td></tr></table></figure>
<ul>
<li><code>AbstractFallbackTransactionAttributeSource#computeTransactionAttribute</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">computeTransactionAttribute</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;  </span><br><span class="line">   <span class="comment">// Don&#x27;t allow no-public methods as required.  </span></span><br><span class="line">   <span class="comment">//非public 方法，返回@Transactional信息一律是null  </span></span><br><span class="line">   <span class="keyword">if</span> (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;  </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">//后面省略.......  </span></span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure>
<p><strong>不创建代理对象</strong></p>
<p>所以，如果所有方法上的修饰符都是非public的时候，那么将不会创建代理对象。以一开始的测试代码为例，如果正常的修饰符的testService是下面图片中的，经过cglib创建的代理对象。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/17/1016-kIvrdM.png" alt="图片"></p>
<p>如果class中的方法都是非public的那么将不是代理对象。</p>
<p><strong>不进行代理调用</strong></p>
<p>考虑一种情况，如下面代码所示。两个方法都被<code>@Transactional</code>注解标注，但是一个有public修饰符一个没有，那么这种情况我们可以预见的话，一定会创建代理对象，因为至少有一个public修饰符的<code>@Transactional</code>注解标注方法。</p>
<p>创建了代理对象，<code>insertTestWrongModifier</code>就会开启事务吗？答案是不会。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhoujy  </span></span><br><span class="line"><span class="comment"> **/</span>  </span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> <span class="keyword">implements</span> <span class="title">TestService</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Resource</span>  </span><br><span class="line">    TestMapper testMapper;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="meta">@Transactional</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertTest</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> re = testMapper.insert(<span class="keyword">new</span> Test(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>));  </span><br><span class="line">        <span class="keyword">if</span> (re &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NeedToInterceptException(<span class="string">&quot;need intercept&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        testMapper.insert(<span class="keyword">new</span> Test(<span class="number">210</span>,<span class="number">20</span>,<span class="number">30</span>));  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Transactional</span>  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertTestWrongModifier</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> re = testMapper.insert(<span class="keyword">new</span> Test(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>));  </span><br><span class="line">        <span class="keyword">if</span> (re &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NeedToInterceptException(<span class="string">&quot;need intercept&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        testMapper.insert(<span class="keyword">new</span> Test(<span class="number">210</span>,<span class="number">20</span>,<span class="number">30</span>));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>原因是在动态代理对象进行代理逻辑调用时，在cglib创建的代理对象的拦截函数中<code>CglibAopProxy.DynamicAdvisedInterceptor#intercept</code>，有一个逻辑如下，目的是获取当前被代理对象的当前需要执行的method适配的aop逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);  </span><br></pre></td></tr></table></figure>
<p>而针对@Transactional注解查找aop逻辑过程，相似地，也是执行一次</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">AbstractFallbackTransactionAttributeSource#getTransactionAttribute</span><br></pre></td></tr></table></figure>
<ul>
<li><code>AbstractFallbackTransactionAttributeSource#computeTransactionAttribute</code></li>
</ul>
<p>也就是说还需要找一个方法上的<code>@Transactional</code>注解信息，没有的话就不执行代理<code>@Transactional</code>对应的代理逻辑，直接执行方法。没有了<code>@Transactional</code>注解代理逻辑，就无法开启事务，这也是上一篇已经讲到的。</p>
<h3 id="第二种-1"><a href="#第二种-1" class="headerlink" title="第二种"></a>第二种</h3><p>在类内部调用调用类内部<code>@Transactional</code>标注的方法。这种情况下也会导致事务不开启。</p>
<p>经过对第一种的详细分析，对这种情况为何不开启事务管理，原因应该也能猜到；</p>
<blockquote>
<p>既然事务管理是基于动态代理对象的代理逻辑实现的，那么如果在类内部调用类内部的事务方法，这个调用事务方法的过程并不是通过代理对象来调用的，而是直接通过this对象来调用方法，绕过的代理对象，肯定就是没有代理逻辑了。</p>
</blockquote>
<p>其实我们可以这样玩，内部调用也能实现开启事务，代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhoujy  </span></span><br><span class="line"><span class="comment"> **/</span>  </span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> <span class="keyword">implements</span> <span class="title">TestService</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Resource</span>  </span><br><span class="line">    TestMapper testMapper;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Resource</span>  </span><br><span class="line">    TestServiceImpl testServiceImpl;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Transactional</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertTestInnerInvoke</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> re = testMapper.insert(<span class="keyword">new</span> Test(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>));  </span><br><span class="line">        <span class="keyword">if</span> (re &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NeedToInterceptException(<span class="string">&quot;need intercept&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        testMapper.insert(<span class="keyword">new</span> Test(<span class="number">210</span>,<span class="number">20</span>,<span class="number">30</span>));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInnerInvoke</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="comment">//内部调用事务方法  </span></span><br><span class="line">        testServiceImpl.insertTestInnerInvoke();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>上面就是使用了代理对象进行事务调用，所以能够开启事务管理，但是实际操作中，没人会闲的蛋疼这样子玩~</p>
<h3 id="第三种-1"><a href="#第三种-1" class="headerlink" title="第三种"></a>第三种</h3><p>事务方法内部捕捉了异常，没有抛出新的异常，导致事务操作不会进行回滚。</p>
<p>这种的话，可能我们比较常见，问题就出在代理逻辑中，我们先看看源码里卖弄动态代理逻辑是如何为我们管理事务的。</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><span class="line">TransactionAspectSupport<span class="meta">#invokeWithinTransaction</span></span><br></pre></td></tr></table></figure>
<p>代码如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">invokeWithinTransaction</span><span class="params">(Method method, Class&lt;?&gt; targetClass, <span class="keyword">final</span> InvocationCallback invocation)</span>  </span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> Throwable </span>&#123;  </span><br><span class="line">  </span><br><span class="line">   <span class="comment">// If the transaction attribute is null, the method is non-transactional.  </span></span><br><span class="line">   <span class="keyword">final</span> TransactionAttribute txAttr = getTransactionAttributeSource().getTransactionAttribute(method, targetClass);  </span><br><span class="line">   <span class="keyword">final</span> PlatformTransactionManager tm = determineTransactionManager(txAttr);  </span><br><span class="line">   <span class="keyword">final</span> String joinpointIdentification = methodIdentification(method, targetClass);  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">if</span> (txAttr == <span class="keyword">null</span> || !(tm <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;  </span><br><span class="line">      <span class="comment">// Standard transaction demarcation with getTransaction and commit/rollback calls.  </span></span><br><span class="line">       <span class="comment">//开启事务  </span></span><br><span class="line">      TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);  </span><br><span class="line">      Object retVal = <span class="keyword">null</span>;  </span><br><span class="line">      <span class="keyword">try</span> &#123;  </span><br><span class="line">         <span class="comment">// This is an around advice: Invoke the next interceptor in the chain.  </span></span><br><span class="line">         <span class="comment">// This will normally result in a target object being invoked.  </span></span><br><span class="line">          <span class="comment">//反射调用业务方法  </span></span><br><span class="line">         retVal = invocation.proceedWithInvocation();  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">catch</span> (Throwable ex) &#123;  </span><br><span class="line">         <span class="comment">// target invocation exception  </span></span><br><span class="line">          <span class="comment">//异常时，在catch逻辑中回滚事务  </span></span><br><span class="line">         completeTransactionAfterThrowing(txInfo, ex);  </span><br><span class="line">         <span class="keyword">throw</span> ex;  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">finally</span> &#123;  </span><br><span class="line">         cleanupTransactionInfo(txInfo);  </span><br><span class="line">      &#125;  </span><br><span class="line">       <span class="comment">//提交事务  </span></span><br><span class="line">      commitTransactionAfterReturning(txInfo);  </span><br><span class="line">      <span class="keyword">return</span> retVal;  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">else</span> &#123;  </span><br><span class="line">     <span class="comment">//....................  </span></span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>所以看了上面的代码就一目了然了，事务想要回滚，必须能够在这里捕捉到异常才行，如果异常中途被捕捉掉，那么事务将不会回滚。</p>
<p>总结了以上几种情况。</p>
]]></content>
      <categories>
        <category>BUG</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>Spring</tag>
        <tag>SpringBoot</tag>
        <tag>事务</tag>
        <tag>数据库</tag>
        <tag>堆</tag>
        <tag>栈</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机中整数的加减运算</title>
    <url>/posts/NHRPJF.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h1><blockquote>
<p>原码：<strong>是最简单的机器数表示法，用最高位表示符号位（0正 1负），其他位存放该数的二进制的绝对值</strong>。</p>
</blockquote>
<p>以带符号位的四位二进制数为例：1010，最高位为1表示这是一个负数，其它三位010，即0 <em> 2^2 + 1 </em> 2^1 + 0 * 2^0 = 2，所以1010表示十进制数-2。</p>
<p><strong>9</strong> 在8位二进制的表示为：00001001</p>
<p><strong>-9</strong> 在8位二进制的表示为：10001001</p>
<p><strong>这样用8个bit表示整数的取值范围是-27-1~27-1，即-127~127。</strong></p>
<p>采用这种表示法，计算机做加法运算需要处理以下逻辑：</p>
<ol>
<li>如果两数符号位相同，就把它们的低7位相加，符号位不变。如果低7位相加时在最高位产生进位，说明结果的绝对值大于127，超出7位所能表示的数值范围，这称为溢出（Overflow)，这时通常把计算机中的一个标志位置1表示当前运算产生了溢出。</li>
<li>如果两数符号位不同，首先比较它们的低7位谁大，然后用大数减小数，结果的符号位和大数相同。</li>
</ol>
<p>那么减法如何计算呢？由于我们规定了负数的表示，可以把减法转换成加法来计算，要计算a-b，可以先把b变号然后和a相加，相当于计算a+(-b)。但如果两个加数的符号位不同就要用大数的绝对值减小数的绝对值，这一步减法计算仍然是免不了的。我们知道加法要进位，减法要借位，计算过程是不同的，所以除了要有第 1 节 “为什么计算机用二进制计数”提到的加法器电路之外，还要另外有一套减法器电路。</p>
<p>如果采用Sign and Magnitude（符号和大小）表示法，计算机做加减运算需要处理很多逻辑：比较符号位，比较绝对值，加法改减法，减法改加法，小数减大数改成大数减小数……这是非常低效率的。还有一个缺点是0的表示不唯一，既可以表示成10000000也可以表示成00000000，这进一步增加了逻辑的复杂性，所以我们迫切需要重新设计整数的表示方法使计算过程更简单。</p>
<p>原码的表示法很简单，虽然出现了+0和-0，但是直观易懂。于是开始运算——</p>
<blockquote>
<p>​       0001+0010=0011，1+2=3；<br>​       0000+1000=1000，+0+(-0)=-0；<br>​       0001+1001=1010，1+(-1)=-2。（错误）</p>
</blockquote>
<p>​   于是可以看到其实正数之间的加法通常是不会出错的，因为它就是一个很简单的二进制加法，而正数与负数相加，或负数与负数相加，就要引起莫名其妙的结果，这都是符号位引起的。0分为+0和-0也是因它而起。</p>
<p><strong>原码的特点：</strong></p>
<ol>
<li>原码表示直观、易懂，与真值转换容易。</li>
<li>原码中0有两种不同的表示形式，给使用带来了不便。</li>
</ol>
<blockquote>
<p>​       通常0的原码用+0表示，若在计算过程中出现了-0，则需要用硬件将-0变成+0。</p>
</blockquote>
<ol>
<li>原码表示加减运算复杂。</li>
</ol>
<blockquote>
<p>​       利用原码进行两数相加运算时，首先要判别两数符号，若同号则做加法，若异号则做减法。在利用原码进行两数相减运算时，不仅要判别两数符号，使得同号相减，异号相加；还要判别两数绝对值的大小，用绝对值大的数减去绝对值小的数，取绝对值大的数的符号为结果的符号。可见，原码表示不便于实现加减运算。</p>
</blockquote>
<h1 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h1><blockquote>
<p>反码：<strong>正数的反码还是等于原码；负数的反码就是它的原码除符号位外，按位取反</strong>。</p>
</blockquote>
<p><strong>9</strong> 在8位二进制的原码表示为：10001001，反码为10001001 （正数的反码还是等于原码）</p>
<p><strong>-9</strong> 在8位二进制的原码表示为：10001001，反码为11110110  (负数的反码就是它的原码除符号位外，按位取反)</p>
<p> 再试着用反码的方式解决一下原码的问题——</p>
<blockquote>
<p>​       0001+1110=1111，1+(-1)=-0；<br>​       1110+1100=1010，(-1)+(-3)=-5。</p>
</blockquote>
<p>互为相反数相加等于0，虽然的到的结果是1111也就是-0。但是两个负数相加的出错了。</p>
<p> 反码的特点</p>
<ol>
<li>在反码表示中，用符号位表示数值的正负，形式与原码表示相同，即0为正；1为负。</li>
<li>在反码表示中，数值0有两种表示方法。</li>
<li>反码的表示范围与原码的表示范围相同。</li>
</ol>
<p><strong>反码表示在计算机中往往作为数码变换的中间环节。并不会直接参与结算</strong></p>
<h1 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h1><blockquote>
<p>补码：<strong>正数的补码等于它的原码；负数的补码等于反码+1</strong>（这只是一种算补码的方式，多数书对于补码就是这句话）。</p>
</blockquote>
<p><strong>9</strong> 在8位二进制的原码表示为：10001001,反码为10001001,<strong>补码为10001001</strong> （不变）</p>
<p><strong>-9</strong> 在8位二进制的原码表示为：10001001，反码为11110110 ,<strong>补码为11110111</strong> </p>
<blockquote>
<p>其实负数的补码等于反码+1只是补码的求法，而不是补码的定义，很多人以为求补码就要先求反码，其实并不是，那些计算机学家并不会心血来潮的把反码+1就定义为补码，只不过补码正好就等于反码+1而已。</p>
<p>如果有兴趣了解补码的严格说法，建议可以看一下《计算机组成原理》，它会用“模”和“同余”的概念，严谨地解释补码。</p>
</blockquote>
<p>综上所述，正数的源码、反码、补码都是不变的，负数的反码、补码与源码都是不一致的，所以在计算时，只有负数需要进行反码或者补码。</p>
<h1 id="两个正数的加法运算"><a href="#两个正数的加法运算" class="headerlink" title="两个正数的加法运算"></a>两个正数的加法运算</h1><p>示例：16 + 5</p>
<p>16的补码：00010000</p>
<p>5的补码：  00000101</p>
<p>加法运算：00010000 + 00000101 = 00010101</p>
<p>00010101的十进制是：21  —&gt;16 + 5=21</p>
<p>8bit的正数的最大值为：01111111，转为十进制为127。当进行两个正数加法运算时，可能会出现溢出的情况。</p>
<p>126的二进制为01111110</p>
<p>2的二进制为00000010</p>
<p>01111110 + 00000010 = 10000000</p>
<p>最高变成了1，就说明产生了溢出。</p>
<p>所以，两个正数相加时，如果最高为变成了1，就说明了产生了溢出。</p>
<h1 id="一正一负的运算"><a href="#一正一负的运算" class="headerlink" title="一正一负的运算"></a>一正一负的运算</h1><p><strong>示例1</strong></p>
<p>16 - 9 也可看做是16 + （-9）</p>
<p>16的补码为：00010000</p>
<p>-9的补码为11110111</p>
<p>00010000 + 11110111 = 100000111</p>
<p>100000111超出了8位，需要去除一位，就去除最高位的1，就成了00000111，00000111的十进制为7</p>
<p>所谓16 - 9 = 7</p>
<p><strong>示例二</strong></p>
<p>5-9，可看做是5 + （-9）</p>
<p>5的补码为：00000101</p>
<p>-9的补码为：11110111</p>
<p>00000101 + 11110111 = 11111100</p>
<p>11111100为-4的补码，即5-9=-4</p>
<p>根据上述，可以看出，无论是正数的加法运算，还是正负数的加法运算，其实是对他们的补码进行运算。</p>
<p>如何判断产生了溢出呢？我们还是分四种情况讨论：如果两个正数相加溢出，结果一定是负数；如果两个负数相加溢出，结果一定是正数；一正一负相加，无论结果是正是负都不可能溢出。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/11/15/101025bQWtrl.png" alt=""></p>
<p>从上图可以得出结论：<em>在相加过程中最高位产生的进位和次高位产生的进位如果相同则没有溢出，如果不同则表示有溢出</em>。逻辑电路的实现可以把这两个进位连接到一个异或门，把异或门的输出连接到溢出标志位。</p>
]]></content>
      <categories>
        <category>C&amp;C++</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>小数在计算机的存储形式</title>
    <url>/posts/3SE47KD.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="小数转二进制的过程"><a href="#小数转二进制的过程" class="headerlink" title="小数转二进制的过程"></a>小数转二进制的过程</h1><p><strong>示例一</strong></p>
<p>4.25转为二进制的过程：</p>
<p>拆分为整数部分和小数部分，整数部分为4，小数部分为0.25。</p>
<p>4转二进制为：100</p>
<p>0.25转二进制为：0.01</p>
<p>将两个二进制相加就是：100.01，所以4.25的转为二进制就是100.01</p>
<p>0.25转二进制的过程：</p>
<p>0.25*2=0.5，取整数为0</p>
<p>0.5*2=1.0，取整数为1</p>
<p>这时小数部分为0时结束，0.25的二进制的小数部分就是01。</p>
<p><strong>示例二</strong></p>
<p>19.625转为二进制过程：</p>
<p>19转二进制为：10011</p>
<p>0.625转二进制的过程：</p>
<p>0.625*2=1.25，取整数部分 1</p>
<p>0.25*2=0.5，取整数部分 0</p>
<p>0.5*2=1.0，取整数部分 1</p>
<p>这时小数部分为0，结束。</p>
<p>0.625的二进制就表示为：0.101</p>
<p>19.625的二进制表示为：10011.101</p>
<h1 id="小数在计算机中的存储形式"><a href="#小数在计算机中的存储形式" class="headerlink" title="小数在计算机中的存储形式"></a>小数在计算机中的存储形式</h1><p>C语言中，对于浮点类型的数据采用单精度类型<code>（float）</code>和双精度类型<code>(double)</code>来存储，<code>float</code>数据占用32bit, <code>double</code>数据占用64bit。</p>
<p>无论是单精度还是双精度在存储中都分为三个部分：</p>
<ul>
<li><strong>符号位(Sign)</strong> : 0代表正，1代表为负</li>
<li><strong>指数位（Exponent）</strong>: 用于存储科学计数法中的指数数据，并且采用移位存储</li>
<li><strong>尾数部分（Mantissa）</strong>：尾数部分</li>
</ul>
<p><img data-src="https://xuemingde.com/pages/image/2022/11/11/1009586PctKl.png" alt=""></p>
<ul>
<li><p>符号的存储</p>
<p>符号的存储很容易，就像存储 short、int 等普通整数一样，单独分配出一个位（Bit）来，<strong>用 0 表示正数，用 1 表示负数</strong>。对于 19.625，这一位的值是 0。</p>
</li>
<li><p>尾数的存储</p>
<p>计算机采用二进制形式存储浮点数，尾数部分的取值范围为 1 ≤ mantissa ＜ 2，这意味着：<strong>尾数的整数部分一定为 1，是一个恒定的值，这样就无需在内存中提现出来，可以将其直接截掉</strong>，<strong>只要把小数点后面的二进制数字放入内存中即可</strong>。对于 1.0011101，就是把 0011101 放入内存。</p>
</li>
</ul>
<blockquote>
<p>19.625的二进制为10011.101，也可表示为1.0011101 * 2^4^，所以19.625的尾数部分为1.0011101</p>
<p>4.6的二进制为100.1001100110011001…….,小数部分出现了死循环，所有有无数位，100.1001100110011001…….可转为1.001001100110011001……. * 2^2^,又因为float的尾数部分为23bit，所以会截取23个存储，这时就出现了精度丢失。</p>
<p><code>double</code>为64bit，尾数部分占52bit，虽然提高了精度，但也不能完全保证一致。</p>
</blockquote>
<ul>
<li>指数的存储</li>
</ul>
<blockquote>
<p>指数是一个整数，并且有正负之分，不但需要存储它的值，还得能区分出正负号来。<br> <strong>先确定内存中指数部分的取值范围，得到一个中间值，写入指数时加上这个中间值，读取指数时减去这个中间值，这样符号和值就都能确定下来了。</strong></p>
</blockquote>
<p><code>float 的指数部分占用 8 Bits，能表示从 0~255 的值，取其中间值 127，指数在写入内存前先加上127，读取时再减去127，正数负数就显而易见了</code>。</p>
<p><code>而对于指数部分，因为指数可正可负(占1位)，所以8位的指数位能表示的指数范围就只能用7位，范围是:-127至128。所以指数部分的存储采用移位存储，存储的数据为元数据 +127。</code></p>
<p>19.625 的二进制为10011.101，可表示为1.0011101 * 2^4^，所以他的指数为4（就是2的多少次方），4+127=131，131的二进制为10000011，所以19.625的指数部分存储的为10000011</p>
<blockquote>
<p><code>double</code>的指数部分为11</p>
</blockquote>
<p>结束上述的描述，19.625  float 的存储形式为：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>符号位</th>
<th>指数为</th>
<th>尾数部分</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>10000011</td>
<td>001 1101 0000 0000 0000 0000</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>float的尾数部分为23bit，0011101只用了7bit，后面的补0，补刀23bit为止</p>
</blockquote>
]]></content>
      <categories>
        <category>C&amp;C++</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习笔记1</title>
    <url>/posts/3XAT60D.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="using的三种用法详解"><a href="#using的三种用法详解" class="headerlink" title="using的三种用法详解"></a>using的三种用法详解</h3><ol>
<li><p>using声明(引入单个名称)</p>
<p>using声明是将命名空间中某个名字单独引入到当前作用域。这使得我们在当前作用域下可以直接使用该名字而无需使用作用域限定符。</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;123&quot;</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>using指示(引入命名空间)</p>
<p>using指示就是将一个命名空间中的<strong>所有</strong>名字全部引入到当前作用域(将命名空间在当前作用域展开)。可能会存在命名冲突的问题。</p>
<blockquote>
<p>using namespace std; //我们常用的std命名空间展开</p>
</blockquote>
</li>
<li><p><strong>类型重定义(替代typedef)</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> alias = <span class="keyword">typename</span>;	<span class="comment">//使用别名去替代原始类型(重命名)</span></span><br></pre></td></tr></table></figure>
<p>在C++11中，我们可以使用这样的语法来替代typedef的功能了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> ULL = <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>;		<span class="comment">//typedef unsigned long long ULL;</span></span><br><span class="line"><span class="keyword">using</span> func = <span class="keyword">void</span>(*)(<span class="keyword">int</span>, <span class="keyword">int</span>);		<span class="comment">//typedef void(*func)(int, int);</span></span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ol>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ol>
<li><p>整数类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">short</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//2字节</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">//4字节</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">long</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//windows 4字节 / Linux 32位=4字节 64位=8字节 / MACOS=8字节</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">long</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//8字节</span></span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>浮点型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">float</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 4字节 单精度  7位有效数字</span></span><br><span class="line"><span class="keyword">float</span> f1 = <span class="number">12345.1234567</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//12345.1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> f1 = <span class="number">12345.1234567</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//12345.1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> f1 = <span class="number">123.1234567</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//123.123</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> f1 = <span class="number">1.1234567</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//1.12346</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="keyword">sizeof</span> (<span class="keyword">double</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 8 字节 双精度 15-16 位有效数字</span></span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>字符型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c1 = <span class="string">&#x27;a&#x27;</span>;<span class="comment">//必须用单引号,并只能放一个字符</span></span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">char</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 1字节</span></span><br><span class="line">   char c2 = &#x27;assssssssq&#x27;;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">//q</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//对应ASCII 码</span></span><br><span class="line">   <span class="keyword">char</span> c3 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>)c3 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">//97</span></span><br><span class="line">   <span class="keyword">char</span> c3 = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>)c3 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">//65</span></span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>字符串类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//C中的字符串</span></span><br><span class="line"><span class="keyword">char</span> c3[] = <span class="string">&quot;2324234324&quot;</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c3 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//C++中的字符串</span></span><br><span class="line"><span class="comment">//需要加头文件  #include &lt;string&gt;</span></span><br><span class="line"><span class="comment">//书写方式</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">&quot;qqqqq&quot;</span>;</span><br><span class="line"><span class="comment">//如果想省略std，需要指定空间</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//在main中可书写成：</span></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;qqqqq&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>布尔类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">bool</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//占用1字节</span></span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; flag &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; flag &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="三元运算"><a href="#三元运算" class="headerlink" title="三元运算"></a>三元运算</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> c;</span><br><span class="line">c = b &gt; a ? b : a;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// c=20</span></span><br><span class="line"><span class="comment">////////////</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">(b &gt; a ? b : a) = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 10</span></span><br><span class="line"><span class="comment">////////////</span></span><br><span class="line">  </span><br><span class="line"> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">(b &lt; a ? b : a) = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 20</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>
<h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 系统生成随机数 这样生成的随机数，每次都是一样的，是伪随机数</span></span><br><span class="line"><span class="keyword">int</span> num = rand() % <span class="number">100</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加随机数种子， 作用是利用当前系统时间生成随机数，防止每次随机数都一样</span></span><br><span class="line">srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="comment">//这样生成的随机数，每次都不一样</span></span><br><span class="line"><span class="keyword">int</span> num = rand() % <span class="number">100</span> + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; num &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h3 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h3><blockquote>
<p>在程序中不建议使用 goto 语句，以免造成程序的混乱</p>
</blockquote>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// 查看数组的内存大小</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(arr) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">//20 int类型一个数字占4个字节，5个数字就占20个字节</span></span><br><span class="line"><span class="comment">//通过数组名查看数组地址</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; &amp;arr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//0x7ffee5434b70</span></span><br><span class="line"><span class="comment">//通过数组名查看数组第一个元素地址 （与数组地址一致）</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; &amp;arr[<span class="number">0</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//0x7ffee5434b70</span></span><br><span class="line"><span class="comment">//通过数组名查看数组第二个元素地址</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; &amp;arr[<span class="number">1</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//0x7ffee5434b7</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p>冒泡排序</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">9</span>] = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]) - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]) - i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])&#123;</span><br><span class="line">      <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">      arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">      arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]); ++i) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>const修饰指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//const修饰的是指针，指针指向可以修改，指针指向的值不可以修改</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * p2 = &amp;a;</span><br><span class="line">p2 = &amp;b; <span class="comment">//正确</span></span><br><span class="line">*p2 = <span class="number">100</span>; <span class="comment">//错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰的是常量，指针指向不可以修改，指针指向的值可以修改</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p2 = &amp;a;</span><br><span class="line">p2 = &amp;b; <span class="comment">//错误</span></span><br><span class="line">*p2 = <span class="number">100</span>; <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//const既修饰指针又修饰常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p3 = &amp;a;</span><br><span class="line">p3 = &amp;b; <span class="comment">//错误</span></span><br><span class="line">*p3 = <span class="number">100</span>; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>指针和数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据指针获取数据</span></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">9</span>] = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = arr;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">//3</span></span><br><span class="line">p++;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *p &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>指针和函数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap2</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////////</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//值传递无法改变实参</span></span><br><span class="line">swap(a, b);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//地址传递可法改变实参</span></span><br><span class="line">swap2(&amp;a, &amp;b);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">// 20</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><blockquote>
<p>结构体属于用户自定义的数据类型，允许用户存储不同的数据类型</p>
<p>(相当java中的实体类、DTO、VO等)</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值方式1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s1</span>;</span></span><br><span class="line">s1.name = <span class="string">&quot;admin&quot;</span>;</span><br><span class="line">s1.age = <span class="number">12</span>;</span><br><span class="line">s1.score = <span class="number">45.2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值方式2</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s1</span> =</span> &#123;<span class="string">&quot;admin&quot;</span>, <span class="number">12</span>, <span class="number">34.5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值方式3</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">&#125;s3;</span><br><span class="line">s3.name = <span class="string">&quot;admin&quot;</span>;</span><br><span class="line">s3.age = <span class="number">12</span>;</span><br><span class="line">s3.score = <span class="number">45.2</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>结构体数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式1</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stuArray</span>[3] =</span> &#123;</span><br><span class="line">  &#123;<span class="string">&quot;张三&quot;</span>, <span class="number">12</span>, <span class="number">23.4</span>&#125;,</span><br><span class="line">  &#123;<span class="string">&quot;王五&quot;</span>, <span class="number">12</span>, <span class="number">23.4</span>&#125;,</span><br><span class="line">  &#123;<span class="string">&quot;马六&quot;</span>, <span class="number">12</span>, <span class="number">23.4</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stuArray</span>[3];</span></span><br><span class="line">stuArray[<span class="number">0</span>] = &#123;<span class="string">&quot;张三&quot;</span>, <span class="number">12</span>, <span class="number">23.4</span>&#125;;</span><br><span class="line">stuArray[<span class="number">1</span>] = &#123;<span class="string">&quot;王五&quot;</span>, <span class="number">12</span>, <span class="number">23.4</span>&#125;;</span><br><span class="line">stuArray[<span class="number">2</span>] = &#123;<span class="string">&quot;马六&quot;</span>, <span class="number">12</span>, <span class="number">23.4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式3</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stuArray</span>[3];</span></span><br><span class="line">stuArray[<span class="number">0</span>].name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">stuArray[<span class="number">0</span>].age = <span class="number">12</span>;</span><br><span class="line">stuArray[<span class="number">0</span>].score = <span class="number">23.9</span>;</span><br><span class="line"></span><br><span class="line">stuArray[<span class="number">1</span>].name = <span class="string">&quot;王五&quot;</span>;</span><br><span class="line">stuArray[<span class="number">1</span>].age = <span class="number">12</span>;</span><br><span class="line">stuArray[<span class="number">1</span>].score = <span class="number">23.9</span>;</span><br><span class="line"></span><br><span class="line">stuArray[<span class="number">2</span>].name = <span class="string">&quot;马六&quot;</span>;</span><br><span class="line">stuArray[<span class="number">2</span>].age = <span class="number">12</span>;</span><br><span class="line">stuArray[<span class="number">2</span>].score = <span class="number">23.9</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结构体指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s1</span> =</span> &#123;<span class="string">&quot;张三&quot;</span>, <span class="number">45</span>, <span class="number">34.5</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">t</span> =</span> &amp;s1;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; t-&gt;name &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//设置值</span></span><br><span class="line">t-&gt;age = <span class="number">28</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; t-&gt;age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//28</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>结构体嵌套结构体</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//学生结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">  <span class="built_in">string</span> name;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  <span class="keyword">float</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">teacher</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> id;</span><br><span class="line">  <span class="built_in">string</span> name;</span><br><span class="line">  <span class="keyword">int</span> age;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">teacher t1;</span><br><span class="line">t1.id = <span class="number">1</span>;</span><br><span class="line">t1.name = <span class="string">&quot;老王&quot;</span>;</span><br><span class="line">t1.age = <span class="number">36</span>;</span><br><span class="line">t1.stu.age = <span class="number">16</span>;</span><br><span class="line">t1.stu.name = <span class="string">&quot;小李&quot;</span>;</span><br><span class="line">t1.stu.score = <span class="number">79</span>;</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>结构体做函数参数</p>
<blockquote>
<p>将函数中的形参改为指针，可以减少内存空间，而且不会复制一个新的副本出来</p>
</blockquote>
</li>
<li><p>结构体中使用const</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//加入const后，一旦有修改的操作就会报错，可以防止我们的误操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStudent</span><span class="params">(<span class="keyword">const</span> Student *stu)</span></span>&#123;</span><br><span class="line">    stu-&gt;score = <span class="number">100</span>; <span class="comment">// 此处会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用系统服务</p>
<blockquote>
<p>system(“pause”); // 任意键继续</p>
<p>system(“cls”); //清屏</p>
</blockquote>
</li>
</ol>
<h3 id="C-内存分区模型"><a href="#C-内存分区模型" class="headerlink" title="C++ 内存分区模型"></a>C++ 内存分区模型</h3><ul>
<li>代码区：存放函数体的二进制代码，由操作系统管理</li>
<li>全局区：存放全局变量和静态变量以及常量</li>
<li>栈区：由编译器自动分配释放，存放函数的参数值，局部变量等</li>
<li>堆区：由程序员分配和释放，若程序员不释放，程序结束由操作系统回收</li>
</ul>
<blockquote>
<p>四区的意义：不同的区域存放的数据，赋予不同的生命周期，给我们更大的灵活编译</p>
</blockquote>
<ol>
<li><p>程序运行前</p>
<p>再程序编译以后，生成exe可执行文件，未执行该程序前分两个区域</p>
<ul>
<li><p>代码区</p>
<p>存放CPU执行的机械指令</p>
<p>代码区是共享的，目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p>
<p>代码区是只读的，原因是防止程序意外修改它的指令</p>
</li>
<li><p>全局区</p>
<p>全局变量和静态变量存放在这里</p>
<p>还包含了常量区，字符串常量和其他常量存放在这里</p>
<p><strong>该区域的数据在程序结束后有操作系统释放</strong></p>
</li>
</ul>
<blockquote>
<ul>
<li>C++中在程序运行之前分为全局区和代码区</li>
</ul>
<ul>
<li>代码区特点是共享和只读</li>
<li>全局区中存放全局变量、静态变量、常量</li>
<li>常量区中存放const修饰的全局变量和字符串常量</li>
</ul>
</blockquote>
</li>
<li><p>程序运行后</p>
<ul>
<li><p>栈区</p>
<p>由编译器自动分配释放，存放函数的参数值，局部变量等</p>
<p><strong>注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自定释放</strong></p>
</li>
<li><p>堆区</p>
<p>由程序员分配释放，若程序员不释放，程序结束时，由操作系统回收</p>
<p>在C++中主要利用new在堆中开辟内存</p>
</li>
</ul>
</li>
<li><p>new 操作符</p>
<p>利用new 在堆区开辟内存</p>
<p>由程序员手动开辟，手动释放，释放利用关键字：delete</p>
<p>利用new 创建的数据，会返回该数据对应的类型的指针</p>
<blockquote>
<p>释放数组的时候，要加[]才可以</p>
</blockquote>
<p>​</p>
</li>
</ol>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><blockquote>
<p>作用：给变量起别名</p>
</blockquote>
<p>语法：数据类型 别名 = 原名</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引用的基本类型</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//创建引用</span></span><br><span class="line"><span class="keyword">int</span> &amp;b = a;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//10</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">//10</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//100</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">//100</span></span><br><span class="line"><span class="comment">//a和b使用的是同一块内存</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>注意事项</p>
<ul>
<li>引用必须初始化</li>
<li>引用在初始化后，不可以改变</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引用的基本类型</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//创建引用，引用必须初始化</span></span><br><span class="line"><span class="keyword">int</span> &amp;b; <span class="comment">//错误的</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引用的基本类型</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//创建引用</span></span><br><span class="line"><span class="keyword">int</span> &amp;b = a;</span><br><span class="line"><span class="comment">//引用在初始化后，不可以改变</span></span><br><span class="line">&amp;b = c;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>引用做函数参数</p>
<ul>
<li><p>函数中的值传递，会改变形参的值，不会改变实参的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">20</span>;</span><br><span class="line">yesyt(a,c);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main a = &quot;</span> &lt;&lt;  a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main c = &quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">yesyt</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = c;</span><br><span class="line">    c = temp;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;yesyt a = &quot;</span> &lt;&lt;  a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;yesyt c = &quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">yesyt a = <span class="number">20</span></span><br><span class="line">yesyt c = <span class="number">10</span></span><br><span class="line">main a = <span class="number">10</span></span><br><span class="line">main c = <span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>地址传递会改变形参和实参的值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">20</span>;</span><br><span class="line">yesyt2(&amp;a,&amp;c);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main a = &quot;</span> &lt;&lt;  a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main c = &quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">yesyt2</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> *c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *c;</span><br><span class="line">    *c = temp;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;yesyt a = &quot;</span> &lt;&lt;  *a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;yesyt c = &quot;</span> &lt;&lt; *c &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">yesyt2 a = <span class="number">20</span></span><br><span class="line">yesyt2 c = <span class="number">10</span></span><br><span class="line">main a = <span class="number">20</span></span><br><span class="line">main c = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>引用传递会改变形参和实参的值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">20</span>;</span><br><span class="line">yesyt3(a,c);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main a = &quot;</span> &lt;&lt;  a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main c = &quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">yesyt3</span><span class="params">(<span class="keyword">int</span> &amp;a,<span class="keyword">int</span> &amp;c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = a;</span><br><span class="line">    a = c;</span><br><span class="line">    c = temp;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;yesyt3 a = &quot;</span> &lt;&lt;  a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;yesyt3 c = &quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">yesyt3 a = <span class="number">20</span></span><br><span class="line">yesyt3 c = <span class="number">10</span></span><br><span class="line">main a = <span class="number">20</span></span><br><span class="line">main c = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>解析：函数 yesyt3 中 &amp;a是实参 a的别名， &amp;b是实参 b的别名，综合上述知道，更改别名的值，原名的值也会改变。</p>
</blockquote>
<p>​</p>
</li>
<li><p>引用做函数的返回值</p>
<p>作用：引用是可以作为函数的返回值存在</p>
<p>注意：<strong>不要返回局部变量引用</strong>  (局部变量存放在栈区，栈区数据在执行完成以后自动释放)</p>
<p>用法：函数调用作为左值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回引用</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">yesyt4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>  <span class="keyword">int</span> d = <span class="number">120</span>;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;f = yesyt4();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main1 f = &quot;</span> &lt;&lt;  f &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">//120</span></span><br><span class="line"></span><br><span class="line">yesyt4() = <span class="number">100</span>; <span class="comment">//如果函数返回的值是引用，这个函数调用可以作为左值。(此处等于 a=100)</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main2 f = &quot;</span> &lt;&lt;  f &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">//100 (因为&amp;f为a的别名，a的值变了，&amp;f也就变了)</span></span><br></pre></td></tr></table></figure>
<p>​</p>
<p>​</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>引用的本质</p>
<blockquote>
<p>本质：引用的本质在C++内部实现是一个指针常量。所有的指针操作编译器帮我们做了</p>
</blockquote>
<p>指针常量：指针的指向不可修改，指针指向的值可以修改</p>
<p><img data-src="https://xuemingde.com/pages/image/2023/03/13/191457jZ2I5n.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可修改，也说明为什么引用不可更改</span></span><br><span class="line"><span class="keyword">int</span>&amp; ref = a;</span><br><span class="line">ref = <span class="number">20</span>;<span class="comment">//内部发现ref是引用，自动帮我们转换为：*ref = 20;</span></span><br><span class="line">func(a);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//发现是引用，转换为 int* const ref = &amp;a;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>&amp; ref)</span></span>&#123;</span><br><span class="line">      ref = <span class="number">100</span>; <span class="comment">//ref是引用，转换为 *ref = 100;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>常量引用</p>
<blockquote>
<p>作用：常量引用主要用来修饰形参，防止误操作</p>
</blockquote>
<p>函数形参列表中，可以加const修饰形参，防止形参改变实参</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">func(a);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; ref)</span></span>&#123;</span><br><span class="line">    ref = <span class="number">100</span>; <span class="comment">//此处报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
<h3 id="函数提高"><a href="#函数提高" class="headerlink" title="函数提高"></a>函数提高</h3><ol>
<li><p>函数默认参数</p>
<p>在C++中，函数的形参列表中的形参是可以默认值的</p>
<p>语法：返回值类型 函数名(参数 = 默认值){}</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">func(a,b);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c = <span class="number">14</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func c = &quot;</span> &lt;&lt; c &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a = <span class="number">10</span>,<span class="keyword">int</span> b= <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="comment">//此处报错，因为声明和实现只能有一个有默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a = <span class="number">10</span>,<span class="keyword">int</span> b= <span class="number">10</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>函数占位参数</p>
<p>C++中函数的形参列表里可以有占位参数，用来占位，调用函数时必须填补该位置</p>
<p>语法：返回值类型 函数名(数据类型){}</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//第二个int就是占位参数，调用是必须传int值（现在还没有用到）</span></span><br><span class="line"><span class="comment">//占位参数也可以有默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line">func(a,b);</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>函数重载</p>
<ul>
<li><p>函数重载概述</p>
<p>作用：函数名可以相同，提高复用性</p>
<p>条件：</p>
<ul>
<li>同一作用域下</li>
<li>函数名相同</li>
<li><strong>参数不同</strong>或者<strong>个数不同</strong>或者<strong>顺序不同</strong></li>
</ul>
<p>注意：函数的返回值不可以作为函数重载条件</p>
<p>​</p>
</li>
<li><p>函数重载注意事项</p>
<ul>
<li><p>引用作为重载条件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面两个函数是可以编译通过的</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> &amp;a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">func(a); <span class="comment">//调用不加const的函数，因为a是一个变量</span></span><br><span class="line"><span class="comment">//int &amp;a = 10  是不合法的</span></span><br><span class="line"></span><br><span class="line">func(<span class="number">10</span>);<span class="comment">//调用加const的函数</span></span><br><span class="line"><span class="comment">//const int &amp;a = 10  是合法的</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>函数重载碰到函数默认值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b = <span class="number">10</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">func(a);<span class="comment">//此处报错</span></span><br><span class="line">func(a,<span class="number">10</span>);<span class="comment">//不会报错，但会走带默认参数的函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当函数重载碰到默认参数，会出现二义性，应尽量避免这种情况</span></span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
<p>​</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>C&amp;C++</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>内存</tag>
        <tag>const</tag>
        <tag>堆</tag>
        <tag>栈</tag>
        <tag>函数</tag>
        <tag>数组</tag>
        <tag>C++</tag>
        <tag>linux</tag>
        <tag>CPU</tag>
        <tag>指针</tag>
        <tag>全局</tag>
        <tag>局部</tag>
        <tag>变量</tag>
      </tags>
  </entry>
  <entry>
    <title>C++学习笔记2</title>
    <url>/posts/1HT8JDQ.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><p>C++面向对象的三大特性：封装、继承、多态。  （与java的特性一致）</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><h4 id="struct与class的区别"><a href="#struct与class的区别" class="headerlink" title="struct与class的区别"></a>struct与class的区别</h4><p>默认的访问权限不同</p>
<ul>
<li>struct 默认权限为公共</li>
<li>class 默认权限为私有</li>
</ul>
<h4 id="成员属性设置为私有"><a href="#成员属性设置为私有" class="headerlink" title="成员属性设置为私有"></a>成员属性设置为私有</h4><p>优点：</p>
<ul>
<li>将所有的成员属性</li>
<li>对于写权限，我们可以检测数据的有效性</li>
</ul>
<h3 id="对象的初始化和清理"><a href="#对象的初始化和清理" class="headerlink" title="对象的初始化和清理"></a>对象的初始化和清理</h3><ul>
<li>生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用的时候也会删除一些自己信息数据保证安全</li>
<li>C++中的面向对象来源于生活，每个对象也都会有初始设置以及对象销毁前的清理数据的设。</li>
</ul>
<h4 id="构造函数和析构函数"><a href="#构造函数和析构函数" class="headerlink" title="构造函数和析构函数"></a>构造函数和析构函数</h4><p>对象的初始化和清理也是两个非常重要的安全问题</p>
<p>一个对象或者变是没有初始状态，对其使用后果是未知</p>
<p>同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p>
<p>C++利用了构造函数和析构函数决上述问题，这两个函数将会被编译器自动调角,完成对象初始化和清理工作，对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供编译器提供的构造函数和析构函数是空实现</p>
<ul>
<li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编泽器自动调用,无须手动调用。</li>
<li>析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。</li>
</ul>
<p><img data-src="https://xuemingde.com/pages/image/2023/03/14/151445mBLa97.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    person()&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;无参构造函数-- &quot;</span>  &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~person()&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;析构函数-- &quot;</span>  &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    person pe; <span class="comment">//在栈上的数据，执行完main 释放这个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="构造函数的分类及调用"><a href="#构造函数的分类及调用" class="headerlink" title="构造函数的分类及调用"></a>构造函数的分类及调用</h4><p><img data-src="https://xuemingde.com/pages/image/2023/03/14/1531201KZPG0.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//无参构造函数</span></span><br><span class="line">    person() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;无参构造函数-- &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有参构造函数</span></span><br><span class="line">    person(<span class="keyword">int</span> a) &#123;</span><br><span class="line">        age = a;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;有参构造函数-- &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拷贝构造函数，防止参数的数据被修改，需要加const</span></span><br><span class="line">    person(<span class="keyword">const</span> person &amp;p) &#123;</span><br><span class="line">        age = p.age;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;拷贝构造函数-- &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~person() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;析构函数-- &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main&#123;</span><br><span class="line">  <span class="comment">//注意事项：在调用无参构造函数（默认构造函数）时，不要加 () ，因为编译器会认为是一个函数声明，不会认为在创建对象。</span></span><br><span class="line">  <span class="function">person <span class="title">p</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//括号法 (推荐)</span></span><br><span class="line">  person p1;</span><br><span class="line">  <span class="function">person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">  <span class="function">person <span class="title">p3</span><span class="params">(p2)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//显式法</span></span><br><span class="line">  person p1;</span><br><span class="line">  person p2 = person(<span class="number">10</span>);</span><br><span class="line">  person p3 = person(p2);</span><br><span class="line"></span><br><span class="line">  person(<span class="number">10</span>); <span class="comment">//匿名对象，特点：当前行执行结束后，系统会立即回收掉匿名对象</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//注意事项：不要利用拷贝构造函数初始化匿名对象，编译器会认为：person(p3) = person p3; 对象重定义了</span></span><br><span class="line">  person(p3); <span class="comment">//会出错</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//隐式转换法</span></span><br><span class="line">  person p4 = <span class="number">10</span>; <span class="comment">//相当于  person p4 = person(10);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="拷贝构造函数调用的时机"><a href="#拷贝构造函数调用的时机" class="headerlink" title="拷贝构造函数调用的时机"></a>拷贝构造函数调用的时机</h4><p><img data-src="https://xuemingde.com/pages/image/2023/03/14/1648379wQcvZ.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用一个已经创建完毕的对象初始化吧另一个新对象</span></span><br><span class="line"><span class="function">person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">person <span class="title">p3</span><span class="params">(p2)</span></span>;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(person p)</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//值传递的方式给函数参数传值</span></span><br><span class="line">person p;</span><br><span class="line">func(p);</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line"><span class="comment">//值方式返回局部对象</span></span><br><span class="line"><span class="function">person <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    person p1;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    person p = func();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    func2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="构造函数调用规则"><a href="#构造函数调用规则" class="headerlink" title="构造函数调用规则"></a>构造函数调用规则</h4><p><img data-src="https://xuemingde.com/pages/image/2023/03/15/093613wEIw3F.png" alt=""></p>
<ul>
<li>如果我们写了有参构造函数，编译器不再提供默认构造函数，依然提供拷贝构造</li>
<li>如果我们写了拷贝构造函数，编译器就不再提供其他普通构造函数</li>
</ul>
<h4 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h4><p>浅烤贝：简单的赋值拷贝操作<br>深烤贝：在堆区重新申请空间，进行拷贝操作</p>
<p>存在的问题解析：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">//无参构造函数</span></span><br><span class="line">    person() &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;无参构造函数-- &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有参构造函数</span></span><br><span class="line">    person(<span class="keyword">int</span> a, <span class="keyword">int</span> height) &#123;</span><br><span class="line">        age = a;</span><br><span class="line">        m_height = <span class="keyword">new</span> <span class="keyword">int</span>(height);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;有参构造函数-- &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//析构函数</span></span><br><span class="line">    ~person() &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_height != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="comment">//将堆区开辟的数据释放</span></span><br><span class="line">            <span class="keyword">delete</span> m_height;</span><br><span class="line">            m_height  =<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;析构函数-- &quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">int</span> *m_height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">person <span class="title">p1</span><span class="params">(<span class="number">18</span>,<span class="number">178</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p1  = &quot;</span> &lt;&lt; p1.age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p1-2  = &quot;</span> &lt;&lt; *p1.m_height &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">person <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p2  = &quot;</span> &lt;&lt; p2.age &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p2-2  = &quot;</span> &lt;&lt; *p2.m_height &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    func2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动出现错误</span></span><br><span class="line"><span class="comment">//smple_1_1(4069,0x10cfa0dc0) malloc: *** error for object 0x7f8ae6405780: pointer being freed was not allocated</span></span><br><span class="line"><span class="comment">//smple_1_1(4069,0x10cfa0dc0) malloc: *** set a breakpoint in malloc_error_break to debug</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C&amp;C++</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>bug</tag>
        <tag>const</tag>
        <tag>堆</tag>
        <tag>栈</tag>
        <tag>函数</tag>
        <tag>C++</tag>
        <tag>局部</tag>
        <tag>变量</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中有几种引用</title>
    <url>/posts/APJKVT.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><div style="text-align: center;">
</div><br><span id="more"></span><br>Gitee原文 : <span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vbWVhZGVyL2hleG8tYmxvZy9ibG9iL2Jsb2cvc291cmNlL19wb3N0cy9KQVZBJUU1JTlGJUJBJUU3JUExJTgwLzIwMjIwMjE0LUphdmElRTQlQjglQUQlRTYlOUMlODklRTUlODclQTAlRTclQTclOEQlRTUlQkMlOTUlRTclOTQlQTgubWQ=">https://gitee.com/meader/hexo-blog/blob/blog/source/_posts/JAVA%E5%9F%BA%E7%A1%80/20220214-Java%E4%B8%AD%E6%9C%89%E5%87%A0%E7%A7%8D%E5%BC%95%E7%94%A8.md<i class="fa fa-external-link-alt"></i></span></p>
<p>四种：强、软、弱、虚。</p>
<ul>
<li>强引用：<br>有引用变量指向时永远不会被垃圾回收，哪怕内存不足时，JVM宁愿抛出OutOfMemory错误也不会回收这种对象。如果想中断强引用与对象之间的联系，可以显示的将强引用赋值为null，这样一来，JVM就可以适时的回收对象了<br>例子：<code>M m = new M();</code><br><code>m = null;</code> 此时垃圾回收器才会回收。<br>​</li>
</ul>
<ul>
<li>软引用<br>在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。<br>例子：<code>SoftReference&lt;Byte[]&gt; m = new SoftReference&lt;&gt;(new Byte[1024]);</code><br>​</li>
</ul>
<ul>
<li>弱引用 (面试重点）<br>弱引用的引用强度比软引用要更弱一些，<strong>无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收。</strong><br>例子：<code>WeakReference&lt;M&gt; m = new WeakReference&lt;&gt;(new M());</code><br>​</li>
</ul>
<ul>
<li>虚引用<br>虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收。<br>例子：<code>PhantomReference phantomReference = new PhantomReference&lt;Object&gt;(new CanisterInfo(), new ReferenceQueue&lt;&gt;());</code><br><code>phantomReference.get();</code> 什么时候都无法get到。<br>当垃圾回收器准备回收一个对象时，如果发现它与虚引用关联，就会在回收它之前，将这个虚引用加入到引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被回收，如果确实要被回收，就可以做一些回收之前的收尾工作。  </li>
</ul>
<p><strong>弱引用重点示例（结合ThreadLocal）</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadLocal&lt;CanisterInfo&gt; tl = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">        tl.set(<span class="keyword">new</span> CanisterInfo());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//此处的this 是ThreadLocal对象</span></span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// We don&#x27;t use a fast path as with get() because it is at</span></span><br><span class="line">            <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">            <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">            <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">            Entry[] tab = table;</span><br><span class="line">            <span class="keyword">int</span> len = tab.length;</span><br><span class="line">            <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">                 e != <span class="keyword">null</span>;</span><br><span class="line">                 e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">                ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                    e.value = value;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    replaceStaleEntry(key, value, i);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">            <span class="keyword">int</span> sz = ++size;</span><br><span class="line">            <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">                rehash();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Entry对象继承了WeakReference，一个弱引用对象</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><br><img data-src="https://xuemingde.com/pages/image/others/WvXOry.png" alt=""><br>此图说明了，在 <code>ThreadLocal&lt;CanisterInfo&gt; tl = new ThreadLocal&lt;&gt;();</code> 并且 <code>tl.set(new CanisterInfo());</code>后有一个强引用tl指向了ThreadLocal对象，也有一个弱引用（ThreadLocalMap的key）也指向了ThreadLocal。<br>为什么Entry会使用弱引用，图中也说明了。</p>
]]></content>
      <categories>
        <category>JAVA基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>C</tag>
        <tag>内存</tag>
        <tag>变量</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Guava中这些Map的骚操作</title>
    <url>/posts/4ENXFE.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><div style="text-align: center;"></div><br><span id="more"></span></p>
<p>在线查看：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYWxpeXVuZHJpdmUuY29tL3MvWnZ1aGU1Mm1lS24=">阿里云盘<i class="fa fa-external-link-alt"></i></span></p>
<hr>
<p>原文：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvTE9aLXA2ZGl2UmpPOVpUY3VzMTAxQQ==">https://mp.weixin.qq.com/s/LOZ-p6divRjO9ZTcus101A<i class="fa fa-external-link-alt"></i></span><br>在线预览：<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vbWVhZGVyL2hleG8tYmxvZy9yYXcvYmxvZy9zb3VyY2UvcGRmUGF0aC9HdWF2YSVFNCVCOCVBRCVFOCVCRiU5OSVFNCVCQSU5Qk1hcCVFNyU5QSU4NCVFOSVBQSU5QSVFNiU5MyU4RCVFNCVCRCU5Qy5wZGY=">预览<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>JAVA基础</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>pdf</tag>
      </tags>
  </entry>
  <entry>
    <title>如何优雅地记录操作日志</title>
    <url>/posts/2SZHQ52.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><div style="text-align: center;"></div><br><span id="more"></span></p>
<blockquote>
<p>本文转自 <span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvSkM1MVNfYkkwMm5wbTRDRTVORUVvdw=="> 美团技术团队<i class="fa fa-external-link-alt"></i></span></p>
<p>操作日志几乎存在于每个系统中，而这些系统都有记录操作日志的一套 API。操作日志和系统日志不一样，操作日志必须要做到简单易懂。所以如何让操作日志不跟业务逻辑耦合，如何让操作日志的内容易于理解，如何让操作日志的接入更加简单？上面这些都是本文要回答的问题。我们主要围绕着如何“优雅”地记录操作日志展开描述，希望对从事相关工作的同学能够有所帮助或者启发。</p>
</blockquote>
<ul>
<li><ol>
<li>操作日志的使用场景</li>
</ol>
</li>
<li><ol>
<li>实现方式</li>
</ol>
</li>
<li><ul>
<li>2.1 使用 Canal 监听数据库记录操作日志</li>
<li>2.2 通过日志文件的方式记录</li>
<li>2.3 通过 LogUtil 的方式记录日志</li>
<li>2.4 方法注解实现操作日志</li>
</ul>
</li>
<li><ol>
<li>优雅地支持 AOP 生成动态的操作日志</li>
</ol>
</li>
<li><ul>
<li>3.1 动态模板</li>
</ul>
</li>
<li><ol>
<li>代码实现解析</li>
</ol>
</li>
<li><ul>
<li>4.1 代码结构</li>
<li>4.2 模块介绍</li>
</ul>
</li>
<li><ol>
<li>总结</li>
</ol>
</li>
</ul>
<h2 id="操作日志的使用场景"><a href="#操作日志的使用场景" class="headerlink" title="操作日志的使用场景"></a>操作日志的使用场景</h2><p><img data-src="https://xuemingde.com/pages/image/2022/03/203319.png" alt="图片">例子</p>
<p><strong>系统日志和操作日志的区别</strong></p>
<p><strong>系统日志</strong>：系统日志主要是为开发排查问题提供依据，一般打印在日志文件中；系统日志的可读性要求没那么高，日志中会包含代码的信息，比如在某个类的某一行打印了一个日志。</p>
<p><strong>操作日志</strong>：主要是对某个对象进行新增操作或者修改操作后记录下这个新增或者修改，操作日志要求可读性比较强，因为它主要是给用户看的，比如订单的物流信息，用户需要知道在什么时间发生了什么事情。再比如，客服对工单的处理记录信息。</p>
<p>操作日志的记录格式大概分为下面几种：</p>
<ul>
<li>单纯的文字记录，比如：2021-09-16 10:00 订单创建。</li>
<li>简单的动态的文本记录，比如：2021-09-16 10:00 订单创建，订单号：NO.11089999，其中涉及变量订单号“NO.11089999”。</li>
<li>修改类型的文本，包含修改前和修改后的值，比如：2021-09-16 10:00 用户小明修改了订单的配送地址：从“金灿灿小区”修改到“银盏盏小区” ，其中涉及变量配送的原地址“金灿灿小区”和新地址“银盏盏小区”。</li>
<li>修改表单，一次会修改多个字段。</li>
</ul>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="使用-Canal-监听数据库记录操作日志"><a href="#使用-Canal-监听数据库记录操作日志" class="headerlink" title="使用 Canal 监听数据库记录操作日志"></a>使用 Canal 监听数据库记录操作日志</h3><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FsaWJhYmEvY2FuYWw=">Canal<i class="fa fa-external-link-alt"></i></span> 是一款基于 MySQL 数据库增量日志解析，提供增量数据订阅和消费的开源组件，通过采用监听数据库 Binlog 的方式，这样可以从底层知道是哪些数据做了修改，然后根据更改的数据记录操作日志。</p>
<p>这种方式的优点是和业务逻辑完全分离。缺点也很明显，局限性太高，只能针对数据库的更改做操作日志记录，如果修改涉及到其他团队的 RPC 的调用，就没办法监听数据库了。举个例子：给用户发送通知，通知服务一般都是公司内部的公共组件，这时候只能在调用 RPC 的时候手工记录发送通知的操作日志了。</p>
<h3 id="通过日志文件的方式记录"><a href="#通过日志文件的方式记录" class="headerlink" title="通过日志文件的方式记录"></a>通过日志文件的方式记录</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">log</span>.<span class="keyword">info</span>(&quot;订单创建&quot;)</span><br><span class="line"><span class="keyword">log</span>.<span class="keyword">info</span>(&quot;订单已经创建，订单编号:&#123;&#125;&quot;, orderNo)</span><br><span class="line"><span class="keyword">log</span>.<span class="keyword">info</span>(&quot;修改了订单的配送地址：从“&#123;&#125;”修改到“&#123;&#125;”， &quot;金灿灿小区&quot;, &quot;银盏盏小区&quot;)</span><br></pre></td></tr></table></figure>
<p>这种方式的操作记录需要解决三个问题。</p>
<p><strong>问题一：操作人如何记录</strong></p>
<p>借助 SLF4J 中的 MDC 工具类，把操作人放在日志中，然后在日志中统一打印出来。首先在用户的拦截器中把用户的标识 Put 到 MDC 中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//获取到用户标识</span></span><br><span class="line">    String userNo = getUserNo(request);</span><br><span class="line">    <span class="comment">//把用户 ID 放到 MDC 上下文中</span></span><br><span class="line">    MDC.put(<span class="string">&quot;userId&quot;</span>, userNo);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.preHandle(request, response, handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">getUserNo</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过 SSO 或者Cookie 或者 Auth信息获取到 当前登陆的用户信息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其次，把 userId 格式化到日志中，使用 %X{userId} 可以取到 MDC 中用户标识。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pattern</span>&gt;</span>&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %t %-5level %X&#123;userId&#125; %logger&#123;30&#125;.%method:%L - %msg%n&quot;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>问题二：操作日志如何和系统日志区分开</strong></p>
<p>通过配置 Log 的配置文件，把有关操作日志的 Log 单独放到一日志文件中。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//不同业务日志记录到不同的文件</span><br><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;businessLogAppender&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">File</span>&gt;</span>logs/business.log<span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">append</span>&gt;</span>true<span class="tag">&lt;/<span class="name">append</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>logs/业务A.%d.%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>90<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>10MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %t %-5level %X&#123;userId&#125; %logger&#123;30&#125;.%method:%L - %msg%n&quot;<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;businessLog&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span> <span class="attr">level</span>=<span class="string">&quot;INFO&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;businessLogAppender&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在 Java 代码中单独的记录业务日志。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//记录特定日志的声明</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Logger businessLog = LoggerFactory.getLogger(<span class="string">&quot;businessLog&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//日志存储</span></span><br><span class="line">businessLog.info(<span class="string">&quot;修改了配送地址&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>问题三：如何生成可读懂的日志文案</strong></p>
<p>可以采用 LogUtil 的方式，也可以采用切面的方式生成日志模板，后续内容将会进行介绍。这样就可以把日志单独保存在一个文件中，然后通过日志收集可以把日志保存在 Elasticsearch 或者数据库中，接下来我们看下如何生成可读的操作日志。</p>
<h3 id="通过-LogUtil-的方式记录日志"><a href="#通过-LogUtil-的方式记录日志" class="headerlink" title="通过 LogUtil 的方式记录日志"></a>通过 LogUtil 的方式记录日志</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LogUtil.log(orderNo, <span class="string">&quot;订单创建&quot;</span>, <span class="string">&quot;小明&quot;</span>)</span><br><span class="line">LogUtil.log(orderNo, <span class="string">&quot;订单创建，订单号&quot;</span>+<span class="string">&quot;NO.11089999&quot;</span>,  <span class="string">&quot;小明&quot;</span>)</span><br><span class="line">String template = <span class="string">&quot;用户%s修改了订单的配送地址：从“%s”修改到“%s”&quot;</span></span><br><span class="line">LogUtil.log(orderNo, String.format(tempalte, <span class="string">&quot;小明&quot;</span>, <span class="string">&quot;金灿灿小区&quot;</span>, <span class="string">&quot;银盏盏小区&quot;</span>),  <span class="string">&quot;小明&quot;</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里解释下为什么记录操作日志的时候都绑定了一个 OrderNo，因为操作日志记录的是：某一个“时间”“谁”对“什么”做了什么“事情”。当查询业务的操作日志的时候，会查询针对这个订单的的所有操作，所以代码中加上了 OrderNo，记录操作日志的时候需要记录下操作人，所以传了操作人“小明”进来。</p>
</blockquote>
<p>上面看起来问题并不大，在修改地址的业务逻辑方法中使用一行代码记录了操作日志，接下来再看一个更复杂的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> OnesIssueDO <span class="title">updateAddress</span><span class="params">(updateDeliveryRequest request)</span> </span>&#123;</span><br><span class="line">    DeliveryOrder deliveryOrder = deliveryQueryService.queryOldAddress(request.getDeliveryOrderNo());</span><br><span class="line">    <span class="comment">// 更新派送信息，电话，收件人，地址</span></span><br><span class="line">    doUpdate(request);</span><br><span class="line">    String logContent = getLogContent(request, deliveryOrder);</span><br><span class="line">    LogUtils.logRecord(request.getOrderNo(), logContent, request.getOperator);</span><br><span class="line">    <span class="keyword">return</span> onesIssueDO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getLogContent</span><span class="params">(updateDeliveryRequest request, DeliveryOrder deliveryOrder)</span> </span>&#123;</span><br><span class="line">    String template = <span class="string">&quot;用户%s修改了订单的配送地址：从“%s”修改到“%s”&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> String.format(tempalte, request.getUserName(), deliveryOrder.getAddress(), request.getAddress);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到上面的例子使用了两个方法代码，外加一个 getLogContent 的函数实现了操作日志的记录。当业务变得复杂后，记录操作日志放在业务代码中会导致业务的逻辑比较繁杂，最后导致 LogUtils.logRecord() 方法的调用存在于很多业务的代码中，而且类似 getLogContent() 这样的方法也散落在各个业务类中，对于代码的可读性和可维护性来说是一个灾难。下面介绍下如何避免这个灾难。</p>
<h3 id="方法注解实现操作日志"><a href="#方法注解实现操作日志" class="headerlink" title="方法注解实现操作日志"></a>方法注解实现操作日志</h3><p>为了解决上面问题，一般采用 AOP 的方式记录日志，让操作日志和业务逻辑解耦，接下来看一个简单的 AOP 日志的例子。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@LogRecord(content=&quot;修改了配送地址&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyAddress</span><span class="params">(updateDeliveryRequest request)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 更新派送信息 电话，收件人、地址</span></span><br><span class="line">    doUpdate(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以在注解的操作日志上记录固定文案，这样业务逻辑和业务代码可以做到解耦，让我们的业务代码变得纯净起来。可能有同学注意到，上面的方式虽然解耦了操作日志的代码，但是记录的文案并不符合我们的预期，文案是静态的，没有包含动态的文案，因为我们需要记录的操作日志是：用户%s修改了订单的配送地址，从“%s”修改到“%s”。接下来，我们介绍一下如何优雅地使用 AOP 生成动态的操作日志。</p>
<h2 id="优雅地支持-AOP-生成动态的操作日志"><a href="#优雅地支持-AOP-生成动态的操作日志" class="headerlink" title="优雅地支持 AOP 生成动态的操作日志"></a>优雅地支持 AOP 生成动态的操作日志</h2><h3 id="动态模板"><a href="#动态模板" class="headerlink" title="动态模板"></a>动态模板</h3><p>一提到动态模板，就会涉及到让变量通过占位符的方式解析模板，从而达到通过注解记录操作日志的目的。模板解析的方式有很多种，这里使用了 SpEL（Spring Expression Language，Spring表达式语言）来实现。我们可以先写下期望的记录日志的方式，然后再看看能否实现这样的功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@LogRecord(content = &quot;修改了订单的配送地址：从“#oldAddress”, 修改到“#request.address”&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyAddress</span><span class="params">(updateDeliveryRequest request, String oldAddress)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 更新派送信息 电话，收件人、地址</span></span><br><span class="line">    doUpdate(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 SpEL 表达式引用方法上的参数，可以让变量填充到模板中达到动态的操作日志文本内容。但是现在还有几个问题需要解决：</p>
<ul>
<li>操作日志需要知道是哪个操作人修改的订单配送地址。</li>
<li>修改订单配送地址的操作日志需要绑定在配送的订单上，从而可以根据配送订单号查询出对这个配送订单的所有操作。</li>
<li>为了在注解上记录之前的配送地址是什么，在方法签名上添加了一个和业务无关的 oldAddress 的变量，这样就不优雅了。</li>
</ul>
<p>为了解决前两个问题，我们需要把期望的操作日志使用形式改成下面的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@LogRecord(</span></span><br><span class="line"><span class="meta">     content = &quot;修改了订单的配送地址：从“#oldAddress”, 修改到“#request.address”&quot;,</span></span><br><span class="line"><span class="meta">     operator = &quot;#request.userName&quot;, bizNo=&quot;#request.deliveryOrderNo&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyAddress</span><span class="params">(updateDeliveryRequest request, String oldAddress)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 更新派送信息 电话，收件人、地址</span></span><br><span class="line">    doUpdate(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改后的代码在注解上添加两个参数，一个是操作人，一个是操作日志需要绑定的对象。但是，在普通的 Web 应用中用户信息都是保存在一个线程上下文的静态方法中，所以 operator 一般是这样的写法（假定获取当前登陆用户的方式是 UserContext.getCurrentUser()）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">operator = <span class="string">&quot;#&#123;T(com.meituan.user.UserContext).getCurrentUser()&#125;&quot;</span></span><br></pre></td></tr></table></figure>
<p>这样的话，每个 @LogRecord 的注解上的操作人都是这么长一串。为了避免过多的重复代码，我们可以把注解上的 operator 参数设置为非必填，这样用户可以填写操作人。但是，如果用户不填写我们就取 UserContext 的 user（下文会介绍如何取 user）。最后，最简单的日志变成了下面的形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@LogRecord(content = &quot;修改了订单的配送地址：从“#oldAddress”, 修改到“#request.address”&quot;, </span></span><br><span class="line"><span class="meta">           bizNo=&quot;#request.deliveryOrderNo&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyAddress</span><span class="params">(updateDeliveryRequest request, String oldAddress)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 更新派送信息 电话，收件人、地址</span></span><br><span class="line">    doUpdate(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们需要解决第三个问题：为了记录业务操作记录添加了一个 oldAddress 变量，不管怎么样这都不是一个好的实现方式，所以接下来，我们需要把 oldAddress 变量从修改地址的方法签名上去掉。但是操作日志确实需要 oldAddress 变量，怎么办呢？</p>
<p>要么和产品经理 PK 一下，让产品经理把文案从“修改了订单的配送地址：从 xx 修改到 yy” 改为 “修改了订单的配送地址为：yy”。但是从用户体验上来看，第一种文案更人性化一些，显然我们不会 PK 成功的。那么我们就必须要把这个 oldAddress 查询出来然后供操作日志使用了。还有一种解决办法是：把这个参数放到操作日志的线程上下文中，供注解上的模板使用。我们按照这个思路再改下操作日志的实现代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@LogRecord(content = &quot;修改了订单的配送地址：从“#oldAddress”, 修改到“#request.address”&quot;,</span></span><br><span class="line"><span class="meta">        bizNo=&quot;#request.deliveryOrderNo&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyAddress</span><span class="params">(updateDeliveryRequest request)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 查询出原来的地址是什么</span></span><br><span class="line">    LogRecordContext.putVariable(<span class="string">&quot;oldAddress&quot;</span>, DeliveryService.queryOldAddress(request.getDeliveryOrderNo()));</span><br><span class="line">    <span class="comment">// 更新派送信息 电话，收件人、地址</span></span><br><span class="line">    doUpdate(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候可以看到，LogRecordContext 解决了操作日志模板上使用方法参数以外变量的问题，同时避免了为了记录操作日志修改方法签名的设计。虽然已经比之前的代码好了些，但是依然需要在业务代码里面加了一行业务逻辑无关的代码，如果有“强迫症”的同学还可以继续往下看，接下来我们会讲解自定义函数的解决方案。下面再看另一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@LogRecord(content = &quot;修改了订单的配送员：从“#oldDeliveryUserId”, 修改到“#request.userId”&quot;,</span></span><br><span class="line"><span class="meta">        bizNo=&quot;#request.deliveryOrderNo&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyAddress</span><span class="params">(updateDeliveryRequest request)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 查询出原来的地址是什么</span></span><br><span class="line">    LogRecordContext.putVariable(<span class="string">&quot;oldDeliveryUserId&quot;</span>, DeliveryService.queryOldDeliveryUserId(request.getDeliveryOrderNo()));</span><br><span class="line">    <span class="comment">// 更新派送信息 电话，收件人、地址</span></span><br><span class="line">    doUpdate(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个操作日志的模板最后记录的内容是这样的格式：修改了订单的配送员：从 “10090”，修改到 “10099”，显然用户看到这样的操作日志是不明白的。用户对于用户 ID 是 10090 还是 10099 并不了解，用户期望看到的是：修改了订单的配送员：从“张三（18910008888）”，修改到“小明（13910006666）”。用户关心的是配送员的姓名和电话。但是我们方法中传递的参数只有配送员的 ID，没有配送员的姓名可电话。我们可以通过上面的方法，把用户的姓名和电话查询出来，然后通过 LogRecordContext 实现。</p>
<p>但是，“强迫症”是不期望操作日志的代码嵌入在业务逻辑中的。接下来，我们考虑另一种实现方式：自定义函数。如果我们可以通过自定义函数把用户 ID 转换为用户姓名和电话，那么就能解决这一问题，按照这个思路，我们把模板修改为下面的形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@LogRecord(content = &quot;修改了订单的配送员：从“&#123;deliveryUser&#123;#oldDeliveryUserId&#125;&#125;”, 修改到“&#123;deveryUser&#123;#request.userId&#125;&#125;”&quot;,</span></span><br><span class="line"><span class="meta">        bizNo=&quot;#request.deliveryOrderNo&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyAddress</span><span class="params">(updateDeliveryRequest request)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 查询出原来的地址是什么</span></span><br><span class="line">    LogRecordContext.putVariable(<span class="string">&quot;oldDeliveryUserId&quot;</span>, DeliveryService.queryOldDeliveryUserId(request.getDeliveryOrderNo()));</span><br><span class="line">    <span class="comment">// 更新派送信息 电话，收件人、地址</span></span><br><span class="line">    doUpdate(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 deliveryUser 是自定义函数，使用大括号把 Spring 的 SpEL 表达式包裹起来，这样做的好处：一是把 Spring EL 表达式和自定义函数区分开便于解析；二是如果模板中不需要 SpEL 表达式解析可以容易的识别出来，减少 SpEL 的解析提高性能。这时候我们发现上面代码还可以优化成下面的形式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@LogRecord(content = &quot;修改了订单的配送员：从“&#123;queryOldUser&#123;#request.deliveryOrderNo()&#125;&#125;”, 修改到“&#123;deveryUser&#123;#request.userId&#125;&#125;”&quot;,</span></span><br><span class="line"><span class="meta">        bizNo=&quot;#request.deliveryOrderNo&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyAddress</span><span class="params">(updateDeliveryRequest request)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 更新派送信息 电话，收件人、地址</span></span><br><span class="line">    doUpdate(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就不需要在 modifyAddress 方法中通过 LogRecordContext.putVariable() 设置老的快递员了，通过直接新加一个自定义函数 queryOldUser() 参数把派送订单传递进去，就能查到之前的配送人了，只需要让方法的解析在 modifyAddress() 方法执行之前运行。这样的话，我们让业务代码又变得纯净了起来，同时也让“强迫症”不再感到难受了。</p>
<h2 id="代码实现解析"><a href="#代码实现解析" class="headerlink" title="代码实现解析"></a>代码实现解析</h2><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><p><img data-src="https://xuemingde.com/pages/image/2022/03/203536.png" alt="图片"></p>
<p>上面的操作日志主要是通过一个 AOP 拦截器实现的，整体主要分为 AOP 模块、日志解析模块、日志保存模块、Starter 模块；组件提供了4个扩展点，分别是：自定义函数、默认处理人、业务保存和查询；业务可以根据自己的业务特性定制符合自己业务的逻辑。</p>
<h3 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍"></a>模块介绍</h3><p>有了上面的分析，已经得出一种我们期望的操作日志记录的方式，接下来我们看下如何实现上面的逻辑。实现主要分为下面几个步骤：</p>
<ul>
<li><p>AOP 拦截逻辑</p>
</li>
<li><p>解析逻辑</p>
</li>
<li><ul>
<li>模板解析</li>
<li>LogContext 逻辑</li>
<li>默认的 operator 逻辑</li>
<li>自定义函数逻辑</li>
</ul>
</li>
<li><p>默认的日志持久化逻辑</p>
</li>
<li><p>Starter 封装逻辑</p>
</li>
</ul>
<h4 id="AOP-拦截逻辑"><a href="#AOP-拦截逻辑" class="headerlink" title="AOP 拦截逻辑"></a>AOP 拦截逻辑</h4><p>这块逻辑主要是一个拦截器，针对 @LogRecord 注解分析出需要记录的操作日志，然后把操作日志持久化，这里把注解命名为 @LogRecordAnnotation。接下来，我们看下注解的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> LogRecordAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">success</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">fail</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">operator</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">bizNo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">category</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">detail</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">condition</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注解中除了上面提到参数外，还增加了 fail、category、detail、condition 等参数，这几个参数是为了满足特定的场景，后面还会给出具体的例子。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/203601.png" alt="图片"></p>
<p>为了保持简单，组件的必填参数就两个。业务中的 AOP 逻辑大部分是使用 @Aspect 注解实现的，但是基于注解的 AOP 在 Spring boot 1.5 中兼容性是有问题的，组件为了兼容 Spring boot1.5 的版本我们手工实现 Spring 的 AOP 逻辑。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/28/165704.jpg" alt="165704"></p>
<p>切面选择 <code>AbstractBeanFactoryPointcutAdvisor</code> 实现，切点是通过 <code>StaticMethodMatcherPointcut</code> 匹配包含 <code>LogRecordAnnotation</code> 注解的方法。通过实现 <code>MethodInterceptor</code> 接口实现操作日志的增强逻辑。</p>
<p>下面是拦截器的切点逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogRecordPointcut</span> <span class="keyword">extends</span> <span class="title">StaticMethodMatcherPointcut</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// LogRecord的解析类</span></span><br><span class="line">    <span class="keyword">private</span> LogRecordOperationSource logRecordOperationSource;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(<span class="meta">@NonNull</span> Method method, <span class="meta">@NonNull</span> Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// 解析 这个 method 上有没有 @LogRecordAnnotation 注解，有的话会解析出来注解上的各个参数</span></span><br><span class="line">        <span class="keyword">return</span> !CollectionUtils.isEmpty(logRecordOperationSource.computeLogRecordOperations(method, targetClass));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setLogRecordOperationSource</span><span class="params">(LogRecordOperationSource logRecordOperationSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.logRecordOperationSource = logRecordOperationSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>切面的增强逻辑主要代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Method method = invocation.getMethod();</span><br><span class="line">    <span class="comment">// 记录日志</span></span><br><span class="line">    <span class="keyword">return</span> execute(invocation, invocation.getThis(), method, invocation.getArguments());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">execute</span><span class="params">(MethodInvocation invoker, Object target, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Class&lt;?&gt; targetClass = getTargetClass(target);</span><br><span class="line">    Object ret = <span class="keyword">null</span>;</span><br><span class="line">    MethodExecuteResult methodExecuteResult = <span class="keyword">new</span> MethodExecuteResult(<span class="keyword">true</span>, <span class="keyword">null</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    LogRecordContext.putEmptySpan();</span><br><span class="line">    Collection&lt;LogRecordOps&gt; operations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Map&lt;String, String&gt; functionNameAndReturnMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        operations = logRecordOperationSource.computeLogRecordOperations(method, targetClass);</span><br><span class="line">        List&lt;String&gt; spElTemplates = getBeforeExecuteFunctionTemplate(operations);</span><br><span class="line">        <span class="comment">//业务逻辑执行前的自定义函数解析</span></span><br><span class="line">        functionNameAndReturnMap = processBeforeExecuteFunctionTemplate(spElTemplates, targetClass, method, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;log record parse before function exception&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ret = invoker.proceed();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        methodExecuteResult = <span class="keyword">new</span> MethodExecuteResult(<span class="keyword">false</span>, e, e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(operations)) &#123;</span><br><span class="line">            recordExecute(ret, method, args, operations, targetClass,</span><br><span class="line">                    methodExecuteResult.isSuccess(), methodExecuteResult.getErrorMsg(), functionNameAndReturnMap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception t) &#123;</span><br><span class="line">        <span class="comment">//记录日志错误不要影响业务</span></span><br><span class="line">        log.error(<span class="string">&quot;log record parse exception&quot;</span>, t);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        LogRecordContext.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (methodExecuteResult.throwable != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> methodExecuteResult.throwable;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拦截逻辑的流程：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/203622.png" alt="图片"></p>
<p>可以看到，操作日志的记录持久化是在方法执行完之后执行的，当方法抛出异常之后会先捕获异常，等操作日志持久化完成后再抛出异常。在业务的方法执行之前，会对提前解析的自定义函数求值，解决了前面提到的需要查询修改之前的内容。</p>
<h4 id="解析逻辑"><a href="#解析逻辑" class="headerlink" title="解析逻辑"></a>解析逻辑</h4><p><strong>模板解析</strong></p>
<p>Spring 3 中提供了一个非常强大的功能：SpEL，SpEL 在 Spring 产品中是作为表达式求值的核心基础模块，它本身是可以脱离 Spring 独立使用的。举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpelExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line">        Expression expression = parser.parseExpression(<span class="string">&quot;#root.purchaseName&quot;</span>);</span><br><span class="line">        Order order = <span class="keyword">new</span> Order();</span><br><span class="line">        order.setPurchaseName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        System.out.println(expression.getValue(order));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法将打印 “张三”。LogRecord 解析的类图如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/203633.png" alt="图片"></p>
<p><strong>解析核心类</strong>：<code>LogRecordValueParser</code> 里面封装了自定义函数和 SpEL 解析类 <code>LogRecordExpressionEvaluator</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogRecordExpressionEvaluator</span> <span class="keyword">extends</span> <span class="title">CachedExpressionEvaluator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;ExpressionKey, Expression&gt; expressionCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;AnnotatedElementKey, Method&gt; targetMethodCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">parseExpression</span><span class="params">(String conditionExpression, AnnotatedElementKey methodKey, EvaluationContext evalContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getExpression(<span class="keyword">this</span>.expressionCache, methodKey, conditionExpression).getValue(evalContext, String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>LogRecordExpressionEvaluator</code> 继承自 <code>CachedExpressionEvaluator</code> 类，这个类里面有两个 Map，一个是 expressionCache 一个是 targetMethodCache。在上面的例子中可以看到，SpEL 会解析成一个 Expression 表达式，然后根据传入的 Object 获取到对应的值，所以 expressionCache 是为了缓存方法、表达式和 SpEL 的 Expression 的对应关系，让方法注解上添加的 SpEL 表达式只解析一次。下面的 targetMethodCache 是为了缓存传入到 Expression 表达式的 Object。核心的解析逻辑是上面最后一行代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">getExpression(<span class="keyword">this</span>.expressionCache, methodKey, conditionExpression).getValue(evalContext, String.class);</span><br></pre></td></tr></table></figure>
<p><code>getExpression</code> 方法会从 expressionCache 中获取到 @LogRecordAnnotation 注解上的表达式的解析 Expression 的实例，然后调用 <code>getValue</code> 方法，<code>getValue</code> 传入一个 evalContext 就是类似上面例子中的 order 对象。其中 Context 的实现将会在下文介绍。</p>
<p><strong>日志上下文实现</strong></p>
<p>下面的例子把变量放到了 LogRecordContext 中，然后 SpEL 表达式就可以顺利的解析方法上不存在的参数了，通过上面的 SpEL 的例子可以看出，要把方法的参数和 LogRecordContext 中的变量都放到 SpEL 的 <code>getValue</code> 方法的 Object 中才可以顺利的解析表达式的值。下面看看如何实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@LogRecord(content = &quot;修改了订单的配送员：从“&#123;deveryUser&#123;#oldDeliveryUserId&#125;&#125;”, 修改到“&#123;deveryUser&#123;#request.getUserId()&#125;&#125;”&quot;,</span></span><br><span class="line"><span class="meta">            bizNo=&quot;#request.getDeliveryOrderNo()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyAddress</span><span class="params">(updateDeliveryRequest request)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 查询出原来的地址是什么</span></span><br><span class="line">    LogRecordContext.putVariable(<span class="string">&quot;oldDeliveryUserId&quot;</span>, DeliveryService.queryOldDeliveryUserId(request.getDeliveryOrderNo()));</span><br><span class="line">    <span class="comment">// 更新派送信息 电话，收件人、地址</span></span><br><span class="line">    doUpdate(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 LogRecordValueParser 中创建了一个 EvaluationContext，用来给 SpEL 解析方法参数和 Context 中的变量。相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">EvaluationContext evaluationContext = expressionEvaluator.createEvaluationContext(method, args, targetClass, ret, errorMsg, beanFactory);</span><br></pre></td></tr></table></figure>
<p>在解析的时候调用 <code>getValue</code> 方法传入的参数 evalContext，就是上面这个 EvaluationContext 对象。下面是 LogRecordEvaluationContext 对象的继承体系：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/203701.png" alt="图片"></p>
<p>LogRecordEvaluationContext 做了三个事情：</p>
<ul>
<li>把方法的参数都放到 SpEL 解析的 RootObject 中。</li>
<li>把 LogRecordContext 中的变量都放到 RootObject 中。</li>
<li>把方法的返回值和 ErrorMsg 都放到 RootObject 中。</li>
</ul>
<p>LogRecordEvaluationContext 的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogRecordEvaluationContext</span> <span class="keyword">extends</span> <span class="title">MethodBasedEvaluationContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LogRecordEvaluationContext</span><span class="params">(Object rootObject, Method method, Object[] arguments,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      ParameterNameDiscoverer parameterNameDiscoverer, Object ret, String errorMsg)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//把方法的参数都放到 SpEL 解析的 RootObject 中</span></span><br><span class="line">       <span class="keyword">super</span>(rootObject, method, arguments, parameterNameDiscoverer);</span><br><span class="line">       <span class="comment">//把 LogRecordContext 中的变量都放到 RootObject 中</span></span><br><span class="line">        Map&lt;String, Object&gt; variables = LogRecordContext.getVariables();</span><br><span class="line">        <span class="keyword">if</span> (variables != <span class="keyword">null</span> &amp;&amp; variables.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, Object&gt; entry : variables.entrySet()) &#123;</span><br><span class="line">                setVariable(entry.getKey(), entry.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把方法的返回值和 ErrorMsg 都放到 RootObject 中</span></span><br><span class="line">        setVariable(<span class="string">&quot;_ret&quot;</span>, ret);</span><br><span class="line">        setVariable(<span class="string">&quot;_errorMsg&quot;</span>, errorMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是 LogRecordContext 的实现，这个类里面通过一个 ThreadLocal 变量保持了一个栈，栈里面是个 Map，Map 对应了变量的名称和变量的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogRecordContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InheritableThreadLocal&lt;Stack&lt;Map&lt;String, Object&gt;&gt;&gt; variableMapStack = <span class="keyword">new</span> InheritableThreadLocal&lt;&gt;();</span><br><span class="line">   <span class="comment">//其他省略....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面使用了 InheritableThreadLocal，所以在线程池的场景下使用 LogRecordContext 会出现问题，如果支持线程池可以使用阿里巴巴开源的 TTL 框架。那这里为什么不直接设置一个 ThreadLocal<Map<String, Object>&gt; 对象，而是要设置一个 Stack 结构呢？我们看一下这么做的原因是什么。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@LogRecord(content = &quot;修改了订单的配送员：从“&#123;deveryUser&#123;#oldDeliveryUserId&#125;&#125;”, 修改到“&#123;deveryUser&#123;#request.getUserId()&#125;&#125;”&quot;,</span></span><br><span class="line"><span class="meta">        bizNo=&quot;#request.getDeliveryOrderNo()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyAddress</span><span class="params">(updateDeliveryRequest request)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 查询出原来的地址是什么</span></span><br><span class="line">    LogRecordContext.putVariable(<span class="string">&quot;oldDeliveryUserId&quot;</span>, DeliveryService.queryOldDeliveryUserId(request.getDeliveryOrderNo()));</span><br><span class="line">    <span class="comment">// 更新派送信息 电话，收件人、地址</span></span><br><span class="line">    doUpdate(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码的执行流程如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/203731.png" alt="图片"></p>
<p>看起来没有什么问题，但是使用 LogRecordAnnotation 的方法里面嵌套了另一个使用 LogRecordAnnotation 方法的时候，流程就变成下面的形式：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/203739.png" alt="图片"></p>
<p>可以看到，当方法二执行了释放变量后，继续执行方法一的 logRecord 逻辑，此时解析的时候 ThreadLocal<Map<String, Object>&gt;的 Map 已经被释放掉，所以方法一就获取不到对应的变量了。方法一和方法二共用一个变量 Map 还有个问题是：如果方法二设置了和方法一相同的变量两个方法的变量就会被相互覆盖。所以最终 LogRecordContext 的变量的生命周期需要是下面的形式：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/203751.png" alt="图片"></p>
<p>LogRecordContext 每执行一个方法都会压栈一个 Map，方法执行完之后会 Pop 掉这个 Map，从而避免变量共享和覆盖问题。</p>
<p><strong>默认操作人逻辑</strong></p>
<p>在 LogRecordInterceptor 中 IOperatorGetService 接口，这个接口可以获取到当前的用户。下面是接口的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IOperatorGetService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以在里面外部的获取当前登陆的用户，比如 UserContext.getCurrentUser()</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 转换成Operator返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Operator <span class="title">getUser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面给出了从用户上下文中获取用户的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultOperatorGetServiceImpl</span> <span class="keyword">implements</span> <span class="title">IOperatorGetService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Operator <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//UserUtils 是获取用户上下文的方法</span></span><br><span class="line">         <span class="keyword">return</span> Optional.ofNullable(UserUtils.getUser())</span><br><span class="line">                        .map(a -&gt; <span class="keyword">new</span> Operator(a.getName(), a.getLogin()))</span><br><span class="line">                        .orElseThrow(()-&gt;<span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;user is null&quot;</span>));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>组件在解析 operator 的时候，就判断注解上的 operator 是否是空，如果注解上没有指定，我们就从 IOperatorGetService 的 getUser 方法获取了。如果都获取不到，就会报错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String realOperatorId = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (StringUtils.isEmpty(operatorId)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (operatorGetService.getUser() == <span class="keyword">null</span> || StringUtils.isEmpty(operatorGetService.getUser().getOperatorId())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;user is null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    realOperatorId = operatorGetService.getUser().getOperatorId();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    spElTemplates = Lists.newArrayList(bizKey, bizNo, action, operatorId, detail);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>自定义函数逻辑</strong></p>
<p>自定义函数的类图如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/203817.png" alt="图片"></p>
<p>下面是 IParseFunction 的接口定义：<code>executeBefore</code> 函数代表了自定义函数是否在业务代码执行之前解析，上面提到的查询修改之前的内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IParseFunction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">executeBefore</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">String <span class="title">functionName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">String <span class="title">apply</span><span class="params">(String value)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ParseFunctionFactory 的代码比较简单，它的功能是把所有的 IParseFunction 注入到函数工厂中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParseFunctionFactory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, IParseFunction&gt; allFunctionMap;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ParseFunctionFactory</span><span class="params">(List&lt;IParseFunction&gt; parseFunctions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(parseFunctions)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    allFunctionMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (IParseFunction parseFunction : parseFunctions) &#123;</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.isEmpty(parseFunction.functionName())) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      allFunctionMap.put(parseFunction.functionName(), parseFunction);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IParseFunction <span class="title">getFunction</span><span class="params">(String functionName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> allFunctionMap.get(functionName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBeforeFunction</span><span class="params">(String functionName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> allFunctionMap.get(functionName) != <span class="keyword">null</span> &amp;&amp; allFunctionMap.get(functionName).executeBefore();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DefaultFunctionServiceImpl 的逻辑就是根据传入的函数名称 functionName 找到对应的 IParseFunction，然后把参数传入到 IParseFunction 的 <code>apply</code> 方法上最后返回函数的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultFunctionServiceImpl</span> <span class="keyword">implements</span> <span class="title">IFunctionService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ParseFunctionFactory parseFunctionFactory;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DefaultFunctionServiceImpl</span><span class="params">(ParseFunctionFactory parseFunctionFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.parseFunctionFactory = parseFunctionFactory;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String functionName, String value)</span> </span>&#123;</span><br><span class="line">    IParseFunction function = parseFunctionFactory.getFunction(functionName);</span><br><span class="line">    <span class="keyword">if</span> (function == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> function.apply(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">beforeFunction</span><span class="params">(String functionName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> parseFunctionFactory.isBeforeFunction(functionName);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="日志持久化逻辑"><a href="#日志持久化逻辑" class="headerlink" title="日志持久化逻辑"></a>日志持久化逻辑</h4><p>同样在 LogRecordInterceptor 的代码中引用了 ILogRecordService，这个 Service 主要包含了日志记录的接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ILogRecordService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存 log</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> logRecord 日志实体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">record</span><span class="params">(LogRecord logRecord)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>业务可以实现这个保存接口，然后把日志保存在任何存储介质上。这里给了一个 2.2 节介绍的通过 log.info 保存在日志文件中的例子，业务可以把保存设置成异步或者同步，可以和业务放在一个事务中保证操作日志和业务的一致性，也可以新开辟一个事务，保证日志的错误不影响业务的事务。业务可以保存在 Elasticsearch、数据库或者文件中，用户可以根据日志结构和日志的存储实现相应的查询逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultLogRecordServiceImpl</span> <span class="keyword">implements</span> <span class="title">ILogRecordService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="comment">//    @Transactional(propagation = Propagation.REQUIRES_NEW)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">record</span><span class="params">(LogRecord logRecord)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;【logRecord】log=&#123;&#125;&quot;</span>, logRecord);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Starter-逻辑封装"><a href="#Starter-逻辑封装" class="headerlink" title="Starter 逻辑封装"></a>Starter 逻辑封装</h4><p>上面逻辑代码已经介绍完毕，那么接下来需要把这些组件组装起来，然后让用户去使用。在使用这个组件的时候只需要在 Springboot 的入口上添加一个注解 @EnableLogRecord(tenant = “com.mzt.test”)。其中 tenant 代表租户，是为了多租户使用的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="meta">@EnableLogRecord(tenant = &quot;com.mzt.test&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Main.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再看下 EnableLogRecord 的代码，代码中 Import 了 <code>LogRecordConfigureSelector.class</code>，在 <code>LogRecordConfigureSelector</code> 类中暴露了 <code>LogRecordProxyAutoConfiguration</code> 类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import(LogRecordConfigureSelector.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableLogRecord &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">tenant</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">AdviceMode <span class="title">mode</span><span class="params">()</span> <span class="keyword">default</span> AdviceMode.PROXY</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>LogRecordProxyAutoConfiguration</code> 就是装配上面组件的核心类了，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogRecordProxyAutoConfiguration</span> <span class="keyword">implements</span> <span class="title">ImportAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> AnnotationAttributes enableLogRecord;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> LogRecordOperationSource <span class="title">logRecordOperationSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LogRecordOperationSource();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean(IFunctionService.class)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IFunctionService <span class="title">functionService</span><span class="params">(ParseFunctionFactory parseFunctionFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultFunctionServiceImpl(parseFunctionFactory);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ParseFunctionFactory <span class="title">parseFunctionFactory</span><span class="params">(<span class="meta">@Autowired</span> List&lt;IParseFunction&gt; parseFunctions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ParseFunctionFactory(parseFunctions);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean(IParseFunction.class)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> DefaultParseFunction <span class="title">parseFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultParseFunction();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> BeanFactoryLogRecordAdvisor <span class="title">logRecordAdvisor</span><span class="params">(IFunctionService functionService)</span> </span>&#123;</span><br><span class="line">    BeanFactoryLogRecordAdvisor advisor =</span><br><span class="line">            <span class="keyword">new</span> BeanFactoryLogRecordAdvisor();</span><br><span class="line">    advisor.setLogRecordOperationSource(logRecordOperationSource());</span><br><span class="line">    advisor.setAdvice(logRecordInterceptor(functionService));</span><br><span class="line">    <span class="keyword">return</span> advisor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> LogRecordInterceptor <span class="title">logRecordInterceptor</span><span class="params">(IFunctionService functionService)</span> </span>&#123;</span><br><span class="line">    LogRecordInterceptor interceptor = <span class="keyword">new</span> LogRecordInterceptor();</span><br><span class="line">    interceptor.setLogRecordOperationSource(logRecordOperationSource());</span><br><span class="line">    interceptor.setTenant(enableLogRecord.getString(<span class="string">&quot;tenant&quot;</span>));</span><br><span class="line">    interceptor.setFunctionService(functionService);</span><br><span class="line">    <span class="keyword">return</span> interceptor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean(IOperatorGetService.class)</span></span><br><span class="line">  <span class="meta">@Role(BeanDefinition.ROLE_APPLICATION)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> IOperatorGetService <span class="title">operatorGetService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultOperatorGetServiceImpl();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean(ILogRecordService.class)</span></span><br><span class="line">  <span class="meta">@Role(BeanDefinition.ROLE_APPLICATION)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ILogRecordService <span class="title">recordService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultLogRecordServiceImpl();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImportMetadata</span><span class="params">(AnnotationMetadata importMetadata)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.enableLogRecord = AnnotationAttributes.fromMap(</span><br><span class="line">            importMetadata.getAnnotationAttributes(EnableLogRecord.class.getName(), <span class="keyword">false</span>));</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.enableLogRecord == <span class="keyword">null</span>) &#123;</span><br><span class="line">      log.info(<span class="string">&quot;@EnableCaching is not present on importing class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个类继承 ImportAware 是为了拿到 EnableLogRecord 上的租户属性，这个类使用变量 logRecordAdvisor 和 logRecordInterceptor 装配了 AOP，同时把自定义函数注入到了 logRecordAdvisor 中。</p>
<p><strong>对外扩展类</strong>：分别是<code>IOperatorGetService</code>、<code>ILogRecordService</code>、<code>IParseFunction</code>。业务可以自己实现相应的接口，因为配置了 @ConditionalOnMissingBean，所以用户的实现类会覆盖组件内的默认实现。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章介绍了操作日志的常见写法，以及如何让操作日志的实现更加简单、易懂，通过组件的四个模块，介绍了组件的具体实现。对于上面的组件介绍，大家如果有疑问，也欢迎在文末留言，我们会进行答疑。</p>
<h2 id="作者简介"><a href="#作者简介" class="headerlink" title="作者简介"></a>作者简介</h2><p>站通，2020年加入美团，基础研发平台/研发质量及效率部工程师。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FsaWJhYmEvY2FuYWw=">Canal<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zcHJpbmcuaW8vcHJvamVjdHMvc3ByaW5nLWZyYW1ld29yaw==">Spring-Framework<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnNwcmluZy5pby9zcHJpbmctZnJhbWV3b3JrL2RvY3MvMy4yLngvc3ByaW5nLWZyYW1ld29yay1yZWZlcmVuY2UvaHRtbC9leHByZXNzaW9ucy5odG1s">Spring Expression Language (SpEL)<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk1NDMwMy9hcnRpY2xlL2RldGFpbHMvMTEzODM3OTI4P3NwbT0xMDAxLjIwMTQuMzAwMS41NTAx">ThreadLocal、InheritableThreadLocal、TransmittableThreadLocal三者之间区别<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>JAVA基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>Spring</tag>
        <tag>SpringBoot</tag>
        <tag>sql</tag>
        <tag>GC</tag>
        <tag>事务</tag>
        <tag>数据库</tag>
        <tag>栈</tag>
        <tag>函数</tag>
        <tag>变量</tag>
        <tag>Mysql</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>Column注解解析</title>
    <url>/posts/2ZZM48T.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>功能：@Column注解用来标识实体类中属性与数据表中字段的对应关系<br>语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Column(columnDefinition = &quot;bigint(18)  comment &#x27;公司ID&#x27;&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> Long ouId;</span><br><span class="line"><span class="comment">//columnDefinition表示创建表时，该字段创建的SQL语句，一般用于通过Entity生成表定义时使用。（也就是说，如果DB中表已经建好了，该属性就没有必要使用了）</span></span><br><span class="line"><span class="comment">//comment(注释的意思-我这个文盲硬生生以为是@Column里面带的，类似于name属性的字段)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Column &#123;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"><span class="comment">//name属性定义了，被标注字段在数据库表中所对应字段的名称</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">unique</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"><span class="comment">//unique属性表示该字段是否为唯一标识，默认为false。如果表中有一个字段需要唯一标识，则既可以使用该标记，也可以使用@Table标记中的@UniqueConstraint</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">nullable</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line"><span class="comment">//nullable属性表示该字段是否可以为null值，默认为true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">insertable</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line"><span class="comment">//insertable属性表示在使用“INSERT”脚本插入数据时，是否需要插入该字段的值</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">updatable</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line"><span class="comment">//updatable属性表示在使用“UPDATA”脚本插入数据时，是否需要更新该字段的值。</span></span><br><span class="line">    <span class="comment">//ps:insertable和updatable属性一般多用于只读属性，例如主键和外键等。这些字段的值通常是自动生成的。</span></span><br><span class="line">    <span class="function">String <span class="title">columnDefinition</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"><span class="comment">//上面的代码注释已经写了</span></span><br><span class="line">    <span class="function">String <span class="title">table</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"><span class="comment">//table属性定义了包含当前字段的表名</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">default</span> 255</span>;</span><br><span class="line"><span class="comment">//length属性表示字段的长度，当字段的类型为varchar时，该属性才有效，默认为255个字符</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">precision</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line"><span class="comment">//precision和scale属性表示精度，当字段类型为double时，precision表示数值的总长度，scale表示小数点所占的位数。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">scale</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JAVA基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>sql</tag>
        <tag>const</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>内存泄漏和内存溢出</title>
    <url>/posts/266A6Z5.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><div style="text-align: center;"></div><br><span id="more"></span></p>
<h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><p>是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。 </p>
<h2 id="内存泄漏产生的原因"><a href="#内存泄漏产生的原因" class="headerlink" title="内存泄漏产生的原因"></a>内存泄漏产生的原因</h2><ol>
<li>单例造成的内存泄漏 </li>
</ol>
<p>由于单例的静态特性使得其生命周期和应用的生命周期一样长，如果一个对象已经不再需要使用了，而单例对象还持有该对象的引用，就会使得该对象不能被正常回收，从而导致了内存泄漏。 </p>
<ol>
<li>​非静态内部类创建静态实例造成的内存泄漏 </li>
<li><p>​资源未关闭造成的内存泄漏 </p>
<h2 id="如何避免内存泄漏"><a href="#如何避免内存泄漏" class="headerlink" title="如何避免内存泄漏"></a>如何避免内存泄漏</h2></li>
<li><p>​尽量减少使用静态变量，或者使用完及时 赋值为 null。 </p>
</li>
<li>​各种连接（数据库连接，网络连接，IO连接）操作，务必显示调用close关闭 </li>
<li>​减少长生命周期的对象持有短生命周期的引用； </li>
<li>养成良好的编码习惯。<h2 id="遇到的内存泄漏"><a href="#遇到的内存泄漏" class="headerlink" title="遇到的内存泄漏"></a>遇到的内存泄漏</h2>在使用ThreadLocal时最后没有调用remove，使ThreadLocal对象没有被垃圾回收器回收，造成了内存泄漏。<h1 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h1></li>
</ol>
<p>指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错OOM,即所谓的内存溢出。OutOfMemoryError </p>
<h2 id="内存溢出产生的原因"><a href="#内存溢出产生的原因" class="headerlink" title="内存溢出产生的原因"></a>内存溢出产生的原因</h2><h3 id="堆溢出"><a href="#堆溢出" class="headerlink" title="堆溢出"></a>堆溢出</h3><blockquote>
<p>java.lang.OutOfMemoryError: Java heap space  </p>
</blockquote>
<p><strong>原因</strong></p>
<ol>
<li>代码中可能存在大对象分配。</li>
<li>可能存在内存泄露，导致在多次GC之后，还是无法找到一块足够大的内存容纳当前对象。</li>
</ol>
<p><strong>解决方法</strong></p>
<ol>
<li>检查是否存在大对象的分配，最有可能的是大数组分配。</li>
<li>通过jmap命令，把堆内存dump下来，使用mat工具分析一下，检查是否存在内存泄露的问题。</li>
<li>如果没有找到明显的内存泄露，使用 -Xmx 加大堆内存.</li>
<li>还有一点容易被忽略，检查是否有大量的自定义的 Finalizable 对象，也有可能是框架内部提供的，考虑其存在的必要性  </li>
</ol>
<h3 id="永久代-元空间溢出"><a href="#永久代-元空间溢出" class="headerlink" title="永久代/元空间溢出"></a>永久代/元空间溢出</h3><p>报错信息：</p>
<blockquote>
<p>java.lang.OutOfMemoryError: PermGen spacejava.lang.OutOfMemoryError: Metaspace</p>
</blockquote>
<p><strong>原因</strong><br>永久代是 HotSot 虚拟机对方法区的具体实现，存放了被虚拟机加载的类信息、常量、静态变量、JIT编译后的代码等。<br>JDK8后，元空间替换了永久代，元空间使用的是本地内存，还有其它细节变化: </p>
<ul>
<li>字符串常量由永久代转移到堆中</li>
<li>和永久代相关的JVM参数已移除</li>
<li>​</li>
</ul>
<p>可能原因有如下几种：</p>
<ol>
<li>在Java7之前，频繁的错误使用String.intern()方法</li>
<li>运行期间生成了大量的代理类，导致方法区被撑爆，无法卸载</li>
<li>应用长时间运行，没有重启</li>
</ol>
<p>没有重启 JVM 进程一般发生在调试时，如下面 tomcat 官网的一个 FAQ：</p>
<blockquote>
<p>Why does the memory usage increase when I redeploy a web application? That is because your web application has a memory leak. A common issue are “PermGen” memory leaks. They happen because the Classloader (and the Class objects it loaded) cannot be recycled unless some requirements are met (). They are stored in the permanent heap generation by the JVM, and when you redeploy a new class loader is created, which loads another copy of all these classes. This can cause OufOfMemoryErrors eventually. (*) The requirement is that all classes loaded by this classloader should be able to be gc’ed at the same time.</p>
</blockquote>
<p><strong>解决方法</strong><br>因为该OOM原因比较简单，解决方法有如下几种：</p>
<ol>
<li>检查是否永久代空间或者元空间设置的过小</li>
<li>检查代码中是否存在大量的反射操作</li>
<li>dump之后通过mat检查是否存在大量由于反射生成的代理类</li>
<li>放大招，重启JVM</li>
</ol>
<h3 id="GC-overhead-limit-exceeded"><a href="#GC-overhead-limit-exceeded" class="headerlink" title="GC overhead limit exceeded"></a>GC overhead limit exceeded</h3><p>这个异常比较的罕见，报错信息：</p>
<blockquote>
<p>java.lang.OutOfMemoryError：GC overhead limit exceeded</p>
</blockquote>
<p><strong>原因</strong><br>这个是JDK6新加的错误类型，一般都是堆太小导致的。Sun 官方对此的定义：超过98%的时间用来做GC并且回收了不到2%的堆内存时会抛出此异常。</p>
<p><strong>解决方法</strong></p>
<ol>
<li>检查项目中是否有大量的死循环或有使用大内存的代码，优化代码。</li>
<li>添加参数 -XX:-UseGCOverheadLimit  禁用这个检查，其实这个参数解决不了内存问题，只是把错误的信息延后，最终出现 java.lang.OutOfMemoryError: Java heap space。</li>
<li>dump内存，检查是否存在内存泄露，如果没有，加大内存。</li>
</ol>
<h3 id="方法栈溢出"><a href="#方法栈溢出" class="headerlink" title="方法栈溢出"></a>方法栈溢出</h3><p>报错信息：</p>
<blockquote>
<p>java.lang.OutOfMemoryError : unable to create new native Thread</p>
</blockquote>
<p><strong>原因</strong><br>出现这种异常，基本上都是创建的了大量的线程导致的，以前碰到过一次，通过jstack出来一共8000多个线程。</p>
<p><strong>解决方法</strong></p>
<ol>
<li>通过 -Xss 降低的每个线程栈大小的容量</li>
<li>线程总数也受到系统空闲内存和操作系统的限制，检查是否该系统下有此限制：</li>
</ol>
<ul>
<li>/proc/sys/kernel/pid_max</li>
<li>/proc/sys/kernel/thread-max</li>
<li>maxuserprocess（ulimit -u）</li>
<li>/proc/sys/vm/maxmapcount</li>
</ul>
<h3 id="非常规溢出"><a href="#非常规溢出" class="headerlink" title="非常规溢出"></a>非常规溢出</h3><p>下面这些OOM异常，可能大部分的同学都没有碰到过，但还是需要了解一下</p>
<h3 id="分配超大数组"><a href="#分配超大数组" class="headerlink" title="分配超大数组"></a>分配超大数组</h3><p>报错信息 ：</p>
<blockquote>
<p>java.lang.OutOfMemoryError: Requested array size exceeds VM limit</p>
</blockquote>
<p>这种情况一般是由于不合理的数组分配请求导致的，在为数组分配内存之前，JVM 会执行一项检查。要分配的数组在该平台是否可以寻址(addressable)，如果不能寻址(addressable)就会抛出这个错误<br>解决方法就是检查你的代码中是否有创建超大数组的地方。</p>
<h3 id="swap溢出"><a href="#swap溢出" class="headerlink" title="swap溢出"></a>swap溢出</h3><p>报错信息 ：</p>
<blockquote>
<p>java.lang.OutOfMemoryError: Out of swap space</p>
</blockquote>
<p>这种情况一般是操作系统导致的，可能的原因有：</p>
<ol>
<li>swap 分区大小分配不足；</li>
<li>其他进程消耗了所有的内存。</li>
</ol>
<p>解决方案：<br>1、其它服务进程可以选择性的拆分出去 2、加大swap分区大小，或者加大机器内存大小</p>
<h3 id="本地方法溢出"><a href="#本地方法溢出" class="headerlink" title="本地方法溢出"></a>本地方法溢出</h3><p>报错信息 ：</p>
<blockquote>
<p>java.lang.OutOfMemoryError: stack_trace_with_native_method</p>
</blockquote>
<p>本地方法在运行时出现了内存分配失败，和之前的方法栈溢出不同，方法栈溢出发生在 JVM 代码层面，而本地方法溢出发生在JNI代码或本地方法处。<br>这个异常出现的概率极低，只能通过操作系统本地工具进行诊断，难度有点大，还是放弃为妙。</p>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLjUxY3RvLmNvbS91XzE0NDQyMDk0LzI0NDkxNTE=">相关文章<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h1 id="两者关系"><a href="#两者关系" class="headerlink" title="两者关系"></a>两者关系</h1><ul>
<li>内存泄漏的堆积最终会导致内存溢出 </li>
<li>内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系统相当于没法满足你的需求，就会报内存溢出的错误。 </li>
<li>内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问（也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的程序。就相当于你租了个带钥匙的柜子，你存完东西之后把柜子锁上之后，把钥匙丢了或者没有将钥匙还回去，那么结果就是这个柜子将无法供给任何人使用，也无法被垃圾回收器回收，因为找不到他的任何信息。 </li>
<li>内存溢出：一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉倒地上不能吃了。这就是溢出。比方说栈，栈满时再做进栈必定产生空间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分配的内存不足以放下数据项序列,称为内存溢出。说白了就是我承受不了那么多，那我就报错。</li>
</ul>
<blockquote>
<p>内存溢出参考文章：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLjUxY3RvLmNvbS91XzE0NDQyMDk0LzI0NDkxNTE=">https://blog.51cto.com/u_14442094/2449151<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>C</tag>
        <tag>内存</tag>
        <tag>GC</tag>
        <tag>数据库</tag>
        <tag>堆</tag>
        <tag>栈</tag>
        <tag>数组</tag>
        <tag>变量</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Java对象布局</title>
    <url>/posts/28DG2WP.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><div style="text-align: center;"></div><br><span id="more"></span></p>
<p>一个新 new 出来的对象，分为四部分：</p>
<ul>
<li>mark word  </li>
<li>klass point </li>
<li>Instance Data</li>
<li>Padding</li>
</ul>
<p>可使用JOL类库查看</p>
<p> <img data-src="https://xuemingde.com/pages/image/others/thitTa.png" alt=""></p>
<p> <img data-src="https://xuemingde.com/pages/image/others/ah1qVo.png" alt=""></p>
<p>Instance size ： new一个空对象，没有任何成员变量的时候，占用16个字节。</p>
<p>面试室可能被问道：new 一个 Object 的时候占多少字节？ 16个字节。</p>
<h2 id="mark-word"><a href="#mark-word" class="headerlink" title="mark word"></a>mark word</h2><p> <img data-src="https://xuemingde.com/pages/image/others/PvxWET.png" alt=""></p>
<p><strong>如果给这个对象上把锁，会有什么效果？</strong></p>
<p> <img data-src="https://xuemingde.com/pages/image/others/yjCWYI.png" alt=""></p>
<p>  <img data-src="https://xuemingde.com/pages/image/others/aYzqtV.png" alt=""></p>
<p><u><strong>上图可以看出，锁信息是放在mark word里面的</strong>。</u></p>
<h2 id="klass-point"><a href="#klass-point" class="headerlink" title="klass point"></a>klass point</h2><p> <img data-src="https://xuemingde.com/pages/image/others/JUS6K3.png" alt=""></p>
<p>这4个字节属于klass point，可以认为他是一个指针，是用来指向这个对象是属于哪个类的。</p>
<h2 id="Padding"><a href="#Padding" class="headerlink" title="Padding"></a>Padding</h2><p> <img data-src="https://xuemingde.com/pages/image/others/VryRBZ.png" alt=""></p>
<p>这4个字节，如果有成员变量，里面装的就是成员变量，如果没有，则是对其的作用。</p>
<blockquote>
<p>对其的意思就是，mark word 所占用的字节 和  klass point所占用的字节 加起来能不能被8整除，如果不能，则需要补齐，能够被8整除。 是为了提高效率。</p>
</blockquote>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>指针</tag>
        <tag>变量</tag>
        <tag>面试</tag>
        <tag>锁</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM视频学习笔记-A</title>
    <url>/posts/C0YKJ4.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>视频地址：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVBKNDExbjd4Wg==">尚硅谷宋红康JVM全套教程（详解java虚拟机）_哔哩哔哩_bilibili<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>好好学习，天天向上。</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpreU1qTXpPRFU0TlE9PSZhbXA7bWlkPTIyNDc0ODUzMDgmYW1wO2lkeD0xJmFtcDtzbj0zYWE1MjQ1YmMxYjllYTNiNzgzN2ZkZjAxMjZjOWUzOCZhbXA7Y2hrc209YzFmNDkzMGFmNjgzMWExYzFjYzEwNmY2NjZhOTkzMmIyZDkwY2EzMTE5MGFiNjZhMmZmMzY2NmViZjc0NDBlZDY4MjFlNDlkN2E2ZiZhbXA7c2NlbmU9MTc4JmFtcDtjdXJfYWxidW1faWQ9MjQyNzgwMTgzMTE3MjIxMDY5MyNyZA==">01-JVM与java体系结构<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpreU1qTXpPRFU0TlE9PSZhbXA7bWlkPTIyNDc0ODUzMTQmYW1wO2lkeD0xJmFtcDtzbj1iODkwNTNhM2QwNjFjYTIzY2U2YjI4ODkyMjVlMmRlMCZhbXA7Y2hrc209YzFmNDkzZjRmNjgzMWFlMjQ3MmMxMjg5YTkwYTU5Y2QwZjlhYjgyYmNlYzBmOGE2Y2I4ZjMxYjUzNDQ4Yzk2NDk5MzQ4NzlmMWRiNSZhbXA7dG9rZW49MTgwMDcyMDg3OCZhbXA7bGFuZz16aF9DTiNyZA==">02-Java代码执行流程<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpreU1qTXpPRFU0TlE9PSZhbXA7bWlkPTIyNDc0ODUzMjQmYW1wO2lkeD0xJmFtcDtzbj1jZDRmNzc2NDY3ZDAxYmYxOGE0NWRhYTdmNjU3OTYwZCZhbXA7Y2hrc209YzFmNDkzZmFmNjgzMWFlY2Y3NzYzNTI4YzRiMDI3ZDFiODgwNjMwYzBjOTM5OGJjZWRjYzIzMWQ0NDI5NzkzMzcxMTllMGUxOGU5NSZhbXA7dG9rZW49MTgwMDcyMDg3OCZhbXA7bGFuZz16aF9DTiNyZA==">03-JVM的结构模型<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpreU1qTXpPRFU0TlE9PSZhbXA7bWlkPTIyNDc0ODUzMzEmYW1wO2lkeD0xJmFtcDtzbj00MWYwNTI0NmUxMDU5MDAwMzA2MzkwNTZmNDQ2ODFhNSZhbXA7Y2hrc209YzFmNDkzZTVmNjgzMWFmMzg1NzJiZTliMDk0ZGVhNjU5ODg5NWM3MGRlMGMxNjNhNWY5ODYzYzFiYjVlODcyMjlmNjczNTViMGVmNiZhbXA7dG9rZW49MTgwMDcyMDg3OCZhbXA7bGFuZz16aF9DTiNyZA==">04-JVM的生命周期<i class="fa fa-external-link-alt"></i></span>  </li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpreU1qTXpPRFU0TlE9PSZhbXA7bWlkPTIyNDc0ODUzNTMmYW1wO2lkeD0xJmFtcDtzbj03MzFhMzlhM2M5NWM1MTdmZWFlNzgzNjNjNzVkMjEzMiZhbXA7Y2hrc209YzFmNDkzZGZmNjgzMWFjOTc2MDcwY2Y2M2FkZTg0MDMxNWVlZGZhMjVmZTkwYjhmNzg0ODdjYThmMzliY2M3YzU5ZjIxODdmZTE4MSNyZA==">05-概述类的加载器及类加载过程<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpreU1qTXpPRFU0TlE9PSZhbXA7bWlkPTIyNDc0ODUzNjQmYW1wO2lkeD0xJmFtcDtzbj0zM2YwZTM3OTc0MDFmOTk2MTk4MzE0NGRlYzI3YjViZCZhbXA7Y2hrc209YzFmNDkzYzJmNjgzMWFkNGU3M2RjMjdiODJhMzU0ODI4MmU1OTQ5ZTRjYjYyYmRjMTQ1MmEzNGE3ZTU4MjgyOTJlN2FmYjg4MmM5NiZhbXA7dG9rZW49MTgwMDcyMDg3OCZhbXA7bGFuZz16aF9DTiNyZA==">06-几种类加载器的使用体会<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpreU1qTXpPRFU0TlE9PSZhbXA7bWlkPTIyNDc0ODUzNzYmYW1wO2lkeD0xJmFtcDtzbj0zOWI2ZmYzMzYxMzZlOGNiMmI4NDkzOGI5MmE4Njg5YyZhbXA7Y2hrc209YzFmNDkzYjZmNjgzMWFhMDUzMzNlNmZjYmQzY2U1NjI5ZmE3NDlhYTYzYTFiYzY5ZjcyY2VmZTMzOGE1MzhlMTQwOGE5NWE4NjYzMyZhbXA7dG9rZW49MTgwMDcyMDg3OCZhbXA7bGFuZz16aF9DTiNyZA==">07-引导类、扩展类、系统类加载器的使用及演示<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpreU1qTXpPRFU0TlE9PSZhbXA7bWlkPTIyNDc0ODUzODYmYW1wO2lkeD0xJmFtcDtzbj1lMjE3Mjg0NGFmYTQ0NzMwY2IyOWE0NTgzODY3NmZlMiZhbXA7Y2hrc209YzFmNDkzYmNmNjgzMWFhYTgxNjZiZmVjMWY0MDcxYjBlOWQzNzQ0MTNlODhiNjVkZWFkZDkwOWM2ZDgwYzZjZjk1NTgzZGFmMDFlNyZhbXA7dG9rZW49MTgwMDcyMDg3OCZhbXA7bGFuZz16aF9DTiNyZA==">为什么需要用户自定义类加载器及具体实现<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpreU1qTXpPRFU0TlE9PSZhbXA7bWlkPTIyNDc0ODUzOTMmYW1wO2lkeD0xJmFtcDtzbj05MGUyMDcyZTE4ZTY1Yzc0MjEwYjBjMjZlMDFjM2Y1NSZhbXA7Y2hrc209YzFmNDkzYTdmNjgzMWFiMTQ2ZGVkYTNlZjEzYjEzNTI0MDZlODQ2ZDI0ZGU0YzY1ZDM4YWZhYzg0YTM3NDE5NmRhYzMyMjA5NDNhOSZhbXA7dG9rZW49MTgwMDcyMDg3OCZhbXA7bGFuZz16aF9DTiNyZA==">08-ClassLoader的常用方法及获取方法<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpreU1qTXpPRFU0TlE9PSZhbXA7bWlkPTIyNDc0ODU0MzUmYW1wO2lkeD0xJmFtcDtzbj1mNjkxYWY1NGQxNmIyMGQwOWMzMmJkMDEwMzYwMTQzMCZhbXA7Y2hrc209YzFmNDkzOGRmNjgzMWE5Yjg5NzgxZmI3ODZmM2FlOTA5N2Y2ZjUzODVhMTk0ODI3OTFmMTYzOGU5ZTNlNzFjM2IyNGI4YmUzMjA2OSZhbXA7dG9rZW49MTgwMDcyMDg3OCZhbXA7bGFuZz16aF9DTiNyZA==">09-双亲委派机制的工作原理及演示<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpreU1qTXpPRFU0TlE9PSZhbXA7bWlkPTIyNDc0ODU0NDUmYW1wO2lkeD0xJmFtcDtzbj1hYzk3ZjBlMGMxMTEyMDM1NWEyY2FmMTEwNmI3OGM4MyZhbXA7Y2hrc209YzFmNDljNzNmNjgzMTU2NTQ2ZmRhZTI3NmI0M2E2ZjVjOGUxZWRiZDJlMGQzMjc1MDFlZjJjZDk2NWYxYjcwNDg2YzJkNmNiMGU4NCZhbXA7dG9rZW49MTgwMDcyMDg3OCZhbXA7bGFuZz16aF9DTiNyZA==">10-沙箱安全机制<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpreU1qTXpPRFU0TlE9PSZhbXA7bWlkPTIyNDc0ODU0NTcmYW1wO2lkeD0xJmFtcDtzbj1mNzRjM2Q1YzAyYjE0ZTk5MGM1N2Q4Y2I1ZjkyNzQ3ZSZhbXA7Y2hrc209YzFmNDljNjdmNjgzMTU3MWM5YzcyMDVlMjFiNmIwNThiMmQxYzM3OGQ4N2IwZDYxMzU2MjFiMjg5NWEyM2VmYjcwNzFiMWMyNDkwMyZhbXA7dG9rZW49MTgwMDcyMDg3OCZhbXA7bGFuZz16aF9DTiNyZA==">11 - 运行时数据区内部结构<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpreU1qTXpPRFU0TlE9PSZhbXA7bWlkPTIyNDc0ODU0NzUmYW1wO2lkeD0xJmFtcDtzbj0zZDM3ODM3MDFhNzFmYjg2NDNjODEwN2FlYmE2YmE2MSZhbXA7Y2hrc209YzFmNDljNTVmNjgzMTU0MzAwMmI5NTc5ZmIxYThkOWYwZTM3ZDZiMWY3YmFiMGVlMTBjOTAxNWU3ODhiYzQ5NWY0MmQyZjI1MDY3MSZhbXA7dG9rZW49MTgwMDcyMDg3OCZhbXA7bGFuZz16aF9DTiNyZA==">12-PC寄存器（程序计数器）<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpreU1qTXpPRFU0TlE9PSZhbXA7bWlkPTIyNDc0ODU1MTQmYW1wO2lkeD0xJmFtcDtzbj01ZGNlM2U3ZjkxYTg5YzY3MGVjYTBiNzdhYmVjODM4MSZhbXA7Y2hrc209YzFmNDljM2NmNjgzMTUyYTFhMjMxMDNkM2I2NTcwM2YyZmQ0NzFkNzMxMTRiYWQ1NDZkNmRiMzk3ZTBmZWIwOTBkYjcxYTFiNDYyZiZhbXA7c2NlbmU9MTc4JmFtcDtjdXJfYWxidW1faWQ9MjMxOTY1NTc5NTU4NTcxMjEzMyNyZA==">13-虚拟机栈-概述<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpreU1qTXpPRFU0TlE9PSZhbXA7bWlkPTIyNDc0ODU1NTQmYW1wO2lkeD0xJmFtcDtzbj1mNmMzNDgxNmEyYmQ5YzMxZTJhZjE3NDk5N2UzYjg1YSZhbXA7Y2hrc209YzFmNDljMDRmNjgzMTUxMjViMTc1NzcyZDZiZWY1ZDcyODA2MWE2NzU1ZTRlYjJlNDA1NmYxZmIyYzIyNWJjNTEwNTZhZDA4ZGI0YyZhbXA7dG9rZW49MTgwMDcyMDg3OCZhbXA7bGFuZz16aF9DTiNyZA==">14-虚拟机栈-栈的存储单位及运行原理<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpreU1qTXpPRFU0TlE9PSZhbXA7bWlkPTIyNDc0ODU1NjAmYW1wO2lkeD0xJmFtcDtzbj0zMDJlNDY2NjJiMDE4YjNlMTQ3NzY5MzQxMDhiNzA0OSZhbXA7Y2hrc209YzFmNDljMGVmNjgzMTUxODQ4NTkxZjAxNjgyZmRhYTkxMDIyY2E1MzZlZGEzNDE2MDVmOGRjOGJjZjcyM2M5MmU3MDA3ZWJlMDk2MyZhbXA7dG9rZW49MTgwMDcyMDg3OCZhbXA7bGFuZz16aF9DTiNyZA==">15-虚拟机栈-栈祯的内部结构<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>C</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>Volatile的概念</title>
    <url>/posts/2TD7P25.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><div style="text-align: center;"></div><br><span id="more"></span></p>
<p>Volatile有两大作用</p>
<ol>
<li>保证线程间可见性</li>
<li>禁止指令重排序</li>
</ol>
<h2 id="CPU的乱序执行"><a href="#CPU的乱序执行" class="headerlink" title="CPU的乱序执行"></a>CPU的乱序执行</h2><p><img data-src="https://xuemingde.com/pages/image/others/S8d07j.png" alt=""></p>
<p>CPU为什么支持乱序执行？是为了提高效率。</p>
<blockquote>
<p>CPU的速度要比内存的速度快100倍</p>
</blockquote>
<p>如果按顺序执行，有两条指令，第一次指令去内存中读取数据，第二个指令要等99%的时间让第一个指令执行完再去执行，浪费CPU的时间，执行效率就很低。</p>
<p>在CPU的优化时候，有可能是这样执行的，在第一个指令执行的时候，会把第二个指令拿出来执行，但是有个前提条件，两个指令不能存在前后的依赖关系。</p>
<h2 id="解释一下对象的创建过程"><a href="#解释一下对象的创建过程" class="headerlink" title="解释一下对象的创建过程"></a>解释一下对象的创建过程</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://xuemingde.com/pages/image/others/hcd0hK.png" alt=""></p>
<p>new 出一个对象至少需要三步：</p>
<p> <img data-src="https://xuemingde.com/pages/image/others/xYGO2T.png" alt=""></p>
<p>第一步：new ，申请一块内存空间，用来装我new出来的对象。如上图所示，申请的内存空间里肯定有一个成员变量m，这个m的值是他的默认值，根据数据类型来定，所以这个m的默认值是0； <img data-src="https://xuemingde.com/pages/image/others/mY2ArO.png" alt=""></p>
<p>第二步：给成员变量赋值，所以此时的m值变为了8。<strong>这个过程就是对象的半初始化状态。</strong> <img data-src="https://xuemingde.com/pages/image/others/zdwTUK.png" alt=""></p>
<p>第三步：建立关联，局部变量 t ，t里面存储一个指针，这个指针就指向一个对象。 <img data-src="https://xuemingde.com/pages/image/others/6rJ0tu.png" alt=""></p>
<h2 id="双重检锁（DCL）单例要不要加Volatile"><a href="#双重检锁（DCL）单例要不要加Volatile" class="headerlink" title="双重检锁（DCL）单例要不要加Volatile"></a>双重检锁（DCL）单例要不要加Volatile</h2><p>双重检锁（DCL）单例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//2.要不要加 volatile</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> TestDemo INST;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">TestDemo</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TestDemo <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.这个地方为什么要为空判断？</span></span><br><span class="line">        <span class="keyword">if</span> (INST == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (TestDemo.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (INST == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    INST = <span class="keyword">new</span> TestDemo();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INST;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>为什么要进来就为空判断？</strong></p>
<p>假如去掉这个判断，现在有1000个线程都来抢这把锁，上来就开始锁竞争，最终只有一个线程能够持有锁，去new对象，剩下的所有线程都参与了锁竞争过程，这样会降低效率。如果加上了判断，只要一个线程new出了对象，就不用去参与锁竞争过程了。</p>
<p><strong>要不要加Volatile ？？？</strong></p>
<p>答案是<strong>必须要加</strong>的。</p>
<p>为什么呢？</p>
<p> <img data-src="https://xuemingde.com/pages/image/others/UF3vK1.png" alt=""></p>
<p>前面讲了，new一个对象至少有三步，在线程1创建对象时，在申请内存空间的时候，发生了指令重排序（我们前面也讲了，CPU会有乱序执行），第二步和第三步发生了执行顺序的颠倒，线程1在执行完第一步去执行了第三步，这时候局部变量INST指向了创建的对象，此时线程2判断INST不再为null，而线程1还没有执行完第三步，此时线程2拿到的对象是一个半成品，而成员变量的值还是他的默认值。</p>
<p>Volatile的一个作用就是禁止指令重排序，用Volatile修饰的任何内存空间（对象），在他上面执行的指令不可以乱序。</p>
<h2 id="Volatile为什么会禁止重排的？"><a href="#Volatile为什么会禁止重排的？" class="headerlink" title="Volatile为什么会禁止重排的？"></a>Volatile为什么会禁止重排的？</h2><p>内存屏障！！</p>
<h3 id="内存屏障-（JVM级别）"><a href="#内存屏障-（JVM级别）" class="headerlink" title="内存屏障 （JVM级别）"></a>内存屏障 （JVM级别）</h3><p>JVM级别的内存屏障分为四种</p>
<p> <img data-src="https://xuemingde.com/pages/image/others/yGGBJz.png" alt=""></p>
<p>JVM是一种规范，这个规范要求被Volatile修饰的东西要实现内存屏障。但是硬件级别或者hostpot级别或者操作系统级别如何实现的，实际上与JVM的规定没有直接的关系。</p>
<p> <img data-src="https://xuemingde.com/pages/image/others/vSRQKY.png" alt=""></p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>C</tag>
        <tag>内存</tag>
        <tag>CPU</tag>
        <tag>指针</tag>
        <tag>局部</tag>
        <tag>变量</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>谈谈你对 JVM 方法区的理解</title>
    <url>/posts/2GN96QM.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>原文：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvdS03T2pfQk5tdlFzdWwtZEVkeFJvZw==">面试官：谈谈你对 JVM 方法区的理解<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>运行时数据区”包括程序计数器、虚拟机栈、本地方法栈和堆空间，今天我们就来了解一下方法区。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/0811nMChKa.png" alt=""></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>创建对象时内存分配简图</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/08128OLLNU.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/08139cSMvE.png" alt=""></p>
<p>《Java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。</p>
<p>虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。所以，方法区可以看作是一块<strong>独立</strong>于 Java 堆的内存空间。</p>
<p>方法区与 Java 堆一样，是各个线程共享的内存区域。方法区在 JVM 启动时就会被创建，并且它的实际的物理内存空间是可以<strong>不连续</strong>的，关闭 JVM 就会释放这个区域的内存。</p>
<h2 id="永久代、元空间"><a href="#永久代、元空间" class="headerlink" title="永久代、元空间"></a>永久代、元空间</h2><p>《java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEA JRockit/IBM J9 中不存在永久代的概念。而对于 HotSpot 来说，在 jdk7 及以前，习惯上把方法区的实现称为<strong>永久代</strong>，而从 jdk8 开始，使用<strong>元空间</strong>取代了永久代。</p>
<blockquote>
<p>方法区是 Java 虚拟机规范中的概念，而永久代和元空间是 HotSpot 虚拟机对方法区的一种实现。通俗点讲：如果把方法区比作接口的话，那永久代和元空间可以比作实现该接口的实现类。</p>
</blockquote>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>永久代、元空间并不只是名字变了，内部结构也进行了调整。永久代使用的是 JVM 的内存，而元空间使用的是本地的直接内存。</p>
<p>直接内存并不是 JVM 运行时数据区的一部分，因此不会受到 Java 堆的限制。但是它会受到本机总内存大小以及处理器寻址空间的限制，所以如果这部分内存也被频繁的使用，依然会导致 OOM 错误的出现。</p>
<h3 id="方法区的大小"><a href="#方法区的大小" class="headerlink" title="方法区的大小"></a>方法区的大小</h3><p>方法区的大小是可以进行设置的，可以选择固定大小也可以进行扩展。</p>
<h4 id="jdk7-及以前"><a href="#jdk7-及以前" class="headerlink" title="jdk7 及以前"></a>jdk7 及以前</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">-XX:PermSize=N //方法区 (永久代) 初始分配空间，默认值为 20.75M</span><br><span class="line">-XX:MaxPermSize=N //方法区 (永久代) 最大可分配空间。32位机器默认是64M，64位机器默认是82M</span><br></pre></td></tr></table></figure>
<h4 id="jdk8及以后"><a href="#jdk8及以后" class="headerlink" title="jdk8及以后"></a>jdk8及以后</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">-XX:MetaspaceSize=N //方法区 (元空间) 初始分配空间，如果未指定此标志，则元空间将根据运行时的应用程序需求动态地重新调整大小。</span><br><span class="line">-XX:MaxMetaspaceSize=N //方法区 (元空间) 最大可分配空间，默认值为 -1，即没有限制</span><br></pre></td></tr></table></figure>
<p>与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。</p>
<p>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，比如：加载大量的第三方 jar 包、Tomcat 部署的工程过多、大量动态生成反射类等都会导致方法区溢出，抛出内存溢出错误。</p>
<ul>
<li>永久代：OutOfMemoryError:PermGen space</li>
<li>元空间：OutOfMemoryError:Metaspace</li>
</ul>
<p><strong>至于如何解决 OOM 异常，将在以后的文章中讲解！</strong></p>
<h3 id="jvisualvm"><a href="#jvisualvm" class="headerlink" title="jvisualvm"></a>jvisualvm</h3><p>我们可以通过 JDK 自带的 <strong>jvisualvm</strong> 工具来查看程序加载的类文件：</p>
<p><strong>例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;end...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，可以看到一个简单的程序就需要加载这么多的类文件。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/08172fHLHQ.png" alt=""></p>
<h3 id="高水位线"><a href="#高水位线" class="headerlink" title="高水位线"></a>高水位线</h3><p>对于一个64位的服务器端 JVM 来说，<code>XX：MetaspaceSize=21</code> 就是初始的高水位线，一旦触及这个水位线，Full GC 将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。</p>
<p>新的高水位线的值取决于 GC 后释放了多少元空间：</p>
<ul>
<li>如果释放的空间不足，那么在不超过 MaxMetaspaceSize 时，适当提高该值；</li>
<li>如果释放空间过多，则适当降低该值。</li>
</ul>
<blockquote>
<p>如果初始化的高水位线设置过低，高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到 Full GC 多次调用。为了避免频繁地GC，建议将 <code>-XX ：MetaspaceSize</code> 设置为一个相对较高的值。</p>
</blockquote>
<h2 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h2><p>《深入理解Java虚拟机》书中对方法区存储内容描述如下：它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。接下来我们就一起来看一下它的内部结构。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/0818BTvM7A.png" alt=""></p>
<h3 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h3><p>对每个加载的类型（ 类 class、接口 interface、枚举 enum、注解 annotation），JVM 必须在方法区中存储以下类型信息：</p>
<ol>
<li>这个类型的完整有效名称（全名=包名.类名）</li>
<li>这个类型直接父类的完整有效名（对于 interface 或是 java. lang.Object ，都没有父类）</li>
<li>这个类型的修饰符（ public ， abstract， final 的某个子集）</li>
<li>这个类型直接接口的一个有序列表</li>
</ol>
<h3 id="域（Field）信息"><a href="#域（Field）信息" class="headerlink" title="域（Field）信息"></a>域（Field）信息</h3><ul>
<li>JVM必须在方法区中保存类型的所有域（field，也称为属性）的相关信息以及域的声明顺序；</li>
<li>域的相关信息包括：域名称、 域类型、域修饰符（public， private，protected， static， final， volatile， transient 的某个子集）</li>
</ul>
<h3 id="方法（Method）信息"><a href="#方法（Method）信息" class="headerlink" title="方法（Method）信息"></a>方法（Method）信息</h3><p>JVM 必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p>
<ul>
<li>方法名称</li>
<li>方法的返回类型（或void）</li>
<li>方法参数的数量和类型（按顺序）</li>
<li>方法的修饰符（public， private， protected， static， final，synchronized， native ， abstract 的一个子集）</li>
<li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（ abstract 和 native 方法除外）</li>
<li>异常表（ abstract 和 native 方法除外）每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li>
</ul>
<h3 id="non-final-的类变量"><a href="#non-final-的类变量" class="headerlink" title="non-final 的类变量"></a>non-final 的类变量</h3><ul>
<li>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</li>
<li>类变量被类的所有实例所共享，即使没有类实例你也可以访问它。</li>
</ul>
<p>我们可以通过例子来查看：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Order order = <span class="keyword">null</span>;</span><br><span class="line">        order.hello();</span><br><span class="line">        System.out.println(order.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> number = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight erlang-repl"><table><tr><td class="code"><pre><span class="line">hello!</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>可以打开 IDEA 的 Terminal 窗口，在 MethodAreaDemo2.class 所在的路径下，输入 <code>javap -v -p MethodAreaDemo2.class</code> 命令</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/0820D8dllV.png" alt=""></p>
<p>通过图片我们可以看出被声明为 final 的类变量的处理方法是不一样的，全局常量在编译的时候就被分配了。</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>说到运行时常量池，我们先来了解一下什么是常量池表。</p>
<h4 id="常量池表"><a href="#常量池表" class="headerlink" title="常量池表"></a>常量池表</h4><p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表（Constant Pool Table），里边存储着<strong>数量值</strong>、<strong>字符串值</strong>、<strong>类引用</strong>、<strong>字段引用</strong>和<strong>方法引用</strong>。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/0821NLzPMe.png" alt="图片"></p>
<h4 id="为什么字节码文件需要常量池？"><a href="#为什么字节码文件需要常量池？" class="headerlink" title="为什么字节码文件需要常量池？"></a>为什么字节码文件需要常量池？</h4><p>java 源文件中的类、接口，编译后会产生一个字节码文件。而字节码文件需要数据支持，通常这种数据会很大，以至于不能直接存放到字节码中。换一种方式，可以将指向这些数据的<strong>符号引用</strong>存到字节码文件的常量池中，这样字节码只需使用常量池就可以在运行时通过<strong>动态链接</strong>找到相应的数据并使用。</p>
<h4 id="运行时常量池-1"><a href="#运行时常量池-1" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>运行时常量池（ <code>Runtime Constant Pool</code>）是方法区的一部分，类加载器加载字节码文件时，将常量池表加载进方法区的运行时常量池。运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为<strong>真实</strong>地址。</p>
<blockquote>
<p>运行时常量池，相对于 Class 文件常量池的另一重要特征是：具备动态性，比如 <code>String.intern()</code>。</p>
</blockquote>
<h2 id="演进细节"><a href="#演进细节" class="headerlink" title="演进细节"></a>演进细节</h2><p>针对的是 <strong>Hotspot</strong> 的虚拟机：</p>
<ul>
<li>jdk1.6 及之前：有<strong>永久代</strong> ，静态变量存放在永久代上；</li>
<li>jdk1.7：有<strong>永久代</strong>，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中；</li>
<li>jdk1.8及之后：无永久代，类型信息、字段、方法、常量保存在本地内存的<strong>元空间</strong>，但字符串常量池、静态变量仍在堆中；</li>
</ul>
<h3 id="演变示例图"><a href="#演变示例图" class="headerlink" title="演变示例图"></a>演变示例图</h3><p><img data-src="https://xuemingde.com/pages/image/2022/06/02/0822Hj7z0e.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/0822u3jIxG.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/0823bbxVIm.png" alt=""></p>
<h3 id="为什么要将永久代替换为元空间呢"><a href="#为什么要将永久代替换为元空间呢" class="headerlink" title="为什么要将永久代替换为元空间呢?"></a>为什么要将永久代替换为元空间呢?</h3><ol>
<li>永久代使用的是 JVM 的内存，受 JVM 设置的内存大小限制；元空间使用的是本地直接内存，它的最大可分配空间是系统可用内存的空间。因为元空间里存放的是类的<strong>元数据</strong>，所以随着内存空间的增大，能加载的类就更多了，相应的溢出的机率会大大减小。</li>
<li>在 JDK8，合并 HotSpot 和 JRockit 的代码时，JRockit 从来没有一个叫永久代的东西，合并之后就没有必要额外的设置这么一个永久代的地方了。</li>
<li>对永久代进行调优是很困难的。</li>
</ol>
<h3 id="StringTable-为什么要调整"><a href="#StringTable-为什么要调整" class="headerlink" title="StringTable 为什么要调整"></a>StringTable 为什么要调整</h3><p>因为永久代的回收效率很低，在 full gc 的时候才会触发。而 full GC 是老年代的空间不足、永久代不足时才会触发。这就导致了<code>StringTable</code> 回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。方法区的垃圾收集主要回收两部分内容：常量池中废奔的<strong>常量</strong>和不再使用的<strong>类型</strong>。</p>
<p>方法区内常量池中主要存放字面量和符号引用两大类常量：</p>
<ul>
<li>字面量比较接近 Java 语言层次的常量概念，如文本字符串、被声明为 final 的常量值等。</li>
<li>符号引用则属于编译原理方面的概念，包括类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。</li>
</ul>
<p>HotSpot 虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p>
<h3 id="类型判定"><a href="#类型判定" class="headerlink" title="类型判定"></a>类型判定</h3><p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p>
<ul>
<li>该类所有的<strong>实例</strong>都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例；</li>
<li>加载该类的<strong>类加载器</strong>已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的；</li>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>Java 虛拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>C</tag>
        <tag>内存</tag>
        <tag>GC</tag>
        <tag>const</tag>
        <tag>堆</tag>
        <tag>栈</tag>
        <tag>全局</tag>
        <tag>局部</tag>
        <tag>变量</tag>
        <tag>面试</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot整合nacos</title>
    <url>/posts/3MH3EJ1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="下载服务端压缩包"><a href="#下载服务端压缩包" class="headerlink" title="下载服务端压缩包"></a>下载服务端压缩包</h4><p>下载地址：链接: <span class="exturl" data-url="aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMThHUi16U0hqQ0YtUWc5OGF1NnpmYUE=">https://pan.baidu.com/s/18GR-zSHjCF-Qg98au6zfaA<i class="fa fa-external-link-alt"></i></span> 提取码: n9fk </p>
<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p><img data-src="https://xuemingde.com/pages/image/others/20210304163758.png" alt="image-20210304163751931"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210304163845.png" alt="image-20210304163843821"></p>
<p>访问：<span class="exturl" data-url="aHR0cDovLzEyNy4wLjAuMTo4ODQ4L25hY29z">http://127.0.0.1:8848/nacos<i class="fa fa-external-link-alt"></i></span>  </p>
<p>账户密码默认：nacos/nacos </p>
<h4 id="登录首页"><a href="#登录首页" class="headerlink" title="登录首页"></a>登录首页</h4><p><img data-src="https://xuemingde.com/pages/image/others/20210304164000.png" alt="image-20210304163959764"></p>
<h4 id="客户端设置与代码实现-（Springboot-项目）"><a href="#客户端设置与代码实现-（Springboot-项目）" class="headerlink" title="客户端设置与代码实现 （Springboot 项目）"></a>客户端设置与代码实现 （Springboot 项目）</h4><ol>
<li><p>新建  命名空间</p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210305092814.png" alt="image-20210305092812721"></p>
</li>
</ol>
<p><img data-src="https://xuemingde.com/pages/image/others/20210305092920.png" alt="image-20210305092919689"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210305092945.png" alt="image-20210305092944790"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210305093109.png" alt="image-20210305093108311"></p>
<p>新建配置</p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210305093324.png" alt="image-20210305093323554"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210305093506.png" alt="image-20210305093505015"></p>
<p>代码配置</p>
<p>maven引用</p>
<!--nacos组件-->
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>新建 bootstrap.yml 文件，内容如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210305093731.png" alt="image-20210305093729513"></p>
<p>与服务端配置对比</p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210305094240.png" alt="image-20210305094238911"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210305094354.png" alt="image-20210305094353139"></p>
<p>新建获取配置信息文件，示例：</p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210305094646.png" alt="image-20210305094645537"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210305094636.png" alt="image-20210305094635853"></p>
<p>测试获取配置信息：</p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210305094745.png" alt="image-20210305094744176"></p>
<p>测试：</p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210305095010.png" alt="image-20210305095009444"></p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Spring</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务_JTA</title>
    <url>/posts/12G3J8V.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="分布式事务（二）"><a href="#分布式事务（二）" class="headerlink" title="分布式事务（二）"></a>分布式事务（二）</h2><blockquote>
<p>文章来源：</p>
<ul>
<li><span class="exturl" data-url="aHR0cDovL2NvZGluLmltLzIwMTgvMDYvMjUvaW1wbGVtZW50aW5nLWRpc3RyaWJ1dGVkLXRyYW5zYWN0aW9uLXdpdGgtc3ByaW5nLw==">http://codin.im/2018/06/25/implementing-distributed-transaction-with-spring/<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODQ0OTAzNjY2MjczNDg0ODE0">https://juejin.cn/post/6844903666273484814<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppYW5neXUxMDEzL2FydGljbGUvZGV0YWlscy84NDM5NzM2Ng==">https://blog.csdn.net/jiangyu1013/article/details/84397366<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</blockquote>
<h3 id="Transactional-详解"><a href="#Transactional-详解" class="headerlink" title="@Transactional 详解"></a>@Transactional 详解</h3><p><img data-src="https://xuemingde.com/pages/image/others/image-20210310134240771.png" alt="image-20210310134240771"></p>
<blockquote>
<ul>
<li><strong>编程式事务</strong>使用TransactionTemplate或者直接使用底层的PlatformTransactionManager。对于编程式事务管理，spring推荐使用TransactionTemplate。</li>
<li><strong>声明式事务</strong>是建立在AOP之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。声明式事务最大的优点就是不需要通过编程的方式管理事务，这样就不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明(或通过基于@Transactional注解的方式)，便可以将事务规则应用到业务逻辑中</li>
</ul>
</blockquote>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210310140333912.png" alt="image-20210310140333912"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210310141931318.png" alt="image-20210310141931318"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/20181123164638554.png" alt="img"></p>
<h3 id="JTA"><a href="#JTA" class="headerlink" title="JTA"></a>JTA</h3><p><img data-src="https://xuemingde.com/pages/image/others/image-20210310133454787.png" alt="image-20210310133454787"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210310133718647.png" alt="image-20210310133718647"></p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Spring</tag>
        <tag>事务</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务</title>
    <url>/posts/36WRKNE.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="分布式事务（一）"><a href="#分布式事务（一）" class="headerlink" title="分布式事务（一）"></a>分布式事务（一）</h2><blockquote>
<p>文章来源：<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xODM3NTM3NzQ=">https://zhuanlan.zhihu.com/p/183753774<i class="fa fa-external-link-alt"></i></span>   、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vZHl6Y3MvcC8xMzc4MDY2OC5odG1s">https://www.cnblogs.com/dyzcs/p/13780668.html<i class="fa fa-external-link-alt"></i></span>  、 </p>
<p>具体不多讲，详情看文章来源</p>
</blockquote>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p><img data-src="https://xuemingde.com/pages/image/others/image-20210310095052994.png" alt="image-20210310095052994"></p>
<h3 id="分布式事务产生的情景"><a href="#分布式事务产生的情景" class="headerlink" title="分布式事务产生的情景"></a>分布式事务产生的情景</h3><p><img data-src="https://xuemingde.com/pages/image/others/image-20210310111105762.png" alt="image-20210310111105762"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210310111122121.png" alt="image-20210310111122121"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210310111135604.png" alt="image-20210310111135604"></p>
<h3 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h3><p><img data-src="https://xuemingde.com/pages/image/others/image-20210310111713208.png" alt="image-20210310111713208"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210310111823153.png" alt="image-20210310111823153"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210310111839653.png" alt="image-20210310111839653"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210310112230088.png" alt="image-20210310112230088"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210310112245668.png" alt="image-20210310112245668"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210310112305735.png" alt="image-20210310112305735"></p>
<p><strong>重点 </strong></p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210310112443572.png" alt="image-20210310112443572"></p>
<p><strong>CPA的组合方式</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210310112909937.png" alt="image-20210310112909937"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210310112932874.png" alt="image-20210310112932874"></p>
<p>总结</p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210310113100211.png" alt="image-20210310113100211"></p>
<p><strong>几个分布式架构CPA</strong></p>
<ul>
<li><p>zookeeper（Dubbo）：CP</p>
</li>
<li><p>eureka（springcloud  - netflix）：AP</p>
</li>
<li><p>nacos：（Springcloud  - alibaba）：AP</p>
</li>
<li><p>redis集群：AP</p>
</li>
</ul>
<h3 id="BASE-理论"><a href="#BASE-理论" class="headerlink" title="BASE 理论"></a>BASE 理论</h3><p><img data-src="https://xuemingde.com/pages/image/others/image-20210310113839296.png" alt="image-20210310113839296"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210310113947118.png" alt="image-20210310113947118"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210310114211959.png" alt="image-20210310114211959"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210310114558794.png" alt="image-20210310114558794"></p>
<p>ACID 和 BASE 的区别与联系ACID 和 BASE 的区别与联系</p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210310114325451.png" alt="image-20210310114325451"></p>
<p>CAP 与 BASE 关系</p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210310114440621.png" alt="image-20210310114440621"></p>
<h3 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="headerlink" title="分布式事务解决方案"></a>分布式事务解决方案</h3><p><img data-src="https://xuemingde.com/pages/image/others/image-20210310095942828.png" alt="image-20210310095942828"></p>
<h4 id="2PC-两阶段提交"><a href="#2PC-两阶段提交" class="headerlink" title="2PC   两阶段提交"></a><strong>2PC </strong>  两阶段提交</h4><p><img data-src="https://xuemingde.com/pages/image/others/image-20210310100845788.png" alt="image-20210310100845788"></p>
<p>假如在第一阶段所有参与者都返回准备成功，那么协调者则向所有参与者发送提交事务命令，然后等待所有事务都提交成功之后，返回事务执行成功。</p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210310103855011.png" alt="image-20210310103855011"></p>
<p>假如在第一阶段有一个参与者返回失败，那么协调者就会向所有参与者发送回滚事务的请求，即分布式事务执行失败</p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210310103910529.png" alt="image-20210310103910529"></p>
<p>如果第二阶段提交失败会如何？</p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210310104040403.png" alt="image-20210310104040403"></p>
<p>协调者故障</p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210310104139596.png" alt="image-20210310104139596"></p>
<p>总结</p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210310104522151.png" alt="image-20210310104522151"></p>
<h4 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h4><p><img data-src="https://xuemingde.com/pages/image/others/image-20210310104742475.png" alt="image-20210310104742475"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/v2-885daf4ba34102d6e1047b0b67910652_r.jpg" alt="img"></p>
<p>总结</p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210310105402382.png" alt="image-20210310105402382"></p>
<h4 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h4><p><img data-src="https://xuemingde.com/pages/image/others/image-20210310105753937.png" alt="image-20210310105753937"></p>
<p>流程</p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210310105851289.png" alt="image-20210310105851289"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/v2-90179fa933c0a389ffa6ac04e244a58f_720w.jpg" alt="img"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210310110112096.png" alt="image-20210310110112096"></p>
<blockquote>
<p><strong>幂等性：就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用</strong></p>
</blockquote>
<h4 id="本地消息列表"><a href="#本地消息列表" class="headerlink" title="本地消息列表"></a>本地消息列表</h4><p><img data-src="https://xuemingde.com/pages/image/others/image-20210310110342821.png" alt="image-20210310110342821"></p>
<h4 id="消息事务"><a href="#消息事务" class="headerlink" title="消息事务"></a>消息事务</h4><p><img data-src="https://xuemingde.com/pages/image/others/image-20210310110553662.png" alt="image-20210310110553662"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/v2-72ba7bed684e855606c44ddda185987d_720w.jpg" alt="img"></p>
<p>可以看到消息事务实现的也是最终一致性。</p>
<h4 id="最大努力通知-（MQ就是一种）"><a href="#最大努力通知-（MQ就是一种）" class="headerlink" title="最大努力通知 （MQ就是一种）"></a>最大努力通知 （MQ就是一种）</h4><p><img data-src="https://xuemingde.com/pages/image/others/image-20210310114807940.png" alt="image-20210310114807940"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210310114822848.png" alt="image-20210310114822848"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210310114907740.png" alt="image-20210310114907740"></p>
<p>总结</p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210310115019855.png" alt="image-20210310115019855"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210310115109923.png" alt="image-20210310115109923"></p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Spring</tag>
        <tag>GC</tag>
        <tag>事务</tag>
        <tag>分布式</tag>
        <tag>Redis</tag>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务_seata</title>
    <url>/posts/2KNM24Z.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>文章来源</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuc29mYXN0YWNrLnRlY2gvYmxvZy9zZWF0YS1kaXN0cmlidXRlZC10cmFuc2FjdGlvbi1kZWVwLWRpdmUv">https://www.sofastack.tech/blog/seata-distributed-transaction-deep-dive/<i class="fa fa-external-link-alt"></i></span></li>
<li>官网：<span class="exturl" data-url="aHR0cDovL3NlYXRhLmlvL3poLWNuL2luZGV4Lmh0bWw=">http://seata.io/zh-cn/index.html<i class="fa fa-external-link-alt"></i></span></li>
<li>推荐文章：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vY2hlbmd4eS1uZHMvcC8xNDA0Njg1Ni5odG1s">https://www.cnblogs.com/chengxy-nds/p/14046856.html<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</blockquote>
<p><img data-src="https://xuemingde.com/pages/image/others/QxsNJBC7TiaLyZv.png" alt="image-20210311152028639"></p>
<h3 id="分布式事务问题产生原因"><a href="#分布式事务问题产生原因" class="headerlink" title="分布式事务问题产生原因"></a>分布式事务问题产生原因</h3><p><img data-src="https://xuemingde.com/pages/image/others/image-20210311153056539.png" alt="image-20210311153056539"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210311153133798.png" alt="image-20210311153133798"></p>
<h3 id="数据一致性问题"><a href="#数据一致性问题" class="headerlink" title="数据一致性问题"></a>数据一致性问题</h3><p><img data-src="https://xuemingde.com/pages/image/others/image-20210311153222409.png" alt="image-20210311153222409"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210311153254270.png" alt="image-20210311153254270"></p>
<h3 id="seata"><a href="#seata" class="headerlink" title="seata"></a>seata</h3><h4 id="什么是seata"><a href="#什么是seata" class="headerlink" title="什么是seata"></a>什么是seata</h4><p>官网介绍</p>
<p><img data-src="https://xuemingde.com/pages/image/others/QxsNJBC7TiaLyZv.png" alt="image-20210311152028639"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210311153456333.png" alt="image-20210311153456333"></p>
<h4 id="分布式事务-Seata-解决方案"><a href="#分布式事务-Seata-解决方案" class="headerlink" title="分布式事务 Seata 解决方案"></a>分布式事务 Seata 解决方案</h4><p><img data-src="https://xuemingde.com/pages/image/others/image-20210311153638276.png" alt="image-20210311153638276"></p>
<h5 id="AT-模式"><a href="#AT-模式" class="headerlink" title="AT 模式"></a>AT 模式</h5><p><img data-src="https://xuemingde.com/pages/image/others/image-20210311153810577.png" alt="image-20210311153810577"></p>
<p>执行流程</p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210311154207648.png" alt="image-20210311154207648"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210311154303985.png" alt="image-20210311154303985"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210311154439965.png" alt="image-20210311154439965"></p>
<h5 id="TCC-模式"><a href="#TCC-模式" class="headerlink" title="TCC 模式"></a>TCC 模式</h5><p><img data-src="https://xuemingde.com/pages/image/others/image-20210311154540770.png" alt="image-20210311154540770"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210311154603265.png" alt="image-20210311154603265"></p>
<p><strong>业务模型分 2 阶段设计</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210311154913051.png" alt="image-20210311154913051"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210311155124114.png" alt="image-20210311155124114"></p>
<h5 id="Saga-模式"><a href="#Saga-模式" class="headerlink" title="Saga 模式"></a>Saga 模式</h5><p><img data-src="https://xuemingde.com/pages/image/others/image-20210311155236693.png" alt="image-20210311155236693"></p>
<h5 id="XA-模式"><a href="#XA-模式" class="headerlink" title="XA 模式"></a>XA 模式</h5><p><img data-src="https://xuemingde.com/pages/image/others/image-20210311155404143.png" alt="image-20210311155404143"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210311155447736.png" alt="image-20210311155447736"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210311155520511.png" alt="image-20210311155520511"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210311155622601.png" alt="image-20210311155622601"></p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>事务</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>springBoot整合seata</title>
    <url>/posts/QWTBG7.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>参考文章</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vaXRDamIvc3ByaW5nLWNsb3VkLWFsaWJhYmEtc2VhdGEtZGVtbw==">https://gitee.com/itCjb/spring-cloud-alibaba-seata-demo<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly90aGlua2luZ2Nhby5ibG9nLmNzZG4ubmV0L2FydGljbGUvZGV0YWlscy8xMDkzMjAyMjE=">https://thinkingcao.blog.csdn.net/article/details/109320221<i class="fa fa-external-link-alt"></i></span></li>
</ul>
</blockquote>
<h2 id="安装seata"><a href="#安装seata" class="headerlink" title="安装seata"></a>安装seata</h2><blockquote>
<p>在安装了nacos的前提下</p>
</blockquote>
<h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>下载seata-1.3.0</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jb2RlbG9hZC5naXRodWIuY29tL3NlYXRhL3NlYXRhL3ppcC92MS4zLjA=">https://codeload.github.com/seata/seata/zip/v1.3.0<i class="fa fa-external-link-alt"></i></span></p>
<p>下载seata-server-1.4.1</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9waG9lbml4bmFwLmRsLnNvdXJjZWZvcmdlLm5ldC9wcm9qZWN0L3NlYXRhLm1pcnJvci92MS40LjEvc2VhdGEtc2VydmVyLTEuNC4xLnppcA==">https://phoenixnap.dl.sourceforge.net/project/seata.mirror/v1.4.1/seata-server-1.4.1.zip<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>在你的参与全局事务的数据库中加入undo_log这张表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS &#96;undo_log&#96;</span><br><span class="line">(</span><br><span class="line">    &#96;branch_id&#96;     BIGINT(20)   NOT NULL COMMENT &#39;branch transaction id&#39;,</span><br><span class="line">    &#96;xid&#96;           VARCHAR(100) NOT NULL COMMENT &#39;global transaction id&#39;,</span><br><span class="line">    &#96;context&#96;       VARCHAR(128) NOT NULL COMMENT &#39;undo_log context,such as serialization&#39;,</span><br><span class="line">    &#96;rollback_info&#96; LONGBLOB     NOT NULL COMMENT &#39;rollback info&#39;,</span><br><span class="line">    &#96;log_status&#96;    INT(11)      NOT NULL COMMENT &#39;0:normal status,1:defense status&#39;,</span><br><span class="line">    &#96;log_created&#96;   DATETIME(6)  NOT NULL COMMENT &#39;create datetime&#39;,</span><br><span class="line">    &#96;log_modified&#96;  DATETIME(6)  NOT NULL COMMENT &#39;modify datetime&#39;,</span><br><span class="line">    UNIQUE KEY &#96;ux_undo_log&#96; (&#96;xid&#96;, &#96;branch_id&#96;)</span><br><span class="line">) ENGINE &#x3D; InnoDB</span><br><span class="line">  AUTO_INCREMENT &#x3D; 1</span><br><span class="line">  DEFAULT CHARSET &#x3D; utf8 COMMENT &#x3D;&#39;AT transaction mode undo table&#39;;</span><br></pre></td></tr></table></figure>
<p>在你的mysql数据库中创建名为seata的库,并使用以下下sql</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS &#96;global_table&#96;</span><br><span class="line">(</span><br><span class="line">    &#96;xid&#96;                       VARCHAR(128) NOT NULL,</span><br><span class="line">    &#96;transaction_id&#96;            BIGINT,</span><br><span class="line">    &#96;status&#96;                    TINYINT      NOT NULL,</span><br><span class="line">    &#96;application_id&#96;            VARCHAR(32),</span><br><span class="line">    &#96;transaction_service_group&#96; VARCHAR(32),</span><br><span class="line">    &#96;transaction_name&#96;          VARCHAR(128),</span><br><span class="line">    &#96;timeout&#96;                   INT,</span><br><span class="line">    &#96;begin_time&#96;                BIGINT,</span><br><span class="line">    &#96;application_data&#96;          VARCHAR(2000),</span><br><span class="line">    &#96;gmt_create&#96;                DATETIME,</span><br><span class="line">    &#96;gmt_modified&#96;              DATETIME,</span><br><span class="line">    PRIMARY KEY (&#96;xid&#96;),</span><br><span class="line">    KEY &#96;idx_gmt_modified_status&#96; (&#96;gmt_modified&#96;, &#96;status&#96;),</span><br><span class="line">    KEY &#96;idx_transaction_id&#96; (&#96;transaction_id&#96;)</span><br><span class="line">) ENGINE &#x3D; InnoDB</span><br><span class="line">  DEFAULT CHARSET &#x3D; utf8;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS &#96;branch_table&#96;</span><br><span class="line">(</span><br><span class="line">    &#96;branch_id&#96;         BIGINT       NOT NULL,</span><br><span class="line">    &#96;xid&#96;               VARCHAR(128) NOT NULL,</span><br><span class="line">    &#96;transaction_id&#96;    BIGINT,</span><br><span class="line">    &#96;resource_group_id&#96; VARCHAR(32),</span><br><span class="line">    &#96;resource_id&#96;       VARCHAR(256),</span><br><span class="line">    &#96;branch_type&#96;       VARCHAR(8),</span><br><span class="line">    &#96;status&#96;            TINYINT,</span><br><span class="line">    &#96;client_id&#96;         VARCHAR(64),</span><br><span class="line">    &#96;application_data&#96;  VARCHAR(2000),</span><br><span class="line">    &#96;gmt_create&#96;        DATETIME(6),</span><br><span class="line">    &#96;gmt_modified&#96;      DATETIME(6),</span><br><span class="line">    PRIMARY KEY (&#96;branch_id&#96;),</span><br><span class="line">    KEY &#96;idx_xid&#96; (&#96;xid&#96;)</span><br><span class="line">) ENGINE &#x3D; InnoDB</span><br><span class="line">  DEFAULT CHARSET &#x3D; utf8;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE IF NOT EXISTS &#96;lock_table&#96;</span><br><span class="line">(</span><br><span class="line">    &#96;row_key&#96;        VARCHAR(128) NOT NULL,</span><br><span class="line">    &#96;xid&#96;            VARCHAR(96),</span><br><span class="line">    &#96;transaction_id&#96; BIGINT,</span><br><span class="line">    &#96;branch_id&#96;      BIGINT       NOT NULL,</span><br><span class="line">    &#96;resource_id&#96;    VARCHAR(256),</span><br><span class="line">    &#96;table_name&#96;     VARCHAR(32),</span><br><span class="line">    &#96;pk&#96;             VARCHAR(36),</span><br><span class="line">    &#96;gmt_create&#96;     DATETIME,</span><br><span class="line">    &#96;gmt_modified&#96;   DATETIME,</span><br><span class="line">    PRIMARY KEY (&#96;row_key&#96;),</span><br><span class="line">    KEY &#96;idx_branch_id&#96; (&#96;branch_id&#96;)</span><br><span class="line">) ENGINE &#x3D; InnoDB</span><br><span class="line">  DEFAULT CHARSET &#x3D; utf8;</span><br></pre></td></tr></table></figure>
<h3 id="第三部"><a href="#第三部" class="headerlink" title="第三部"></a>第三部</h3><p>在你的项目中引入seata依赖</p>
<p>如果你的微服务是dubbo:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果你是springcloud</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h3><p>从官方github仓库拿到参考配置做修改:<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NlYXRhL3NlYXRhL3RyZWUvZGV2ZWxvcC9zY3JpcHQvY2xpZW50">https://github.com/seata/seata/tree/develop/script/client<i class="fa fa-external-link-alt"></i></span></p>
<p>加到你项目的application.yml中.</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">seata:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">application-id:</span> <span class="string">applicationName</span></span><br><span class="line">  <span class="attr">tx-service-group:</span> <span class="string">my_test_tx_group</span></span><br><span class="line">  <span class="attr">enable-auto-data-source-proxy:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">namespace:</span></span><br><span class="line">      <span class="attr">serverAddr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">SEATA_GROUP</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">&quot;nacos&quot;</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">&quot;nacos&quot;</span></span><br><span class="line">  <span class="attr">registry:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">nacos</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">application:</span> <span class="string">seata-server</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">group:</span> <span class="string">SEATA_GROUP</span></span><br><span class="line">      <span class="attr">namespace:</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">&quot;nacos&quot;</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">&quot;nacos&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h3><p>运行你下载的nacos,并参考<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3NlYXRhL3NlYXRhL3RyZWUvZGV2ZWxvcC9zY3JpcHQvY29uZmlnLWNlbnRlcg==">https://github.com/seata/seata/tree/develop/script/config-center<i class="fa fa-external-link-alt"></i></span> 的config.txt并修改</p>
<p>文件在</p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210312170639465.png" alt="image-20210312170639465"></p>
<p>修改config.txt</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">service.vgroupMapping.my_test_tx_group</span>=<span class="string">default</span></span><br><span class="line"><span class="meta">store.mode</span>=<span class="string">db</span></span><br><span class="line"><span class="meta">store.db.datasource</span>=<span class="string">druid</span></span><br><span class="line"><span class="meta">store.db.dbType</span>=<span class="string">mysql</span></span><br><span class="line"><span class="meta">store.db.driverClassName</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="meta">store.db.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/seata?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC</span></span><br><span class="line"><span class="meta">store.db.user</span>=<span class="string">username</span></span><br><span class="line"><span class="meta">store.db.password</span>=<span class="string">password</span></span><br><span class="line"><span class="meta">store.db.minConn</span>=<span class="string">5</span></span><br><span class="line"><span class="meta">store.db.maxConn</span>=<span class="string">30</span></span><br><span class="line"><span class="meta">store.db.globalTable</span>=<span class="string">global_table</span></span><br><span class="line"><span class="meta">store.db.branchTable</span>=<span class="string">branch_table</span></span><br><span class="line"><span class="meta">store.db.queryLimit</span>=<span class="string">100</span></span><br><span class="line"><span class="meta">store.db.lockTable</span>=<span class="string">lock_table</span></span><br><span class="line"><span class="meta">store.db.maxWait</span>=<span class="string">5000</span></span><br></pre></td></tr></table></figure>
<p>运行仓库中提供的nacos脚本,将以上信息提交到nacos控制台,如果有需要更改,可直接通过控制台更改</p>
<p>进入文件夹下</p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210312171029260.png" alt="image-20210312171029260"></p>
<p>右键</p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210312171131042.png" alt="image-20210312171131042"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210312171216907.png" alt="image-20210312171216907"></p>
<p> 进入nacos查看</p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210312171537526.png" alt="image-20210312171537526"></p>
<h3 id="第六步"><a href="#第六步" class="headerlink" title="第六步"></a>第六步</h3><p>更改server中的registry.conf</p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210312171654248.png" alt="image-20210312171654248"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210312171805716.png" alt="image-20210312171805716"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210312171822584.png" alt="image-20210312171822584"></p>
<h3 id="第七步"><a href="#第七步" class="headerlink" title="第七步"></a>第七步</h3><p>运行seata-server</p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210312171941551.png" alt="image-20210312171941551"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210312172018047.png" alt="image-20210312172018047"></p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Spring</tag>
        <tag>sql</tag>
        <tag>GC</tag>
        <tag>事务</tag>
        <tag>数据库</tag>
        <tag>全局</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式锁</title>
    <url>/posts/17B6E0W.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="为什么要分布式锁"><a href="#为什么要分布式锁" class="headerlink" title="为什么要分布式锁"></a>为什么要分布式锁</h3><h4 id="什么是分布式锁"><a href="#什么是分布式锁" class="headerlink" title="什么是分布式锁"></a>什么是分布式锁</h4><ul>
<li>当在分布式模型下，数据只有一份（或有限制），此时需要利用锁的技术控制某一时刻修改数据的进程数。</li>
<li>与单机模式下的锁不仅需要保证进程可见，还需要考虑进程与锁之间的网络问题。（我觉得分布式情况下之所以问题变得复杂，主要就是需要考虑到网络的延时和不可靠。。。一个大坑）</li>
<li>分布式锁还是可以将标记存在内存，只是该内存不是某个进程分配的内存而是公共内存如 Redis、Memcache。至于利用数据库、文件等做锁与单机的实现是一样的，只要保证标记能互斥就行。</li>
</ul>
<h4 id="无锁带来的问题实例"><a href="#无锁带来的问题实例" class="headerlink" title="无锁带来的问题实例"></a>无锁带来的问题实例</h4><p><img data-src="https://xuemingde.com/pages/image/others/1607657980932-e7be9bfa-d222-407f-bf5a-1e29054d2b54.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1607657994147-cd6b551c-aa7d-4dbc-a812-62c078e76b67.png" alt="image.png"></p>
<h4 id="为何需要分布式锁"><a href="#为何需要分布式锁" class="headerlink" title="为何需要分布式锁"></a>为何需要分布式锁</h4><ul>
<li>效率:使用分布式锁可以避免不同节点重复相同的工作，这些工作会浪费资源。比如用户付了钱之后有可能不同节点会发出多封短信。</li>
<li>正确性:加分布式锁同样可以避免破坏正确性的发生，如果两个节点在同一条数据上面操作，比如多个节点机器对同一个订单操作不同的流程有可能会导致该笔订单最后状态出现错误，造成损失。</li>
</ul>
<h4 id="分布式锁的一些特点"><a href="#分布式锁的一些特点" class="headerlink" title="分布式锁的一些特点"></a>分布式锁的一些特点</h4><ul>
<li>互斥性:和我们本地锁一样互斥性是最基本，但是分布式锁需要保证在不同节点的不同线程的互斥。</li>
<li>可重入性:同一个节点上的同一个线程如果获取了锁之后那么也可以再次获取这个锁。</li>
<li>锁超时:和本地锁一样支持锁超时，防止死锁。</li>
<li>高效，高可用:加锁和解锁需要高效，同时也需要保证高可用防止分布式锁失效，可以增加降级。</li>
<li>支持阻塞和非阻塞:和ReentrantLock一样支持lock和trylock以及tryLock(long timeOut)。</li>
<li>支持公平锁和非公平锁(可选):公平锁的意思是按照请求加锁的顺序获得锁，非公平锁就相反是无序的。这个一般来说实现的比较少。</li>
</ul>
<h3 id="Redis实现分布式锁"><a href="#Redis实现分布式锁" class="headerlink" title="Redis实现分布式锁"></a>Redis实现分布式锁</h3><blockquote>
<p>参考文章：<span class="exturl" data-url="aHR0cHM6Ly94aWFvbWktaW5mby5naXRodWIuaW8vMjAxOS8xMi8xNy9yZWRpcy1kaXN0cmlidXRlZC1sb2NrLw==">文章一<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>Redis 锁主要利用 Redis 的 setnx 命令。</p>
<ul>
<li>加锁命令：SETNX key value，当键不存在时，对键进行设置操作并返回成功，否则返回失败。KEY 是锁的唯一标识，一般按业务来决定命名。</li>
<li>解锁命令：DEL key，通过删除键值对释放锁，以便其他线程可以通过 SETNX 命令来获取锁。</li>
<li>锁超时：EXPIRE key timeout, 设置 key 的超时时间，以保证即使锁没有被显式释放，锁也可以在一定时间后自动释放，避免资源被永远锁住。</li>
</ul>
<p>SETNX的伪代码：</p>
<p>(SETNX 命令对应到 StringRedisTemplate 的 api 是 setIfAbsent)</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">Boolean</span> setIfAbsent(K key, V value) &#123;</span><br><span class="line">    byte[] rawKey = <span class="keyword">this</span>.rawKey(key);</span><br><span class="line">    byte[] rawValue = <span class="keyword">this</span>.rawValue(value);</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">Boolean</span>)<span class="keyword">this</span>.execute((connection) -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> connection.setNX(rawKey, rawValue);</span><br><span class="line">    &#125;, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上述锁实现方式存在一些问题：</p>
</blockquote>
<h4 id="SETNX-和-EXPIRE-非原子性"><a href="#SETNX-和-EXPIRE-非原子性" class="headerlink" title="SETNX 和 EXPIRE 非原子性"></a>SETNX 和 EXPIRE 非原子性</h4><p>如果 SETNX 成功，在设置锁超时时间后，服务器挂掉、重启或网络问题等，导致 EXPIRE 命令没有执行，锁没有设置超时时间变成死锁。</p>
<p><img data-src="https://xuemingde.com/pages/image/others/1607670900145-fb2a2f04-3885-424f-91d7-096327be2640.png" alt="image.png"></p>
<p><strong>解决方式：</strong></p>
<p>有很多开源代码来解决这个问题，比如使用 lua 脚本。示例：</p>
<figure class="highlight scilab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;setnx&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]) &lt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">then</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line">redis.call(<span class="string">&#x27;expire&#x27;</span>, KEYS[<span class="number">1</span>], tonumber(ARGV[<span class="number">2</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用实例</span></span><br><span class="line">EVAL <span class="string">&quot;if (redis.call(&#x27;</span>setnx&#x27;,KEYS[<span class="number">1</span>],ARGV[<span class="number">1</span>]) &lt; <span class="number">1</span>) <span class="keyword">then</span> <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">end</span>; redis.call(<span class="string">&#x27;expire&#x27;</span>,KEYS[<span class="number">1</span>],tonumber(ARGV[<span class="number">2</span>])); <span class="keyword">return</span> <span class="number">1</span>;<span class="string">&quot; 1 key value 100</span></span><br></pre></td></tr></table></figure>
<h4 id="锁误解除"><a href="#锁误解除" class="headerlink" title="锁误解除"></a>锁误解除</h4><p>如果线程 A 成功获取到了锁，并且设置了过期时间 30 秒，但线程 A 执行时间超过了 30 秒，锁过期自动释放，此时线程 B 获取到了锁；随后 A 执行完成，线程 A 使用 DEL 命令来释放锁，但此时线程 B 加的锁还没有执行完成，线程 A 实际释放的线程 B 加的锁。</p>
<p><img data-src="https://xuemingde.com/pages/image/others/1607670976467-2e7148d4-a1fb-46a1-962f-ed3344c90506.png" alt="image"></p>
<p>解决方法：</p>
<p>通过在 value 中设置当前线程加锁的标识，在删除之前验证 key 对应的 value 判断锁是否是当前线程持有。可生成一个 UUID 标识当前线程，作为当前线程的唯一标示。</p>
<h4 id="超时解锁导致并发"><a href="#超时解锁导致并发" class="headerlink" title="超时解锁导致并发"></a>超时解锁导致并发</h4><p>如果线程 A 成功获取锁并设置过期时间 30 秒，但线程 A 执行时间超过了 30 秒，锁过期自动释放，此时线程 B 获取到了锁，线程 A 和线程 B 并发执行</p>
<p><img data-src="https://xuemingde.com/pages/image/others/1607671455219-53c5e944-4e3d-46f7-9003-cde5f431b8ff.png" alt="image"></p>
<p>A、B 两个线程发生并发显然是不被允许的，一般有两种方式解决该问题：</p>
<ul>
<li>将过期时间设置足够长，确保代码逻辑在锁释放之前能够执行完成。</li>
<li>为获取锁的线程增加守护线程，为将要过期但未释放的锁增加有效时间。</li>
</ul>
<p><img data-src="https://xuemingde.com/pages/image/others/1607671510560-5da451d2-ae36-4a97-af79-7e4f953b6454.png" alt="image"></p>
<h4 id="不可重入"><a href="#不可重入" class="headerlink" title="不可重入"></a>不可重入</h4><p>当线程在持有锁的情况下再次请求加锁，如果一个锁支持一个线程多次加锁，那么这个锁就是可重入的。如果一个不可重入锁被再次加锁，由于该锁已经被持有，再次加锁会失败。Redis 可通过对锁进行重入计数，加锁时加 1，解锁时减 1，当计数归 0 时释放锁。</p>
<p>在本地记录记录重入次数，如 Java 中使用 ThreadLocal 进行重入次数统计，简单示例代码：</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Map&lt;<span class="keyword">String</span>, Integer&gt;&gt; LOCKERS = ThreadLocal.withInitial(<span class="keyword">HashMap</span>::<span class="keyword">new</span>);</span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">boolean</span> lock(<span class="keyword">String</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">  Map&lt;<span class="keyword">String</span>, Integer&gt; lockers = LOCKERS.<span class="built_in">get</span>();</span><br><span class="line">  <span class="keyword">if</span> (lockers.containsKey(<span class="built_in">key</span>)) &#123;</span><br><span class="line">    lockers.put(<span class="built_in">key</span>, lockers.<span class="built_in">get</span>(<span class="built_in">key</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (SET <span class="built_in">key</span> uuid NX EX <span class="number">30</span>) &#123;</span><br><span class="line">      lockers.put(<span class="built_in">key</span>, <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> unlock(<span class="keyword">String</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">  Map&lt;<span class="keyword">String</span>, Integer&gt; lockers = LOCKERS.<span class="built_in">get</span>();</span><br><span class="line">  <span class="keyword">if</span> (lockers.getOrDefault(<span class="built_in">key</span>, <span class="number">0</span>) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    lockers.remove(<span class="built_in">key</span>);</span><br><span class="line">    DEL <span class="built_in">key</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    lockers.put(<span class="built_in">key</span>, lockers.<span class="built_in">get</span>(<span class="built_in">key</span>) - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本地记录重入次数虽然高效，但如果考虑到过期时间和本地、Redis 一致性的问题，就会增加代码的复杂性。另一种方式是 Redis Map 数据结构来实现分布式锁，既存锁的标识也对重入次数进行计数。Redission 加锁示例：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果 lock_key 不存在</span></span><br><span class="line"><span class="keyword">if</span> (redis.<span class="keyword">call</span>(<span class="string">&#x27;exists&#x27;</span>, KEYS[<span class="number">1</span>]) == <span class="number">0</span>)</span><br><span class="line">then</span><br><span class="line">    <span class="comment">// 设置 lock_key 线程标识 1 进行加锁</span></span><br><span class="line">    redis.<span class="keyword">call</span>(<span class="string">&#x27;hset&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>], <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 设置过期时间</span></span><br><span class="line">    redis.<span class="keyword">call</span>(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">    end;</span><br><span class="line"><span class="comment">// 如果 lock_key 存在且线程标识是当前欲加锁的线程标识</span></span><br><span class="line"><span class="keyword">if</span> (redis.<span class="keyword">call</span>(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>]) == <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 自增</span></span><br><span class="line">    then redis.<span class="keyword">call</span>(<span class="string">&#x27;hincrby&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">2</span>], <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 重置过期时间</span></span><br><span class="line">    redis.<span class="keyword">call</span>(<span class="string">&#x27;pexpire&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">    end;</span><br><span class="line"><span class="comment">// 如果加锁失败，返回锁剩余时间</span></span><br><span class="line"><span class="keyword">return</span> redis.<span class="keyword">call</span>(<span class="string">&#x27;pttl&#x27;</span>, KEYS[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
<h4 id="无法等待锁释放"><a href="#无法等待锁释放" class="headerlink" title="无法等待锁释放"></a>无法等待锁释放</h4><p>上述命令执行都是立即返回的，如果客户端可以等待锁释放就无法使用。</p>
<ul>
<li>可以通过客户端轮询的方式解决该问题，当未获取到锁时，等待一段时间重新获取锁，直到成功获取锁或等待超时。这种方式比较消耗服务器资源，当并发量比较大时，会影响服务器的效率。</li>
<li>另一种方式是使用 Redis 的发布订阅功能，当获取锁失败时，订阅锁释放消息，获取锁成功后释放时，发送锁释放消息。如下：</li>
</ul>
<p><img data-src="https://xuemingde.com/pages/image/others/1608010901340-ac6cc428-5810-47f3-b91b-423feb19b5b7.png" alt="image"></p>
<h3 id="Redisson-实现分布式锁"><a href="#Redisson-实现分布式锁" class="headerlink" title="Redisson 实现分布式锁"></a>Redisson 实现分布式锁</h3><blockquote>
<p>参考文章：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MveV9VdzNQMkxsN3d2a19qNUZkbHVzdw==">文章一<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h4 id="maven引用"><a href="#maven引用" class="headerlink" title="maven引用"></a>maven引用</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="原理图解析"><a href="#原理图解析" class="headerlink" title="原理图解析"></a>原理图解析</h4><p><img data-src="https://xuemingde.com/pages/image/others/1608027684749-b12735be-e685-4c0c-975b-67153a935048.jpeg" alt="image"></p>
<p> while循环获取锁是CAS机制，等待锁。</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>内存</tag>
        <tag>数据库</tag>
        <tag>锁</tag>
        <tag>分布式</tag>
        <tag>Redis</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Redisson 分布式锁</title>
    <url>/posts/2AGZ1Y7.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>推荐文章：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RpYW55YWxlaXhpYW93dS9hcnRpY2xlL2RldGFpbHMvOTAwMzYxODA=">Springboot使用分布式锁（基于redisson）<i class="fa fa-external-link-alt"></i></span>， </p>
</blockquote>
<h2 id="常见的分布式锁实现方案"><a href="#常见的分布式锁实现方案" class="headerlink" title="常见的分布式锁实现方案"></a><strong>常见的分布式锁实现方案</strong></h2><p><img data-src="https://xuemingde.com/pages/image/others/1616407355479-40ffe6b9-5476-488a-a8a1-6970e53f9bbc.png" alt="image.png"> </p>
<h2 id="Redisson原理分析图解"><a href="#Redisson原理分析图解" class="headerlink" title="Redisson原理分析图解"></a>Redisson原理分析图解</h2><p><img data-src="https://xuemingde.com/pages/image/others/1616405735205-372355c1-5217-48da-a0e5-370c220d189b.jpeg" alt="image"></p>
<h3 id="加锁机制"><a href="#加锁机制" class="headerlink" title="加锁机制"></a>加锁机制</h3><p><img data-src="https://xuemingde.com/pages/image/others/1616405769058-8e6279e7-68bd-4f1e-bd15-8090693c9687.png" alt="image.png"></p>
<h3 id="watch-dog自动延期机制"><a href="#watch-dog自动延期机制" class="headerlink" title="watch dog自动延期机制"></a>watch dog自动延期机制</h3><p><img data-src="https://xuemingde.com/pages/image/others/1616405802606-06d89d99-3382-4f4c-8432-40427e6f3fd8.png" alt="image.png"></p>
<h3 id="为啥要用lua脚本呢"><a href="#为啥要用lua脚本呢" class="headerlink" title="为啥要用lua脚本呢"></a>为啥要用lua脚本呢</h3><p><img data-src="https://xuemingde.com/pages/image/others/1616405833923-f3d5a659-b9a8-4f7c-b32e-3b42fbe3e21f.png" alt="image.png"></p>
<h3 id="可重入加锁机制"><a href="#可重入加锁机制" class="headerlink" title="可重入加锁机制"></a>可重入加锁机制</h3><p><img data-src="https://xuemingde.com/pages/image/others/1616405855881-10cb381d-4a17-415e-a61d-61e3724341fb.png" alt="image.png"></p>
<h2 id="Redis分布式锁的缺点"><a href="#Redis分布式锁的缺点" class="headerlink" title="Redis分布式锁的缺点"></a>Redis分布式锁的缺点</h2><p><img data-src="https://xuemingde.com/pages/image/others/1616405899527-5f409d65-9559-4a54-8e44-1f573b0bfd08.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Spring</tag>
        <tag>SpringBoot</tag>
        <tag>锁</tag>
        <tag>分布式</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>sentinel工作原理</title>
    <url>/posts/2DNYERW.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误！！" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="cbf81d490c4c1297ad80f14f25dfc3c39f68f934cb350ac5479eac2fe81bf795">6e9d7ca9294f2dfe030bce02e69a0643d3374ac3279d2c953140fc5b462fa95768a0575d8ee19f8eaabafefa0ce24d080f3c6db31bc839a25ec96924a2ee2138925fdedf97f04cbbd35a7cb5448a06b483fd142a79f5e768b7a2dd62d64ea7ff8bc1f2f3b0569e187c4e93982cefd734f3ff0587f4315b73092b42e6533cc1a7eb3eeca96e455e8e2c1f2e23efbf619c1ca96c106fcb79a4fc03ed712f2bca4a773e4c9b39acafb235ddcd955a24c02aecd2111c9f357ff85acb2ea97ec05ffa7aef084f4742475648d7e2cacbe00140428e395592a92c4b19de0ed535279f898b1ba5cb456b72e36191bd419a07eae9b4e9bfd505895a58599d3ed29638db7ccbe9bf16a689951723106485b73dc908d501187dcdd67eade1e9af31bbeb25295daf52823658a9c9dfca0745c5af7ae2c3ee0c87682ac21ed59457d4a1168fa77bd7a6c810d13d6d337193c86d731d17af358d658357e4d47ba49074c432ffbd3183c0e80848a3e0eb6e8ee1d2a47eb7231c173896361ae0a2832ad9ea0af31ec77967b17114c70ec39ad5df5c9696857a42b10a27fe80139bd4230329e8262f</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">未完结，暂不开放</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>并发场景下的幂等问题——分布式锁详解</title>
    <url>/posts/11E73BB.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>来自：<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzgxNjI3Mj9zcG09YTJjNmguMTI4NzM1ODEuMC5kQXJ0aWNsZTgxNjI3Mi4yNTg1MzlhMGIzeW1CYg==">阿里技术<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/193444.jpg" alt="image.png"></p>
<blockquote>
<p><strong>简介：</strong>                    </p>
<p>本文从钉钉实人认证场景的一例数据重复问题出发，分析了其原因是因为并发导致幂等失效，引出幂等的概念。针对并发场景下的幂等问题，提出了一种实现幂等可行的方法论，结合通讯录加人业务场景对数据库幂等问题进行了简单分析，就分布式锁实现幂等方法展开了详细讨论。分析了锁在分布式场景下存在的问题，包括单点故障、网络超时、错误释放他人锁、提前释放锁以及分布式锁单点故障等，提出了对应的解决方案，介绍了对应方案的具体实现。                </p>
</blockquote>
<p>作者 | 百书<br>来源 | 阿里技术公众号</p>
<blockquote>
<p>写在前面：本文讨论的幂等问题，均为并发场景下的幂等问题。即系统本存在幂等设计，但是在并发场景下失效了。</p>
</blockquote>
<h3 id="一-摘要"><a href="#一-摘要" class="headerlink" title="一  摘要"></a>一  摘要</h3><p>本文从钉钉实人认证场景的一例数据重复问题出发，分析了其原因是因为并发导致幂等失效，引出幂等的概念。</p>
<p>针对并发场景下的幂等问题，提出了一种实现幂等可行的方法论，结合通讯录加人业务场景对数据库幂等问题进行了简单分析，就分布式锁实现幂等方法展开了详细讨论。</p>
<p>分析了锁在分布式场景下存在的问题，包括单点故障、网络超时、错误释放他人锁、提前释放锁以及分布式锁单点故障等，提出了对应的解决方案，介绍了对应方案的具体实现。</p>
<h3 id="二-问题"><a href="#二-问题" class="headerlink" title="二  问题"></a>二  问题</h3><p>钉钉实人认证业务存在数据重复的问题。</p>
<h4 id="1-问题现象"><a href="#1-问题现象" class="headerlink" title="1  问题现象"></a>1  问题现象</h4><p>正常情况下，数据库中应该只有一条实人认证成功记录，但是实际上某用户有多条。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/191340.jpg" alt="image.png"></p>
<h4 id="2-问题原因"><a href="#2-问题原因" class="headerlink" title="2  问题原因"></a>2  问题原因</h4><p>并发导致了不幂等。</p>
<p>我们先来回顾一下幂等的概念：</p>
<blockquote>
<p>幂等（idempotent、idempotence）是一个数学与计算机学概念，常见于抽象代数中。<br>在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。<br>—来自百度百科</p>
</blockquote>
<p>实人认证在业务上有幂等设计，其一般流程为：</p>
<p>1）用户选择实人认证后会在服务端初始化一条记录；<br>2）用户在钉钉移动端按照指示完成人脸比对；<br>3）比对完成后访问服务端修改数据库状态。</p>
<p>在第3步中，在修改数据库状态之前，会判断「是否已经初始化」、「是否已经实人认证」以及「智科是否返回认证成功」以保证幂等。仅当请求首次访问服务端尝试修改数据库状态时，才能满足幂等的判断条件并修改数据库状态。其余任意次请求将直接返回，对数据库状态无影响。请求多次访问服务端所产生的结果，和请求首次访问服务端一致。因此，在实人认证成功的前提下，数据库应当有且仅有一条认证成功的记录。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/191425.jpg" alt="image.png"></p>
<p>但是在实际过程中我们发现，同一个请求会多次修改数据库状态，系统并未按照我们预期的那样实现幂等。究其原因，是因为请求并发访问，在首次请求完成修改服务端状态前，并发的其他请求和首次请求都通过了幂等判断，对数据库状态进行了多次修改。</p>
<p>并发导致了原幂等设计失效。</p>
<p>并发导致了不幂等。</p>
<h3 id="三-解决方案"><a href="#三-解决方案" class="headerlink" title="三  解决方案"></a>三  解决方案</h3><p>解决并发场景下幂等问题的关键，是找到唯一性约束，执行唯一性检查，相同的数据保存一次，相同的请求操作一次。</p>
<p>一次访问服务端的请求，可能产生以下几种交互：</p>
<ol>
<li>与数据源交互，例如数据库状态变更等；</li>
<li>与其他业务系统交互，例如调用下游服务或发送消息等；</li>
</ol>
<p>一次请求可以只包含一次交互，也可以包含多次交互。例如一次请求可以仅仅修改一次数据库状态，也可以在修改数据库状态后再发送一条数据库状态修改成功的消息。</p>
<p>于是我们可以得出一个结论：并发场景下，如果一个系统依赖的组件幂等，那么该系统在天然幂等。</p>
<p>以数据库为例，如果一个请求对数据造成的影响是新增一条数据，那么唯一索引可以是幂等问题的解法。数据库会帮助我们执行唯一性检查，相同数据不会重复落库。</p>
<p>钉钉通讯录加人就是通过数据库的唯一索引解决了幂等问题。以钉钉通讯录加人为例，在向数据库写数据之前，会先判断数据是否已经存在于数据库之中，如果不存在，加人请求最终会向数据库的员工表插入一条数据。大量相同的并发的通讯录加人请求让系统的幂等设计失效成为可能。在一次加人请求中，（组织ID，工号）可以唯一标记一个请求，在数据库中，也存在（组织ID，工号）的唯一索引。因此我们可以保证，多次相同的加人请求，只会修改一次数据库状态，即添加一条记录。</p>
<p>如果所依赖的组件天然幂等，那么问题就简单了，但是实际情况往往更加复杂。并发场景下，如果系统依赖的组件无法幂等，我们就需要使用额外的手段实现幂等。</p>
<p>一个常用的手段就是使用分布式锁。分布式锁的实现方式有很多，比较常用的是缓存式分布式锁。</p>
<h3 id="四-分布式锁"><a href="#四-分布式锁" class="headerlink" title="四  分布式锁"></a>四  分布式锁</h3><p>在What is a Java distributed lock?中有这样几段话：</p>
<blockquote>
<p>In computer science, locks are mechanisms in a multithreaded environment  to prevent different threads from operating on the same resource. When  using locking, a resource is “locked” for access by a specific thread,  and can only be accessed by a different thread once the resource has  been released. Locks have several benefits: they stop two threads from  doing the same work, and they prevent errors and data corruption when  two threads try to use the same resource simultaneously.</p>
<p>Distributed  locks in Java are locks that can work with not only multiple threads  running on the same machine, but also threads running on clients on  different machines in a distributed system. The threads on these  separate machines must communicate and coordinate to make sure that none of them try to access a resource that has been locked up by another.</p>
</blockquote>
<p>这几段话告诉我们，锁的本质是共享资源的互斥访问，分布式锁解决了分布式系统中共享资源的互斥访问的问题。</p>
<p>java.util.concurrent.locks包提供了丰富的锁实现，包括公平锁/非公平锁，阻塞锁/非阻塞锁，读写锁以及可重入锁等。</p>
<p>我们要如何实现一个分布式锁呢？</p>
<p><strong>方案一</strong></p>
<p>分布式系统中常见有两个问题：</p>
<p>1）单点故障问题，即当持有锁的应用发生单点故障时，锁将被长期无效占有；<br>2）网络超时问题，即当客户端发生网络超时但实际上锁成功时，我们无法再次正确的</p>
<p>获取锁。</p>
<p>要解决问题1，一个简单的方案是引入过期时间（lease time），对锁的持有将是有时效的，当应用发生单点故障时，被其持有的锁可以自动释放。</p>
<p>要解决问题2，一个简单的方案是支持可重入，我们为每个获取锁的客户端都配置一个不会重复的身份标识（通常是UUID），上锁成功后锁将带有该客户端的身份标识。当实际上锁成功而客户端超时重试时，我们可以判断锁已被该客户端持有而返回成功。</p>
<p>综上我们给出了一个lease-based distribute lock方案。出于性能考量，使用缓存作为锁的存储介质，利用MVCC（Multiversion concurrency control）机制解决共享资源互斥访问问题，具体实现可见附录代码。</p>
<p>分布式锁的一般使用方式如下</p>
<p>● 初始化分布式锁的工厂<br>● 利用工厂生成一个分布式锁实例<br>● 使用该分布式实例上锁和解锁操作</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTryLock</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化工厂</span></span><br><span class="line">    MdbDistributeLockFactory mdbDistributeLockFactory = <span class="keyword">new</span> MdbDistributeLockFactory();</span><br><span class="line">    mdbDistributeLockFactory.setNamespace(<span class="number">603</span>);</span><br><span class="line">    mdbDistributeLockFactory.setMtairManager(<span class="keyword">new</span> MultiClusterTairManager());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得锁</span></span><br><span class="line">    DistributeLock <span class="keyword">lock</span> = mdbDistributeLockFactory.getLock(<span class="string">&quot;TestLock&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上锁解锁操作</span></span><br><span class="line">    boolean locked = <span class="keyword">lock</span>.tryLock();</span><br><span class="line">    <span class="keyword">if</span> (!locked) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//do something </span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">lock</span>.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方案简单易用，但是问题也很明显。例如，释放锁的时候只是简单的将缓存中的key失效，所以存在错误释放他人已持有锁问题。所幸只要锁的租期设置的足够长，该问题出现几率就足够小。</p>
<p>我们借用Martin Kleppmann在文章How to do distributed locking中的一张图说明该问题。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/191436.jpg" alt="image.png"></p>
<p>设想一种情况，当占有锁的Client 1在释放锁之前，锁就已经到期了，Client 2将获取锁，此时锁被Client 2持有，但是Client  1可能会错误的将其释放。一个更优秀的方案，我们给每个锁都设置一个身份标识，在释放锁的时候，1）首先查询锁是否是自己的，2）如果是自己的则释放锁。受限于实现方式，步骤1和步骤2不是原子操作，在步骤1和步骤2之间，如果锁到期被其他客户端获取，此时也会错误的释放他人的锁。</p>
<p><strong>方案二</strong></p>
<p>借助Redis的Lua脚本，可以完美的解决存在错误释放他人已持有锁问题的。在Distributed locks with Redis这篇文章的 Correct implementation with a single instance  这一节中，我们可以得到我们想要的答案——如何实现一个分布式锁。</p>
<p>当我们想要获取锁时，我们可以执行如下方法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SET resource_name my_random_value NX PX 30000</span><br></pre></td></tr></table></figure>
<p>当我们想要释放锁时，我们可以执行如下的Lua脚本</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] then</span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p><strong>方案三</strong></p>
<p>在方案一和方案二的讨论过程中，有一个问题被我们反复提及：锁的自动释放。</p>
<p>这是一把双刃剑：</p>
<p>1）一方面它很好的解决了持有锁的客户端单点故障的问题<br>2）另一方面，如果锁提前释放，就会出现锁的错误持有状态</p>
<p>这个时候，我们可以引入Watch Dog自动续租机制，我们可以参考以下Redisson是如何实现的。</p>
<p>在上锁成功后，Redisson会调用renewExpiration()方法开启一个Watch Dog线程，为锁自动续期。每过1/3时间续一次，成功则继续下一次续期，失败取消续期操作。</p>
<p>我们可以再看看Redisson是如何续期的。renewExpiration()方法的第17行renewExpirationAsync()方法是执行锁续期的关键操作，我们进入到方法内部，可以看到Redisson也是使用Lua脚本进行锁续租的：1）判断锁是否存在，2）如果存在则重置过期时间。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">renewExpiration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ExpirationEntry ee = EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">    <span class="keyword">if</span> (ee == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Timeout task = commandExecutor.getConnectionManager().newTimeout(timeout -&gt; &#123;</span><br><span class="line">        ExpirationEntry ent = EXPIRATION_RENEWAL_MAP.get(getEntryName());</span><br><span class="line">        <span class="keyword">if</span> (ent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Long threadId = ent.getFirstThreadId();</span><br><span class="line">        <span class="keyword">if</span> (threadId == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        RFuture&lt;Boolean&gt; future = renewExpirationAsync(threadId);</span><br><span class="line">        future.onComplete((res, e) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;Can&#x27;t update lock &quot;</span> + getRawName() + <span class="string">&quot; expiration&quot;</span>, e);</span><br><span class="line">                EXPIRATION_RENEWAL_MAP.remove(getEntryName());</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (res) &#123;</span><br><span class="line">                <span class="comment">// reschedule itself</span></span><br><span class="line">                renewExpiration();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cancelExpirationRenewal(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;, internalLockLeaseTime / <span class="number">3</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    ee.setTimeout(task);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> RFuture&lt;Boolean&gt; <span class="title">renewExpirationAsync</span><span class="params">(<span class="keyword">long</span> threadId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> evalWriteAsync(getRawName(), LongCodec.INSTANCE, RedisCommands.EVAL_BOOLEAN,</span><br><span class="line">                          <span class="string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;return 1; &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;end; &quot;</span> +</span><br><span class="line">                          <span class="string">&quot;return 0;&quot;</span>,</span><br><span class="line">                          Collections.singletonList(getRawName()),</span><br><span class="line">                          internalLockLeaseTime, getLockName(threadId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方案四</strong></p>
<p>借助Redisson的自动续期机制，我们无需再担心锁的自动释放。但是讨论到这里，我还是不得不面对一个问题：分布式锁本身不是一个分布式应用。当Redis服务器故障无法正常工作时，整个分布式锁也就无法提供服务。</p>
<p>更进一步，我们可以看看Distributed locks with Redis这篇文章中提到的Redlock算法及其实现。</p>
<p>Redlock算法不是银弹，关于它的好与坏，也有很多争论：</p>
<p>How to do distributed locking：<br><span class="exturl" data-url="aHR0cHM6Ly9tYXJ0aW4ua2xlcHBtYW5uLmNvbS8yMDE2LzAyLzA4L2hvdy10by1kby1kaXN0cmlidXRlZC1sb2NraW5nLmh0bWw=">https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html<i class="fa fa-external-link-alt"></i></span></p>
<p>Is Redlock safe?：<br><span class="exturl" data-url="aHR0cDovL2FudGlyZXouY29tL25ld3MvMTAx">http://antirez.com/news/101<i class="fa fa-external-link-alt"></i></span></p>
<p>Martin Kleppmann和Antirez关于Redlock的争辩：<br><span class="exturl" data-url="aHR0cHM6Ly9uZXdzLnljb21iaW5hdG9yLmNvbS9pdGVt">https://news.ycombinator.com/item<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>参考资料</strong></p>
<p>What is a Java distributed lock?<br><span class="exturl" data-url="aHR0cHM6Ly9yZWRpc3Nvbi5vcmcvZ2xvc3NhcnkvamF2YS1kaXN0cmlidXRlZC1sb2NrLmh0bWw=">https://redisson.org/glossary/java-distributed-lock.html<i class="fa fa-external-link-alt"></i></span></p>
<p>Distributed locks and synchronizers：<br><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JlZGlzc29uL3JlZGlzc29uL3dpa2kvOC4tZGlzdHJpYnV0ZWQtbG9ja3MtYW5kLXN5bmNocm9uaXplcnM=">https://github.com/redisson/redisson/wiki/8.-distributed-locks-and-synchronizers<i class="fa fa-external-link-alt"></i></span></p>
<p>Distributed locks with Redis：<br><span class="exturl" data-url="aHR0cHM6Ly9yZWRpcy5pby90b3BpY3MvZGlzdGxvY2s/c3BtPWF0YS4yMTczNjAxMC4wLjAuMzFmNzdlM2FGczk2cno=">https://redis.io/topics/distlock?spm=ata.21736010.0.0.31f77e3aFs96rz<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>附录</strong></p>
<p>分布式锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MdbDistributeLock</span> <span class="keyword">implements</span> <span class="title">DistributeLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁的命名空间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> namespace;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁对应的缓存key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String lockName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁的唯一标识，保证可重入，以应对put成功，但是返回超时的情况</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String lockId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否持有锁。true：是</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> locked;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TairManager tairManager;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MdbDistributeLock</span><span class="params">(TairManager tairManager, <span class="keyword">int</span> namespace, String lockCacheKey)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.tairManager = tairManager;</span><br><span class="line">        <span class="keyword">this</span>.namespace = namespace;</span><br><span class="line">        <span class="keyword">this</span>.lockName = lockCacheKey;</span><br><span class="line">        <span class="keyword">this</span>.lockId = UUID.randomUUID().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//获取锁状态</span></span><br><span class="line">            Result&lt;DataEntry&gt; getResult = <span class="keyword">null</span>;</span><br><span class="line">            ResultCode getResultCode = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> cnt = <span class="number">0</span>; cnt &lt; DEFAULT_RETRY_TIMES; cnt++) &#123;</span><br><span class="line">                getResult = tairManager.get(namespace, lockName);</span><br><span class="line">                getResultCode = getResult == <span class="keyword">null</span> ? <span class="keyword">null</span> : getResult.getRc();</span><br><span class="line">                <span class="keyword">if</span> (noNeedRetry(getResultCode)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//重入，已持有锁，返回成功</span></span><br><span class="line">            <span class="keyword">if</span> (ResultCode.SUCCESS.equals(getResultCode)</span><br><span class="line">                &amp;&amp; getResult.getValue() != <span class="keyword">null</span> &amp;&amp; lockId.equals(getResult.getValue().getValue())) &#123;</span><br><span class="line">                locked = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//不可获取锁，返回失败</span></span><br><span class="line">            <span class="keyword">if</span> (!ResultCode.DATANOTEXSITS.equals(getResultCode)) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;tryLock fail code=&#123;&#125; lock=&#123;&#125; traceId=&#123;&#125;&quot;</span>, getResultCode, <span class="keyword">this</span>, EagleEye.getTraceId());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//尝试获取锁</span></span><br><span class="line">            ResultCode putResultCode = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> cnt = <span class="number">0</span>; cnt &lt; DEFAULT_RETRY_TIMES; cnt++) &#123;</span><br><span class="line">                putResultCode = tairManager.put(namespace, lockName, lockId, MDB_CACHE_VERSION,</span><br><span class="line">                    DEFAULT_EXPIRE_TIME_SEC);</span><br><span class="line">                <span class="keyword">if</span> (noNeedRetry(putResultCode)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!ResultCode.SUCCESS.equals(putResultCode)) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;tryLock fail code=&#123;&#125; lock=&#123;&#125; traceId=&#123;&#125;&quot;</span>, getResultCode, <span class="keyword">this</span>, EagleEye.getTraceId());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            locked = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;DistributedLock.tryLock fail lock=&#123;&#125;&quot;</span>, <span class="keyword">this</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!locked) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ResultCode resultCode = tairManager.invalid(namespace, lockName);</span><br><span class="line">        <span class="keyword">if</span> (!resultCode.isSuccess()) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;DistributedLock.unlock fail lock=&#123;&#125; resultCode=&#123;&#125; traceId=&#123;&#125;&quot;</span>, <span class="keyword">this</span>, resultCode,</span><br><span class="line">                EagleEye.getTraceId());</span><br><span class="line">        &#125;</span><br><span class="line">        locked = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否需要重试</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resultCode 缓存的返回码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true：不用重试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">noNeedRetry</span><span class="params">(ResultCode resultCode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> resultCode != <span class="keyword">null</span> &amp;&amp; !ResultCode.CONNERROR.equals(resultCode) &amp;&amp; !ResultCode.TIMEOUT.equals(</span><br><span class="line">            resultCode) &amp;&amp; !ResultCode.UNKNOW.equals(resultCode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分布式锁工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MdbDistributeLockFactory</span> <span class="keyword">implements</span> <span class="title">DistributeLockFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 缓存的命名空间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> namespace;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="keyword">private</span> MultiClusterTairManager mtairManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DistributeLock <span class="title">getLock</span><span class="params">(String lockName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MdbDistributeLock(mtairManager, namespace, lockName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>GC</tag>
        <tag>数据库</tag>
        <tag>锁</tag>
        <tag>索引</tag>
        <tag>分布式</tag>
        <tag>Redis</tag>
        <tag>并发</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析 RPC 与基本实现</title>
    <url>/posts/1E7Q3HG.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>本文主要论述的是“RPC 实现原理”，那么首先明确一个问题什么是 RPC 呢？RPC 是 Remote Procedure Call 的缩写，即，远程过程调用。RPC  是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而开发人员无需额外地为这个交互编程。<br>值得注意是，两个或多个应用程序都分布在不同的服务器上，它们之间的调用都像是本地方法调用一样。接下来我们便来分析一下一次 RPC 调用发生了些什么？</p>
<h2 id="一次基本的-RPC-调用会涉及到什么？"><a href="#一次基本的-RPC-调用会涉及到什么？" class="headerlink" title="一次基本的 RPC 调用会涉及到什么？"></a>一次基本的 RPC 调用会涉及到什么？</h2><p>现在业界内比较流行的一些 RPC 框架，例如 Dubbo 提供的是<code>基于接口的远程方法调用</code>，即客户端只需要知道接口的定义即可调用远程服务。在 Java 中接口并不能直接调用实例方法，必须通过其实现类对象来完成此操作，这意味着客户端必须为这些接口生成<code>代理对象</code>，对此 Java 提供了 <code>Proxy</code>、<code>InvocationHandler</code> 生成动态代理的支持；生成了代理对象，那么每个具体的发方法是怎么调用的呢？jdk 动态代理生成的代理对象调用指定方法时实际会执行 <code>InvocationHandler</code> 中定义的 <code>#invoke</code> 方法，在该方法中完成远程方法调用并获取结果。</p>
<p>抛开客户端，回过头来看 RPC 是两台计算机间的调用，实质上是两台主机间的<code>网络通信</code>，涉及到网络通信又必然会有<code>序列化、反序列化</code>，<code>编解码</code>等一些必须要考虑的问题；同时实际上现在大多系统都是集群部署的，多台主机/容器对外提供相同的服务，如果集群的节点数量很大的话，那么管理服务地址也将是一件十分繁琐的事情，常见的做法是各个服务节点将自己的地址和提供的服务列表注册到一个 <code>注册中心</code>，由 <code>注册中心</code> 来统一管理服务列表；这样的做法解决了一些问题同时为客户端增加了一项新的工作——那就是<code>服务发现</code>，通俗来说就是从注册中心中找到远程方法对应的服务列表并通过某种策略从中选取一个服务地址来完成网络通信。</p>
<p>聊了客户端和 <code>注册中心</code>，另外一个重要的角色自然是服务端，服务端最重要的任务便是提供服务接口的真正实现并在某个端口上监听网络请求，监听到请求后从网络请求中获取到对应的参数（比如服务接口、方法、请求参数等），再根据这些参数通过<code>反射</code>的方式调用接口的真正实现获取结果并将其写入对应的响应流中。</p>
<p>综上所述，一次基本的 RPC 调用流程大致如下：<br><img data-src="https://xuemingde.com/pages/image/2022/03/28/154901.jpg" alt="154901"></p>
<h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><h3 id="服务端（生产者）"><a href="#服务端（生产者）" class="headerlink" title="服务端（生产者）"></a>服务端（生产者）</h3><ul>
<li>服务接口</li>
</ul>
<p>在 RPC 中，生产者和消费者有一个共同的服务接口 API。如下，定义一个 HelloService 接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 孙浩</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Descrption</span>  服务接口</span></span><br><span class="line"><span class="comment"> ***/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(String somebody)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>服务实现</li>
</ul>
<p>生产者要提供服务接口的实现，创建 HelloServiceImpl 实现类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 孙浩</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Descrption</span> 服务实现</span></span><br><span class="line"><span class="comment"> ***/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String somebody)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello &quot;</span> + somebody + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>服务注册</li>
</ul>
<p>本例使用 Spring 来管理 bean，采用自定义 xml 和解析器的方式来将服务实现类载入容器（当然也可以采用自定义注解的方式，此处不过多论述）并将服务接口信息注册到注册中心。<br>首先自定义<code>xsd</code>,</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">&quot;service&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:complexType</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:complexContent</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsd:extension</span> <span class="attr">base</span>=<span class="string">&quot;beans:identifiedType&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">&quot;interface&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xsd:string&quot;</span> <span class="attr">use</span>=<span class="string">&quot;required&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">&quot;timeout&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xsd:int&quot;</span> <span class="attr">use</span>=<span class="string">&quot;required&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">&quot;serverPort&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xsd:int&quot;</span> <span class="attr">use</span>=<span class="string">&quot;required&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">&quot;ref&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xsd:string&quot;</span> <span class="attr">use</span>=<span class="string">&quot;required&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">&quot;weight&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xsd:int&quot;</span> <span class="attr">use</span>=<span class="string">&quot;optional&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">&quot;workerThreads&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xsd:int&quot;</span> <span class="attr">use</span>=<span class="string">&quot;optional&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">&quot;appKey&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xsd:string&quot;</span> <span class="attr">use</span>=<span class="string">&quot;required&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">&quot;groupName&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xsd:string&quot;</span> <span class="attr">use</span>=<span class="string">&quot;optional&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">xsd:extension</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">xsd:complexContent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xsd:complexType</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xsd:element</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>分别指定 schema 和 xmd，schema 和对应 handler 的映射：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">schema</span><br><span class="line">http\://www.storm.com/schema/storm-service.xsd=META-INF/storm-service.xsd</span><br><span class="line">http\://www.storm.com/schema/storm-reference.xsd=META-INF/storm-reference.xsd</span><br><span class="line">handler</span><br><span class="line">http\://www.storm.com/schema/storm-service=com.hsunfkqm.storm.framework.spring.StormServiceNamespaceHandler</span><br><span class="line">http\://www.storm.com/schema/storm-reference=com.hsunfkqm.storm.framework.spring.StormRemoteReferenceNamespaceHandler</span><br></pre></td></tr></table></figure>
<p>将编写好的文件放入 <code>classpath</code> 下的 <code>META-INF</code> 目录下：<br><img data-src="https://xuemingde.com/pages/image/2022/03/28/154921.jpg" alt="154921"></p>
<p>在 Spring 配置文件中配置服务类：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 发布远程服务 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;helloService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.hsunfkqm.storm.framework.test.HelloServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">storm:service</span> <span class="attr">id</span>=<span class="string">&quot;helloServiceRegister&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">interface</span>=<span class="string">&quot;com.hsunfkqm.storm.framework.test.HelloService&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">ref</span>=<span class="string">&quot;helloService&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">groupName</span>=<span class="string">&quot;default&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">weight</span>=<span class="string">&quot;2&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">appKey</span>=<span class="string">&quot;ares&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">workerThreads</span>=<span class="string">&quot;100&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">serverPort</span>=<span class="string">&quot;8081&quot;</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">timeout</span>=<span class="string">&quot;600&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>编写对应的 Handler 和 Parser：<br><code>StormServiceNamespaceHandler</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.xml.NamespaceHandlerSupport;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 孙浩</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Descrption</span> 服务发布自定义标签</span></span><br><span class="line"><span class="comment"> ***/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StormServiceNamespaceHandler</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;service&quot;</span>, <span class="keyword">new</span> ProviderFactoryBeanDefinitionParser());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ProviderFactoryBeanDefinitionParser</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Class <span class="title">getBeanClass</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ProviderFactoryBean.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doParse</span><span class="params">(Element element, BeanDefinitionBuilder bean)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String serviceItf = element.getAttribute(<span class="string">&quot;interface&quot;</span>);</span><br><span class="line">            String serverPort = element.getAttribute(<span class="string">&quot;serverPort&quot;</span>);</span><br><span class="line">            String ref = element.getAttribute(<span class="string">&quot;ref&quot;</span>);</span><br><span class="line">            <span class="comment">// ....</span></span><br><span class="line">            bean.addPropertyValue(<span class="string">&quot;serverPort&quot;</span>, Integer.parseInt(serverPort));</span><br><span class="line">            bean.addPropertyValue(<span class="string">&quot;serviceItf&quot;</span>, Class.forName(serviceItf));</span><br><span class="line">            bean.addPropertyReference(<span class="string">&quot;serviceObject&quot;</span>, ref);</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">if</span> (NumberUtils.isNumber(weight)) &#123;</span><br><span class="line">                bean.addPropertyValue(<span class="string">&quot;weight&quot;</span>, Integer.parseInt(weight));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// ...        </span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>ProviderFactoryBean</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 孙浩</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Descrption</span> 服务发布</span></span><br><span class="line"><span class="comment"> ***/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>, <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务接口</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; serviceItf;</span><br><span class="line">    <span class="comment">//服务实现</span></span><br><span class="line">    <span class="keyword">private</span> Object serviceObject;</span><br><span class="line">    <span class="comment">//服务端口</span></span><br><span class="line">    <span class="keyword">private</span> String serverPort;</span><br><span class="line">    <span class="comment">//服务超时时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timeout;</span><br><span class="line">    <span class="comment">//服务代理对象，暂时没有用到</span></span><br><span class="line">    <span class="keyword">private</span> Object serviceProxyObject;</span><br><span class="line">    <span class="comment">//服务提供者唯一标识</span></span><br><span class="line">    <span class="keyword">private</span> String appKey;</span><br><span class="line">    <span class="comment">//服务分组组名</span></span><br><span class="line">    <span class="keyword">private</span> String groupName = <span class="string">&quot;default&quot;</span>;</span><br><span class="line">    <span class="comment">//服务提供者权重，默认为 1 , 范围为 [1-100]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> weight = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//服务端线程数，默认 10 个线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> workerThreads = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serviceProxyObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> serviceItf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//启动 Netty 服务端</span></span><br><span class="line">        NettyServer.singleton().start(Integer.parseInt(serverPort));</span><br><span class="line">        <span class="comment">//注册到 zk, 元数据注册中心</span></span><br><span class="line">        List&lt;ProviderService&gt; providerServiceList = buildProviderServiceInfos();</span><br><span class="line">        IRegisterCenter4Provider registerCenter4Provider = RegisterCenter.singleton();</span><br><span class="line">        registerCenter4Provider.registerProvider(providerServiceList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//================RegisterCenter#registerProvider======================</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerProvider</span><span class="params">(<span class="keyword">final</span> List&lt;ProviderService&gt; serviceMetaData)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(serviceMetaData)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接 zk, 注册服务</span></span><br><span class="line">    <span class="keyword">synchronized</span> (RegisterCenter.class) &#123;</span><br><span class="line">        <span class="keyword">for</span> (ProviderService provider : serviceMetaData) &#123;</span><br><span class="line">            String serviceItfKey = provider.getServiceItf().getName();</span><br><span class="line"></span><br><span class="line">            List&lt;ProviderService&gt; providers = providerServiceMap.get(serviceItfKey);</span><br><span class="line">            <span class="keyword">if</span> (providers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                providers = Lists.newArrayList();</span><br><span class="line">            &#125;</span><br><span class="line">            providers.add(provider);</span><br><span class="line">            providerServiceMap.put(serviceItfKey, providers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (zkClient == <span class="keyword">null</span>) &#123;</span><br><span class="line">            zkClient = <span class="keyword">new</span> ZkClient(ZK_SERVICE, ZK_SESSION_TIME_OUT, ZK_CONNECTION_TIME_OUT, <span class="keyword">new</span> SerializableSerializer());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建 ZK 命名空间/当前部署应用 APP 命名空间/</span></span><br><span class="line">        String APP_KEY = serviceMetaData.get(<span class="number">0</span>).getAppKey();</span><br><span class="line">        String ZK_PATH = ROOT_PATH + <span class="string">&quot;/&quot;</span> + APP_KEY;</span><br><span class="line">        <span class="keyword">boolean</span> exist = zkClient.exists(ZK_PATH);</span><br><span class="line">        <span class="keyword">if</span> (!exist) &#123;</span><br><span class="line">            zkClient.createPersistent(ZK_PATH, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;ProviderService&gt;&gt; entry : providerServiceMap.entrySet()) &#123;</span><br><span class="line">            <span class="comment">//服务分组</span></span><br><span class="line">            String groupName = entry.getValue().get(<span class="number">0</span>).getGroupName();</span><br><span class="line">            <span class="comment">//创建服务提供者</span></span><br><span class="line">            String serviceNode = entry.getKey();</span><br><span class="line">            String servicePath = ZK_PATH + <span class="string">&quot;/&quot;</span> + groupName + <span class="string">&quot;/&quot;</span> + serviceNode + <span class="string">&quot;/&quot;</span> + PROVIDER_TYPE;</span><br><span class="line">            exist = zkClient.exists(servicePath);</span><br><span class="line">            <span class="keyword">if</span> (!exist) &#123;</span><br><span class="line">                zkClient.createPersistent(servicePath, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建当前服务器节点</span></span><br><span class="line">            <span class="keyword">int</span> serverPort = entry.getValue().get(<span class="number">0</span>).getServerPort();<span class="comment">//服务端口</span></span><br><span class="line">            <span class="keyword">int</span> weight = entry.getValue().get(<span class="number">0</span>).getWeight();<span class="comment">//服务权重</span></span><br><span class="line">            <span class="keyword">int</span> workerThreads = entry.getValue().get(<span class="number">0</span>).getWorkerThreads();<span class="comment">//服务工作线程</span></span><br><span class="line">            String localIp = IPHelper.localIp();</span><br><span class="line">            String currentServiceIpNode = servicePath + <span class="string">&quot;/&quot;</span> + localIp + <span class="string">&quot;|&quot;</span> + serverPort + <span class="string">&quot;|&quot;</span> + weight + <span class="string">&quot;|&quot;</span> + workerThreads + <span class="string">&quot;|&quot;</span> + groupName;</span><br><span class="line">            exist = zkClient.exists(currentServiceIpNode);</span><br><span class="line">            <span class="keyword">if</span> (!exist) &#123;</span><br><span class="line">                <span class="comment">//注意，这里创建的是临时节点</span></span><br><span class="line">                zkClient.createEphemeral(currentServiceIpNode);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//监听注册服务的变化，同时更新数据到本地缓存</span></span><br><span class="line">            zkClient.subscribeChildChanges(servicePath, <span class="keyword">new</span> IZkChildListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleChildChange</span><span class="params">(String parentPath, List&lt;String&gt; currentChilds)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (currentChilds == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        currentChilds = Lists.newArrayList();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//存活的服务 IP 列表</span></span><br><span class="line">                    List&lt;String&gt; activityServiceIpList = Lists.newArrayList(Lists.transform(currentChilds, <span class="keyword">new</span> Function&lt;String, String&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> StringUtils.split(input, <span class="string">&quot;|&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;));</span><br><span class="line">                    refreshActivityService(activityServiceIpList);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此服务实现类已被载入 Spring 容器中，且服务接口信息也注册到了注册中心。</p>
<ul>
<li>网络通信</li>
</ul>
<p>作为生产者对外提供 RPC 服务，必须有一个网络程序来来监听请求和做出响应。在 Java 领域 Netty 是一款高性能的 NIO 通信框架，很多的框架的通信都是采用 Netty 来实现的，本例中也采用它当做通信服务器。</p>
<p>构建并启动 Netty 服务监听指定端口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (NettyServer.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bossGroup != <span class="keyword">null</span> || workerGroup != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">            workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap</span><br><span class="line">                    .group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>)</span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                    .childOption(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">//注册解码器 NettyDecoderHandler</span></span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> NettyDecoderHandler(StormRequest.class, serializeType));</span><br><span class="line">                            <span class="comment">//注册编码器 NettyEncoderHandler</span></span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> NettyEncoderHandler(serializeType));</span><br><span class="line">                            <span class="comment">//注册服务端业务逻辑处理器 NettyServerInvokeHandler</span></span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> NettyServerInvokeHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                channel = serverBootstrap.bind(port).sync().channel();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中向 Netty 服务的 pipeline 中添加了编解码和业务处理器，当接收到请求时，经过编解码后，真正处理业务的是业务处理器，即<code>NettyServerInvokeHandler</code>, 该处理器继承自<code>SimpleChannelInboundHandler</code>, 当数据读取完成将触发一个事件，并调用<code>NettyServerInvokeHandler#channelRead0</code>方法来处理请求。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, StormRequest request)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ctx.channel().isWritable()) &#123;</span><br><span class="line">        <span class="comment">//从服务调用对象里获取服务提供者信息</span></span><br><span class="line">        ProviderService metaDataModel = request.getProviderService();</span><br><span class="line">        <span class="keyword">long</span> consumeTimeOut = request.getInvokeTimeout();</span><br><span class="line">        <span class="keyword">final</span> String methodName = request.getInvokedMethodName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据方法名称定位到具体某一个服务提供者</span></span><br><span class="line">        String serviceKey = metaDataModel.getServiceItf().getName();</span><br><span class="line">        <span class="comment">//获取限流工具类</span></span><br><span class="line">        <span class="keyword">int</span> workerThread = metaDataModel.getWorkerThreads();</span><br><span class="line">        Semaphore semaphore = serviceKeySemaphoreMap.get(serviceKey);</span><br><span class="line">        <span class="keyword">if</span> (semaphore == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (serviceKeySemaphoreMap) &#123;</span><br><span class="line">                semaphore = serviceKeySemaphoreMap.get(serviceKey);</span><br><span class="line">                <span class="keyword">if</span> (semaphore == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    semaphore = <span class="keyword">new</span> Semaphore(workerThread);</span><br><span class="line">                    serviceKeySemaphoreMap.put(serviceKey, semaphore);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取注册中心服务</span></span><br><span class="line">        IRegisterCenter4Provider registerCenter4Provider = RegisterCenter.singleton();</span><br><span class="line">        List&lt;ProviderService&gt; localProviderCaches = registerCenter4Provider.getProviderServiceMap().get(serviceKey);</span><br><span class="line"></span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> acquire = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ProviderService localProviderCache = Collections2.filter(localProviderCaches, <span class="keyword">new</span> Predicate&lt;ProviderService&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">apply</span><span class="params">(ProviderService input)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> StringUtils.equals(input.getServiceMethod().getName(), methodName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).iterator().next();</span><br><span class="line">            Object serviceObject = localProviderCache.getServiceObject();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//利用反射发起服务调用</span></span><br><span class="line">            Method method = localProviderCache.getServiceMethod();</span><br><span class="line">            <span class="comment">//利用 semaphore 实现限流</span></span><br><span class="line">            acquire = semaphore.tryAcquire(consumeTimeOut, TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="keyword">if</span> (acquire) &#123;</span><br><span class="line">                result = method.invoke(serviceObject, request.getArgs());</span><br><span class="line">                <span class="comment">//System.out.println(&quot;---------------&quot;+result);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(JSON.toJSONString(localProviderCaches) + <span class="string">&quot;  &quot;</span> + methodName+<span class="string">&quot; &quot;</span>+e.getMessage());</span><br><span class="line">            result = e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (acquire) &#123;</span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据服务调用结果组装调用返回对象</span></span><br><span class="line">        StormResponse response = <span class="keyword">new</span> StormResponse();</span><br><span class="line">        response.setInvokeTimeout(consumeTimeOut);</span><br><span class="line">        response.setUniqueKey(request.getUniqueKey());</span><br><span class="line">        response.setResult(result);</span><br><span class="line">        <span class="comment">//将服务调用返回对象回写到消费端</span></span><br><span class="line">        ctx.writeAndFlush(response);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;------------channel closed!---------------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处还有部分细节如自定义的编解码器等，篇幅所限不在此详述，继承 <code>MessageToByteEncoder</code> 和 <code>ByteToMessageDecoder</code> 覆写对应的 <code>encode</code> 和 <code>decode</code> 方法即可自定义编解码器，使用到的序列化工具如 Hessian/Proto 等可参考对应的官方文档。</p>
<ul>
<li>请求和响应包装<br>为便于封装请求和响应，定义两个 bean 来表示请求和响应。</li>
</ul>
<p>请求：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 孙浩</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Descrption</span></span></span><br><span class="line"><span class="comment"> ***/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StormRequest</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5196465012408804755L</span>;</span><br><span class="line">    <span class="comment">//UUID, 唯一标识一次返回值</span></span><br><span class="line">    <span class="keyword">private</span> String uniqueKey;</span><br><span class="line">    <span class="comment">//服务提供者信息</span></span><br><span class="line">    <span class="keyword">private</span> ProviderService providerService;</span><br><span class="line">    <span class="comment">//调用的方法名称</span></span><br><span class="line">    <span class="keyword">private</span> String invokedMethodName;</span><br><span class="line">    <span class="comment">//传递参数</span></span><br><span class="line">    <span class="keyword">private</span> Object[] args;</span><br><span class="line">    <span class="comment">//消费端应用名</span></span><br><span class="line">    <span class="keyword">private</span> String appName;</span><br><span class="line">    <span class="comment">//消费请求超时时长</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> invokeTimeout;</span><br><span class="line">    <span class="comment">// getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>响应：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 孙浩</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Descrption</span></span></span><br><span class="line"><span class="comment"> ***/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StormResponse</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5785265307118147202L</span>;</span><br><span class="line">    <span class="comment">//UUID, 唯一标识一次返回值</span></span><br><span class="line">    <span class="keyword">private</span> String uniqueKey;</span><br><span class="line">    <span class="comment">//客户端指定的服务超时时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> invokeTimeout;</span><br><span class="line">    <span class="comment">//接口调用返回的结果对象</span></span><br><span class="line">    <span class="keyword">private</span> Object result;</span><br><span class="line">    <span class="comment">//getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="客户端（消费者）"><a href="#客户端（消费者）" class="headerlink" title="客户端（消费者）"></a>客户端（消费者）</h3><p>客户端（消费者）在 RPC 调用中主要是生成服务接口的代理对象，并从注册中心获取对应的服务列表发起网络请求。<br>客户端和服务端一样采用 Spring 来管理 bean 解析 xml 配置等不再赘述，重点看下以下几点：</p>
<ul>
<li>通过 jdk 动态代理来生成引入服务接口的代理对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;targetInterface&#125;, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>从注册中心获取服务列表并依据某种策略选取其中一个服务节点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//服务接口名称</span></span><br><span class="line">String serviceKey = targetInterface.getName();</span><br><span class="line"><span class="comment">//获取某个接口的服务提供者列表</span></span><br><span class="line">IRegisterCenter4Invoker registerCenter4Consumer = RegisterCenter.singleton();</span><br><span class="line">List&lt;ProviderService&gt; providerServices = registerCenter4Consumer.getServiceMetaDataMap4Consume().get(serviceKey);</span><br><span class="line"><span class="comment">//根据软负载策略，从服务提供者列表选取本次调用的服务提供者</span></span><br><span class="line">ClusterStrategy clusterStrategyService = ClusterEngine.queryClusterStrategy(clusterStrategy);</span><br><span class="line">ProviderService providerService = clusterStrategyService.select(providerServices);</span><br></pre></td></tr></table></figure>
<ul>
<li>通过 Netty 建立连接，发起网络请求</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 孙浩</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Descrption</span> Netty 消费端 bean 代理工厂</span></span><br><span class="line"><span class="comment"> ***/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RevokerProxyBeanFactory</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ExecutorService fixedThreadPool = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//服务接口</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; targetInterface;</span><br><span class="line">    <span class="comment">//超时时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> consumeTimeout;</span><br><span class="line">    <span class="comment">//调用者线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> threadWorkerNumber = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">//负载均衡策略</span></span><br><span class="line">    <span class="keyword">private</span> String clusterStrategy;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//复制一份服务提供者信息</span></span><br><span class="line">        ProviderService newProvider = providerService.copy();</span><br><span class="line">        <span class="comment">//设置本次调用服务的方法以及接口</span></span><br><span class="line">        newProvider.setServiceMethod(method);</span><br><span class="line">        newProvider.setServiceItf(targetInterface);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明调用 AresRequest 对象，AresRequest 表示发起一次调用所包含的信息</span></span><br><span class="line">        <span class="keyword">final</span> StormRequest request = <span class="keyword">new</span> StormRequest();</span><br><span class="line">        <span class="comment">//设置本次调用的唯一标识</span></span><br><span class="line">        request.setUniqueKey(UUID.randomUUID().toString() + <span class="string">&quot;-&quot;</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="comment">//设置本次调用的服务提供者信息</span></span><br><span class="line">        request.setProviderService(newProvider);</span><br><span class="line">        <span class="comment">//设置本次调用的方法名称</span></span><br><span class="line">        request.setInvokedMethodName(method.getName());</span><br><span class="line">        <span class="comment">//设置本次调用的方法参数信息</span></span><br><span class="line">        request.setArgs(args);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//构建用来发起调用的线程池</span></span><br><span class="line">            <span class="keyword">if</span> (fixedThreadPool == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (RevokerProxyBeanFactory.class) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> == fixedThreadPool) &#123;</span><br><span class="line">                        fixedThreadPool = Executors.newFixedThreadPool(threadWorkerNumber);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//根据服务提供者的 ip,port, 构建 InetSocketAddress 对象，标识服务提供者地址</span></span><br><span class="line">            String serverIp = request.getProviderService().getServerIp();</span><br><span class="line">            <span class="keyword">int</span> serverPort = request.getProviderService().getServerPort();</span><br><span class="line">            InetSocketAddress inetSocketAddress = <span class="keyword">new</span> InetSocketAddress(serverIp, serverPort);</span><br><span class="line">            <span class="comment">//提交本次调用信息到线程池 fixedThreadPool, 发起调用</span></span><br><span class="line">            Future&lt;StormResponse&gt; responseFuture = fixedThreadPool.submit(RevokerServiceCallable.of(inetSocketAddress, request));</span><br><span class="line">            <span class="comment">//获取调用的返回结果</span></span><br><span class="line">            StormResponse response = responseFuture.get(request.getInvokeTimeout(), TimeUnit.MILLISECONDS);</span><br><span class="line">            <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> response.getResult();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Netty 的响应是异步的，为了在方法调用返回前获取到响应结果，需要将异步的结果同步化。</p>
<ul>
<li>Netty 异步返回的结果存入阻塞队列</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, StormResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//将 Netty 异步返回的结果存入阻塞队列，以便调用端同步获取</span></span><br><span class="line">    RevokerResponseHolder.putResultValue(response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>请求发出后同步获取结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//提交本次调用信息到线程池 fixedThreadPool, 发起调用</span></span><br><span class="line">Future&lt;StormResponse&gt; responseFuture = fixedThreadPool.submit(RevokerServiceCallable.of(inetSocketAddress, request));</span><br><span class="line"><span class="comment">//获取调用的返回结果</span></span><br><span class="line">StormResponse response = responseFuture.get(request.getInvokeTimeout(), TimeUnit.MILLISECONDS);</span><br><span class="line"><span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> response.getResult();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//===================================================</span></span><br><span class="line"><span class="comment">//从返回结果容器中获取返回结果，同时设置等待超时时间为 invokeTimeout</span></span><br><span class="line"><span class="keyword">long</span> invokeTimeout = request.getInvokeTimeout();</span><br><span class="line">StormResponse response = RevokerResponseHolder.getValue(request.getUniqueKey(), invokeTimeout);</span><br></pre></td></tr></table></figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p><code>Server</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 孙浩</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Descrption</span></span></span><br><span class="line"><span class="comment"> ***/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//发布服务</span></span><br><span class="line">        <span class="keyword">final</span> ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;storm-server.xml&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot; 服务发布完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Client</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(Client.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;storm-client.xml&quot;</span>);</span><br><span class="line">        <span class="keyword">final</span> HelloService helloService = (HelloService) context.getBean(<span class="string">&quot;helloService&quot;</span>);</span><br><span class="line">        String result = helloService.sayHello(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>生产者：<br><img data-src="https://xuemingde.com/pages/image/2022/03/28/154827.jpg" alt="154827"></p>
<p>消费者：<br><img data-src="https://xuemingde.com/pages/image/2022/03/28/154812.jpg" alt="154812"></p>
<p>注册中心<br><img data-src="https://xuemingde.com/pages/image/2022/03/28/154746.jpg" alt="154746"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文简单介绍了 RPC 的整个流程，并实现了一个简单的 RPC 调用。希望阅读完本文之后，能加深你对 RPC 的一些认识。</p>
<ul>
<li>生产者端流程：<ul>
<li>加载服务接口，并缓存</li>
<li>服务注册，将服务接口以及服务主机信息写入注册中心（本例使用的是 zookeeper)</li>
<li>启动网络服务器并监听</li>
<li>反射，本地调用</li>
</ul>
</li>
<li>消费者端流程：<ul>
<li>代理服务接口生成代理对象</li>
<li>服务发现（连接 zookeeper，拿到服务地址列表，通过客户端负载策略获取合适的服务地址）</li>
<li>远程方法调用（本例通过 Netty，发送消息，并获取响应结果）</li>
</ul>
</li>
</ul>
<p>限于篇幅，本文代码并不完整，如有需要，访问：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2ZhbmtvbmdxaXVtdS9zdG9ybS5naXTvvIzojrflj5blrozmlbTku6PnoIHjgII=">https://github.com/fankongqiumu/storm.git，获取完整代码。<i class="fa fa-external-link-alt"></i></span></p>
<p>如有错误之处，还望大家指正。</p>
<blockquote>
<p>本文转自：<span class="exturl" data-url="aHR0cHM6Ly94aWFvbWktaW5mby5naXRodWIuaW8vMjAyMC8wMy8wMi9ycGMtYWNoaWV2ZS8=">https://xiaomi-info.github.io/2020/03/02/rpc-achieve/<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p><em><code>注：文中所用到的代码已上传至 github: https://github.com/fankongqiumu/storm.git</code></em></p>
<p><strong>[作者简介]</strong> 孙浩，信息部售后组研发工程师</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>Spring</tag>
        <tag>线程池</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>撸一下Nacos</title>
    <url>/posts/MMNJGZ.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>什么是 Nacos</p>
<p>Nacos 是阿里巴巴开源的一款优秀的中间件，在分布式微服务场景下用的非常多。</p>
<p><strong>Nacos</strong> 英文全称 <strong>Naming and Configuration Service</strong>，其中 Na 是 naming 的缩写，注册中心；co为 configuration 的缩写， 配置中心；</p>
<p>不管是配置中心还是注册中心本质都是围着<strong>服务（微服务）</strong>转的，用官方的话来说：<strong>服务在 Nacos 里是一等公民</strong>。</p>
<p>Nacos 分为服务端和客户端，这一点不要含糊。</p>
<p><strong>Nacos Server</strong></p>
<p>Nacos Server 使用 Java 语言编写，提供了服务注册发现和服务配置功能；对外提供了 SDK 接入以及HTTP RESTful 开放接口，SDK 接入和 RESTful 接口的功能是一致的。</p>
<p><strong>Nacos Client</strong></p>
<p>Nacos提供了官方的 SDK，遗憾的是只有 Java 版本，官方的 SDK 可以很方便与一些主流的框架进行集成，比如：Spring Cloud、Dubbo 等。</p>
<p>Nacos Client 主要的作用是订阅获取服务实例信息以及配置信息。</p>
<p><strong>数据模型</strong></p>
<p>在 Nacos中最重要的就是服务，为了方便管理还引入了<strong>数据模型</strong>这个概念，数据模型主要分为<strong>命名空间</strong>、<strong>集群</strong>、<strong>服务</strong>。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/31/141103.jpeg" alt="图片"></p>
<p>数据模型主要作用是给服务分类，方便维护管理。如果觉得抽象，简单举个例子：假如你叫张三，生活在武汉，国籍是中国，在其他城市或者省也有张三这个人。</p>
<h1 id="Nacos-注册中心原理"><a href="#Nacos-注册中心原理" class="headerlink" title="Nacos 注册中心原理"></a>Nacos 注册中心原理</h1><p><img data-src="https://xuemingde.com/pages/image/2022/03/31/141114.jpeg" alt="图片"></p>
<p>服务注册成功后，为了向 Nacos Server 报告自己的健康状态，客户端每5秒向 Nacos server发送一次心跳，心跳带上了服务名，服务ip，服务端口等信息。当然 Nacos server 也会向 client 主动发起健康检查，支持tcp/http检查。</p>
<p>如果15秒内无心跳且健康检查失败则会将该实例标记为不健康的状态，如果30秒内健康检查再次失败则会直接剔除实例。</p>
<p>服务消费者订阅成功后，如果服务提供者的实例不健康或者被剔除掉了，Nacos Server 会发送变更通知。</p>
<h1 id="小试牛刀：Nacos-服务注册发现功能体验"><a href="#小试牛刀：Nacos-服务注册发现功能体验" class="headerlink" title="小试牛刀：Nacos 服务注册发现功能体验"></a>小试牛刀：Nacos 服务注册发现功能体验</h1><p>对理论知识稍加理解后，我们可以动动小手，把 Nacos真正用起来吧。</p>
<h2 id="搭建运行-Nacos-Server"><a href="#搭建运行-Nacos-Server" class="headerlink" title="搭建运行 Nacos Server"></a>搭建运行 Nacos Server</h2><p><strong>（1）下载 Nacos Server 安装包，启动 Nacos Server</strong></p>
<p>进入 Github Nacos 下载主页：</p>
<blockquote>
<p>主页链接：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly8qZ2l0aHViKi5jb20vYWxpYmFiYS9uYWNvcy9yZWxlYXNlcw==">https://*github*.com/alibaba/nacos/releases<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>目前最新的稳定版本是 2.0.4，直接下载 zip 包或者 tar.gz包即可，windows 和 Linux 均可运行。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/31/141124.png" alt="图片"></p>
<p>解压完毕，如果是 Linux 系统，执行以下命令，以单实例的方式运行：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sh </span>startup.<span class="keyword">sh </span>-m standalone</span><br></pre></td></tr></table></figure>
<p>如果是 windows 系统，执行以下命令：</p>
<figure class="highlight dos"><table><tr><td class="code"><pre><span class="line">startup.<span class="built_in">cmd</span> -m standalone</span><br></pre></td></tr></table></figure>
<p><strong>（2）使用 Docker 启动 Nacos Server</strong></p>
<p>如果你电脑上已经装了 Docker，建议你直接使用 Docker 来运行。</p>
<p>先拉取最新镜像：</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><span class="line">docker pull nacos/nacos-<span class="keyword">server</span></span><br></pre></td></tr></table></figure>
<p>拉取成功后启动实例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name nacos-demo -e MODE=standalone -p 8848:8848 -p 9848:9848 -d nacos/nacos-server</span><br></pre></td></tr></table></figure>
<p>这里有坑需要注意下，8848 是 Nacos Server 的主端口需要暴露出来，如果你安装的是 Nacos 2.0 版本还需要将 9848 端口暴露出来，这里我含泪调试了一下午才知道的，哭晕……</p>
<p>为什么需要 9848 端口呢？因为 Nacos 2.0 版本之后默认将这个端口作为 grpc 的通信端口，官方提供的 Client SDK使用 grpc 来与 Nacos Server 进行通信，包括服务实例注册、心跳检查等功能。</p>
<blockquote>
<p>这里需要说明下：grpc 的端口 = 主端口 + 偏移量1000，假如你的主端口是 8848，加上偏移量就是 9848</p>
</blockquote>
<h2 id="熟悉-Nacos-Server-控制台界面"><a href="#熟悉-Nacos-Server-控制台界面" class="headerlink" title="熟悉 Nacos Server 控制台界面"></a>熟悉 Nacos Server 控制台界面</h2><p>Nacos Server 运行成功后我们可以打开后台管理界面，查看其运行状态和管理信息。</p>
<blockquote>
<p>本地访问地址：<span class="exturl" data-url="aHR0cDovLzEyNy4wLjAuMTo4ODQ4L25hY29z">http://127.0.0.1:8848/nacos<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>第一次打开默认进入后台登录界面，默认用户名和密码都是：<strong>nacos</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/31/141137.png" alt="图片"></p>
<p>登录成功后可以看到左侧的菜单栏，主要功能有：<strong>配置管理</strong>、<strong>服务管理</strong>、<strong>权限管理</strong>、<strong>命名空间</strong>、<strong>集群管理</strong>。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/31/141149.png" alt="图片"></p>
<p><strong>（1）服务管理</strong></p>
<p>Nacos 的主要功能分为两块：<strong>配置管理</strong>和<strong>服务管理</strong>，这次主要展开讲解服务管理。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/31/141200.png" alt="图片"></p>
<p>展开菜单后，有<strong>服务列表</strong>和<strong>订阅者列表</strong>两块，服务列表会显示所有注册到 Nacos Server 的服务，包括实例数、实例健康状态等信息。</p>
<p><strong>订阅者列表</strong>会显示某个服务下有哪些客户端订阅了，以及包括客户端的版本信息等。</p>
<p><strong>（2）权限控制</strong></p>
<p>权限控制主要的作用是维护管理后台系统的用户角色和权限，一般的系统都有这个功能，这里不再赘述了。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/31/141212.png" alt="图片"></p>
<p><strong>（3）命名空间</strong></p>
<p>命名空间比较好理解，比如同样一个服务ServiceA可能会在研发环境、集成测试环境、生产环境各自部署一套，那如何区分它们呢？命名空间可以起这个作用，在下图中，我新建了好几个命名空间，用于将服务的注册订阅信息在逻辑上隔离开来。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/31/141223.png" alt="图片"></p>
<p><strong>（4）集群管理</strong></p>
<p>Nacos Server可以是集群部署的也可以是单机部署，在实际生产环境中为了防止单点故障我们肯定不可能部署一个节点，为了方便测试演示，我在本地只启动了一个节点，下图中可以看到这个节点的ip、状态等信息。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/31/141236.png" alt="图片"></p>
<h2 id="学习使用-Nacos-Client-SDK"><a href="#学习使用-Nacos-Client-SDK" class="headerlink" title="学习使用 Nacos Client SDK"></a>学习使用 Nacos Client SDK</h2><p>目前官网只推出了 Java 版的 SDK，其他语言版本暂时靠社区自行贡献。</p>
<p>我们拿 Java 版本 SDK 为例进行说明。</p>
<p>新建一个 Java Maven 工程，引入nacos-client 依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.nacos<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nacos-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面讲过 Nacos 主要分为两块大的功能：<strong>配置中心</strong>、<strong>注册中心</strong>，为了方便使用，Nacos-client 提供了三个工厂类：<code>NacosFactory</code>、<code>ConfigFactory</code>、<code>NamingFactory</code>，使用这些工厂类很容易生成对应实例对象。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/31/141256.jpeg" alt="图片"></p>
<p>NacosFactory 包含了 ConfigFactory 和 NamingFactory的所有功能，如果你想创建一个注册中心功能的实例，你可以使用：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">NacosFactory</span>.</span></span>create<span class="constructor">NamingService()</span>` 或者使用 `<span class="module-access"><span class="module"><span class="identifier">NamingFactory</span>.</span></span>create<span class="constructor">NamingFactory()</span></span><br></pre></td></tr></table></figure>
<h2 id="使用-Nacos-Client-注册实例"><a href="#使用-Nacos-Client-注册实例" class="headerlink" title="使用 Nacos Client 注册实例"></a>使用 Nacos Client 注册实例</h2><p>Nacos Client SDK 代码非常简单，基本一看就能学会怎么用，下面直接贴代码，可以运行的那种代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.nacos.api.exception.NacosException;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.nacos.api.naming.NamingFactory;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.nacos.api.naming.NamingService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟服务提供者注册服务实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用工厂类创建注册中心对象，构造参数为 Nacos Server 的 ip 地址，连接 Nacos 服务器</span></span><br><span class="line">        NamingService naming = NamingFactory.createNamingService(<span class="string">&quot;127.0.0.1:8848&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印 Nacos Server 的运行状态</span></span><br><span class="line">        System.out.println(<span class="string">&quot;server status: &quot;</span> + naming.getServerStatus());</span><br><span class="line">        <span class="comment">// 模拟注册当前服务实例，传入参数：服务名、ip 地址、端口</span></span><br><span class="line">        naming.registerInstance(<span class="string">&quot;com.leixiaoshuai.rpc.provider&quot;</span>, <span class="string">&quot;11.11.11.11&quot;</span>, <span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟当前进程不退出</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看完 demo 之后有没有同学比较好奇，Nacos Client 是通过什么协议与 Nacos Server通信的？简单看下源码就可以得到答案：Google grpc</p>
<p>这里需要特别说明一下：在 Nacos 1.x 时代是使用 HTTP RESTful 接口与Nacos Server交互的，后面 2.x 时候为了提升效率改成了 grpc。</p>
<h2 id="使用-Nacos-Client-消费实例"><a href="#使用-Nacos-Client-消费实例" class="headerlink" title="使用 Nacos Client 消费实例"></a>使用 Nacos Client 消费实例</h2><p>假如服务 A 需要调用服务 B 的接口，首先得知道服务 B 实例的 ip 和端口，在这个场景下服务 A 就是服务消费者了，通过简单的代码很容易获取到服务实例信息，为了方便感知服务实例变化，Nacos 还提供了事件通知能力。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.nacos.api.exception.NacosException;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.nacos.api.naming.NamingFactory;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.nacos.api.naming.NamingService;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.nacos.api.naming.listener.Event;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.nacos.api.naming.listener.EventListener;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.nacos.api.naming.listener.NamingEvent;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟服务消费者订阅服务实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NacosException </span>&#123;</span><br><span class="line">        <span class="comment">// 使用工厂类创建注册中心对象，构造参数为 Nacos Server 的 ip 地址，连接 Nacos 服务器</span></span><br><span class="line">        NamingService naming = NamingFactory.createNamingService(<span class="string">&quot;127.0.0.1:8848&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印 Nacos Server 的运行状态</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;server status: %s&quot;</span>, naming.getServerStatus());</span><br><span class="line">        <span class="comment">// 获取指定服务所有的实例列表</span></span><br><span class="line">        System.out.println(naming.getAllInstances(<span class="string">&quot;com.leixiaoshuai.rpc.provider&quot;</span>));</span><br><span class="line">        <span class="comment">// 订阅指定服务，并注册回调接口</span></span><br><span class="line">        naming.subscribe(<span class="string">&quot;com.leixiaoshuai.rpc.provider&quot;</span>, <span class="keyword">new</span> EventListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 服务实例有变动就自动收到通知</span></span><br><span class="line">                System.out.println(<span class="string">&quot;~~event start&quot;</span>);</span><br><span class="line">                System.out.println(((NamingEvent) event).getServiceName());</span><br><span class="line">                System.out.println(((NamingEvent) event).getInstances());</span><br><span class="line">                System.out.println(<span class="string">&quot;~~event end&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟当前进程不退出</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Nacos 是阿里巴巴开源的一款中间件，常用于分布式微服务场景，主要功能包括两大块：服务注册发现、服务配置。</p>
<p>Nacos 分为 server 和 client，可以在官网下载安装包在本地运行，运行成功后通过后台管理界面对 Nacos Server 进行管理和维护；</p>
<p>Client 端的接入方式有 SDK 和 HTTP RESTful 两种方式，功能都是一样的。</p>
<blockquote>
<p>原文连接：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvMmNSZkNzWGU1VW9LNVpvaVg5eGxpQQ==">折腾一个周末，撸Nacos可真不容易<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>Spring</tag>
        <tag>linux</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式锁的多种实现</title>
    <url>/posts/5HB0NA.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>原文：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MveFFrbmQ2eHNWRFBCcjRUYkVUVGsyQQ==">聊聊分布式锁的多种实现！<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>今天跟大家探讨一下分布式锁的设计与实现。希望对大家有帮助，如果有不正确的地方，欢迎指出。</p>
<h2 id="分布式锁概述"><a href="#分布式锁概述" class="headerlink" title="分布式锁概述"></a>分布式锁概述</h2><p>我们的系统都是分布式部署的，日常开发中，<strong>秒杀下单、抢购商品</strong>等等业务场景，为了防⽌库存超卖，都需要用到<strong>分布式锁</strong>。</p>
<blockquote>
<p>分布式锁其实就是，控制分布式系统不同进程共同访问共享资源的一种锁的实现。如果不同的系统或同一个系统的不同主机之间共享了某个临界资源，往往需要互斥来防止彼此干扰，以保证一致性。</p>
</blockquote>
<p>业界流行的分布式锁实现，一般有这3种方式：</p>
<ul>
<li>基于数据库实现的分布式锁</li>
<li>基于Redis实现的分布式锁</li>
<li>基于Zookeeper实现的分布式锁</li>
</ul>
<h2 id="基于数据库的分布式锁"><a href="#基于数据库的分布式锁" class="headerlink" title="基于数据库的分布式锁"></a>基于数据库的分布式锁</h2><h3 id="数据库悲观锁实现的分布式锁"><a href="#数据库悲观锁实现的分布式锁" class="headerlink" title="数据库悲观锁实现的分布式锁"></a>数据库悲观锁实现的分布式锁</h3><p>可以使用<code>select ... for update</code>来实现分布式锁。我们自己的项目，<strong>分布式定时任务</strong>，就使用类似的实现方案，我给大家来展示个<strong>简单版的哈</strong></p>
<p>表结构如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CREATE TABLE `t_resource_lock` (</span><br><span class="line">  `key_resource` varchar(<span class="number">45</span>) COLLATE utf8_bin NOT NULL DEFAULT <span class="string">&#x27;资源主键&#x27;</span>,</span><br><span class="line">  `status` <span class="keyword">char</span>(<span class="number">1</span>) COLLATE utf8_bin NOT NULL DEFAULT <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;S,F,P&#x27;</span>,</span><br><span class="line">  `lock_flag` <span class="keyword">int</span>(<span class="number">10</span>) unsigned NOT NULL DEFAULT <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;1是已经锁 0是未锁&#x27;</span>,</span><br><span class="line">  `begin_time` datetime DEFAULT NULL COMMENT <span class="string">&#x27;开始时间&#x27;</span>,</span><br><span class="line">  `end_time` datetime DEFAULT NULL COMMENT <span class="string">&#x27;结束时间&#x27;</span>,</span><br><span class="line">  `client_ip` varchar(<span class="number">45</span>) COLLATE utf8_bin NOT NULL DEFAULT <span class="string">&#x27;抢到锁的IP&#x27;</span>,</span><br><span class="line">  `time` <span class="keyword">int</span>(<span class="number">10</span>) unsigned NOT NULL DEFAULT <span class="string">&#x27;60&#x27;</span> COMMENT <span class="string">&#x27;方法生命周期内只允许一个结点获取一次锁，单位：分钟&#x27;</span>,</span><br><span class="line">  <span class="function">PRIMARY <span class="title">KEY</span> <span class="params">(`key_resource`)</span> USING BTREE</span></span><br><span class="line"><span class="function">) ENGINE</span>=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin</span><br></pre></td></tr></table></figure>
<p>加锁<code>lock</code>方法的伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transcational</span> <span class="comment">//一定要加事务</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String keyResource，<span class="keyword">int</span> time)</span></span>&#123;</span><br><span class="line">   resourceLock = &#x27;select * from t_resource_lock where key_resource =&#x27;#&#123;keySource&#125;&#x27; for update&#x27;;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(resourceLock==<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="comment">//插入锁的数据</span></span><br><span class="line">      resourceLock = <span class="keyword">new</span> ResourceLock();</span><br><span class="line">      resourceLock.setTime(time);</span><br><span class="line">      resourceLock.setLockFlag(<span class="number">1</span>);  <span class="comment">//上锁</span></span><br><span class="line">      resourceLock.setStatus(P); <span class="comment">//处理中</span></span><br><span class="line">      resourceLock.setBeginTime(<span class="keyword">new</span> Date());</span><br><span class="line">      <span class="keyword">int</span> count = <span class="string">&quot;insert into resourceLock&quot;</span>; </span><br><span class="line">      <span class="keyword">if</span>(count==<span class="number">1</span>)&#123;</span><br><span class="line">         <span class="comment">//获取锁成功</span></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;<span class="keyword">catch</span>(Exception x)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//没上锁并且锁已经超时，即可以获取锁成功</span></span><br><span class="line">   <span class="keyword">if</span>(resourceLock.getLockFlag==<span class="string">&#x27;0&#x27;</span>&amp;&amp;<span class="string">&#x27;S&#x27;</span>.equals(resourceLock.getstatus)</span><br><span class="line">    &amp;&amp; <span class="keyword">new</span> Date()&gt;=resourceLock.addDateTime(resourceLock.getBeginTime(,time))&#123;</span><br><span class="line">      resourceLock.setLockFlag(<span class="number">1</span>);  <span class="comment">//上锁</span></span><br><span class="line">      resourceLock.setStatus(P); <span class="comment">//处理中</span></span><br><span class="line">      resourceLock.setBeginTime(<span class="keyword">new</span> Date());</span><br><span class="line">      <span class="comment">//update resourceLock;</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">new</span> Date()&gt;=resourceLock.addDateTime(resourceLock.getBeginTime(,time))&#123;</span><br><span class="line">     <span class="comment">//超时未正常执行结束,获取锁失败</span></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解锁<code>unlock</code>方法的伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">(String v，status)</span></span>&#123;</span><br><span class="line">      resourceLock.setLockFlag(<span class="number">0</span>);  <span class="comment">//解锁</span></span><br><span class="line">      resourceLock.setStatus(status); S:表示成功，F表示失败</span><br><span class="line">      <span class="comment">//update resourceLock;</span></span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体流程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(lock(keyResource,time))&#123; <span class="comment">//加锁</span></span><br><span class="line">   status = process();<span class="comment">//你的业务逻辑处理。</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">    unlock(keyResource,status); <span class="comment">//释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实这个悲观锁实现的分布式锁，整体的流程还是比较清晰的。就是先<code>select ... for update</code>锁住主键<code>key_resource</code>那个记录，如果为空，则可以插入一条记录，如果已有记录判断下<strong>状态和时间</strong>，<strong>是否已经超时</strong>。这里需要注意一下哈，必须要加<strong>事务</strong>哈。</p>
<h3 id="数据库乐观锁实现的分布式锁"><a href="#数据库乐观锁实现的分布式锁" class="headerlink" title="数据库乐观锁实现的分布式锁"></a>数据库乐观锁实现的分布式锁</h3><p>除了悲观锁，还可以用<strong>乐观锁实现分布式锁</strong>。乐观锁，顾名思义，就是很乐观，每次更新操作，都觉得不会存在并发冲突，只有更新失败后，才重试。它是基于CAS思想实现的。我以前的公司，<strong>扣减余额</strong>就是用这种方案。</p>
<blockquote>
<p>搞个version字段，每次更新修改，都会自增加一，然后去更新余额时，把查出来的那个版本号，带上条件去更新，如果是上次那个版本号，就更新，如果不是，表示别人并发修改过了，就继续重试。</p>
</blockquote>
<p>大概流程如下：</p>
<ol>
<li>查询版本号和余额</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> version,balance <span class="keyword">from</span> account <span class="keyword">where</span> user_id <span class="operator">=</span><span class="string">&#x27;666&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>假设查到版本号是oldVersion=1.</p>
<ol>
<li>逻辑处理，判断余额</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(balance&lt;扣减金额)&#123;</span><br><span class="line">   <span class="keyword">return</span>；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">left_balance = balance - 扣减金额;</span><br></pre></td></tr></table></figure>
<ol>
<li>进行扣减余额</li>
</ol>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">update account set balance = #&#123;left_balance&#125; ,version = version+1 where version </span><br><span class="line">= #&#123;oldVersion&#125; and balance&gt;= #&#123;left_balance&#125; and user_id =&#x27;666&#x27;;</span><br></pre></td></tr></table></figure>
<p>大家可以看下这个流程图哈：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/14/1045-RjWzaR.png" alt="图片"></p>
<p>这种方式适合<strong>并发不高</strong>的场景，一般需要设置一下重试的次数</p>
<h2 id="基于Redis实现的分布式锁"><a href="#基于Redis实现的分布式锁" class="headerlink" title="基于Redis实现的分布式锁"></a>基于Redis实现的分布式锁</h2><p>Redis分布式锁一般有以下这几种实现方式：</p>
<ul>
<li>setnx + expire</li>
<li>setnx + value值是过期时间</li>
<li>set的扩展命令（set ex px nx）</li>
<li>set ex px nx + 校验唯一随机值,再删除</li>
<li>Redisson</li>
<li>Redisson + RedLock</li>
</ul>
<h3 id="setnx-expire"><a href="#setnx-expire" class="headerlink" title="setnx + expire"></a>setnx + expire</h3><p>聊到Redis分布式锁，很多小伙伴反手就是<code>setnx + expire</code>，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>（jedis.setnx(key,lock_value) == <span class="number">1</span>）&#123; <span class="comment">//setnx加锁</span></span><br><span class="line">    expire（key，<span class="number">100</span>）; <span class="comment">//设置过期时间</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> something  <span class="comment">//业务处理</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">       jedis.del(key); <span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码是可以加锁成功，但是你有没有发现问题，<strong>加锁操作和设置超时时间是分开的</strong>。假设在执行完<code>setnx</code>加锁后，正要执行<code>expire</code>设置过期时间时，进程<code>crash</code>掉或者要重启维护了，那这个锁就<strong>长生不老</strong>了，别的线程永远获取不到锁啦，所以<strong>分布式锁不能这么实现</strong>！</p>
<h3 id="setnx-value值是过期时间"><a href="#setnx-value值是过期时间" class="headerlink" title="setnx + value值是过期时间"></a>setnx + value值是过期时间</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> expires = System.currentTimeMillis() + expireTime; <span class="comment">//系统时间+设置的过期时间</span></span><br><span class="line">String expiresStr = String.valueOf(expires);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果当前锁不存在，返回加锁成功</span></span><br><span class="line"><span class="keyword">if</span> (jedis.setnx(key, expiresStr) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 如果锁已经存在，获取锁的过期时间</span></span><br><span class="line">String currentValueStr = jedis.get(key);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果获取到的过期时间，小于系统当前时间，表示已经过期</span></span><br><span class="line"><span class="keyword">if</span> (currentValueStr != <span class="keyword">null</span> &amp;&amp; Long.parseLong(currentValueStr) &lt; System.currentTimeMillis()) &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 锁已过期，获取上一个锁的过期时间，并设置现在锁的过期时间（不了解redis的getSet命令的小伙伴，可以去官网看下哈）</span></span><br><span class="line">    String oldValueStr = jedis.getSet(key, expiresStr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (oldValueStr != <span class="keyword">null</span> &amp;&amp; oldValueStr.equals(currentValueStr)) &#123;</span><br><span class="line">         <span class="comment">// 考虑多线程并发的情况，只有一个线程的设置值和当前值相同，它才可以加锁</span></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//其他情况，均返回加锁失败</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>日常开发中，有些小伙伴就是这么实现分布式锁的，但是会有这些<strong>缺点</strong>：</p>
<ul>
<li>过期时间是客户端自己生成的，分布式环境下，<strong>每个客户端的时间必须同步。</strong></li>
<li>没有保存持有者的唯一标识，<strong>可能被别的客户端释放/解锁</strong>。</li>
<li>锁过期的时候，并发多个客户端同时请求过来，都执行了<code>jedis.getSet()</code>，最终只能有一个客户端加锁成功，但是该客户端锁的过期时间，<strong>可能被别的客户端覆盖。</strong></li>
</ul>
<h3 id="set的扩展命令-set-ex-px-nx"><a href="#set的扩展命令-set-ex-px-nx" class="headerlink" title="set的扩展命令(set ex px nx)"></a>set的扩展命令(set ex px nx)</h3><p>这个命令的几个参数分别表示什么意思呢？跟大家复习一下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">SET key value <span class="selector-attr">[EX seconds]</span> <span class="selector-attr">[PX milliseconds]</span> <span class="selector-attr">[NX|XX]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>EX second ：设置键的过期时间为<code>second</code>秒。</li>
<li>PX millisecond ：设置键的过期时间为<code>millisecond</code>毫秒。</li>
<li>NX ：只在键不存在时，才对键进行设置操作。</li>
<li>XX ：只在键已经存在时，才对键进行设置操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>（jedis.set(key, lock_value, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;EX&quot;</span>, 100s) == <span class="number">1</span>）&#123; <span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> something  <span class="comment">//业务处理</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">       jedis.del(key); <span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方案可能存在这样的问题：</p>
<ul>
<li>锁过期释放了，业务还没执行完。</li>
<li>锁被别的线程误删。</li>
</ul>
<p>有些伙伴可能会有个疑问，就是<strong>锁为什么会被别的线程误删</strong>呢？假设并发多线程场景下，<strong>线程A获得了锁，但是它没释放锁的话，线程B是获取不到锁的</strong>，所以按道理它是执行不到加锁下面的代码滴，怎么会导致锁被别的线程误删呢？</p>
<blockquote>
<p>假设线程A和B，都想用<code>key</code>加锁，最后A抢到锁加锁成功，但是由于执行业务逻辑的耗时很长，超过了设置的超时时间<code>100s</code>。这时候，Redis就自动释放了<code>key</code>锁。这时候线程B就可以加锁成功了，接下啦，它也执行业务逻辑处理。假设碰巧这时候，A执行完自己的业务逻辑，它就去释放锁，但是它就把B的锁给释放了。</p>
</blockquote>
<h3 id="set-ex-px-nx-校验唯一随机值-再删除"><a href="#set-ex-px-nx-校验唯一随机值-再删除" class="headerlink" title="set ex px nx + 校验唯一随机值,再删除"></a>set ex px nx + 校验唯一随机值,再删除</h3><p>为了解决<strong>锁被别的线程误删</strong>问题。可以在<code>set ex px nx</code>的基础上，加上个校验的唯一随机值，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>（jedis.set(key, uni_request_id, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;EX&quot;</span>, 100s) == <span class="number">1</span>）&#123; <span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> something  <span class="comment">//业务处理</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">       <span class="comment">//判断是不是当前线程加的锁,是才释放</span></span><br><span class="line">       <span class="keyword">if</span> (uni_request_id.equals(jedis.get(key))) &#123;</span><br><span class="line">          jedis.del(key); <span class="comment">//释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，判断当前线程加的锁和释放锁<strong>不是一个原子操作</strong>。如果调用<code>jedis.del()</code>释放锁的时候，可能<strong>这把锁已经不属于当前客户端</strong>，会解除他人加的锁。</p>
<p>一般可以用lua脚本来包一下。lua脚本如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;get&#x27;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] then </span><br><span class="line">   <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>,KEYS[<span class="number">1</span>]) </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
<p>这种方式比较不错了，一般情况下，已经可以使用这种实现方式。但是还是存在：<strong>锁过期释放了，业务还没执行完的问题</strong>。</p>
<h3 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h3><p>对于可能存在<strong>锁过期释放，业务没执行完</strong>的问题。我们可以稍微把锁过期时间设置长一些，大于正常业务处理时间就好啦。如果你觉得不是很稳，还可以给获得锁的线程，开启一个定时守护线程，每隔一段时间检查锁是否还存在，存在则对锁的过期时间延长，防止锁过期提前释放。</p>
<p>当前开源框架Redisson解决了这个问题。可以看下Redisson底层原理图：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/14/1048-36291O.png" alt="图片"></p>
<p>只要线程一加锁成功，就会启动一个<code>watch dog</code>看门狗，它是一个后台线程，会每隔10秒检查一下，如果线程1还持有锁，那么就会不断的延长锁key的生存时间。因此，Redisson就是使用<code>watch dog</code>解决了<strong>锁过期释放，业务没执行完问题</strong>。</p>
<h3 id="Redisson-RedLock"><a href="#Redisson-RedLock" class="headerlink" title="Redisson + RedLock"></a>Redisson + RedLock</h3><p>前面六种方案都只是基于<strong>Redis单机版</strong>的分布式锁讨论，还不是很完美。因为<strong>Redis</strong>一般都是集群部署的：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/14/1049-gDgwyU.png" alt="图片"></p>
<p>如果线程一在<code>Redis</code>的<code>master</code>节点上拿到了锁，但是加锁的<code>key</code>还没同步到<code>slave</code>节点。恰好这时，<code>master</code>节点发生故障，一个<code>slave</code>节点就会升级为<code>master</code>节点。线程二就可以顺理成章获取同个<code>key</code>的锁啦，但线程一也已经拿到锁了，锁的安全性就没了。</p>
<p>为了解决这个问题，Redis作者antirez提出一种高级的分布式锁算法：<strong>Redlock</strong>。它的核心思想是这样的：</p>
<blockquote>
<p>部署多个Redis master，以保证它们不会同时宕掉。并且这些master节点是完全相互独立的，相互之间不存在数据同步。同时，需要确保在这多个master实例上，是与在Redis单实例，使用相同方法来获取和释放锁。</p>
</blockquote>
<p>我们假设当前有5个Redis master节点，在5台服务器上面运行这些Redis实例。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/14/1049-Haarab.png" alt="图片">RedLock的实现步骤:</p>
<ol>
<li>获取当前时间，以毫秒为单位。</li>
<li>按顺序向5个master节点请求加锁。客户端设置网络连接和响应超时时间，并且超时时间要小于锁的失效时间。（假设锁自动失效时间为10秒，则超时时间一般在5-50毫秒之间,我们就假设超时时间是50ms吧）。如果超时，跳过该master节点，尽快去尝试下一个master节点。</li>
<li>客户端使用当前时间减去开始获取锁时间（即步骤1记录的时间），得到获取锁使用的时间。当且仅当超过一半（N/2+1，这里是5/2+1=3个节点）的Redis master节点都获得锁，并且使用的时间小于锁失效时间时，锁才算获取成功。（如上图，10s&gt;  30ms+40ms+50ms+4m0s+50ms）</li>
<li>如果取到了锁，key的真正有效时间就变啦，需要减去获取锁所使用的时间。</li>
<li>如果获取锁失败（没有在至少N/2+1个master实例取到锁，有或者获取锁时间已经超过了有效时间），客户端要在所有的master节点上解锁（即便有些master节点根本就没有加锁成功，也需要解锁，以防止有些漏网之鱼）。</li>
</ol>
<p>简化下步骤就是：</p>
<ul>
<li>按顺序向5个master节点请求加锁</li>
<li>根据设置的超时时间来判断，是不是要跳过该master节点。</li>
<li>如果大于等于3个节点加锁成功，并且使用的时间小于锁的有效期，即可认定加锁成功啦。</li>
<li>如果获取锁失败，解锁！</li>
</ul>
<p><strong>Redisson实现了redLock版本的锁</strong>，有兴趣的小伙伴，可以去了解一下哈~</p>
<h2 id="Zookeeper分布式锁"><a href="#Zookeeper分布式锁" class="headerlink" title="Zookeeper分布式锁"></a>Zookeeper分布式锁</h2><p>在学习Zookeeper分布式锁之前，我们复习一下Zookeeper的节点哈。</p>
<p>Zookeeper的节点Znode有四种类型：</p>
<ul>
<li><strong>持久节点</strong>：默认的节点类型。创建节点的客户端与zookeeper断开连接后，该节点依旧存在。</li>
<li><strong>持久节点顺序节点</strong>：所谓顺序节点，就是在创建节点时，Zookeeper根据创建的时间顺序给该节点名称进行编号，持久节点顺序节点就是有顺序的持久节点。</li>
<li><strong>临时节点</strong>：和持久节点相反，当创建节点的客户端与zookeeper断开连接后，临时节点会被删除。</li>
<li><strong>临时顺序节点</strong>：有顺序的临时节点。</li>
</ul>
<p>Zookeeper分布式锁实现应用了<strong>临时顺序节点</strong>。这里不贴代码啦，来讲下zk分布式锁的实现原理吧。</p>
<h3 id="zk获取锁过程"><a href="#zk获取锁过程" class="headerlink" title="zk获取锁过程"></a>zk获取锁过程</h3><p>当第一个客户端请求过来时，Zookeeper客户端会创建一个持久节点<code>locks</code>。如果它（Client1）想获得锁，需要在<code>locks</code>节点下创建一个顺序节点<code>lock1</code>.如图</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/14/1050-2C4s2m.png" alt="图片"></p>
<p>接着，客户端Client1会查找<code>locks</code>下面的所有临时顺序子节点，判断自己的节点<code>lock1</code>是不是排序最小的那一个，如果是，则成功获得锁。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/14/1050-gQdpgQ.png" alt="图片"></p>
<p>这时候如果又来一个客户端client2前来尝试获得锁，它会在locks下再创建一个临时节点<code>lock2</code></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/14/1050-PdvZVL.png" alt="图片"></p>
<p>客户端client2一样也会查找locks下面的所有临时顺序子节点，判断自己的节点lock2是不是最小的，此时，发现lock1才是最小的，于是获取锁失败。获取锁失败，它是不会甘心的，client2向它排序靠前的节点lock1注册Watcher事件，用来监听lock1是否存在，也就是说client2抢锁失败进入等待状态。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/14/1050-LLJtgZ.png" alt="图片"></p>
<p>此时，如果再来一个客户端Client3来尝试获取锁，它会在locks下再创建一个临时节点lock3</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/14/1050-XF3UAP.png" alt="图片">同样的，client3一样也会查找locks下面的所有临时顺序子节点，判断自己的节点lock3是不是最小的，发现自己不是最小的，就获取锁失败。它也是不会甘心的，它会向在它前面的节点lock2注册Watcher事件，以监听lock2节点是否存在。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/14/1050-s2ziYm.png" alt="图片"></p>
<h3 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h3><p>我们再来看看释放锁的流程，Zookeeper的客户端业务完成或者发生故障，都会删除临时节点，释放锁。如果是任务完成，Client1会显式调用删除lock1的指令</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/14/1052-nsRn3o.png" alt="图片"></p>
<p>如果是客户端故障了，根据临时节点得特性，lock1是会自动删除的</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/14/1052-A6pioo.png" alt="图片"></p>
<p>lock1节点被删除后，Client2可开心了，因为它一直监听着lock1。lock1节点删除，Client2立刻收到通知，也会查找locks下面的所有临时顺序子节点，发下lock2是最小，就获得锁。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/14/1052-MUDBMt.png" alt="图片"></p>
<p>同理，Client2获得锁之后，Client3也对它虎视眈眈，啊哈哈~</p>
<ul>
<li>Zookeeper设计定位就是分布式协调，简单易用。如果获取不到锁，只需添加一个监听器即可，很适合做分布式锁。</li>
<li>Zookeeper作为分布式锁也缺点：如果有很多的客户端频繁的申请加锁、释放锁，对于Zookeeper集群的压力会比较大。</li>
</ul>
<h2 id="三种分布式锁对比"><a href="#三种分布式锁对比" class="headerlink" title="三种分布式锁对比"></a>三种分布式锁对比</h2><p><strong>数据库分布式锁实现</strong></p>
<p>优点：</p>
<ul>
<li>简单，使用方便，不需要引入<code>Redis、zookeeper</code>等中间件。</li>
</ul>
<p>缺点：</p>
<ul>
<li>不适合高并发的场景</li>
<li>db操作性能较差；</li>
</ul>
<p><strong>Redis分布式锁实现</strong></p>
<p>优点：</p>
<ul>
<li>性能好，适合高并发场景</li>
<li>较轻量级</li>
<li>有较好的框架支持，如Redisson</li>
</ul>
<p>缺点：</p>
<ul>
<li>过期时间不好控制</li>
<li>需要考虑锁被别的线程误删场景</li>
</ul>
<p><strong>Zookeeper分布式锁实现</strong></p>
<p>缺点：</p>
<ul>
<li>性能不如redis实现的分布式锁</li>
<li>比较重的分布式锁。</li>
</ul>
<p>优点：</p>
<ul>
<li>有较好的性能和可靠性</li>
<li>有封装较好的框架，如Curator</li>
</ul>
<p><strong>对比汇总</strong></p>
<blockquote>
<ul>
<li>从性能角度（从高到低）Redis &gt; Zookeeper &gt;= 数据库；</li>
<li>从理解的难易程度角度（从低到高）数据库 &gt; Redis &gt; Zookeeper；</li>
<li>从实现的复杂性角度（从低到高）Zookeeper &gt; Redis &gt; 数据库；</li>
<li>从可靠性角度（从高到低）Zookeeper &gt; Redis &gt; 数据库。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>sql</tag>
        <tag>事务</tag>
        <tag>数据库</tag>
        <tag>锁</tag>
        <tag>分布式</tag>
        <tag>Redis</tag>
        <tag>并发</tag>
        <tag>算法</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Sentinel 万字教程</title>
    <url>/posts/2XZ2VHA.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>原文：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvM2NDUDFKWUJWUHVBSU9SSzBwQlpaUQ==">Sentinel 万字教程<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>限流作为现在微服务中常见的稳定性措施，在面试中肯定也是经常会被问到的，我在面试的时候也经常喜欢问一下你对限流算法知道哪一些？有看过源码吗？实现原理是什么？</p>
<p>第一部分先讲讲限流算法，最后再讲讲源码的实现原理。</p>
<h1 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h1><p>关于限流的算法大体上可以分为四类：固定窗口计数器、滑动窗口计数器、漏桶(也有称漏斗，英文Leaky bucket)、令牌桶(英文Token bucket)。</p>
<h2 id="固定窗口"><a href="#固定窗口" class="headerlink" title="固定窗口"></a>固定窗口</h2><p>固定窗口，相比其他的限流算法，这应该是最简单的一种。</p>
<p>它简单地对一个固定的时间窗口内的请求数量进行计数，如果超过请求数量的阈值，将被直接丢弃。</p>
<p>这个简单的限流算法优缺点都很明显。优点的话就是简单，缺点举个例子来说。</p>
<p>比如我们下图中的黄色区域就是固定时间窗口，默认时间范围是60s，限流数量是100。</p>
<p>如图中括号内所示，前面一段时间都没有流量，刚好后面30秒内来了100个请求，此时因为没有超过限流阈值，所以请求全部通过，然后下一个窗口的20秒内同样通过了100个请求。</p>
<p>所以变相的相当于在这个括号的40秒的时间内就通过了200个请求，超过了我们限流的阈值。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/15/1020-ePDnVA.jpeg" alt="图片"></p>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>为了优化这个问题，于是有了滑动窗口算法，顾名思义，滑动窗口就是时间窗口在随着时间推移不停地移动。</p>
<p>滑动窗口把一个固定时间窗口再继续拆分成N个小窗口，然后对每个小窗口分别进行计数，所有小窗口请求之和不能超过我们设定的限流阈值。</p>
<p>以下图举例子来说，假设我们的窗口拆分成了3个小窗口，小窗口都是20s，同样基于上面的例子，当在第三个20s的时候来了100个请求，可以通过。</p>
<p>然后时间窗口滑动，下一个20s请求又来了100个请求，此时我们滑动窗口的60s范围内请求数量肯定就超过100了啊，所以请求被拒绝。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/15/1020-CGNSUR.jpeg" alt="图片"></p>
<h2 id="漏桶Leaky-bucket"><a href="#漏桶Leaky-bucket" class="headerlink" title="漏桶Leaky bucket"></a>漏桶Leaky bucket</h2><p>漏桶算法，人如其名，他就是一个漏的桶，不管请求的数量有多少，最终都会以固定的出口流量大小匀速流出，如果请求的流量超过漏桶大小，那么超出的流量将会被丢弃。</p>
<p>也就是说流量流入的速度是不定的，但是流出的速度是恒定的。</p>
<p>这个和MQ削峰填谷的思想比较类似，在面对突然激增的流量的时候，通过漏桶算法可以做到匀速排队，固定速度限流。</p>
<p>漏桶算法的优势是匀速，匀速是优点也是缺点，很多人说漏桶不能处理突增流量，这个说法并不准确。</p>
<p>漏桶本来就应该是为了处理间歇性的突增流量，流量一下起来了，然后系统处理不过来，可以在空闲的时候去处理，防止了突增流量导致系统崩溃，保护了系统的稳定性。</p>
<p>但是，换一个思路来想，其实这些突增的流量对于系统来说完全没有压力，你还在慢慢地匀速排队，其实是对系统性能的浪费。</p>
<p>所以，对于这种有场景来说，令牌桶算法比漏桶就更有优势。</p>
<h2 id="令牌桶token-bucket"><a href="#令牌桶token-bucket" class="headerlink" title="令牌桶token bucket"></a>令牌桶token bucket</h2><p>令牌桶算法是指系统以一定地速度往令牌桶里丢令牌，当一个请求过来的时候，会去令牌桶里申请一个令牌，如果能够获取到令牌，那么请求就可以正常进行，反之被丢弃。</p>
<p>现在的令牌桶算法，像Guava和Sentinel的实现都有冷启动/预热的方式，为了避免在流量激增的同时把系统打挂，令牌桶算法会在最开始一段时间内<strong>冷启动</strong>，随着流量的增加，系统会根据流量大小动态地调整生成令牌的速度，最终直到请求达到系统的阈值。</p>
<h1 id="源码举例"><a href="#源码举例" class="headerlink" title="源码举例"></a>源码举例</h1><p>我们以sentinel举例，sentinel中统计用到了滑动窗口算法，然后也有用到漏桶、令牌桶算法。</p>
<h2 id="滑动窗口-1"><a href="#滑动窗口-1" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p><code>sentinel</code>中就使用到了滑动窗口算法来进行统计，不过他的实现和我上面画的图有点不一样，实际上sentinel中的滑动窗口用一个圆形来描述更合理一点。</p>
<p>前期就是创建节点，然后slot串起来就是一个责任链模式，StatisticSlot通过滑动窗口来统计数据，FlowSlot是真正限流的逻辑，还有一些降级、系统保护的措施，最终形成了整个sentinel的限流方式。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/15/1022-Wi0ok6.jpeg" alt="图片">就看看官方图吧，这圆形画起来好恶心</p>
<p>滑动窗口的实现主要可以看<code>LeapArray</code>的代码，默认的话定义了时间窗口的相关参数。</p>
<p>对于sentinel来说其实窗口分为<strong>秒</strong>和<strong>分钟</strong>两个级别，秒的话窗口数量是2，分钟则是60个窗口，每个窗口的时间长度是1s，总的时间周期就是60s，分成60个窗口，这里我们就以分钟级别的统计来说。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LeapArray</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//窗口时间长度，毫秒数，默认1000ms</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> windowLengthInMs;</span><br><span class="line">    <span class="comment">//窗口数量，默认60</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> sampleCount;</span><br><span class="line">    <span class="comment">//毫秒时间周期，默认60*1000</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> intervalInMs;</span><br><span class="line">    <span class="comment">//秒级时间周期，默认60</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> intervalInSecond;</span><br><span class="line">    <span class="comment">//时间窗口数组</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> AtomicReferenceArray&lt;WindowWrap&lt;T&gt;&gt; array;</span><br></pre></td></tr></table></figure>
<p>然后我们要看的就是它是怎么计算出当前窗口的，其实源码里写的听清楚的，但是如果你按照之前想象把他当做一条直线延伸去想的话估计不太好理解。</p>
<p>首先计算数组索引下标和时间窗口时间这个都比较简单，难点应该大部分在于第三点窗口大于old这个是什么鬼，详细说下这几种情况。</p>
<ol>
<li>数组中的时间窗口是是空的，这个说明时间走到了我们初始化的时间之后了，此时new一个新的窗口通过CAS的方式去更新，然后返回这个新的窗口就好了。</li>
<li>第二种情况是刚好时间窗口的时间相等，那么直接返回，没啥好说的</li>
<li>第三种情况就是比较难以理解的，可以参看两条时间线的图，就比较好理解了，第一次时间窗口走完了达到1200，然后圆形时间窗口开始循环，新的时间起始位置还是1200，然后时间窗口的时间来到1676，B2的位置如果还是老的窗口那么就是600，所以我们要重置之前的时间窗口的时间为当前的时间。</li>
<li>最后一种一般情况不太可能发生，除非时钟回拨这样子</li>
</ol>
<p>从这个我们可以发现就是针对每个<code>WindowWrap</code>时间窗口都进行了统计，最后实际上在后面的几个地方都会用到时间窗口统计的QPS结果，这里就不再赘述了，知道即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">calculateTimeIdx</span><span class="params">(<span class="comment">/*@Valid*/</span> <span class="keyword">long</span> timeMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> timeId = timeMillis / windowLengthInMs;</span><br><span class="line">    <span class="comment">// Calculate current index so we can map the timestamp to the leap array.</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) (timeId % array.length());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">calculateWindowStart</span><span class="params">(<span class="comment">/*@Valid*/</span> <span class="keyword">long</span> timeMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> timeMillis - timeMillis % windowLengthInMs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> WindowWrap&lt;T&gt; <span class="title">currentWindow</span><span class="params">(<span class="keyword">long</span> timeMillis)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当前时间如果小于0，返回空</span></span><br><span class="line">    <span class="keyword">if</span> (timeMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算时间窗口的索引</span></span><br><span class="line">    <span class="keyword">int</span> idx = calculateTimeIdx(timeMillis);</span><br><span class="line">    <span class="comment">// 计算当前时间窗口的开始时间</span></span><br><span class="line">    <span class="keyword">long</span> windowStart = calculateWindowStart(timeMillis);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">//在窗口数组中获得窗口</span></span><br><span class="line">        WindowWrap&lt;T&gt; old = array.get(idx);</span><br><span class="line">        <span class="keyword">if</span> (old == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *     B0       B1      B2    NULL      B4</span></span><br><span class="line"><span class="comment">             * ||_______|_______|_______|_______|_______||___</span></span><br><span class="line"><span class="comment">             * 200     400     600     800     1000    1200  timestamp</span></span><br><span class="line"><span class="comment">             *                             ^</span></span><br><span class="line"><span class="comment">             *                          time=888</span></span><br><span class="line"><span class="comment">             * 比如当前时间是888，根据计算得到的数组窗口位置是个空，所以直接创建一个新窗口就好了</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            WindowWrap&lt;T&gt; window = <span class="keyword">new</span> WindowWrap&lt;T&gt;(windowLengthInMs, windowStart, newEmptyBucket(timeMillis));</span><br><span class="line">            <span class="keyword">if</span> (array.compareAndSet(idx, <span class="keyword">null</span>, window)) &#123;</span><br><span class="line">                <span class="comment">// Successfully updated, return the created bucket.</span></span><br><span class="line">                <span class="keyword">return</span> window;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Contention failed, the thread will yield its time slice to wait for bucket available.</span></span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (windowStart == old.windowStart()) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *     B0       B1      B2     B3      B4</span></span><br><span class="line"><span class="comment">             * ||_______|_______|_______|_______|_______||___</span></span><br><span class="line"><span class="comment">             * 200     400     600     800     1000    1200  timestamp</span></span><br><span class="line"><span class="comment">             *                             ^</span></span><br><span class="line"><span class="comment">             *                          time=888</span></span><br><span class="line"><span class="comment">             * 这个更好了，刚好等于，直接返回就行</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (windowStart &gt; old.windowStart()) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *     B0       B1      B2     B3      B4</span></span><br><span class="line"><span class="comment">             * |_______|_______|_______|_______|_______||___</span></span><br><span class="line"><span class="comment">             * 200     400     600     800     1000    1200  timestamp</span></span><br><span class="line"><span class="comment">             *             B0       B1      B2    NULL      B4</span></span><br><span class="line"><span class="comment">             * |_______||_______|_______|_______|_______|_______||___</span></span><br><span class="line"><span class="comment">             * ...    1200     1400    1600    1800    2000    2200  timestamp</span></span><br><span class="line"><span class="comment">             *                              ^</span></span><br><span class="line"><span class="comment">             *                           time=1676</span></span><br><span class="line"><span class="comment">             * 这个要当成圆形理解就好了，之前如果是1200一个完整的圆形，然后继续从1200开始，如果现在时间是1676，落在在B2的位置，</span></span><br><span class="line"><span class="comment">             * 窗口开始时间是1600，获取到的old时间其实会是600，所以肯定是过期了，直接重置窗口就可以了</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (updateLock.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Successfully get the update lock, now we reset the bucket.</span></span><br><span class="line">                    <span class="keyword">return</span> resetWindowTo(old, windowStart);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    updateLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (windowStart &lt; old.windowStart()) &#123;</span><br><span class="line">            <span class="comment">// 这个不太可能出现，嗯。。时钟回拨</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> WindowWrap&lt;T&gt;(windowLengthInMs, windowStart, newEmptyBucket(timeMillis));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="漏桶"><a href="#漏桶" class="headerlink" title="漏桶"></a>漏桶</h2><p>sentinel主要根据<code>FlowSlot</code>中的流控进行流量控制，其中<code>RateLimiterController</code>就是漏桶算法的实现，这个实现相比其他几个还是简单多了，稍微看一下应该就明白了。</p>
<ol>
<li>首先计算出当前请求平摊到1s内的时间花费，然后去计算这一次请求预计时间</li>
<li>如果小于当前时间的话，那么以当前时间为主，返回即可</li>
<li>反之如果超过当前时间的话，这时候就要进行排队等待了，等待的时候要判断是否超过当前最大的等待时间，超过就直接丢弃</li>
<li>没有超过就更新上一次的通过时间，然后再比较一次是否超时，还超时就重置时间，反之在等待时间范围之内的话就等待，如果都不是那就可以通过了</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimiterController</span> <span class="keyword">implements</span> <span class="title">TrafficShapingController</span> </span>&#123;</span><br><span class="line">  <span class="comment">//最大等待超时时间，默认500ms</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxQueueingTimeMs;</span><br><span class="line">  <span class="comment">//限流数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> count;</span><br><span class="line">  <span class="comment">//上一次的通过时间</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong latestPassedTime = <span class="keyword">new</span> AtomicLong(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPass</span><span class="params">(Node node, <span class="keyword">int</span> acquireCount, <span class="keyword">boolean</span> prioritized)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Pass when acquire count is less or equal than 0.</span></span><br><span class="line">      <span class="keyword">if</span> (acquireCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Reject when count is less or equal than 0.</span></span><br><span class="line">      <span class="comment">// Otherwise,the costTime will be max of long and waitTime will overflow in some cases.</span></span><br><span class="line">      <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">long</span> currentTime = TimeUtil.currentTimeMillis();</span><br><span class="line">      <span class="comment">//时间平摊到1s内的花费</span></span><br><span class="line">      <span class="keyword">long</span> costTime = Math.round(<span class="number">1.0</span> * (acquireCount) / count * <span class="number">1000</span>); <span class="comment">// 1 / 100 * 1000 = 10ms</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//计算这一次请求预计的时间</span></span><br><span class="line">      <span class="keyword">long</span> expectedTime = costTime + latestPassedTime.get();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//花费时间小于当前时间，pass，最后通过时间 = 当前时间</span></span><br><span class="line">      <span class="keyword">if</span> (expectedTime &lt;= currentTime) &#123;</span><br><span class="line">          latestPassedTime.set(currentTime);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//预计通过的时间超过当前时间，要进行排队等待，重新获取一下，避免出现问题，差额就是需要等待的时间</span></span><br><span class="line">          <span class="keyword">long</span> waitTime = costTime + latestPassedTime.get() - TimeUtil.currentTimeMillis();</span><br><span class="line">          <span class="comment">//等待时间超过最大等待时间，丢弃</span></span><br><span class="line">          <span class="keyword">if</span> (waitTime &gt; maxQueueingTimeMs) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//反之，可以更新最后一次通过时间了</span></span><br><span class="line">              <span class="keyword">long</span> oldTime = latestPassedTime.addAndGet(costTime);</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  waitTime = oldTime - TimeUtil.currentTimeMillis();</span><br><span class="line">                  <span class="comment">//更新后再判断，还是超过最大超时时间，那么就丢弃，时间重置</span></span><br><span class="line">                  <span class="keyword">if</span> (waitTime &gt; maxQueueingTimeMs) &#123;</span><br><span class="line">                      latestPassedTime.addAndGet(-costTime);</span><br><span class="line">                      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">//在时间范围之内的话，就等待</span></span><br><span class="line">                  <span class="keyword">if</span> (waitTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                      Thread.sleep(waitTime);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="令牌桶"><a href="#令牌桶" class="headerlink" title="令牌桶"></a>令牌桶</h2><p>最后是令牌桶，这个不在于实现的复制，而是你看源码会发现都算的些啥玩意儿。。。sentinel的令牌桶实现基于Guava，代码在<code>WarmUpController</code>中。</p>
<p>这个算法那些各种计算逻辑其实我们可以不管（因为我也没看懂。。），但是流程上我们是清晰的就可以了。</p>
<p>几个核心的参数看注释，构造方法里那些计算逻辑暂时不管他是怎么算的（我也没整明白，但是不影响我们理解），关键看<code>canPass</code>是怎么做的。</p>
<ol>
<li>拿到当前窗口和上一个窗口的QPS</li>
<li>填充令牌，也就是往桶里丢令牌，然后我们先看填充令牌的逻辑</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WarmUpController</span> <span class="keyword">implements</span> <span class="title">TrafficShapingController</span> </span>&#123;</span><br><span class="line">    <span class="comment">//限流QPS</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">double</span> count;</span><br><span class="line">    <span class="comment">//冷启动系数，默认=3</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> coldFactor;</span><br><span class="line">    <span class="comment">//警戒的令牌数</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> warningToken = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//最大令牌数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxToken;</span><br><span class="line">    <span class="comment">//斜率，产生令牌的速度</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">double</span> slope;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储的令牌数量</span></span><br><span class="line">    <span class="keyword">protected</span> AtomicLong storedTokens = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//最后一次填充令牌时间</span></span><br><span class="line">    <span class="keyword">protected</span> AtomicLong lastFilledTime = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WarmUpController</span><span class="params">(<span class="keyword">double</span> count, <span class="keyword">int</span> warmUpPeriodInSec, <span class="keyword">int</span> coldFactor)</span> </span>&#123;</span><br><span class="line">        construct(count, warmUpPeriodInSec, coldFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WarmUpController</span><span class="params">(<span class="keyword">double</span> count, <span class="keyword">int</span> warmUpPeriodInSec)</span> </span>&#123;</span><br><span class="line">        construct(count, warmUpPeriodInSec, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">(<span class="keyword">double</span> count, <span class="keyword">int</span> warmUpPeriodInSec, <span class="keyword">int</span> coldFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (coldFactor &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Cold factor should be larger than 1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">        <span class="keyword">this</span>.coldFactor = coldFactor;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//stableInterval 稳定产生令牌的时间周期，1/QPS</span></span><br><span class="line">        <span class="comment">//warmUpPeriodInSec 预热/冷启动时间 ,默认 10s</span></span><br><span class="line">        warningToken = (<span class="keyword">int</span>)(warmUpPeriodInSec * count) / (coldFactor - <span class="number">1</span>);</span><br><span class="line">        maxToken = warningToken + (<span class="keyword">int</span>)(<span class="number">2</span> * warmUpPeriodInSec * count / (<span class="number">1.0</span> + coldFactor));</span><br><span class="line">    <span class="comment">//斜率的计算参考Guava，当做一个固定改的公式</span></span><br><span class="line">        slope = (coldFactor - <span class="number">1.0</span>) / count / (maxToken - warningToken);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPass</span><span class="params">(Node node, <span class="keyword">int</span> acquireCount, <span class="keyword">boolean</span> prioritized)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当前时间窗口通过的QPS</span></span><br><span class="line">        <span class="keyword">long</span> passQps = (<span class="keyword">long</span>) node.passQps();</span><br><span class="line">        <span class="comment">//上一个时间窗口QPS</span></span><br><span class="line">        <span class="keyword">long</span> previousQps = (<span class="keyword">long</span>) node.previousPassQps();</span><br><span class="line">        <span class="comment">//填充令牌</span></span><br><span class="line">        syncToken(previousQps);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始计算它的斜率</span></span><br><span class="line">        <span class="comment">// 如果进入了警戒线，开始调整他的qps</span></span><br><span class="line">        <span class="keyword">long</span> restToken = storedTokens.get();</span><br><span class="line">        <span class="keyword">if</span> (restToken &gt;= warningToken) &#123;</span><br><span class="line">            <span class="comment">//当前的令牌超过警戒线，获得超过警戒线的令牌数</span></span><br><span class="line">            <span class="keyword">long</span> aboveToken = restToken - warningToken;</span><br><span class="line">            <span class="comment">// 消耗的速度要比warning快，但是要比慢</span></span><br><span class="line">            <span class="comment">// current interval = restToken*slope+1/count</span></span><br><span class="line">            <span class="keyword">double</span> warningQps = Math.nextUp(<span class="number">1.0</span> / (aboveToken * slope + <span class="number">1.0</span> / count));</span><br><span class="line">            <span class="keyword">if</span> (passQps + acquireCount &lt;= warningQps) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (passQps + acquireCount &lt;= count) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>填充令牌的逻辑如下：</p>
<ol>
<li>拿到当前的时间，然后去掉毫秒数，得到的就是秒级时间</li>
<li>判断时间小于这里就是为了控制每秒丢一次令牌</li>
<li>然后就是<code>coolDownTokens</code>去计算我们的冷启动/预热是怎么计算填充令牌的</li>
<li>后面计算当前剩下的令牌数这个就不说了，减去上一次消耗的就是桶里剩下的令牌</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">syncToken</span><span class="params">(<span class="keyword">long</span> passQps)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> currentTime = TimeUtil.currentTimeMillis();</span><br><span class="line">  <span class="comment">//去掉当前时间的毫秒</span></span><br><span class="line">  currentTime = currentTime - currentTime % <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">long</span> oldLastFillTime = lastFilledTime.get();</span><br><span class="line">  <span class="comment">//控制每秒填充一次令牌</span></span><br><span class="line">  <span class="keyword">if</span> (currentTime &lt;= oldLastFillTime) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//当前的令牌数量</span></span><br><span class="line">  <span class="keyword">long</span> oldValue = storedTokens.get();</span><br><span class="line">  <span class="comment">//获取新的令牌数量，包含添加令牌的逻辑，这就是预热的逻辑</span></span><br><span class="line">  <span class="keyword">long</span> newValue = coolDownTokens(currentTime, passQps);</span><br><span class="line">  <span class="keyword">if</span> (storedTokens.compareAndSet(oldValue, newValue)) &#123;</span><br><span class="line">    <span class="comment">//存储的令牌数量当然要减去上一次消耗的令牌</span></span><br><span class="line">    <span class="keyword">long</span> currentValue = storedTokens.addAndGet(<span class="number">0</span> - passQps);</span><br><span class="line">    <span class="keyword">if</span> (currentValue &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      storedTokens.set(<span class="number">0L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    lastFilledTime.set(currentTime);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>最开始的事实因为<code>lastFilledTime</code>和<code>oldValue</code>都是0，所以根据当前时间戳会得到一个非常大的数字，最后和<code>maxToken</code>取小的话就得到了最大的令牌数，所以第一次初始化的时候就会生成<code>maxToken</code>的令牌</li>
<li>之后我们假设系统的QPS一开始很低，然后突然飙高。所以开始的时候回一直走到高于警戒线的逻辑里去，然后<code>passQps</code>又很低，所以会一直处于把令牌桶填满的状态（<code>currentTime - lastFilledTime.get()</code>会一直都是1000，也就是1秒），所以每次都会填充最大QPS<code>count</code>数量的令牌</li>
<li>然后突增流量来了，QPS瞬间很高，慢慢地令牌数量就会消耗到警戒线之下，走到我们<code>if</code>的逻辑里去，然后去按照<code>count</code>数量增加令牌</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">coolDownTokens</span><span class="params">(<span class="keyword">long</span> currentTime, <span class="keyword">long</span> passQps)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> oldValue = storedTokens.get();</span><br><span class="line">  <span class="keyword">long</span> newValue = oldValue;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//水位低于警戒线，就生成令牌</span></span><br><span class="line">  <span class="keyword">if</span> (oldValue &lt; warningToken) &#123;</span><br><span class="line">    <span class="comment">//如果桶中令牌低于警戒线，根据上一次的时间差，得到新的令牌数，因为去掉了毫秒，1秒生成的令牌就是阈值count</span></span><br><span class="line">    <span class="comment">//第一次都是0的话，会生成count数量的令牌</span></span><br><span class="line">    newValue = (<span class="keyword">long</span>)(oldValue + (currentTime - lastFilledTime.get()) * count / <span class="number">1000</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldValue &gt; warningToken) &#123;</span><br><span class="line">    <span class="comment">//反之，如果是高于警戒线，要判断QPS。因为QPS越高，生成令牌就要越慢，QPS低的话生成令牌要越快</span></span><br><span class="line">    <span class="keyword">if</span> (passQps &lt; (<span class="keyword">int</span>)count / coldFactor) &#123;</span><br><span class="line">      newValue = (<span class="keyword">long</span>)(oldValue + (currentTime - lastFilledTime.get()) * count / <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//不要超过最大令牌数</span></span><br><span class="line">  <span class="keyword">return</span> Math.min(newValue, maxToken);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的逻辑理顺之后，我们就可以继续看限流的部分逻辑：</p>
<ol>
<li>令牌计算的逻辑完成，然后判断是不是超过警戒线，按照上面的说法，低QPS的状态肯定是一直超过的，所以会根据斜率来计算出一个<code>warningQps</code>，因为我们处于冷启动的状态，所以这个阶段就是要根据斜率来计算出一个QPS数量，让流量慢慢地达到系统能承受的峰值。举个例子，如果<code>count</code>是100，那么在QPS很低的情况下，令牌桶一直处于满状态，但是系统会控制QPS，实际通过的QPS就是<code>warningQps</code>，根据算法可能只有10或者20（怎么算的不影响理解）。QPS主键提高的时候，<code>aboveToken</code>再逐渐变小，整个<code>warningQps</code>就在逐渐变大，直到走到警戒线之下，到了<code>else</code>逻辑里。</li>
<li>流量突增的情况，就是<code>else</code>逻辑里低于警戒线的情况，我们令牌桶在不停地根据<code>count</code>去增加令牌，这时候消耗令牌的速度超过我们生成令牌的速度，可能就会导致一直处于警戒线之下，这时候判断当然就需要根据最高QPS去判断限流了。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> restToken = storedTokens.get();</span><br><span class="line"><span class="keyword">if</span> (restToken &gt;= warningToken) &#123;</span><br><span class="line"> <span class="comment">//当前的令牌超过警戒线，获得超过警戒线的令牌数</span></span><br><span class="line"> <span class="keyword">long</span> aboveToken = restToken - warningToken;</span><br><span class="line"> <span class="comment">// 消耗的速度要比warning快，但是要比慢</span></span><br><span class="line"> <span class="comment">// current interval = restToken*slope+1/count</span></span><br><span class="line"> <span class="keyword">double</span> warningQps = Math.nextUp(<span class="number">1.0</span> / (aboveToken * slope + <span class="number">1.0</span> / count));</span><br><span class="line"> <span class="keyword">if</span> (passQps + acquireCount &lt;= warningQps) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (passQps + acquireCount &lt;= count) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，按照低QPS到突增高QPS的流程，来想象一下这个过程：</p>
<ol>
<li>刚开始，系统的QPS非常低，初始化我们就直接把令牌桶塞满了</li>
<li>然后这个低QPS的状态持续了一段时间，因为我们一直会填充最大QPS数量的令牌（因为取最小值，所以其实桶里令牌基本不会有变化），所以令牌桶一直处于满的状态，整个系统的限流也处于一个比较低的水平</li>
</ol>
<blockquote>
<p>这以上的部分一直处于警戒线之上，实际上就是叫做冷启动/预热的过程。</p>
</blockquote>
<ol>
<li><p>接着系统的QPS突然激增，令牌消耗速度太快，就算我们每次增加最大QPS数量的令牌任然无法维持消耗，所以桶里的令牌在不断低减少，这个时候，冷启动阶段的限制QPS也在不断地提高，最后直到桶里的令牌低于警戒线</p>
</li>
<li><p>低于警戒线之后，系统就会按照最高QPS去限流，这个过程就是系统在逐渐达到最高限流的过程</p>
</li>
</ol>
<blockquote>
<p>那这样一来，实际就达到了我们处理突增流量的目的，整个系统在漫漫地适应突然飙高的QPS，然后最终达到系统的QPS阈值。</p>
</blockquote>
<ol>
<li>最后，如果QPS回复正常，那么又会逐渐回到警戒线之上，就回到了最开始的过程。</li>
</ol>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/15/1023-CBruaZ.jpeg" alt="图片"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>因为算法如果单独说的话都比较简单，一说大家都可以听明白，不需要几个字就能说明白，所以还是得弄点源码看看别人是怎么玩的，所以尽管我很讨厌放源码，但是还是不得不干。</p>
<p>光靠别人说一点其实有点看不明白，按照顺序读一遍的话心里就有数了。</p>
<p>那源码的话最难以理解的就是令牌桶的实现了，说实话那几个计算的逻辑我看了好几遍不知道他算的什么鬼，但是思想我们理解就行了，其他的逻辑相对来说就比较容易理解。</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>GC</tag>
        <tag>const</tag>
        <tag>数组</tag>
        <tag>面试</tag>
        <tag>索引</tag>
        <tag>MQ</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Seata 实现 TCC模式 解决分布式事务</title>
    <url>/posts/322ZD04.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>原文：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvT3lJUlBOZDJiSlpsY2luOVZGTzlodw==">实战！阿里神器 Seata 实现 TCC模式 解决分布式事务，真香！<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>今天这篇文章介绍一下<strong>Seata</strong>如何实现<strong>TCC</strong>事务模式，文章目录如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/26/0915-EURuCQ.png" alt="图片"></p>
<h2 id="什么是TCC模式？"><a href="#什么是TCC模式？" class="headerlink" title="什么是TCC模式？"></a>什么是TCC模式？</h2><p>TCC（Try Confirm Cancel）方案是一种应用层面侵入业务的两阶段提交。是目前最火的一种柔性事务方案，其核心思想是：<strong>针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作</strong>。</p>
<p>TCC分为两个阶段，分别如下：</p>
<ul>
<li><p><strong>第一阶段</strong>：Try（尝试），主要是对业务系统做检测及资源预留 <strong>(加锁，锁住资源)</strong></p>
</li>
<li><p><strong>第二阶段</strong>：本阶段根据第一阶段的结果，决定是执行<strong>confirm</strong>还是<strong>cancel</strong></p>
</li>
<li><ol>
<li><strong>Confirm</strong>（确认）：执行真正的业务（执行业务，释放锁）</li>
<li><strong>Cancle</strong>（取消）：是预留资源的取消（出问题，释放锁）</li>
</ol>
</li>
</ul>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/26/0916-zBPU2C.png" alt="图片"></p>
<p>TCC</p>
<p>为了方便理解，下面以电商下单为例进行方案解析，这里把整个过程简单分为扣减库存，订单创建 2 个步骤，库存服务和订单服务分别在不同的服务器节点上。</p>
<p>假设商品库存为 100，购买数量为 2，这里检查和更新库存的同时，冻结用户购买数量的库存，同时创建订单，订单状态为待确认。</p>
<h3 id="Try-阶段"><a href="#Try-阶段" class="headerlink" title="Try 阶段"></a>Try 阶段</h3><p>TCC 机制中的 Try 仅是一个初步操作，它和后续的确认一起才能真正构成一个完整的业务逻辑，这个阶段主要完成：</p>
<ul>
<li>完成所有业务检查( 一致性 ) 。</li>
<li>预留必须业务资源( 准隔离性 ) 。</li>
<li>Try 尝试执行业务。</li>
</ul>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/26/0916-avifY6.png" alt="图片"></p>
<h3 id="Confirm-Cancel-阶段"><a href="#Confirm-Cancel-阶段" class="headerlink" title="Confirm / Cancel 阶段"></a>Confirm / Cancel 阶段</h3><p>根据 <strong>Try</strong> 阶段服务是否全部正常执行，继续执行确认操作（Confirm）或取消操作（Cancel）。</p>
<p>Confirm 和 Cancel 操作满足幂等性，如果 Confirm 或 Cancel 操作执行失败，将会不断重试直到执行完成。</p>
<p>Confirm：当 Try 阶段服务全部正常执行， 执行确认业务逻辑操作，业务如下图：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/26/0917-JNgWvp.png" alt="图片">Try-&gt;Confirm</p>
<p>这里使用的资源一定是 Try 阶段预留的业务资源。在 TCC 事务机制中认为，如果在 Try 阶段能正常的预留资源，那 Confirm 一定能完整正确的提交。</p>
<p>Confirm 阶段也可以看成是对 Try 阶段的一个补充，Try+Confirm 一起组成了一个完整的业务逻辑。</p>
<p>Cancel：当 Try 阶段存在服务执行失败， 进入 Cancel 阶段，业务如下图：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/26/0917-oWUAom.png" alt="图片"></p>
<p>Try-Cancel</p>
<p>Cancel 取消执行，释放 Try 阶段预留的业务资源，上面的例子中，Cancel 操作会把冻结的库存释放，并更新订单状态为取消。</p>
<p>以上便是TCC模式的全部概念，这部分内容在陈某之前的文章也是详细的介绍过：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpVM01EQXpORGcxTUE9PSZhbXA7bWlkPTIyNDc0OTk0MjEmYW1wO2lkeD0xJmFtcDtzbj1hNTU3OTc2NTIyODRiYWZkOTIxNmVhOTgxZjQxMjVlMCZhbXA7c2NlbmU9MjEjd2VjaGF0X3JlZGlyZWN0">对比7种分布式事务方案，还是偏爱阿里开源的Seata，真香！(原理+实战)<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="TCC模式的三种类型？"><a href="#TCC模式的三种类型？" class="headerlink" title="TCC模式的三种类型？"></a>TCC模式的三种类型？</h2><p>业内实际生产中对TCC模式进行了扩展，总结出了如下三种类型，其实从官方的定义中无此说法，不过是企业生产中根据实际的需求衍生出来的三种方案。</p>
<h3 id="1、通用型-TCC-解决方案"><a href="#1、通用型-TCC-解决方案" class="headerlink" title="1、通用型 TCC 解决方案"></a>1、通用型 TCC 解决方案</h3><p>通用型TCC解决方案是最经典的TCC事务模型的实现，正如第一节介绍的模型，所有的从业务都参与到主业务的决策中。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/26/0917-B2G1cU.png" alt="图片">通用型TCC</p>
<p><strong>适用场景</strong>：</p>
<p>由于从业务服务是同步调用，其结果会影响到主业务服务的决策，因此通用型 TCC 分布式事务解决方案<strong>适用于执行时间确定且较短的业务</strong>，比如电商系统的三个核心服务：订单服务、账户服务、库存服务。</p>
<p>这个三个服务要么同时成功，要么同时失败。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/26/0918-QX5SLr.png" alt="图片"></p>
<p>当库存服务、账户服务的第二阶段调用完成后，整个分布式事务完成。</p>
<h3 id="2、异步确保型-TCC-解决方案"><a href="#2、异步确保型-TCC-解决方案" class="headerlink" title="2、异步确保型 TCC 解决方案"></a>2、异步确保型 TCC 解决方案</h3><p>异步确保型 TCC 解决方案的直接从业务服务是可靠消息服务，而真正的从业务服务则通过消息服务解耦，作为消息服务的消费端，异步地执行。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/26/0918-zFDeH7.png" alt="图片"></p>
<p>异步确保型</p>
<p>可靠消息服务需要提供 Try，Confirm，Cancel 三个接口。Try 接口预发送，只负责持久化存储消息数据；Confirm 接口确认发送，这时才开始真正的投递消息；Cancel 接口取消发送，删除消息数据。</p>
<p>消息服务的消息数据独立存储，独立伸缩，降低从业务服务与消息系统间的耦合，在消息服务可靠的前提下，实现分布式事务的最终一致性。</p>
<p>此解决方案虽然增加了消息服务的维护成本，但由于消息服务代替从业务服务实现了 TCC 接口，从业务服务不需要任何改造，接入成本非常低。</p>
<p><strong>适用场景：</strong></p>
<p>由于从业务服务消费消息是一个异步的过程，执行时间不确定，可能会导致不一致时间窗口增加。因此，异步确保性 TCC  分布式事务解决方案只适用于对最终一致性时间敏感度较低的一些被动型业务（从业务服务的处理结果不影响主业务服务的决策，只被动的接收主业务服务的决策结果）。比如会员注册服务和邮件发送服务：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/26/0918-5NmlWj.png" alt="图片"></p>
<h3 id="3、补偿型-TCC-解决方案"><a href="#3、补偿型-TCC-解决方案" class="headerlink" title="3、补偿型 TCC 解决方案"></a>3、补偿型 TCC 解决方案</h3><p>补偿型 TCC 解决方案与通用型 TCC 解决方案的结构相似，其从业务服务也需要参与到主业务服务的活动决策当中。但不一样的是，前者的从业务服务只需要提供 Do 和 Compensate 两个接口，而后者需要提供三个接口。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/26/0918-rCOxMX.png" alt="图片"></p>
<p>Do 接口直接执行真正的完整业务逻辑，完成业务处理，业务执行结果外部可见；Compensate 操作用于业务补偿，抵消或部分抵消正向业务操作的业务结果，Compensate操作需满足幂等性。</p>
<p>与通用型解决方案相比，补偿型解决方案的从业务服务不需要改造原有业务逻辑，只需要额外增加一个补偿回滚逻辑即可，业务改造量较小。但要注意的是，业务在一阶段就执行完整个业务逻辑，无法做到有效的事务隔离，当需要回滚时，可能存在补偿失败的情况，还需要额外的异常处理机制，比如人工介入。</p>
<p><strong>适用场景</strong>：</p>
<p>由于存在回滚补偿失败的情况，补偿型 TCC 分布式事务解决方案只适用于一些并发冲突较少或者需要与外部交互的业务，这些外部业务不属于被动型业务，其执行结果会影响主业务服务的决策。</p>
<blockquote>
<p>以上部分内容参考自：<span class="exturl" data-url="aHR0cHM6Ly9zZWF0YS5pby96aC1jbi9ibG9nL3RjYy1tb2RlLWFwcGxpY2FibGUtc2NlbmFyaW8tYW5hbHlzaXMuaHRtbD91dG1fc291cmNlPWdvbGRfYnJvd3Nlcl9leHRlbnNpb24=">https://seata.io/zh-cn/blog/tcc-mode-applicable-scenario-analysis.html?utm_source=gold_browser_extension<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h2 id="TCC事务模式的落地实现"><a href="#TCC事务模式的落地实现" class="headerlink" title="TCC事务模式的落地实现"></a>TCC事务模式的落地实现</h2><p>在前面文章中介绍了Seata的<strong>AT</strong>模式，有不清楚的可以看：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpVM01EQXpORGcxTUE9PSZhbXA7bWlkPTIyNDc0OTk0MjEmYW1wO2lkeD0xJmFtcDtzbj1hNTU3OTc2NTIyODRiYWZkOTIxNmVhOTgxZjQxMjVlMCZhbXA7c2NlbmU9MjEjd2VjaGF0X3JlZGlyZWN0">对比7种分布式事务方案，还是偏爱阿里开源的Seata，真香！(原理+实战)<i class="fa fa-external-link-alt"></i></span></p>
<p>当然Seata支持的事务模式不局限于AT模式，还有<strong>TCC</strong>模式、<strong>SAGA</strong>模式、<strong>XA</strong>模式，下面整合一下TCC模式。</p>
<h3 id="1、演示场景"><a href="#1、演示场景" class="headerlink" title="1、演示场景"></a>1、演示场景</h3><p>就以电商系统中下订单为例，为了演示，直接去掉账户服务，以订单服务、库存服务为例介绍。</p>
<p>具体的逻辑如下：</p>
<ol>
<li>客户端调用下订单接口</li>
<li>扣库存</li>
<li>创建订单</li>
<li>请求完成</li>
</ol>
<p>根据上面的逻辑可知，订单服务肯定是主业务服务，事务的发起方，库存服务是从业务服务，参与事务的决策。</p>
<p>Seata的AT模式解决方案伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GlobalTransactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Result&lt;Void&gt; <span class="title">createOrder</span><span class="params">(Long productId,Long num,.....)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1、扣库存</span></span><br><span class="line">    reduceStorage();</span><br><span class="line">    <span class="comment">//2、创建订单</span></span><br><span class="line">    saveOrder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>@GlobalTransactional</strong>这个注解用于发起一个全局事务。</p>
<p>但是AT模式有局限性，如下：</p>
<ul>
<li>性能低，锁定资源时间太长</li>
<li>无法解决跨应用的事务</li>
</ul>
<p>因此对于要求性能的下单接口，可以考虑使用TCC模式进行拆分成两阶段执行，这样整个流程锁定资源的时间将会变短，性能也能提高。</p>
<p>此时的TCC模式的拆分如下：</p>
<p><strong>1、一阶段的Try操作</strong></p>
<p>TCC模式中的Try阶段其实就是预留资源，在这个过程中可以将需要的商品数量的<strong>库存冻结</strong>，这样就要在库存表中维护一个冻结的库存这个字段。</p>
<p>伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">try</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//冻结库存</span></span><br><span class="line">  frozenStorage();</span><br><span class="line">  <span class="comment">//生成订单，状态为待确认</span></span><br><span class="line">  saveOrder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：@Transactional开启了本地事务，只要出现了异常，本地事务将会回滚，同时执行第二阶段的cancel操作。</p>
</blockquote>
<p><strong>2、二阶段的confirm操作</strong></p>
<p>confirm操作在一阶段try操作成功之后提交事务，涉及到的操作如下：</p>
<ol>
<li>释放try操作冻结的库存（冻结库存-购买数量）</li>
<li>生成订单</li>
</ol>
<p>伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">confirm</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//释放掉try操作预留的库存</span></span><br><span class="line">    cleanFrozen();</span><br><span class="line">    <span class="comment">//修改订单，状态为已完成</span></span><br><span class="line">    updateOrder();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：这里如果返回false，遵循TCC规范，应该要不断重试，直到confirm完成。</p>
</blockquote>
<p><strong>3、二阶段的cancel操作</strong></p>
<p><strong>cancel</strong>操作在一阶段<strong>try</strong>操作出现异常之后执行，用于回滚资源，涉及到的操作如下：</p>
<ol>
<li>恢复冻结的库存（冻结库存-购买数量、库存+购买数量）</li>
<li>删除订单</li>
</ol>
<p>伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//释放掉try操作预留的库存</span></span><br><span class="line">    rollbackFrozen();</span><br><span class="line">    <span class="comment">//修改订单，状态为已完成</span></span><br><span class="line">    delOrder();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：这里如果返回false，遵循TCC规范，应该要不断重试，直到cancel完成。</p>
</blockquote>
<h3 id="2、TCC事务模型的三个异常"><a href="#2、TCC事务模型的三个异常" class="headerlink" title="2、TCC事务模型的三个异常"></a>2、TCC事务模型的三个异常</h3><p>实现TCC事务模型涉及到的三个异常是不可避免的，实际生产中必须要规避这三大异常。</p>
<p><strong>1、空回滚</strong></p>
<p><strong>定义</strong>：在未调用<strong>try</strong>方法或try方法未执行成功的情况下，就执行了<strong>cancel</strong>方法进行了回滚。</p>
<p>怎么理解呢？未调用try方法就执行了cancel方法，这个很容易理解，既然没有预留资源，那么肯定是不能回滚。</p>
<p><strong>try方法未执行成功是什么意思？</strong></p>
<p>可以看上节中的第一阶段try方法的伪代码，由于try方法开启了本地事务，一旦try方法执行过程中出现了异常，将会导致try方法的本地事务回滚（注意这里不是cancel方法回滚，而是try方法的本地事务回滚），这样其实try方法中的所有操作都将会回滚，也就没有必要调用cancel方法。</p>
<p>但是实际上一旦try方法抛出了异常，那么必定是要调用cancel方法进行回滚，这样就导致了空回滚。</p>
<p><strong>解决方案</strong>：</p>
<p>解决逻辑很简单：在cancel方法执行操作之前，必须要知道try方法是否执行成功。</p>
<p><strong>2、幂等性</strong></p>
<p>TCC模式定义中提到：如果confirm或者cancel方法执行失败，要一直重试直到成功。</p>
<p>这里就涉及了幂等性，confirm和cancel方法必须保证同一个全局事务中的幂等性。</p>
<p><strong>解决方案</strong>：</p>
<p>解决逻辑很简单：对付幂等，自然是要利用幂等标识进行防重操作。</p>
<p><strong>3、悬挂</strong></p>
<p>事务协调器在调用 TCC 服务的一阶段 Try 操作时，可能会出现因网络拥堵而导致的超时，此时事务管理器会触发二阶段回滚，调用 TCC 服务的 Cancel 操作，Cancel 调用未超时；</p>
<p>在此之后，拥堵在网络上的一阶段 Try 数据包被 TCC 服务收到，出现了二阶段 Cancel 请求比一阶段 Try 请求先执行的情况，此 TCC 服务在执行晚到的 Try  之后，将永远不会再收到二阶段的 Confirm 或者 Cancel ，造成 TCC 服务悬挂。</p>
<p><strong>解决方案</strong>：</p>
<p>解决逻辑很简单：在执行try方法操作资源之前判断cancel方法是否已经执行；同样的在cancel方法执行后要记录执行的状态。</p>
<p><strong>4、总结</strong></p>
<p>针对以上三个异常，落地的解决方案很多，比如维护一个<strong>事务状态表</strong>，每个事务的执行阶段全部记录下来。</p>
<ul>
<li>幂等：在执行confirm或者cancel之前根据事务状态表查询当前全局事务是否已经执行过confirm或者cancel方法</li>
<li>空回滚：在执行cancel之前才能根据事务状态表查询当前全局事务是否已经执行成功try方法</li>
<li>悬挂：在执行try方法之前，根据事务状态表查询当前全局事务是否已经执行过cancel方法</li>
</ul>
<h2 id="Seata整合TCC实现"><a href="#Seata整合TCC实现" class="headerlink" title="Seata整合TCC实现"></a>Seata整合TCC实现</h2><p>关于如何搭建项目、添加依赖这里就不再细说了，不熟悉的可以看我之前的文章：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpVM01EQXpORGcxTUE9PSZhbXA7bWlkPTIyNDc0OTk0MjEmYW1wO2lkeD0xJmFtcDtzbj1hNTU3OTc2NTIyODRiYWZkOTIxNmVhOTgxZjQxMjVlMCZhbXA7c2NlbmU9MjEjd2VjaGF0X3JlZGlyZWN0">对比7种分布式事务方案，还是偏爱阿里开源的Seata，真香！(原理+实战)<i class="fa fa-external-link-alt"></i></span></p>
<p>本节只介绍关键代码，毕竟篇幅有限，其他部分请自行下载源码。</p>
<blockquote>
<p>案例源码已上传GitHub，关注公众号：<strong>码猿技术专栏</strong>，回复关键：<strong>9531</strong> 获取！</p>
</blockquote>
<p>源码目录如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/26/0920-sUVDAb.png" alt="图片"></p>
<p>源码目录</p>
<p>项目启动所需要的相关文件如下图：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/26/0920-5Me486.png" alt="图片"></p>
<p><strong>nacos</strong>目录中的<strong>SEATA_GROUP</strong>是Seata事务服务端和客户端所需要的相关配置，直接导入nacos即可。</p>
<p><strong>seata</strong>目录中的conf是1.3.0版本服务端的配置</p>
<p><strong>SQL</strong>目录是相关的几个数据库。</p>
<h3 id="1、TCC接口定义"><a href="#1、TCC接口定义" class="headerlink" title="1、TCC接口定义"></a>1、TCC接口定义</h3><p>在<strong>order-boot</strong>模块创建OrderTccService，代码如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/26/0924-cX2XaO.jpeg" alt="图片"></p>
<p>代码中注释已经很完整了，下面挑几个重点介绍一下：</p>
<ol>
<li><p><strong>@LocalTCC</strong>：该注解开启TCC事务</p>
</li>
<li><p><strong>@TwoPhaseBusinessAction</strong>：该注解标注在try方法上，其中的三个属性如下：</p>
</li>
<li><ol>
<li><strong>name</strong>：TCC事务的名称，必须是唯一的</li>
<li><strong>commitMethod</strong>：confirm方法的名称，默认是commit</li>
<li><strong>rollbackMethod</strong>：cancel方法的名称，，默认是rollback</li>
</ol>
</li>
<li><p>confirm和cancel的返回值尤为重要，返回false则会不断的重试。</p>
</li>
</ol>
<h3 id="2、TCC接口实现"><a href="#2、TCC接口实现" class="headerlink" title="2、TCC接口实现"></a>2、TCC接口实现</h3><p>定义有了，总要实现，如下：</p>
<p><strong>1、try方法</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/26/0924-DKJbuw.jpeg" alt="图片"></p>
<p>try方法</p>
<p><strong>①</strong>处的代码是为了防止悬挂异常，从事务日志表中获取全局事务ID的状态，如果是cancel状态则不执行。</p>
<p><strong>②</strong>处的代码冻结库存</p>
<p><strong>③</strong>处的代码生成订单，状态为待确认</p>
<p><strong>④</strong>处的代码向幂等工具类中添加一个标记，<strong>key</strong>为<strong>当前类</strong>和<strong>全局事务ID</strong>，<strong>value</strong>为当前时间戳。</p>
<blockquote>
<p>注意：必须要开启本地事务，如上代码使用@Transactional开启本地事务</p>
</blockquote>
<p><strong>2、confirm方法</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/26/0920-RMjkq9.jpeg" alt="图片"></p>
<p>confirm方法</p>
<p><strong>①</strong>处的代码从幂等工具类中根据当前类和全局事务ID获取值，由于try阶段执行成功会向其中添加值，confirm方法执行成功会移出这个值，因此在confirm开头判断这个值是否存在就起到了幂等效果，防止重试的效果。</p>
<p><strong>⑥</strong>处的代码从幂等工具类中移出try方法中添加的值。</p>
<p><strong>②</strong>处的代码是从<strong>BusinessActionContext</strong>中获取try方法中的入参。</p>
<p><strong>③</strong>处的代码是释放掉冻结的库存</p>
<p><strong>④</strong>处的代码是修改订单的状态为已完成。</p>
<blockquote>
<p>注意：1. 开启本地事务  2. 注意返回值，返回false时将会重试</p>
</blockquote>
<p><strong>3、cancel方法</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/26/0924-quxaJS.jpeg" alt="图片"></p>
<p>cancel方法</p>
<p><strong>①</strong>处的代码是向事务日志记录表中插入一条数据，标记当前事务进入cancel方法，用来防止悬挂，这个和try方法中的<strong>①</strong>处的代码相呼应。</p>
<p><strong>②</strong>处的代码是为了防止幂等和空回滚，因为只有当try方法中执行成功幂等工具类中对应的当前类和全局事务ID才会存储该值。这样既防止了幂等，也防止了空回滚。</p>
<p><strong>③</strong>处的代码恢复冻结的库存。</p>
<p><strong>④</strong>处的代码删除这笔订单</p>
<p><strong>⑤</strong>处的代码是移出幂等工具类当前类和全局事务ID对应的值。</p>
<h3 id="3、如何防止TCC模型的三个异常？"><a href="#3、如何防止TCC模型的三个异常？" class="headerlink" title="3、如何防止TCC模型的三个异常？"></a>3、如何防止TCC模型的三个异常？</h3><p>实现方法有很多，有些案例是全部使用事务日志表记录当前的状态，这样完美的解决了幂等、空回滚、悬挂的问题。</p>
<p>陈某这里为了方便，使用了两种方案，如下：</p>
<p><strong>1、幂等、空回滚</strong></p>
<p>使用了一个幂等工具类，其中是个Map，key为当前类和全局事务ID，value是时间戳。</p>
<p>代码如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/26/0921-770Bne.jpeg" alt="图片"></p>
<p>思路如下：</p>
<ol>
<li>在try方法最后使用幂等工具类中的add方法添加值</li>
<li>在confirm、cancel方法中使用幂等工具类中的remove方法移出值</li>
<li>在confirm、cancel方法中使用幂等工具类中get方法获取值，如果为空，则表示已经执行过了，直接返回true，这样既防止了幂等，也防止了空回滚。</li>
</ol>
<p><strong>2、悬挂</strong></p>
<p>悬挂的实现依靠的是事务日志表，表结构如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `transactional_record` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `xid` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `status` <span class="type">int</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;1. try  2 commit 3 cancel &#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure>
<p>其中的xid是全局事务ID，status是事务的状态。</p>
<blockquote>
<p>其他的字段自己可以扩展</p>
</blockquote>
<p>解决悬挂问题的逻辑如下：</p>
<ol>
<li>cancel方法中将当前全局事务ID记录到事务日志表中，状态为cancel</li>
<li>try方法执行资源操作前检查事务日志表中当前全局事务ID是否已经是cancel状态</li>
</ol>
<h3 id="4、创建订单的业务方法"><a href="#4、创建订单的业务方法" class="headerlink" title="4、创建订单的业务方法"></a>4、创建订单的业务方法</h3><p>上面只是完成了TCC的三个方法，主业务事务发起方还未提供，代码如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/26/0920-RjvIDx.jpeg" alt="图片"></p>
<p><strong>@GlobalTransactional</strong>这个注解开启了全局事务，是事务的发起方。</p>
<p>内部直接调用的TCC的try方法。</p>
<h3 id="5、其他的配置"><a href="#5、其他的配置" class="headerlink" title="5、其他的配置"></a>5、其他的配置</h3><p>以上只是列出了关键的步骤，剩余其他的配置自己根据案例源码完善，如下：</p>
<ol>
<li>接口测试</li>
<li>整合nacos</li>
<li>整合feign</li>
<li>整合seata，TCC模式中的配置和AT模式的Seata配置相同</li>
</ol>
<blockquote>
<p>注意：一定要配置Seata的事务组<strong>tx-service-group</strong>，配置方法见之前的文章。</p>
</blockquote>
<h3 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a>6、总结</h3><p>TCC事务模型相对来说比较简单的一种，有兴趣的可以下载源码试试。</p>
<blockquote>
<p>案例源码已上传GitHub，关注公众号：<strong>码猿技术专栏</strong>，回复关键：<strong>9531</strong> 获取！</p>
</blockquote>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>sql</tag>
        <tag>事务</tag>
        <tag>数据库</tag>
        <tag>全局</tag>
        <tag>锁</tag>
        <tag>分布式</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>限流实现方案</title>
    <url>/posts/364VK21.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误！！" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="b29432f922f78f19369ace94873762ec212283c7592dbc713ff3162cf56a5e3a">6e9d7ca9294f2dfe030bce02e69a0643d3374ac3279d2c953140fc5b462fa957820052aae13e3eab7accbc7d0ff65e1c6594483e14ba38d762a2668ea1756b27d5e8146230e2fe13cb3d866ec46d665931a0c6c43fc58560859dbcd0ac2bc72e47cc70beff2ba4b64ee305fa6877eec1ff0971290f6351f98871891b8423c18d818f5cb49ed0c869c584407bb1b532958bb431f760471e2798794fa2a28cda17d396c7343c26ab92d04360dbf57e6067108ddbeb83a6726de24bf09c0cebe16536209c2912b1a0722fdc3fdfa194c4ca58a0048bb3d2775544cc5718f3eb574b0850fa4cb32396bfec54804174e86b7820e3053fbdef9b190c51e755f0417978218257b7ffa63f1d593396a3b2ad4b87d23553d4627a276bae963354379f2fe35b4f0ef08a6e240fd1979b41fca26a396b6283e2c00d6030048b19ef5531e3775bbaf048715ab60d82ef09c37fade602042317415796d7e5fbb174af50166fbc260069e1f711972c6bc24d0d1a4adcc75de9ce9e81e70c14ced1cc5ddc8ddfd61bae5266f44f21d0727272a04444b198d3eb0037157dfb5669955fa7e7360d165db151d09732831844b82155f9c72987d24085e06f9e6da4451fcfc29f3ce3572576729f496bdc584387ae17129b2d9a1ae89fa72f01d6512bbd4760475092dac32c14b32a8d911d6de15af4972483a9c17d5051bd399fc25b6911b888eaa03d42355ceaf39b238b7f259fcd2b5835548630df9218e446374771d06533d1d8dd01fe60dac58e070091e79fbbd48b3d527f38a02485a970d59be09f55ae564ad35bff03dd8374ab4d692ed2fdedecbf2b6bc2e8bd4298a6e5321e34db2aabeea1a7a6e92dee4dbde32b53c53a80144c35374a1c595b6a115135105ee5df02f660c6f16bd31efbb1f3ec1249e7c64cf409672548d7668d39b6024f14104a4364ff1bdfb598b8e00bd4f0a1cac61e7e629fcbc28b37ced27cce75df565db695f625b74543817ab45318bc54e45053b10b96ee711f283c82f329c2035ec14d74f206c8f66be748cb2e35988d981b08715817ed48a8ec5b3b08dec43928f5d3701e89ff63f23ec41c3a5e33340d836af0d429a0fa93d1ee53eddcd05f7a3f10e77f5a17b2936e897313b32fa6856b75a94bda3d39922a3dfc16a42eb368ee9c2311ae6ae2a53cab31a4a2cb42ce15c0a45cc0a1a9f5d84e9657fe45924007c17b14e14479c41c6bf54a13b587ce5dbea9b13b51fe97917d47ae89eb3e1bc8ec3e17c13d715fd21891f111076f67d405de6a9987171bc4a6a8acd3fd5dce7447817424b5bbc1948999ddbd56c967917bf79579b384b90dfdb282f6446206a97d842730cb83037e1e7321e5e7deacffa56863e70e720d563de824e4296f0053738c57f072f3afeb59221c939889b7dea4ab201f6ab7e4331ba8c088d433c8e5be0374b2a74556b1570a0bade3e8a25f665fb105520a5975e2b40217120a3c200eb0d3f13983f08b5f122c8050a40380bb4c514c09147d9643e6f9b10547be33ed67253226732d78f034399cd7d250824cb4fbfc556674dcfa60eadbd9a59751e1c4bc84d7e6a04582377082a4688ed0c3ae05a6cb97f80d761f28e79060b1428db9c0afaf2ca240e588a8687a9ae3686fdd445431c77b4849a63e6729fcca4616c3a3cb20804870d3d42d1b86038dc2ac7e4aa25756022596fad96dcb840bfcd7beaa0b2b776bc783db4317e820be41194b4b52bb9bfd6545143918b9ad4b4016fe22e4f769fd34068cc1fd7a551d542da4754e410f8f704c760298ab0c47c043b85205b91050d50dc713a96611840bb6d3b6d60a49f7eecdccb3028dad03e5b659430ed419fffd481e6a1e4e07b5b17e5684c569725c8c1a9e5c75fa15d654c26b73b4eb2791989dff7d0257cd406788c37a8e0683c606fa58b137f652fc3ea373732007ec8645709238881b766ee068159984fbdbe150cf0c9e742cf25ac1cad11a5ff768d103457ceaed2689042046c2ee61099b3923db17f298586cf610ad0af39ff8de8fbe3afaf9dc6254132a0e4598b9a496aba89858685348892f0ddcc330a8c0b0bb689da250fc655fac86eb152496988a385ad0f833c2ea18225d089c98ff02a1852c62b020de6205c55229732d6c986edbd527d4e739a1b530351fd7bd3091d350765a84e9bf2af844145e5232a544da06e9605eb99f65817ba6598afb79ffea4fc475bba73abb4bd4c06d6c8adc8da227ff501069def0001b91eddc7dffc5e6b96dbfb50800be8675c4de954766c124d76a1ae364089fe135f86ffa466812967c94e9098b1c47ec334b91fee40a993cd3bff9fefa5cafc7001d56e8e6a3eaba8925b274018b90e6bae68e30bf367916d129e165973c69b77886fcdd776aae01d2d2db379c9663cd1d57042a7ff62ed2380ac28824ff233f395d1e2f53aed649a9497f380b079f6849711efd671e6a9a0e9a334031001993f3281b16733bfa6a6ab9c4fd779c94d8a4242d38c4cc96c0e76de51d83cdd404f3a3d0f4e95e967f71f5ab3c30d3c359e5fd975997d86591009894df4de226b4d737507f449c50e35bb341f7943c6473a35dacdc2945aa6382bf955d6f602c7da261fc1389eaeb06dc61bce1c75abb5b69a8ae31f18e3fd2b368e8baab0083668be8a56fadd6a3ec3ff83c53a3f5ea13adc8c6ada8c47880ff5beab177043e1190f51c961ce251cd4a7ec09eda40e2c36b055b26c217ddb72c32f81f6892a52ff3a6105ac918dd5c7798a7ad9ddafa7dd4931fe1f7d6cf423e55425eb103edad603cf9ee34114bfcd8c0ba942e561feae4570455ad576642fc332fe89e6e2a1e838ada4d7cab502f1b22bcf4683b67165a21e7ae08e0eae01162cc0093160178306c179ec681bc2837bbb4be991d64020bd8534b2105249425ee7affb191c6b36fbbff50f9f7701d2271ef1791b3267a18272e96b75dc16f1a8c92c9a401c69725411cbbbad99fc3288b20bf5f03e33fc24cc180ea9d69f9740bb7edbdbbdfffbe82cb295a4e9c61dc88ccd33cc96d7acd64e1b7f1d5348f11802339b6b1aa936fd3f056b2a4c3777d9c0650db1957701c8ee1bac7adda73ca2500b8459e0b6fdea3d4decf45cb83b73258ee8b7807aeabd337c6f22679b06280119bc515940933145640dafcf3828560da4153d7d6bc6432f99787bad1632cdafe005e3047f0db49e9943286d37194f88687e8e90a2dd7dac3c43de8625518aec39b221c6bcda7f5ecf27205d81b8af1257139916e71b915f15e5ba6269629b0cb8de78244915fb5410eb81c7c9908bb3ef8deb3f8ddd3a8694a72d9fad455c7265b2284577a544941220b1d05e5ea8ac7105029f045bc3ed0f817d3083246085e7c8728155af7a71a94900528232a2cc6fbb497c5389ac3ee57b69f713b7e60f4bc5cccbde193afc0737d32f1c364d77f03da676b1ce7e7f1957a52e59d1b7c94bd913c4fa55432f02b94145297963398669d36878588ec7518c267804da5f55163d0a82c06ff6888992cd5991bc1d65f0596d54ae61975781064b2221daea87c962fb6110ec2a70140e2f4bd6f8dfab5a8e0ca0bd75bf8a21e6a932da1fa0da7b156d8211bf2f9767d0eb2fd582e085ab88f6bf3567a7306a6492d635b6d0a3aa148ed61883abce5e8d864d69626abe23f01c46ea5af9ef329b4bbb0fab0d18ec6ca8095a83cfaef078557699fc6345b50d4bfcd12492dbbb64046ee9d3eea8b395b06ae4dfe7dfdd49a682051f4514f624e331ad05f9b755dd31a4be5ea4f0066f4842f8d371109595324cdc10500318489f8c268180d7e7a75b4c3baf0b028809d071379a89414b9e62afb0262bd643ce7748bc6c43691415feadd63ac1bd937b9a8c457211596375697fa30284f55bf590811e17c758af8e6dff3ec669f6a425d453d79462824672997cf5161aa1b61924b187ffb110c5d83b61461b1d519dbe591da77e92fbeb5c1dd40f9ccb87b4fcd41bd94d10e653a9f55b416f4b326dfecc411d12d6a67e1681990775efcda87834339572d40569daf25ddfbd01a7b73474d8347b66b1691dce9b2e6795a8163791b14bb85c2786292dd9dab3e4d11ab4ade3885c7de067440b62649e3138b1ab2800a1ceece6c47518f1a721e6a2668491d15b7730598ba329957850ec1c703d779b70f189bf161ed7a119c94f99e3c48aa5e8162904728b829bc8268cda56962386663d0551f2fe5a5f9114a0298251aeb4c936dbae834486473f674fa4afb0359f16309b9fb765f074c38422130094eeef6653052ecac90e9d3568605250fd31d55b8dc91d060149f93d27dc5506a134550a1ef623ec5df7f23f8ba32f1021b91d43676bd9dce13948bef8d2ed9b0e7deb647259c6c4cc75ac92177eb11e99f8946de51d421e7dcc5a74e0383cfcff6bb63692a8af12c9f6a14a94838eff09a28055aec4e3001320eb77926ec409dc3f032684cded6d654d4f12f8b897c3114e8b89c89376ec89db156027030363fc0f0db0e7ca0fd84386ff6b1e2cdf81369bd55371cb2d85747d22324ca393350f28fd01d9ea1274ea1bce9555ef9223c5dde17120311033f4166ed4b602f609e9eb739e89446a73dd5d4d6c479baebcef064567f4651f3216d71ec2b186902890c73a05f0b898b6894d3a1d51da906a248cb23972ff1e65d3e05f29a00e0279ad0c1f24072d9ebe4598910ad56749c302575ebfe957d8174930fcf68229aaa0f26ffaa6269a66f83eb84e1c87ead61c1d735953d24ec0952a53d6cd2c9026ddaef5e23e330f6656e318d105cca65813027468d48ce9485ae3554865e7749f854ce4f0647427c79ff8e68cb12d9cca87eb46d11fb855a2a34fce7ffc8e9a6528d56c28878713197a947728df8e292972488c7e8df08adc04a04687420a39bbcb31d03684808e11a9c2736137a450656e0735297ee4c60c5ba43f982ba099cf41c8d7dad2a832639a27897640582c3a662d2acd83a6da8b1f578dc6e0e97de577c5bccf9bedc75faf021859d3fcac25df73efc7661b054c10b290c0f80e458cc955bb7eb97aee52509c450a2aa6d31a8bea010f72dc57da28dddfcf30f537227619304b7fbac3d35e10e7eec50b5fc9ea50f0f2cf31739daa7bccda2a80bca4c9d487664aaefa2af55534600dbeb150c1baa2904f5b826a2dcdb9174ca91d7ac6c9a71985653f89b1d4548ddce413f4c996c61bfc1a28a4bedef605a0c83c9b16ba2087eda41f22db1da6a9f4de0ed06567159e4813cbddf0382dacfcf98f640c49bb22e9cbd950648457b1bfde8ef73ca1e0f0ee58716bffbb387ae49f2c0f2b5c15a087aba78f2f9b265cad67fc4103a541872370df9daa20c3657a789d0e693f48047643e171389768b0095b97534471c0822073005c2869d4916ad1cd4a697b47be9cebf1a1f54a71f68378364986e2a9f8f3bd1761a80518fb76e1fadb6a043081f4076d22e2692f4fab1defffc5c195f00c7d66190eb06e2d92a1ae7a5653c96b99e0548617ed7354587db87fbad17ecb1f2da13f7150c7111bd1b80190ca3c5d320be0f0fed57aca21e5b7d6b197b6017c0bf5d31953d489cd30172cf20adcd78d8e40f96ed373b1920471d42d737a5390d631ef7da2a7c72710712bd684dac0d67d2ed339aacd605c84dac3fe421de1a882e697942db34acbc6fc083e42655ac3b90635cfcb1e6a98ce14ff1e416ef4c615d0d23b0e20198c95ca3638afbeda7f6f41c61dbd388d626db52579d7b78af4b604037db73c607a2e55abc25e32c69392a221b7aeae04214aeba109ea2442d828fa137bd57a7c19812ad8a5dc68a71133bc14dae50c5eb0028e7f56d79454ff2174f521bdbeafc5d0e58223e02ee696f42bb78915736dfffe9b5666d7eb3e9beb86d219cabf45155f7ee9ef25b81068ee9b0a283b911f7740a19547d4208d649b551031d19eead00792db37fcb7806485707a18f3e24d9df3818c8e610a052ce6125bffc3c5cea8ba13b1959a27f215746750c4dd5f59037a99367b5abf6eefd0fee9d744e242838bdddc91222f3176f80b4c35694aeef807e5fa99a1a7f97c187d9e739ce0a924868b7eb90793ccadf4ed862ecc219b0c6d2d9b0f4857ac3ae94bc46e510041c7027abde0f3e829e53e6cf4b453bf95c3220ec28701cf040623ce02cfd702e38c20582e3761e0cfef053f7fff1c2601fb9d3f19e6c6f41c71a131d005bdb7292622b4874360bb9a74e6600f06ddf98db9afbd84202822c6da757161f0f2a18c2545a0c87fdc7efc3c7070cade78ce904dadbfa0e7dff5b9a96e0659f118d764e3fd8a275b42817a0565519db31d9a575cf89209fdfa4dc145a53df50b7ac0c2d2d74f04b3a8f0820ad5cb5c388baeffa874e03e51a04b50fb3fa6288dbec71d22855eda8d893161fce54711bce92754b52b28dd092c16f9f021b6d3ecff81a968929a117df13f8d50313081b79320c7b6cb5771bf752353c8f31698e1aca764b3f828ff6377db5424e322b5c9a3edcd91453a40654a53322ecb9d238a5ad6e02b4fcb484844d5b6db5ddbdf340f04043e1063450efe7cc11bc195db8402b8c7515269d71915aff774485cf33925df8adc23b91f851416806e5fdc714ca3c1a3fd040a4243d79c2194ed07bba6c679bdecdc0f5b99855c5d5ce7bdbf87b08b8935a29171338ed71e23118361171a125f1263b6e03c60ed461ccbe920444a3dee17350652495ef85b84a803235e4bfcbb6bce2779d5906da3a8dd2454de548dea41cc9490b1886a6fe5e3b97ec48ab8470e6ca4f3887e6914ad46ab194622ea368f8d5246192a9c47bd85ae397b53aab07838d6e2ca21dfd692ec74c7b491c9b999cfb2ffa120cfa28aa7f83aaa160f15db4b91e467a332515a869e4b4a11fa2c1f6882a186cadc7a3bec8454f0838e1497c1236d663455ca28bf7e1425c929115e3c822a9fa9c2d1ff5d11b96e14b99127099c301735601ad939f605cccba121f35a96f70ee409da87cad4062918540406391725f9f447e864d32986d34b66756d2635f5912f8bd4aa97f14ae5b67cb84f5747cc6336f606284b4ebf8b408688846d52a21b35f6cad654b765d544468bf091920e82cc8a6d372e9943e4e3a42537fa450e84d497236283dd8d6c9f8f407a749832b47fcc8a757e19eff00a08fdcb74614e73839b52d413a81c908eaa9458f079bf02384471fcaf74f82d33abf3b08c51b0a5a5eccbe0d1f2ee943cea3a22232baacad53789706d80e0e77feee69cf2cb3cb881fbb9bc983ca409b4b8c0be2f903d70168c2203ea189ce22c39fb104c20f58bf31da73453f73a2ed5486f1121242d2ef0c8f793ccd905907b523b217109c142d8a6ed9677d60c8718963c1783be2cfc1b7aa99b7ecbb06305f2793988e294d9609c0b61dc04e3ab09294be5ea6414fa2c608595755f050535928a5fe377c8dcf485f8ae1d17e93d752613faa0362f1dae6811d278bf79e642616ad8f9a709c056a2aa1c2991c8b9d5652f2d78d52e62b1b5267ac2b7775fd5b58ee1220e760b56dad3c88a32df0110431a102e69bf3b1ebcc72827114537f75408e28f595deeec8740d20f7ff441ea68bce9e2fd7e7ac6be2d0a134322a49dd2b6a279523a57e44b5bbc8d7a8cf1c6427c83c3d2a368675540519d7159bb5816745f8119f38bd6fc0848dc08f8991f1ea378751c5555550f4dc3e791da87050b3840d07720c738d3c5b179c71736c5350a2c342e04aa6d7f7da7a823166042c445e8550bcb2d1ce5cf5b6facc9c7a5010e567a3cb67b75f9e9f6b09d38fbd6f66c8b98a67032788fc7e241aeac03d16219ce290a5e492c80e76beec209d19334c45418939d8d1caea90c2757326f4d1a6fd062c6bc1f6dbd8bba4ddcac45d2cab53208999dccc37686068466c9c124b7080230ee6df68b86787ed951ff4917b61b44aae3e368f3150e483412f9f75ed018753e2b5bed7f1698a75e149a5e7a83db1b2b2f30ee404f8d10244affe1b47e289850068ff4575cbec27574b7b80a7a34ecc596096fbd6d58a288864069469028e68bcd4436a2085d759236dcb2befc4c2ece87a150165376548b3d40c64f4fd1a2a82ef33789460ebe365e3ac7879877a1281c450927441922cd5a7d9bc30b0b55a9e17813eed8cd0f6588887de694953da8da4458767eb6273b7e0188ff79b3c98dbe90c58e57200acabcf882f9da3c01f77c76c091d35d558a956febbe91062a780deb0c0d26ebd18c5f34aff3ac8830eb2cc4f6713b6a180349516a47cbbb35a830142cc1350f5c58ea326312a4e68a814dfbaaed09dabab20957a34758b85b453e6e609d0f808cbd6b7fc60a3919ce236f6684ca84bbafe181d6dae170df97e88c49229c7cd7bc4b2eed2950b8ede3879362adae7e40b226b667b35265e6f08fb6375527e8499c4e17b56ddc1a792714b8c5d3743a2c3125a30a634b95e229af07110993ef1dc33d5bef3013e7eefa8586895a8c9b5053c4615c0d85aab2092cb4bb0bd9a913c0182dc4785142b1ec66918ce85bf35f994c5fccdc41a860e6b594e25f58f61b848e06d03cc9db820f409b8e43e7e5dd7602fd8ec68e6916ffd25ea3ba437638200845bd501749d1e7be571c92b2f4f6eebf9d9cb8a463962e6184803e294785603efc2f023391ff1e229e9ded13bd036daaa437f22f8aa816f253d59b1e366011ac06da7bb1fec1c1fabdd05e70f854c36bbfe6fceb543456fe8554946037a53609affe2e93cfb5ab88fe64dbbcb5ec1c65dd331406dd97486ede4498f02ded9d9f1bbc729cf606461be6920547341d35d79ba28ca85ee5c3fc57d8f8b393971431b2620e33c22cae1b95d32e4a6b77523586cf695a5931ffa497183cccbddef10302b274af20c9f15864e33cfcab6571083a5546b81f1280249d2e75d6eb9e10b0fe1ffa4548cde689b92566d3a73a59a579e871c8e546f5b0294c9eba2c6057d5df6d9b7f408d07e9bf6a3327e60f8451923973cb32e5e11c86bd7c659ebc1511c0c232e806931b22c64fb41dfae5dec72aabd8dc51d15d44275f5e28dfa66d9dc002c931d468251e0f2b15f07fd628fca55efb4bbca0295bb68403a529927786f54873a86d0716040deff22073bc45ff20537cb8538e37fe674971ae2cf8b530f0172f6bb94cd60010253e436413d2bed82d7034354cca8e54704a2c7b5759ce3cb0b50989c36db392f42cc6efc5f90e92fffe673b0a481cf1ccc6c21bf855b57de80ada5e2409d288df15690138dd16cd38cb99364a60eb7d64d54c7a0185716022acce3e6155e492ec0d63d91c4b6640e935b41c51026ad79c0933ff905a7bb96be51b0d18af76a683cd799461792fcb0aea0ae4559a642e3e46d41ba03049875fe97ba44d3b45da12d867f685dff2121730b1e29e5cc4c4555cc4d99c3a82f497252a68b70b2543666552b28fc4923ce88dd0991f51de959bf414b9b5c49a1ef45425d5d560d81e1c20df7cba9f90c05ec6997ff29f2608128e5e5d36a768ae37fabdfc858acfed4a495df3aa0f68fa40c016d46</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">未完结</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>功能实现方案</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>集合</tag>
        <tag>并发</tag>
        <tag>算法</tag>
        <tag>容器</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>PDF导出添加水印和页眉</title>
    <url>/posts/15HC2FY.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><div style="text-align: center;"></div><br><span id="more"></span></p>
<h2 id="maven引用"><a href="#maven引用" class="headerlink" title="maven引用"></a>maven引用</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itextpdf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>itextpdf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.5.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itextpdf<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>itext-asian<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.pdfbox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pdfbox<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itextpdf.tool<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xmlworker<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.5.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * PDF预览</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> response</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> filename 文件名称</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> rect PDF每张页面大小</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> backgroundColor 背景颜色</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> marginLeft 左页边距</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> marginRight 右页边距</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> marginTop 顶部页边距</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> marginBottom 底部页面距</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pdfExportPreview</span><span class="params">(HttpServletResponse response, String filename,Rectangle rect,BaseColor backgroundColor,</span></span></span><br><span class="line"><span class="function"><span class="params">										<span class="keyword">float</span> marginLeft, <span class="keyword">float</span> marginRight, <span class="keyword">float</span> marginTop, <span class="keyword">float</span> marginBottom)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		response.setContentType(<span class="string">&quot;application/pdf&quot;</span>);</span><br><span class="line">		pdfExport(response, filename, rect, backgroundColor, marginLeft, marginRight, marginTop, marginBottom);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pdfExport</span><span class="params">(HttpServletResponse response,String filename,Rectangle rect,BaseColor backgroundColor,</span></span></span><br><span class="line"><span class="function"><span class="params">								  <span class="keyword">float</span> marginLeft, <span class="keyword">float</span> marginRight, <span class="keyword">float</span> marginTop, <span class="keyword">float</span> marginBottom)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		Document document = <span class="keyword">null</span>;</span><br><span class="line">		OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			response.addHeader(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;inline;filename=&quot;</span> + URLEncoder.encode(filename, <span class="string">&quot;UTF-8&quot;</span>) + <span class="string">&quot;.pdf&quot;</span>);</span><br><span class="line">			document =createDocument(rect,backgroundColor,marginLeft, marginRight, marginTop, marginBottom);</span><br><span class="line">			os = <span class="keyword">new</span> BufferedOutputStream(response.getOutputStream());</span><br><span class="line">			<span class="comment">// 2. 获取writer</span></span><br><span class="line">			PdfWriter writer = PdfWriter.getInstance(document, os);</span><br><span class="line">			writer.setPdfVersion(PdfWriter.PDF_VERSION_1_2);</span><br><span class="line">			<span class="comment">// 页眉/页脚</span></span><br><span class="line">			writer.setPageEvent(<span class="keyword">new</span> MyHeaderFooter(marginLeft));</span><br><span class="line">			<span class="comment">// 3. open()</span></span><br><span class="line">			document.open();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (Element element : elementList) &#123;</span><br><span class="line">				document.add(element);</span><br><span class="line">				<span class="keyword">if</span> (newPageList.contains(element)) &#123;</span><br><span class="line">					document.newPage();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			elementList.clear();</span><br><span class="line">			newPageList.clear();</span><br><span class="line">			<span class="keyword">if</span> (document != <span class="keyword">null</span>)&#123;</span><br><span class="line">				document.close();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (os != <span class="keyword">null</span>)&#123;</span><br><span class="line">				os.close();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.itextpdf.text.*;</span><br><span class="line"><span class="keyword">import</span> com.itextpdf.text.pdf.*;</span><br><span class="line"><span class="keyword">import</span> com.itextpdf.text.pdf.draw.LineSeparator;</span><br><span class="line"><span class="keyword">import</span> lombok.SneakyThrows;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chenkang</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHeaderFooter</span> <span class="keyword">extends</span> <span class="title">PdfPageEventHelper</span> </span>&#123;</span><br><span class="line">	MyHeaderFooter()&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">float</span> marginLeft;</span><br><span class="line">	MyHeaderFooter(<span class="keyword">float</span> marginLeft)&#123;</span><br><span class="line">		<span class="keyword">this</span>.marginLeft = marginLeft;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模板</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> PdfTemplate total;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基础字体对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> BaseFont bf = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  文档打开时创建模板</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> PdfPageEventHelper#onOpenDocument(PdfWriter,</span></span><br><span class="line"><span class="comment">     *      Document)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpenDocument</span><span class="params">(PdfWriter writer, Document document)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 共 页 的矩形的长宽高</span></span><br><span class="line">        total = writer.getDirectContent().createTemplate(<span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *  关闭每页的时候，写入页眉，写入&#x27;第几页共&#x27;这几个字。*</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> PdfPageEventHelper#onEndPage(PdfWriter,</span></span><br><span class="line"><span class="comment">     *      Document)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEndPage</span><span class="params">(PdfWriter writer, Document document)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.addPage(writer, document);</span><br><span class="line">        <span class="keyword">this</span>.addWatermark(writer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加分页</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPage</span><span class="params">(PdfWriter writer, Document document)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//设置分页页眉页脚字体</span></span><br><span class="line">        <span class="keyword">if</span> (bf == <span class="keyword">null</span>) &#123;</span><br><span class="line">            bf = BaseFont.createFont(<span class="string">&quot;STSong-Light&quot;</span>, <span class="string">&quot;UniGB-UCS2-H&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Font columnTextfont = <span class="keyword">new</span> Font(bf, Font.DEFAULTSIZE, Font.NORMAL, BaseColor.RED);</span><br><span class="line">        <span class="keyword">int</span> pageS = writer.getPageNumber();</span><br><span class="line">        <span class="keyword">if</span> (pageS != <span class="number">0</span>) &#123;</span><br><span class="line">            ClassPathResource classPathResource = <span class="keyword">new</span> ClassPathResource(<span class="string">&quot;img/logo.png&quot;</span>);</span><br><span class="line">            URL url = classPathResource.getURL();</span><br><span class="line">            Image image = Image.getInstance(url);</span><br><span class="line">            Phrase p1 = <span class="keyword">new</span> Phrase(<span class="string">&quot;&quot;</span>, columnTextfont);</span><br><span class="line">            p1.add(<span class="keyword">new</span> Chunk(image, <span class="number">0</span>, -<span class="number">10</span>));</span><br><span class="line">            ColumnText.showTextAligned(writer.getDirectContent(), Element.ALIGN_LEFT, p1, document.left(), document.top() + <span class="number">15</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">             <span class="comment">//1.写入页眉文字</span></span><br><span class="line">            <span class="comment">//ColumnText.showTextAligned(writer.getDirectContent(), Element.ALIGN_LEFT, new Phrase(&quot;页眉文字内容&quot;, columnTextfont), document.left(), document.top() + 8, 0);</span></span><br><span class="line">            <span class="comment">//ColumnText.showTextAligned(writer.getDirectContent(), Element.ALIGN_RIGHT, new Phrase(header, columnTextfont), document.right(), document.top() + 8, 0);</span></span><br><span class="line">            <span class="comment">// 直线</span></span><br><span class="line">            Paragraph p2 = <span class="keyword">new</span> Paragraph();</span><br><span class="line">            LineSeparator lineSeparator = <span class="keyword">new</span> LineSeparator();</span><br><span class="line">            lineSeparator.setLineColor(BaseColor.GRAY);</span><br><span class="line">            lineSeparator.setLineWidth(<span class="number">1.0f</span>);</span><br><span class="line">            p2.add(<span class="keyword">new</span> Chunk(lineSeparator));</span><br><span class="line">            ColumnText.showTextAligned(writer.getDirectContent(), Element.ALIGN_LEFT, p2, document.left() - marginLeft, document.top() + <span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.写入前半部分的 第 X页/共</span></span><br><span class="line">            String foot1 = <span class="string">&quot;第 &quot;</span> + (pageS) + <span class="string">&quot; 页 /共&quot;</span>;</span><br><span class="line">            Font fontDetail = <span class="keyword">new</span> Font(bf, Font.STRIKETHRU, Font.NORMAL, BaseColor.BLACK);</span><br><span class="line">            Phrase footer = <span class="keyword">new</span> Phrase(foot1, fontDetail);</span><br><span class="line">            <span class="comment">// 3.计算前半部分的foot1的长度，后面好定位最后一部分的&#x27;Y页&#x27;这俩字的x轴坐标，字体长度也要计算进去 = len</span></span><br><span class="line">            <span class="keyword">float</span> len = bf.getWidthPoint(foot1, Font.STRIKETHRU);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4.拿到当前的PdfContentByte</span></span><br><span class="line">            PdfContentByte cb = writer.getDirectContent();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5.写入页脚1，x轴就是(右margin+左margin + right() -left()- len)/2.0F</span></span><br><span class="line">            <span class="comment">// 再给偏移20F适合人类视觉感受，否则肉眼看上去就太偏左了</span></span><br><span class="line">            <span class="comment">// ,y轴就是底边界-20,否则就贴边重叠到数据体里了就不是页脚了；注意Y轴是从下往上累加的，最上方的Top值是大于Bottom好几百开外的。</span></span><br><span class="line">            ColumnText.showTextAligned(cb, Element.ALIGN_CENTER, footer,</span><br><span class="line">                    (document.rightMargin() + document.right() + document.leftMargin() - document.left() - len) / <span class="number">2.0F</span> + <span class="number">20F</span>,</span><br><span class="line">                    document.bottom() - <span class="number">20</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6.写入页脚2的模板（就是页脚的Y页这俩字）添加到文档中，计算模板的和Y轴,X=(右边界-左边界 - 前半部分的len值)/2.0F +</span></span><br><span class="line">            <span class="comment">// len ， y 轴和之前的保持一致，底边界-20 // 调节模版显示的位置</span></span><br><span class="line">            cb.addTemplate(total, (document.rightMargin() + document.right() + document.leftMargin() - document.left()) / <span class="number">2.0F</span> + <span class="number">20F</span>,</span><br><span class="line">                    document.bottom() - <span class="number">20</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加水印</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWatermark</span><span class="params">(PdfWriter writer)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        PdfContentByte content = writer.getDirectContent();</span><br><span class="line">        content.beginText();</span><br><span class="line">        BaseFont font = BaseFont.createFont(<span class="string">&quot;STSong-Light&quot;</span>, <span class="string">&quot;UniGB-UCS2-H&quot;</span>, <span class="keyword">false</span>);</span><br><span class="line">        content.setFontAndSize(font, <span class="number">20</span>);</span><br><span class="line">        <span class="comment">// 设置透明度</span></span><br><span class="line">        <span class="comment">// 设置水印透明度</span></span><br><span class="line">        PdfGState gs = <span class="keyword">new</span> PdfGState();</span><br><span class="line">        <span class="comment">// 设置填充字体不透明度为0.4f</span></span><br><span class="line">        gs.setFillOpacity(<span class="number">0.1f</span>);</span><br><span class="line">        content.setGState(gs);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">50</span>; j++) &#123;</span><br><span class="line">                content.showTextAligned(Element.ALIGN_CENTER, <span class="string">&quot;这是水印       这是水印&quot;</span>, i * <span class="number">200</span>, j * <span class="number">200</span>, <span class="number">45</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置水印颜色(灰色)</span></span><br><span class="line">        content.setColorFill(BaseColor.GRAY);</span><br><span class="line">        <span class="comment">//结束</span></span><br><span class="line">        content.endText();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 关闭文档时，替换模板，完成整个页眉页脚组件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> PdfPageEventHelper#onCloseDocument(PdfWriter,</span></span><br><span class="line"><span class="comment">     *      Document)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCloseDocument</span><span class="params">(PdfWriter writer, Document document)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 7.最后一步了，就是关闭文档的时候，将模板替换成实际的 Y 值,至此，page x of y 制作完毕，完美兼容各种文档size。</span></span><br><span class="line">        total.beginText();</span><br><span class="line">        <span class="comment">// 生成的模版的字体、颜色</span></span><br><span class="line">        total.setFontAndSize(bf, Font.STRIKETHRU);</span><br><span class="line">        <span class="comment">//页脚内容拼接  如  第1页/共2页</span></span><br><span class="line">        String foot2 = <span class="string">&quot; &quot;</span> + (writer.getPageNumber()) + <span class="string">&quot; 页&quot;</span>;</span><br><span class="line">        <span class="comment">// 模版显示的内容</span></span><br><span class="line">        total.showText(foot2);</span><br><span class="line">        total.endText();</span><br><span class="line">        total.closePath();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>示例图：</strong><br><img data-src="https://xuemingde.com/pages/image/others/DoAJOn.png" alt="DoAJOn"></p>
]]></content>
      <categories>
        <category>功能实现方案</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>pdf</tag>
      </tags>
  </entry>
  <entry>
    <title>如何设计一个秒杀系统</title>
    <url>/posts/1J88EXM.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文主要有三个议题：高性能、一致性、高可用。</p>
<p>秒杀大家都不陌生。自2011年首次出现以来，无论是双十一购物还是 12306 抢票，秒杀场景已随处可见。简单来说，秒杀就是在同一时刻大量请求争抢购买同一商品并完成交易的过程。从架构视角来看，秒杀系统本质是一个高性能、高一致、高可用的三高系统。而打造并维护一个超大流量的秒杀系统需要进行哪些关注，就是本文讨论的话题。</p>
<h2 id="整体思考"><a href="#整体思考" class="headerlink" title="整体思考"></a>整体思考</h2><h3 id="秒杀存在的问题"><a href="#秒杀存在的问题" class="headerlink" title="秒杀存在的问题"></a>秒杀存在的问题</h3><p>对于一个日常平稳的业务系统，如果直接开通秒杀功能的话，往往会出现很多问题——</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/12/0921-5SVE4Q.png" alt="image-20220412092138444"></p>
<h3 id="设计方向的思考"><a href="#设计方向的思考" class="headerlink" title="设计方向的思考"></a>设计方向的思考</h3><p>秒杀本质是要求一个瞬时高发下的承压系统，这也是其区别于其他业务的核心场景。对日常系统秒杀产生的问题逐一进行拆解分类，秒杀对应到架构设计，其实就是高可用、一致性和高性能的要求。关于秒杀系统的设计思考，本文即基于此 3 层依次推进，简述如下——</p>
<blockquote>
<ul>
<li>高性能。秒杀涉及高读和高写的支持，如何支撑高并发，如何抵抗高IOPS？核心优化理念其实是类似的：高读就尽量”少读”或”读少”，高写就数据拆分。本文将从动静分离、热点优化以及服务端性能优化 3 个方面展开</li>
<li>一致性。秒杀的核心关注是商品库存，有限的商品在同一时间被多个请求同时扣减，而且要保证准确性，显而易见是一个难题。如何做到既不多又不少？本文将从业界通用的几种减库存方案切入，讨论一致性设计的核心逻辑</li>
<li>高可用。大型分布式系统在实际运行过程中面对的工况是非常复杂的，业务流量的突增、依赖服务的不稳定、应用自身的瓶颈、物理资源的损坏等方方面面都会对系统的运行带来大大小小的的冲击。如何保障应用在复杂工况环境下还能高效稳定运行，如何预防和面对突发问题，系统设计时应该从哪些方面着手？本文将从架构落地的全景视角进行关注思考</li>
</ul>
</blockquote>
<h2 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h2><h3 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h3><p>大家可能会注意到，秒杀过程中你是不需要刷新整个页面的，只有时间在不停跳动。这是因为一般都会对大流量的秒杀系统做系统的静态化改造，即数据意义上的动静分离。动静分离三步走：1、数据拆分；2、静态缓存；3、数据整合。</p>
<h4 id="数据拆分"><a href="#数据拆分" class="headerlink" title="数据拆分"></a>数据拆分</h4><p>动静分离的首要目的是将动态页面改造成适合缓存的静态页面。因此第一步就是分离出动态数据，主要从以下 2 个方面进行：</p>
<blockquote>
<ol>
<li>用户。用户身份信息包括登录状态以及登录画像等，相关要素可以单独拆分出来，通过动态请求进行获取；与之相关的广平推荐，如用户偏好、地域偏好等，同样可以通过异步方式进行加载</li>
<li>时间。秒杀时间是由服务端统一管控的，可以通过动态请求进行获取</li>
</ol>
</blockquote>
<p>这里你可以打开电商平台的一个秒杀页面，看看这个页面里都有哪些动静数据。</p>
<h4 id="静态缓存"><a href="#静态缓存" class="headerlink" title="静态缓存"></a>静态缓存</h4><p>分离出动静态数据之后，第二步就是将静态数据进行合理的缓存，由此衍生出两个问题：1、怎么缓存；2、哪里缓存</p>
<h5 id="怎么缓存"><a href="#怎么缓存" class="headerlink" title="怎么缓存"></a><strong>怎么缓存</strong></h5><p>静态化改造的一个特点是直接缓存整个 HTTP 连接而不是仅仅缓存静态数据，如此一来，Web 代理服务器根据请求  URL，可以直接取出对应的响应体然后直接返回，响应过程无需重组 HTTP 协议，也无需解析 HTTP  请求头。而作为缓存键，URL唯一化是必不可少的，只是对于商品系统，URL 天然是可以基于商品 ID 来进行唯一标识的，比如淘宝的 <code>https://item.taobao.com/item....</code></p>
<h5 id="哪里缓存"><a href="#哪里缓存" class="headerlink" title="哪里缓存"></a><strong>哪里缓存</strong></h5><p>静态数据缓存到哪里呢？可以有三种方式：1、浏览器；2、CDN ；3、服务端。</p>
<p>浏览器当然是第一选择，但用户的浏览器是不可控的，主要体现在如果用户不主动刷新，系统很难主动地把消息推送给用户（注意，当讨论静态数据时，潜台词是 “相对不变”，言外之意是  “可能会变”），如此可能会导致用户端在很长一段时间内看到的信息都是错误的。对于秒杀系统，保证缓存可以在秒级时间内失效是不可或缺的。</p>
<p>服务端主要进行动态逻辑计算及加载，本身并不擅长处理大量连接，每个连接消耗内存较多，同时 Servlet 容器解析 HTTP 较慢，容易侵占逻辑计算资源；另外，静态数据下沉至此也会拉长请求路径。</p>
<p>因此通常将静态数据缓存在 CDN，其本身更擅长处理大并发的静态文件请求，既可以做到主动失效，又离用户尽可能近，同时规避 Java 语言层面的弱点。需要注意的是，上 CDN 有以下几个问题需要解决：</p>
<ol>
<li>失效问题。任何一个缓存都应该是有时效的，尤其对于一个秒杀场景。所以，系统需要保证全国各地的 CDN 在秒级时间内失效掉缓存信息，这实际对 CDN 的失效系统要求是很高的</li>
<li>命中率问题。高命中是缓存系统最为核心的性能要求，不然缓存就失去了意义。如果将数据放到全国各地的 CDN ，势必会导致请求命中同一个缓存的可能性降低，那么命中率就成为一个问题</li>
</ol>
<p>因此，将数据放到全国所有的 CDN 节点是不太现实的，失效问题、命中率问题都会面临比较大的挑战。更为可行的做法是选择若干 CDN 节点进行静态化改造，节点的选取通常需要满足以下几个条件：</p>
<ol>
<li>临近访问量集中的地区</li>
<li>距离主站较远的地区</li>
<li>节点与主站间网络质量良好的地区</li>
</ol>
<p>基于以上因素，选择 CDN 的二级缓存比较合适，因为二级缓存数量偏少，容量也更大，访问量相对集中，这样就可以较好解决缓存的失效问题以及命中率问题，是当前比较理想的一种 CDN 化方案。部署方式如下图所示：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/12/0924-FjO5V0.png" alt="图片"></p>
<h4 id="数据整合"><a href="#数据整合" class="headerlink" title="数据整合"></a>数据整合</h4><p>分离出动静态数据之后，前端如何组织数据页就是一个新的问题，主要在于动态数据的加载处理，通常有两种方案：ESI（Edge Side Includes）方案和 CSI（Client Side Include）方案。</p>
<blockquote>
<ol>
<li>ESI 方案：Web 代理服务器上请求动态数据，并将动态数据插入到静态页面中，用户看到页面时已经是一个完整的页面。这种方式对服务端性能要求高，但用户体验较好</li>
<li>CSI 方案：Web 代理服务器上只返回静态页面，前端单独发起一个异步 JS 请求动态数据。这种方式对服务端性能友好，但用户体验稍差</li>
</ol>
</blockquote>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>动静分离对于性能的提升，抽象起来只有两点，一是数据要尽量少，以便减少没必要的请求，二是路径要尽量短，以便提高单次请求的效率。具体方法其实就是基于这个大方向进行的。</p>
<h3 id="热点优化"><a href="#热点优化" class="headerlink" title="热点优化"></a>热点优化</h3><p>热点分为热点操作和热点数据，以下分开进行讨论。</p>
<h4 id="热点操作"><a href="#热点操作" class="headerlink" title="热点操作"></a>热点操作</h4><p>零点刷新、零点下单、零点添加购物车等都属于热点操作。热点操作是用户的行为，不好改变，但可以做一些限制保护，比如用户频繁刷新页面时进行提示阻断。</p>
<h4 id="热点数据"><a href="#热点数据" class="headerlink" title="热点数据"></a>热点数据</h4><p>热点数据的处理三步走，一是热点识别，二是热点隔离，三是热点优化。</p>
<h5 id="热点识别"><a href="#热点识别" class="headerlink" title="热点识别"></a>热点识别</h5><p>热点数据分为静态热点和动态热点，具体如下：</p>
<ol>
<li>静态热点：能够提前预测的热点数据。大促前夕，可以根据大促的行业特点、活动商家等纬度信息分析出热点商品，或者通过卖家报名的方式提前筛选；另外，还可以通过技术手段提前预测，例如对买家每天访问的商品进行大数据计算，然后统计出 TOP N 的商品，即可视为热点商品</li>
<li>动态热点：无法提前预测的热点数据。冷热数据往往是随实际业务场景发生交替变化的，尤其是如今直播卖货模式的兴起——带货商临时做一个广告，就有可能导致一件商品在短时间内被大量购买。由于此类商品日常访问较少，即使在缓存系统中一段时间后也会被逐出或过期掉，甚至在db中也是冷数据。瞬时流量的涌入，往往导致缓存被击穿，请求直接到达DB，引发DB压力过大</li>
</ol>
<p>因此秒杀系统需要实现热点数据的动态发现能力，一个常见的实现思路是：</p>
<ol>
<li>异步采集交易链路各个环节的热点 Key 信息，如 Nginx采集访问URL或 Agent 采集热点日志（一些中间件本身已具备热点发现能力），提前识别潜在的热点数据</li>
<li>聚合分析热点数据，达到一定规则的热点数据，通过订阅分发推送到链路系统，各系统根据自身需求决定如何处理热点数据，或限流或缓存，从而实现热点保护</li>
</ol>
<p>需要注意的是：</p>
<ol>
<li>热点数据采集最好采用异步方式，一方面不会影响业务的核心交易链路，一方面可以保证采集方式的通用性</li>
<li>热点发现最好做到秒级实时，这样动态发现才有意义，实际上也是对核心节点的数据采集和分析能力提出了较高的要求</li>
</ol>
<h5 id="热点隔离"><a href="#热点隔离" class="headerlink" title="热点隔离"></a>热点隔离</h5><p>热点数据识别出来之后，第一原则就是将热点数据隔离出来，不要让 1% 影响到另外的 99%，可以基于以下几个层次实现热点隔离：</p>
<ol>
<li>业务隔离。秒杀作为一种营销活动，卖家需要单独报名，从技术上来说，系统可以提前对已知热点做缓存预热</li>
<li>系统隔离。系统隔离是运行时隔离，通过分组部署和另外 99% 进行分离，另外秒杀也可以申请单独的域名，入口层就让请求落到不同的集群中</li>
<li>数据隔离。秒杀数据作为热点数据，可以启用单独的缓存集群或者DB服务组，从而更好的实现横向或纵向能力扩展</li>
</ol>
<p>当然，实现隔离还有很多种办法。比如，可以按照用户来区分，为不同的用户分配不同的  Cookie，入口层路由到不同的服务接口中；再比如，域名保持一致，但后端调用不同的服务接口；又或者在数据层给数据打标进行区分等等，这些措施的目的都是把已经识别的热点请求和普通请求区分开来。</p>
<h5 id="热点优化-1"><a href="#热点优化-1" class="headerlink" title="热点优化"></a>热点优化</h5><p>热点数据隔离之后，也就方便对这 1% 的请求做针对性的优化，方式无外乎两种：</p>
<ol>
<li>缓存：热点缓存是最为有效的办法。如果热点数据做了动静分离，那么可以长期缓存静态数据</li>
<li>限流：流量限制更多是一种保护机制。需要注意的是，各服务要时刻关注请求是否触发限流并及时进行review</li>
</ol>
<h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><p>数据的热点优化与动静分离是不一样的，热点优化是基于二八原则对数据进行了纵向拆分，以便进行针对性地处理。热点识别和隔离不仅对“秒杀”这个场景有意义，对其他的高性能分布式系统也非常有参考价值。</p>
<h3 id="系统优化"><a href="#系统优化" class="headerlink" title="系统优化"></a>系统优化</h3><p>对于一个软件系统，提高性能可以有很多种手段，如提升硬件水平、调优JVM 性能，这里主要关注代码层面的性能优化——</p>
<ol>
<li>减少序列化：减少 Java 中的序列化操作可以很好的提升系统性能。序列化大部分是在 RPC 阶段发生，因此应该尽量减少 RPC 调用，一种可行的方案是将多个关联性较强的应用进行 “合并部署”，从而减少不同应用之间的 RPC 调用（微服务设计规范）</li>
<li>直接输出流数据：只要涉及字符串的I/O操作，无论是磁盘 I/O 还是网络 I/O，都比较耗费 CPU  资源，因为字符需要转换成字节，而这个转换又必须查表编码。所以对于常用数据，比如静态字符串，推荐提前编码成字节并缓存，具体到代码层面就是通过  OutputStream()  类函数从而减少数据的编码转换；另外，热点方法toString()不要直接调用ReflectionToString实现，推荐直接硬编码，并且只打印DO的基础要素和核心要素</li>
<li>裁剪日志异常堆栈：无论是外部系统异常还是应用本身异常，都会有堆栈打出，超大流量下，频繁的输出完整堆栈，只会加剧系统当前负载。可以通过日志配置文件控制异常堆栈输出的深度</li>
<li>去组件框架：极致优化要求下，可以去掉一些组件框架，比如去掉传统的 MVC 框架，直接使用 Servlet 处理请求。这样可以绕过一大堆复杂且用处不大的处理逻辑，节省毫秒级的时间，当然，需要合理评估你对框架的依赖程度</li>
</ol>
<h3 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h3><p>性能优化需要一个基准值，所以系统还需要做好应用基线，比如性能基线（何时性能突然下降）、成本基线（去年大促用了多少机器）、链路基线（核心流程发生了哪些变化），通过基线持续关注系统性能，促使系统在代码层面持续提升编码质量、业务层面及时下掉不合理调用、架构层面不断优化改进。</p>
<p>获取面试小抄：<span class="exturl" data-url="aHR0cDovL21wLndlaXhpbi5xcS5jb20vcz9fX2Jpej1NelU0TURNM01EZ3lNQT09JmFtcDttaWQ9MjI0NzUwMzMyNiZhbXA7aWR4PTEmYW1wO3NuPWEzNWJkNmI2ZGQ2MmQ3NDJmMzRjN2M4MGU4ZjhmNDIxJmFtcDtjaGtzbT1mZDU1NjUzNWNhMjJlYzIzNTBiMzk5ZjMzZmQxMTI1Y2U3NWRkMzRmMTM1MWI0N2NiNzBjMmE2MGZmYWQ4MDM4NTMyMDlmZDA4M2I0JmFtcDtzY2VuZT0yMSN3ZWNoYXRfcmVkaXJlY3Q=">后端面试 23万！<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p>秒杀系统中，库存是个关键数据，卖不出去是个问题，超卖更是个问题。秒杀场景下的一致性问题，主要就是库存扣减的准确性问题。</p>
<h3 id="减库存的方式"><a href="#减库存的方式" class="headerlink" title="减库存的方式"></a>减库存的方式</h3><p>电商场景下的购买过程一般分为两步：下单和付款。“提交订单”即为下单，“支付订单”即为付款。基于此设定，减库存一般有以下几个方式：</p>
<ol>
<li>下单减库存。买家下单后，扣减商品库存。下单减库存是最简单的减库存方式，也是控制最为精确的一种</li>
<li>付款减库存。买家下单后，并不立即扣减库存，而是等到付款后才真正扣减库存。但因为付款时才减库存，如果并发比较高，可能出现买家下单后付不了款的情况，因为商品已经被其他人买走了</li>
<li>预扣库存。这种方式相对复杂一些，买家下单后，库存为其保留一定的时间（如 15 分钟），超过这段时间，库存自动释放，释放后其他买家可以购买</li>
</ol>
<p>能够看到，减库存方式是基于购物过程的多阶段进行划分的，但无论是在下单阶段还是付款阶段，都会存在一些问题，下面进行具体分析。</p>
<h3 id="减库存的问题"><a href="#减库存的问题" class="headerlink" title="减库存的问题"></a>减库存的问题</h3><h4 id="下单减库存"><a href="#下单减库存" class="headerlink" title="下单减库存"></a>下单减库存</h4><p>优势：用户体验最好。下单减库存是最简单的减库存方式，也是控制最精确的一种。下单时可以直接通过数据库事务机制控制商品库存，所以一定不会出现已下单却付不了款的情况。</p>
<p>劣势：可能卖不出去。正常情况下，买家下单后付款概率很高，所以不会有太大问题。但有一种场景例外，就是当卖家参加某个促销活动时，竞争对手通过恶意下单的方式将该商品全部下单，导致库存清零，那么这就不能正常售卖了——要知道，恶意下单的人是不会真正付款的，这正是 “下单减库存” 的不足之处。</p>
<h4 id="付款减库存"><a href="#付款减库存" class="headerlink" title="付款减库存"></a>付款减库存</h4><p>优势：一定实际售卖。“下单减库存” 可能导致恶意下单，从而影响卖家的商品销售， “付款减库存” 由于需要付出真金白银，可以有效避免。</p>
<p>劣势：用户体验较差。用户下单后，不一定会实际付款，假设有 100 件商品，就可能出现 200  人下单成功的情况，因为下单时不会减库存，所以也就可能出现下单成功数远远超过真正库存数的情况，这尤其会发生在大促的热门商品上。如此一来就会导致很多买家下单成功后却付不了款，购物体验自然是比较差的。</p>
<h4 id="预扣库存"><a href="#预扣库存" class="headerlink" title="预扣库存"></a>预扣库存</h4><p>优势：缓解了以上两种方式的问题。预扣库存实际就是“下单减库存”和 “付款减库存”两种方式的结合，将两次操作进行了前后关联，下单时预扣库存，付款时释放库存。</p>
<p>劣势：并没有彻底解决以上问题。比如针对恶意下单的场景，虽然可以把有效付款时间设置为 10 分钟，但恶意买家完全可以在 10 分钟之后再次下单。</p>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>减库存的问题主要体现在用户体验和商业诉求两方面，其本质原因在于购物过程存在两步甚至多步操作，在不同阶段减库存，容易存在被恶意利用的漏洞。</p>
<h3 id="实际如何减库存"><a href="#实际如何减库存" class="headerlink" title="实际如何减库存"></a>实际如何减库存</h3><p>业界最为常见的是预扣库存。无论是外卖点餐还是电商购物，下单后一般都有个 “有效付款时间”，超过该时间订单自动释放，这就是典型的预扣库存方案。但如上所述，预扣库存还需要解决恶意下单的问题，保证商品卖的出去；另一方面，如何避免超卖，也是一个痛点。</p>
<ol>
<li>卖的出去：恶意下单的解决方案主要还是结合安全和反作弊措施来制止。比如，识别频繁下单不付款的买家并进行打标，这样可以在打标买家下单时不减库存；再比如为大促商品设置单人最大购买件数，一人最多只能买 N 件商品；又或者对重复下单不付款的行为进行次数限制阻断等</li>
<li>避免超卖：库存超卖的情况实际分为两种。对于普通商品，秒杀只是一种大促手段，即使库存超卖，商家也可以通过补货来解决；而对于一些商品，秒杀作为一种营销手段，完全不允许库存为负，也就是在数据一致性上，需要保证大并发请求时数据库中的库存字段值不能为负，一般有多种方案：一是在通过事务来判断，即保证减后库存不能为负，否则就回滚；二是直接设置数据库字段类型为无符号整数，这样一旦库存为负就会在执行 SQL 时报错；三是使用 CASE WHEN 判断语句——</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UPDATE item <span class="keyword">SET</span> inventory <span class="operator">=</span> <span class="keyword">CASE</span> <span class="keyword">WHEN</span> inventory <span class="operator">&gt;=</span> xxx <span class="keyword">THEN</span> inventory<span class="operator">-</span>xxx <span class="keyword">ELSE</span> inventory <span class="keyword">END</span></span><br></pre></td></tr></table></figure>
<p>业务手段保证商品卖的出去，技术手段保证商品不会超卖，库存问题从来就不是简单的技术难题，解决问题的视角是多种多样的。</p>
<h3 id="一致性性能的优化"><a href="#一致性性能的优化" class="headerlink" title="一致性性能的优化"></a>一致性性能的优化</h3><p>库存是个关键数据，更是个热点数据。对系统来说，热点的实际影响就是 “高读” 和 “高写”，也是秒杀场景下最为核心的一个技术难题。</p>
<h4 id="高并发读"><a href="#高并发读" class="headerlink" title="高并发读"></a>高并发读</h4><p>秒杀场景解决高并发读问题，关键词是“分层校验”。即在读链路时，只进行不影响性能的检查操作，如用户是否具有秒杀资格、商品状态是否正常、用户答题是否正确、秒杀是否已经结束、是否非法请求等，而不做一致性校验等容易引发瓶颈的检查操作；直到写链路时，才对库存做一致性检查，在数据层保证最终准确性。</p>
<p>因此，在分层校验设定下，系统可以采用分布式缓存甚至LocalCache来抵抗高并发读。即允许读场景下一定的脏数据，这样只会导致少量原本无库存的下单请求被误认为是有库存的，等到真正写数据时再保证最终一致性，由此做到高可用和一致性之间的平衡。</p>
<p>实际上，分层校验的核心思想是：不同层次尽可能过滤掉无效请求，只在“漏斗” 最末端进行有效处理，从而缩短系统瓶颈的影响路径。</p>
<h4 id="高并发写"><a href="#高并发写" class="headerlink" title="高并发写"></a>高并发写</h4><p>高并发写的优化方式，一种是更换DB选型，一种是优化DB性能，以下分别进行讨论。</p>
<h5 id="更换DB选型"><a href="#更换DB选型" class="headerlink" title="更换DB选型"></a><strong>更换DB选型</strong></h5><p>秒杀商品和普通商品的减库存是有差异的，核心区别在数据量级小、交易时间短，因此能否把秒杀减库存直接放到缓存系统中实现呢，也就是直接在一个带有持久化功能的缓存中进行减库存操作，比如 Redis？</p>
<p>如果减库存逻辑非常单一的话，比如没有复杂的 SKU 库存和总库存这种联动关系的话，个人认为是完全可以的。但如果有比较复杂的减库存逻辑，或者需要使用到事务，那就必须在数据库中完成减库存操作。</p>
<h5 id="优化DB性能"><a href="#优化DB性能" class="headerlink" title="优化DB性能"></a><strong>优化DB性能</strong></h5><p>库存数据落地到数据库实现其实是一行存储（MySQL），因此会有大量线程来竞争 InnoDB 行锁。但并发越高，等待线程就会越多，TPS 下降，RT 上升，吞吐量会受到严重影响——注意，这里假设数据库已基于上文【性能优化】完成数据隔离，以便于讨论聚焦 。</p>
<p>解决并发锁的问题，有两种办法：</p>
<ol>
<li>应用层排队。通过缓存加入集群分布式锁，从而控制集群对数据库同一行记录进行操作的并发度，同时也能控制单个商品占用数据库连接的数量，防止热点商品占用过多的数据库连接</li>
<li>数据层排队。应用层排队是有损性能的，数据层排队是最为理想的。业界中，阿里的数据库团队开发了针对InnoDB 层上的补丁程序（patch），可以基于DB层对单行记录做并发排队，从而实现秒杀场景下的定制优化——注意，排队和锁竞争是有区别的，如果熟悉  MySQL 的话，就会知道 InnoDB 内部的死锁检测，以及 MySQL Server 和 InnoDB  的切换都是比较消耗性能的。另外阿里的数据库团队还做了很多其他方面的优化，如 COMMIT_ON_SUCCESS 和  ROLLBACK_ON_FAIL 的补丁程序，通过在 SQL 里加入提示（hint），实现事务不需要等待实时提交，而是在数据执行完最后一条  SQL 后，直接根据 TARGET_AFFECT_ROW 的结果进行提交或回滚，减少网络等待的时间（毫秒级）。目前阿里已将包含这些补丁程序的  MySQL 开源，Github上搜索“<strong>AliSQL</strong>”即可找到。</li>
</ol>
<h4 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h4><p>高读和高写的两种处理方式大相径庭。读请求的优化空间要大一些，而写请求的瓶颈一般都在存储层，优化思路的本质还是基于 CAP 理论做平衡。</p>
<h3 id="总结一下-1"><a href="#总结一下-1" class="headerlink" title="总结一下"></a>总结一下</h3><p>当然，减库存还有很多细节问题，例如预扣的库存超时后如何进行回补，再比如第三方支付如何保证减库存和付款时的状态一致性，这些也是很大的挑战。</p>
<p>获取面试小抄：<span class="exturl" data-url="aHR0cDovL21wLndlaXhpbi5xcS5jb20vcz9fX2Jpej1NelU0TURNM01EZ3lNQT09JmFtcDttaWQ9MjI0NzUwMzMyNiZhbXA7aWR4PTEmYW1wO3NuPWEzNWJkNmI2ZGQ2MmQ3NDJmMzRjN2M4MGU4ZjhmNDIxJmFtcDtjaGtzbT1mZDU1NjUzNWNhMjJlYzIzNTBiMzk5ZjMzZmQxMTI1Y2U3NWRkMzRmMTM1MWI0N2NiNzBjMmE2MGZmYWQ4MDM4NTMyMDlmZDA4M2I0JmFtcDtzY2VuZT0yMSN3ZWNoYXRfcmVkaXJlY3Q=">后端面试 23万！<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><p>盯过秒杀流量监控的话，会发现它不是一条蜿蜒而起的曲线，而是一条挺拔的直线，这是因为秒杀请求高度集中于某一特定的时间点。这样一来就会造成一个特别高的零点峰值，而对资源的消耗也几乎是瞬时的。所以秒杀系统的可用性保护是不可或缺的。</p>
<h3 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a>流量削峰</h3><p>对于秒杀的目标场景，最终能够抢到商品的人数是固定的，无论 100 人和 10000  人参加结果都是一样的，即有效请求额度是有限的。并发度越高，无效请求也就越多。但秒杀作为一种商业营销手段，活动开始之前是希望有更多的人来刷页面，只是真正开始后，秒杀请求不是越多越好。因此系统可以设计一些规则，人为的延缓秒杀请求，甚至可以过滤掉一些无效请求。</p>
<h4 id="答题"><a href="#答题" class="headerlink" title="答题"></a>答题</h4><p>早期秒杀只是简单的点击秒杀按钮，后来才增加了答题。为什么要增加答题呢？主要是通过提升购买的复杂度，达到两个目的：</p>
<ol>
<li>防止作弊。早期秒杀器比较猖獗，存在恶意买家或竞争对手使用秒杀器扫货的情况，商家没有达到营销的目的，所以增加答题来进行限制</li>
<li>延缓请求。零点流量的起效时间是毫秒级的，答题可以人为拉长峰值下单的时长，由之前的 &lt;1s 延长到  &lt;10s。这个时间对于服务端非常重要，会大大减轻高峰期并发压力；另外，由于请求具有先后顺序，答题后置的请求到来时可能已经没有库存了，因此根本无法下单，此阶段落到数据层真正的写也就非常有限了</li>
</ol>
<p>需要注意的是，答题除了做正确性验证，还需要对提交时间做验证，比如&lt;1s 人为操作的可能性就很小，可以进一步防止机器答题的情况。</p>
<p>答题目前已经使用的非常普遍了，本质是通过在入口层削减流量，从而让系统更好地支撑瞬时峰值。</p>
<h4 id="排队"><a href="#排队" class="headerlink" title="排队"></a>排队</h4><p>最为常见的削峰方案是使用消息队列，通过把同步的直接调用转换成异步的间接推送缓冲瞬时流量。除了消息队列，类似的排队方案还有很多，例如：</p>
<ol>
<li>线程池加锁等待</li>
<li>本地内存蓄洪等待</li>
<li>本地文件序列化写，再顺序读</li>
</ol>
<p>排队方式的弊端也是显而易见的，主要有两点：</p>
<ol>
<li>请求积压。流量高峰如果长时间持续，达到了队列的水位上限，队列同样会被压垮，这样虽然保护了下游系统，但是和请求直接丢弃也没多大区别</li>
<li>用户体验。异步推送的实时性和有序性自然是比不上同步调用的，由此可能出现请求先发后至的情况，影响部分敏感用户的购物体验</li>
</ol>
<p>排队本质是在业务层将一步操作转变成两步操作，从而起到缓冲的作用，但鉴于此种方式的弊端，最终还是要基于业务量级和秒杀场景做出妥协和平衡。</p>
<h4 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h4><p>过滤的核心结构在于分层，通过在不同层次过滤掉无效请求，达到数据读写的精准触发。常见的过滤主要有以下几层：</p>
<p>1、读限流：对读请求做限流保护，将超出系统承载能力的请求过滤掉 2、读缓存：对读请求做数据缓存，将重复的请求过滤掉 3、写限流：对写请求做限流保护，将超出系统承载能力的请求过滤掉 4、写校验：对写请求做一致性校验，只保留最终的有效数据</p>
<p>过滤的核心目的是通过减少无效请求的数据IO保障有效请求的IO性能。</p>
<h4 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h4><p>系统可以通过入口层的答题、业务层的排队、数据层的过滤达到流量削峰的目的，本质是在寻求商业诉求与架构性能之间的平衡。另外，新的削峰手段也层出不穷，以业务切入居多，比如零点大促时同步发放优惠券或发起抽奖活动，将一部分流量分散到其他系统，这样也能起到削峰的作用。</p>
<h3 id="Plan-B"><a href="#Plan-B" class="headerlink" title="Plan B"></a>Plan B</h3><p>当一个系统面临持续的高峰流量时，其实是很难单靠自身调整来恢复状态的，日常运维没有人能够预估所有情况，意外总是无法避免。尤其在秒杀这一场景下，为了保证系统的高可用，必须设计一个 Plan B 方案来进行兜底。</p>
<p>高可用建设，其实是一个系统工程，贯穿在系统建设的整个生命周期。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/12/0935-2nik5m.png" alt="图片"></p>
<p>具体来说，系统的高可用建设涉及架构阶段、编码阶段、测试阶段、发布阶段、运行阶段，以及故障发生时，逐一进行分析：</p>
<ol>
<li>架构阶段：考虑系统的可扩展性和容错性，避免出现单点问题。例如多地单元化部署，即使某个IDC甚至地市出现故障，仍不会影响系统运转</li>
<li>编码阶段：保证代码的健壮性，例如RPC调用时，设置合理的超时退出机制，防止被其他系统拖垮，同时也要对无法预料的返回错误进行默认的处理</li>
<li>测试阶段：保证CI的覆盖度以及Sonar的容错率，对基础质量进行二次校验，并定期产出整体质量的趋势报告</li>
<li>发布阶段：系统部署最容易暴露错误，因此要有前置的checklist模版、中置的上下游周知机制以及后置的回滚机制</li>
<li>运行阶段：系统多数时间处于运行态，最重要的是运行时的实时监控，及时发现问题、准确报警并能提供详细数据，以便排查问题</li>
<li>故障发生：首要目标是及时止损，防止影响面扩大，然后定位原因、解决问题，最后恢复服务</li>
</ol>
<p>对于日常运维而言，高可用更多是针对运行阶段而言的，此阶段需要额外进行加强建设，主要有以下几种手段：</p>
<ol>
<li>预防：建立常态压测体系，定期对服务进行单点压测以及全链路压测，摸排水位</li>
<li>管控：做好线上运行的降级、限流和熔断保护。需要注意的是，无论是限流、降级还是熔断，对业务都是有损的，所以在进行操作前，一定要和上下游业务确认好再进行。就拿限流来说，哪些业务可以限、什么情况下限、限流时间多长、什么情况下进行恢复，都要和业务方反复确认</li>
<li>监控：建立性能基线，记录性能的变化趋势；建立报警体系，发现问题及时预警</li>
<li>恢复：遇到故障能够及时止损，并提供快速的数据订正工具，不一定要好，但一定要有</li>
</ol>
<p>在系统建设的整个生命周期中，每个环节中都可能犯错，甚至有些环节犯的错，后面是无法弥补的或者成本极高的。所以高可用是一个系统工程，必须放到整个生命周期中进行全面考虑。同时，考虑到服务的增长性，高可用更需要长期规划并进行体系化建设。</p>
<h3 id="总结一下-2"><a href="#总结一下-2" class="headerlink" title="总结一下"></a>总结一下</h3><p>高可用其实是在说  “稳定性”，稳定性是一个平时不重要，但出了问题就要命的事情，然而它的落地又是一个问题——平时业务发展良好，稳定性建设就会降级给业务让路。解决这个问题必须在组织上有所保障，比如让业务负责人背上稳定性绩效指标，同时在部门中建立稳定性建设小组，小组成员由每条线的核心力量兼任，绩效由稳定性负责人来打分，这样就可以把体系化的建设任务落实到具体的业务系统中了。</p>
<h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h2><p>一个秒杀系统的设计，可以根据不同级别的流量，由简单到复杂打造出不同的架构，本质是各方面的取舍和权衡。当然，你可能注意到，本文并没有涉及具体的选型方案，因为这些对于架构来说并不重要，作为架构师，应该时刻提醒自己主线是什么。</p>
<hr>
<blockquote>
<p>原文：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvX01nMjByQldORlFOMVFDa2JjY3U4QQ==">在线面试：如何设计一个秒杀系统？<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
]]></content>
      <categories>
        <category>功能实现方案</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>C</tag>
        <tag>内存</tag>
        <tag>sql</tag>
        <tag>事务</tag>
        <tag>数据库</tag>
        <tag>堆</tag>
        <tag>栈</tag>
        <tag>函数</tag>
        <tag>CPU</tag>
        <tag>面试</tag>
        <tag>Mysql</tag>
        <tag>线程池</tag>
        <tag>锁</tag>
        <tag>分布式</tag>
        <tag>Redis</tag>
        <tag>并发</tag>
        <tag>容器</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>秒杀系统设计</title>
    <url>/posts/J71QTX.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>原文：<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODYxNzQ5MjM4NDY2NTc2Mzk3">秒杀系统设计 - 掘金<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>带着大家看看一个秒杀的设计细节以及中间各种解决方案的利弊，以下就是我设计的秒杀系统，几乎涵盖了市面上所有秒杀的实现细节：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/16/1203-rbO6wl.jpg" alt="img"></p>
<p>首先设计一个系统之前，我们需要先确认我们的业务场景是怎么样子的，我就<strong>带着大家一起假设一个场景</strong>好吧。</p>
<p>我们现场要卖1000件下面这个<strong>婴儿纸尿裤</strong>，然后我们根据以往这样秒杀活动的数据经验来看，目测来抢这100件纸尿裤的人足足有10万人。（南极人打钱！）</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/16/1204-sjhL3N.jpg" alt="img"></p>
<p>你一听，完了呀，这我们的服务器哪里顶得住啊！说真的直接打DB肯定挂，但是别急嘛，有<strong>暖男</strong>敖丙在，任何系统我们开始设计之前我们都应该去思考<strong>会出现哪些问题</strong>？这里我罗列了几个非常经典的问题：</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h3><p>是的<strong>高并发</strong>这个是我们想都不用想的一个点，一瞬间这么多人进来这不是高并发什么时候是呢？</p>
<p>是吧，秒杀的特点就是这样<strong>时间极短</strong>、 <strong>瞬间用户量大</strong>。</p>
<p>正常的店铺营销都是用极低的价格配合上短信、APP的精准推送，吸引特别多的用户来参与这场秒杀，<strong>爽了商家苦了开发呀</strong>。</p>
<p>秒杀大家都知道如果真的营销到位，价格诱人，几十万的流量我觉得完全不是问题，那单机的<strong>Redis</strong>我感觉3-4W的QPS还是能顶得住的，但是再高了就没办法了，那这个数据随便搞个热销商品的秒杀可能都不止了。</p>
<p>大量的请求进来，我们需要考虑的点就很多了，<strong>缓存雪崩</strong>，<strong>缓存击穿</strong>，<strong>缓存穿透</strong>这些我之前提到的点都是有可能发生的，出现问题打挂DB那就很难受了，活动失败用户体验差，活动人气没了，最后背锅的还是<strong>开发</strong>。</p>
<h3 id="超卖"><a href="#超卖" class="headerlink" title="超卖"></a>超卖</h3><p>但凡是个秒杀，都怕<strong>超卖</strong>，我这里举例的只是尿不湿，要是换成100个MacBook Pro，商家的预算经费卖100个可以赚点还可以造势，结果你写错程序多卖出去200个，你不发货用户<strong>投诉你</strong>，平台<strong>封你店</strong>，你发货就<strong>血亏</strong>，你怎么办？ （没事看了敖丙的文章直接不怕）</p>
<p>那最后只能<strong>杀个开发祭天</strong>解气了，秒杀的价格本来就低了，基本上都是不怎么赚钱的，超卖了就恐怖了呀，所以超卖也是很关键的一个点。</p>
<h3 id="恶意请求"><a href="#恶意请求" class="headerlink" title="恶意请求"></a>恶意请求</h3><p>你这么低的价格，假如我抢到了，我转手卖掉我不是<strong>血赚</strong>？就算我不卖我也不亏啊，那用户知道，你知道，别的别有用心的人（黑客、黄牛…）肯定也知道的。</p>
<p>那简单啊，我知道你什么时候抢，我搞个几十台机器搞点脚本，我也模拟出来十几万个人左右的请求，那我是不是意味着我基本上有80%的成功率了。</p>
<p>真实情况可能远远不止，因为机器请求的速度比人的手速往往快太多了，在贵州的敖丙我每年回家抢高铁票都是<strong>秒光</strong>的，我也不知道有没有黄牛的功劳，我要Diss你，黄牛。杰伦演唱会门票抢不到，我也Diss你。</p>
<p>Tip：科普下，小道消息了解到的，黄牛的抢票系统，比国内很多小公司的系统还吊很多，架构设计都是顶级的，我用<strong>顶配的服务</strong>加上<strong>顶配的架构设计</strong>，你还想看演唱会？还想回家？</p>
<p>不过不用黄牛我回家都难，我们云贵川跟我一样要回家过年的仔太多了555！</p>
<h3 id="链接暴露"><a href="#链接暴露" class="headerlink" title="链接暴露"></a>链接暴露</h3><p>前面几个问题大家可能都很好理解，一看到这个有的小伙伴可能会比较疑惑，啥是<strong>链接暴露</strong>呀？</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/16/1209-DpmkpH.jpg" alt="img"></p>
<p>相信是个开发同学都对这个画面一点都不陌生吧，懂点行的仔都可以打开谷歌的<strong>开发者模式</strong>，然后看看你的网页代码，有的就有URL，但是我写VUE的时候是事件触发然后去调用文件里面的接口看源码看不到，但是我可以点击一下<strong>查看你的请求地址</strong>啊，不过你好像可以对按钮在秒杀前置灰。</p>
<p>不管怎么样子都有危险，撇开外面的所有的东西你都挡住了，你卖这个东西实在便宜得过分，有诱惑力，你能保证<strong>开发不动心</strong>？开发知道地址，在秒杀的时候自己提前请求。。。（开发：怎么TM又是我）</p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>每秒上万甚至十几万的<strong>QPS</strong>（每秒请求数）直接打到<strong>数据库</strong>，基本上都要把库打挂掉，而且你服务不单单是做秒杀的还涉及其他的业务，你没做<strong>降级、限流、熔断</strong>啥的，别的一起挂，小公司的话可能<strong>全站崩溃404</strong>。</p>
<p>反正不管你秒杀怎么挂，你别把别的搞挂了对吧，搞挂了就不是杀一个程序员能搞定的。</p>
<p>程序员：我TM好难啊！</p>
<p><strong>问题都列出来了，那怎么设计，怎么解决这些问题就是接下去要考虑的了，我们对症下药。</strong></p>
<p>我会从我设计的秒杀系统从上到下去给大家介绍我们正常电商秒杀系统在每一层做了些什么，每一层存在的问题，难点等。</p>
<p>我们从前端开始：</p>
<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>秒杀系统普遍都是商城网页、H5、APP、小程序这几项。</p>
<p>在前端这一层其实我们可以做的事情有很多，如果用node去做，甚至能直接处理掉整个秒杀，但是node其实应该属于后端，所以我不讨论node Service了。</p>
<h3 id="资源静态化"><a href="#资源静态化" class="headerlink" title="资源静态化"></a>资源静态化</h3><p>秒杀一般都是特定的商品还有页面模板，现在一般都是前后端分离的，页面一般都是不会经过后端的，但是前端也要自己的服务器啊，那就把能提前放入<strong>cdn服务器</strong>的东西都放进去，反正把所有能提升效率的步骤都做一下，减少真正秒杀时候服务器的压力。</p>
<h3 id="秒杀链接加盐"><a href="#秒杀链接加盐" class="headerlink" title="秒杀链接加盐"></a>秒杀链接加盐</h3><p>我们上面说了链接要是提前暴露出去可能有人直接访问url就提前秒杀了，那又有小伙伴要说了我做个时间的校验就好了呀，那我告诉你，知道链接的地址比起页面人工点击的还是有<strong>很大优势</strong>。</p>
<p>我知道url了，那我通过程序不断获取最新的北京时间，可以达到<strong>毫秒级别</strong>的，我就在00毫秒的时候请求，我敢说绝对比你人工点的成功率大太多了，而且我可以一毫秒发送N次请求，搞不好你卖100个产品我全拿了。</p>
<p><strong>那这种情况怎么避免？</strong></p>
<p>简单，把<strong>URL动态化</strong>，就连写代码的人都不知道，你就通过MD5之类的摘要算法加密随机的字符串去做url，然后通过前端代码获取url后台校验才能通过。</p>
<p>这个只能防止一部分没耐心继续破解下去的黑客，有耐心的人研究出来还是能破解，在电商场景存在很多这样的羊毛党，那怎么做呢？</p>
<p>后面我会说。</p>
<h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><p>限流这里我觉得应该分为<strong>前端限流</strong>和<strong>后端限流</strong>。</p>
<p><strong>物理控制：</strong></p>
<p>大家有没有发现没到秒杀前，一般按钮都是<strong>置灰</strong>的，只有时间到了，才能点击。</p>
<p>这是因为怕大家在时间快到的最后几秒秒疯狂请求服务器，然后还没到秒杀的时候基本上服务器就挂了。</p>
<p>这个时候就需要前端的配合，定时去请求你的后端服务器，获取最新的北京时间，到时间点再给按钮可用状态。</p>
<p>按钮可以点击之后也得给他置灰几秒，不然他一样在开始之后一直点的。</p>
<p><strong>你敢说你们秒杀的时候不是这样的？</strong></p>
<p><strong>前端限流</strong>：这个很简单，一般秒杀不会让你一直点的，一般都是点击一下或者两下然后几秒之后才可以继续点击，这也是保护服务器的一种手段。</p>
<p><strong>后端限流</strong>：秒杀的时候肯定是涉及到后续的订单生成和支付等操作，但是都只是成功的幸运儿才会走到那一步，那一旦100个产品卖光了，return了一个false，前端直接秒杀结束，然后你后端也关闭后续无效请求的介入了。</p>
<p>Tip：真正的限流还会有限流组件的加入例如：阿里的Sentinel、Hystrix等。我这里就不展开了，就说一下物理的限流。</p>
<p>我们卖1000件商品，请求有10W，我们不需要把十万都放进来，你可以放1W请求进来，然后再进行操作，因为秒杀对于用户本身就是黑盒的，所以你怎么做的他们是没感知的，至于为啥放1W进来，而不是刚好1000，是因为会丢掉一些薅羊毛的用户，至于怎么判断，后面的风控阶段我会说。</p>
<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p><strong>Nginx</strong>大家想必都不陌生了吧，这玩意是<strong>高性能的web服务器</strong>，并发也随便顶几万不是梦，但是我们的<strong>Tomcat</strong>只能顶几百的并发呀，那简单呀<strong>负载均衡</strong>嘛，一台服务几百，那就多搞点，在秒杀的时候多租点<strong>流量机</strong>。</p>
<p>Tip：据我所知国内某大厂就是在去年春节活动期间租光了亚洲所有的服务器，小公司也很喜欢在双十一期间买流量机来顶住压力。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/16/1212-GXp2le.jpg" alt="img"></p>
<p><strong>这样一对比是不是觉得你的集群能顶很多了。</strong></p>
<p><strong>恶意请求拦截</strong>也需要用到它，一般单个用户请求次数太夸张，不像人为的请求在网关那一层就得拦截掉了，不然请求多了他抢不抢得到是一回事，服务器压力上去了，可能占用网络带宽或者把<strong>服务器打崩、缓存击穿</strong>等等。</p>
<h2 id="风控"><a href="#风控" class="headerlink" title="风控"></a>风控</h2><p>我可以明确的告诉大家，前面的所有措施还是拦不住很多羊毛党，因为他们是专业的团队，他们可以注册很多账号来薅你的羊毛，而且不用机器请求，就用群控，操作几乎跟真实用户一模一样。</p>
<p><strong>那怎么办，是不是无解了？</strong></p>
<p>这个时候就需要风控同学的介入了，在请求到达后端之前，风控可以根据账号行为分析出这个账号机器人的概率大不大，我现在负责公司的某些特殊系统，每个用户的行为都是会送到我们大数据团队进行分析处理，给你打上对应标签的。</p>
<p>那黑客其实也有办法：<strong>养号</strong></p>
<p>他们去黑市买真实用户有过很多记录的账号，买到了还不闲着，帮他们去购物啥的，让系统无法识别他们是黑号还是真实用户的号。</p>
<p><strong>怎么办？</strong></p>
<p>通杀！是的没有办法，只能通杀了，通杀的意思就是，我们通过风管分析出来这个用户是真实用户的概率没有其他用户概率大，那就认为他是机器了，丢弃他的请求。</p>
<p>之前的限流我们放进来10000个请求，但是我们真正的库存只有1000个，那我们就算出最有可能是真实用户的1000人进行秒杀，丢弃其他请求，因为秒杀本来就是黑盒操作的，用户层面是无感知的，这样设计能让真实的用户买到东西，还可以减少自己被薅羊毛的概率。</p>
<p>风控可以说是流量进入的最后一道门槛了，所以很多公司的风控是很强的，蚂蚁金服的风控大家如果了解过就知道了，你的资金在支付宝被盗了，他们是能做到全款补偿是有原因的。</p>
<h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><h3 id="服务单一职责"><a href="#服务单一职责" class="headerlink" title="服务单一职责"></a>服务单一职责</h3><p>设计个能抗住高并发的系统，我觉得还是得<strong>单一职责</strong>。</p>
<p>什么意思呢，大家都知道现在设计都是<strong>微服务的设计思想</strong>，然后再用<strong>分布式的部署方式</strong>。</p>
<p>也就是我们下单是有个订单服务，用户登录管理等有个用户服务等等，那为啥我们不给秒杀也开个服务，我们把秒杀的代码业务逻辑放一起。</p>
<p>单一职责的好处就是就算秒杀没抗住，秒杀库崩了，服务挂了，也不会影响到其他的服务。（高可用）</p>
<h3 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h3><p>之前不是说单机的<strong>Redis</strong>顶不住嘛，那简单多找几个兄弟啊，秒杀本来就是读多写少，那你们是不是瞬间想起来我之前跟你们提到过的，<strong>Redis集群</strong>，<strong>主从同步</strong>、<strong>读写分离</strong>，我们还搞点<strong>哨兵</strong>，开启<strong>持久化</strong>直接无敌高可用！</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/16/1214-7Eeoyi.jpg" alt="img"></p>
<h3 id="库存预热"><a href="#库存预热" class="headerlink" title="库存预热"></a>库存预热</h3><p><strong>秒杀的本质，就是对库存的抢夺</strong>，每个秒杀的用户来你都去数据库查询库存校验库存，然后扣减库存，撇开性能因数，你不觉得这样好繁琐，对业务开发人员都不友好，而且数据库顶不住啊。</p>
<p><strong>开发：你tm总算为我着想一次了。</strong></p>
<h4 id="那怎么办？"><a href="#那怎么办？" class="headerlink" title="那怎么办？"></a>那怎么办？</h4><p>我们都知道数据库顶不住但是他的兄弟非关系型的数据库<strong>Redis</strong>能顶啊！</p>
<p>那不简单了，我们要开始秒杀前你通过定时任务或者运维同学<strong>提前把商品的库存加载到Redis中</strong>去，让整个流程都在Redis里面去做，然后等秒杀介绍了，再异步的去修改库存就好了。</p>
<p>但是用了Redis就有一个问题了，我们上面说了我们采用<strong>主从</strong>，就是我们会去读取库存然后再判断然后有库存才去减库存，正常情况没问题，但是高并发的情况问题就很大了。</p>
<p><strong>多品几遍！！！</strong>就比如现在库存只剩下1个了，我们高并发嘛，4个服务器一起查询了发现都是还有1个，那大家都觉得是自己抢到了，就都去扣库存，那结果就变成了-3，是的只有一个是真的抢到了，别的都是超卖的。咋办？</p>
<h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>Redis本身是支持事务的，而且他有很多原子命令的，大家也可以用LUA，还可以用他的管道，乐观锁他也知支持。</p>
<h5 id="限流-amp-降级-amp-熔断-amp-隔离"><a href="#限流-amp-降级-amp-熔断-amp-隔离" class="headerlink" title="限流&amp;降级&amp;熔断&amp;隔离"></a>限流&amp;降级&amp;熔断&amp;隔离</h5><p>这个为啥要做呢，不怕一万就怕万一，万一你真的顶不住了，<strong>限流</strong>，顶不住就挡一部分出去但是不能说不行，<strong>降级</strong>，降级了还是被打挂了，<strong>熔断</strong>，至少不要影响别的系统，<strong>隔离</strong>，你本身就独立的，但是你会调用其他的系统嘛，你快不行了你别拖累兄弟们啊。</p>
<h5 id="消息队列（削峰填谷）"><a href="#消息队列（削峰填谷）" class="headerlink" title="消息队列（削峰填谷）"></a>消息队列（削峰填谷）</h5><p>一说到这个名词，很多小伙伴就知道了，对的<strong>MQ</strong>，你买东西少了你直接100个请求改库我觉得没问题，但是万一秒杀一万个，10万个呢？服务器挂了，<strong>程序员又要背锅的</strong>。</p>
<p>秒杀就是这种瞬间流量很高，但是平时又没有流量的场景，那消息队列完全契合这样的场景了呀，削峰填谷。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/16/1217-Dt9Uqe.jpg" alt="img"></p>
<p>Tip：<strong>可能小伙伴说我们业务达不到这个量级，没必要。但是我想说我们写代码，就不应该写出有逻辑漏洞的代码，至少以后公司体量上去了，别人一看居然不用改代码，一看代码作者是敖丙？有点东西！</strong></p>
<p>你可以把它放消息队列，然后一点点消费去改库存就好了嘛，不过单个商品其实一次修改就够了，我这里说的是<strong>某个点多个商品</strong>一起秒杀的场景，像极了双十一零点。</p>
<h2 id="数据库-1"><a href="#数据库-1" class="headerlink" title="数据库"></a>数据库</h2><p>数据库用MySQL只要连接池设置合理一般问题是不大的，不过一般大公司不缺钱而且秒杀这样的活动十分频繁，我之前所在的公司就是这样秒杀特卖这样的场景一直都是不间断的。</p>
<p>单独给秒杀建立一个数据库，为秒杀服务，表的设计也是竟可能的简单点，现在的互联网架构部署都是<strong>分库</strong>的。</p>
<p>至于表就看大家怎么设计了，该设置索引的地方还是要设置索引的，建完后记得用<strong>explain</strong>看看<strong>SQL</strong>的执行计划。（不了解的小伙伴也没事，MySQL章节去康康）</p>
<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p><strong>这为啥我不放在后端而放到最后来讲呢？</strong></p>
<p>因为上面的任何一步都是可能出错的，而且我们是在不同的服务里面出错的，那就涉及分布式事务了，但是分布式事务大家想的是一定要成功什么的那就不对了，还是那句话，几个请求丢了就丢了，要保证时效和服务的可用可靠。</p>
<p>所以<strong>TCC</strong>和<strong>最终一致性</strong>其实不是很适合，TCC开发成本很大，所有接口都要写三次，因为涉及TCC的三个阶段。</p>
<p>最终一致性基本上都是靠轮训的操作去保证一个操作一定成功，那时效性就大打折扣了。</p>
<p>大家觉得不那么可靠的<strong>两段式（2PC）</strong>和<strong>三段式（3PC）</strong>就派上用场了，他们不一定能保证数据最终一致，但是效率上还算ok。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里我想我已经基本上把该考虑的点还有对应的解决方案也都说了一下，不知道还有没有没考虑到的，但是就算没考虑到我想我这个设计，应该也能撑住一个完整的秒杀流程。</p>
<p>最后大家再看看这个秒杀系统或许会有新的感悟，是不是一个系统真的没有大家想的那么简单，而且我还是有漏掉的细节，这是一定的。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/16/1218-JVbQcu.jpg" alt="img"></p>
<p>秒杀不一定是每个同学都会问到的，至少肯定没<strong>Redis基础</strong>那样常问，但是一旦问到，大家一定要回答到点上。</p>
<p>至少你得说出<strong>可能出现的情况</strong>，<strong>需要注意的情况</strong>，以及对于的<strong>解决思路和方案</strong>，因为这才是一个coder的基本素养，这些你不考虑你也很难去进步。</p>
<p>最后就是需要对整个链路比较熟悉，注意是一个完整的链路，前端怎么设计的呀，网关的作用呀，怎么<strong>解决Redis的并发竞争</strong>啊，<strong>数据的同步方式</strong>呀，<strong>MQ的作用</strong>啊等等，相信你会有不错的收获。</p>
<p>不知道这是一次成功还是失败的二创，我里面所有提到的技术细节我都写了对应的文章，大家可以关注我去历史文章看看，天色已晚，我溜了。</p>
]]></content>
      <categories>
        <category>功能实现方案</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>sql</tag>
        <tag>事务</tag>
        <tag>数据库</tag>
        <tag>Mysql</tag>
        <tag>锁</tag>
        <tag>索引</tag>
        <tag>分布式</tag>
        <tag>Redis</tag>
        <tag>MQ</tag>
        <tag>并发</tag>
        <tag>算法</tag>
        <tag>Nginx</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>java锁面试题</title>
    <url>/posts/D7TEMP.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p> <img data-src="https://xuemingde.com/pages/image/others/1607395612436-12737bf6-516f-49fb-b00f-41287fe5cbe8.png" alt=""></p>
<h3 id="java中有哪些锁"><a href="#java中有哪些锁" class="headerlink" title="java中有哪些锁"></a>java中有哪些锁</h3><ul>
<li>公平锁/非公平锁</li>
<li>可重入锁</li>
<li>独享锁/共享锁</li>
<li>互斥锁/读写锁</li>
<li>乐观锁/悲观锁</li>
<li>分段锁</li>
<li>偏向锁/轻量级锁/重量级锁</li>
<li>自旋锁<br>​<h3 id="乐观锁-VS-悲观锁"><a href="#乐观锁-VS-悲观锁" class="headerlink" title="乐观锁 VS 悲观锁"></a>乐观锁 VS 悲观锁</h3></li>
</ul>
<h4 id="乐观锁的概念"><a href="#乐观锁的概念" class="headerlink" title="乐观锁的概念"></a>乐观锁的概念</h4><p>乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。<br><img data-src="https://xuemingde.com/pages/image/others/1607396932222-6d3fc249-1ac9-496e-b076-a90db2424fe2.png" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ------------------------- 乐观锁的调用方式 -------------------------</span></span><br><span class="line"><span class="keyword">private</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();  <span class="comment">// 需要保证多个线程使用的是同一个AtomicInteger</span></span><br><span class="line">atomicInteger.incrementAndGet(); <span class="comment">//执行自增1</span></span><br></pre></td></tr></table></figure>
<h4 id="悲观锁的概念"><a href="#悲观锁的概念" class="headerlink" title="悲观锁的概念"></a>悲观锁的概念</h4><p>悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。</p>
<p><img data-src="https://xuemingde.com/pages/image/others/1607396994341-ea09e533-483e-4557-b005-923e11eeee9f.png" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ------------------------- 悲观锁的调用方式 -------------------------</span></span><br><span class="line"><span class="comment">// synchronized</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 操作同步资源</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ReentrantLock</span></span><br><span class="line"><span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(); <span class="comment">// 需要保证多个线程使用的是同一个锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyPublicResources</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	lock.lock();</span><br><span class="line">	<span class="comment">// 操作同步资源</span></span><br><span class="line">	lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="乐观锁在java中的实现"><a href="#乐观锁在java中的实现" class="headerlink" title="乐观锁在java中的实现"></a>乐观锁在java中的实现</h4><p>乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。</p>
<blockquote>
<p>悲观锁在Java中的使用，就是利用各种锁。</p>
</blockquote>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。</li>
<li>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升</li>
</ul>
<h3 id="自旋锁-VS-适应性自旋锁"><a href="#自旋锁-VS-适应性自旋锁" class="headerlink" title="自旋锁 VS 适应性自旋锁"></a>自旋锁 VS 适应性自旋锁</h3><h4 id="自旋锁的概念"><a href="#自旋锁的概念" class="headerlink" title="自旋锁的概念"></a>自旋锁的概念</h4><p>当一个线程尝试去获取某一把锁的时候，如果这个锁此时已经被别人获取(占用)，那么此线程就无法获取到这把锁，该线程将会等待，间隔一段时间后会再次尝试获取。这种采用循环加锁 -&gt; 等待的机制被称为自旋锁(spinlock)。</p>
<h4 id="概念图"><a href="#概念图" class="headerlink" title="概念图"></a>概念图</h4><p><img data-src="https://xuemingde.com/pages/image/others/1607406106200-96579fc8-48b4-47af-993e-892570923983.png" alt=""></p>
<h4 id="自旋锁的实现原理"><a href="#自旋锁的实现原理" class="headerlink" title="自旋锁的实现原理"></a>自旋锁的实现原理</h4><p>自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。</p>
<p><img data-src="https://xuemingde.com/pages/image/others/1607406297240-967f6d60-9f95-4e45-9e81-45b1e8ba458c.png" alt=""></p>
<h4 id="适应性自旋锁"><a href="#适应性自旋锁" class="headerlink" title="适应性自旋锁"></a>适应性自旋锁</h4><p>自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK 6中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。<br>自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p>
<h4 id="自旋锁的优缺点"><a href="#自旋锁的优缺点" class="headerlink" title="自旋锁的优缺点"></a>自旋锁的优缺点</h4><p>自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换！<br>但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用 cpu 做无用功，占着 XX 不 XX，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要 cpu 的线程又不能获取到 cpu，造成 cpu 的浪费。所以这种情况下我们要关闭自旋锁。</p>
<h4 id="java简单实现自旋锁"><a href="#java简单实现自旋锁" class="headerlink" title="java简单实现自旋锁"></a>java简单实现自旋锁</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicBoolean available = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环检测尝试获取锁</span></span><br><span class="line">        <span class="keyword">while</span> (!tryLock())&#123;</span><br><span class="line">            <span class="comment">// doSomething...</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 尝试获取锁，成功返回true，失败返回false</span></span><br><span class="line">        <span class="keyword">return</span> available.compareAndSet(<span class="keyword">false</span>,<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!available.compareAndSet(<span class="keyword">true</span>,<span class="keyword">false</span>))&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;释放锁失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这种简单的自旋锁有一个问题：无法保证多线程竞争的公平性。对于上面的SpinlockTest，当多个线程想要获取锁时，谁最先将available设为false谁就能最先获得锁，这可能会造成某些线程一直都未获取到锁造成线程饥饿。</p>
</blockquote>
<h3 id="公平锁-VS-非公平锁"><a href="#公平锁-VS-非公平锁" class="headerlink" title="公平锁 VS 非公平锁"></a>公平锁 VS 非公平锁</h3><h4 id="公平锁概念"><a href="#公平锁概念" class="headerlink" title="公平锁概念"></a>公平锁概念</h4><p>是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</p>
<h4 id="非公平锁概念"><a href="#非公平锁概念" class="headerlink" title="非公平锁概念"></a>非公平锁概念</h4><p>是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</p>
<h4 id="两个对比图"><a href="#两个对比图" class="headerlink" title="两个对比图"></a>两个对比图</h4><p><img data-src="https://xuemingde.com/pages/image/others/1607406912576-cb145224-f1bd-4705-92f2-00766c7917be.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1607407107342-ddbcd750-d249-4081-9f98-09c0776c4df8.png" alt=""></p>
<h4 id="源码讲解公平锁和非公平锁"><a href="#源码讲解公平锁和非公平锁" class="headerlink" title="源码讲解公平锁和非公平锁"></a>源码讲解公平锁和非公平锁</h4><p><img data-src="https://xuemingde.com/pages/image/others/1607407945887-50d5ac0c-4f6b-4f8e-9719-dd2db42cf528.png" alt="">根据代码可知，ReentrantLock里面有一个内部类Sync，Sync继承AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在Sync中实现的。它有公平锁FairSync和非公平锁NonfairSync两个子类。ReentrantLock默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。</p>
<p>看一下公平锁与非公平锁的加锁方法的源码:</p>
<p><img data-src="https://xuemingde.com/pages/image/others/1607407982065-1029f8ba-3d52-4154-93ce-f292373b872b.png" alt=""><br>通过上图中的源代码对比，我们可以明显的看出公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：hasQueuedPredecessors()。<br><img data-src="https://xuemingde.com/pages/image/others/1607408071437-b37f524d-0b66-429c-a6e9-ba9343a442f1.png" alt=""><br>再进入hasQueuedPredecessors()，可以看到该方法主要做一件事情：主要是判断当前线程是否位于同步队列中的第一个。如果是则返回true，否则返回false。<br>综上，公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。非公平锁加锁时不考虑排队等待问题，直接尝试获取锁，所以存在后申请却先获得锁的情况。</p>
<h3 id="可重入锁-VS-非可重入锁"><a href="#可重入锁-VS-非可重入锁" class="headerlink" title="可重入锁 VS 非可重入锁"></a>可重入锁 VS 非可重入锁</h3><h4 id="可重入锁概念"><a href="#可重入锁概念" class="headerlink" title="可重入锁概念"></a>可重入锁概念</h4><p>又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。</p>
<h4 id="可重入锁示例代码解析"><a href="#可重入锁示例代码解析" class="headerlink" title="可重入锁示例代码解析"></a>可重入锁示例代码解析</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法1执行...&quot;</span>);</span><br><span class="line">        doOthers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doOthers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方法2执行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，类中的两个方法都是被内置锁synchronized修饰的，doSomething()方法中调用doOthers()方法。因为内置锁是可重入的，所以同一个线程在调用doOthers()时可以直接获得当前对象的锁，进入doOthers()进行操作。<br>如果是一个不可重入锁，那么当前线程在调用doOthers()之前需要将执行doSomething()时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。</p>
<h4 id="为什么可重入锁就可以在嵌套调用时可以自动获得锁呢"><a href="#为什么可重入锁就可以在嵌套调用时可以自动获得锁呢" class="headerlink" title="为什么可重入锁就可以在嵌套调用时可以自动获得锁呢"></a>为什么可重入锁就可以在嵌套调用时可以自动获得锁呢</h4><p>还是打水的例子，有多个人在排队打水，此时管理员允许锁和同一个人的多个水桶绑定。这个人用多个水桶打水时，第一个水桶和锁绑定并打完水之后，第二个水桶也可以直接和锁绑定并开始打水，所有的水桶都打完水之后打水人才会将锁还给管理员。这个人的所有打水流程都能够成功执行，后续等待的人也能够打到水。这就是可重入锁。</p>
<p><img data-src="https://xuemingde.com/pages/image/others/1607409491864-00996bca-1008-462f-bcdf-7da6289a5dce.png" alt=""></p>
<p>但如果是非可重入锁的话，此时管理员只允许锁和同一个人的一个水桶绑定。第一个水桶和锁绑定打完水之后并不会释放锁，导致第二个水桶不能和锁绑定也无法打水。当前线程出现死锁，整个等待队列中的所有线程都无法被唤醒。</p>
<p><img data-src="https://xuemingde.com/pages/image/others/1607409508426-3d3eba67-a2fe-45ed-8e53-2495311930bc.png" alt=""></p>
<h4 id="ReentrantLock（可重入锁）和NonReentrantLock（不可重入锁）源码对比"><a href="#ReentrantLock（可重入锁）和NonReentrantLock（不可重入锁）源码对比" class="headerlink" title="ReentrantLock（可重入锁）和NonReentrantLock（不可重入锁）源码对比"></a>ReentrantLock（可重入锁）和NonReentrantLock（不可重入锁）源码对比</h4><p>通过重入锁ReentrantLock以及非可重入锁NonReentrantLock的源码来对比分析一下为什么非可重入锁在重复调用同步资源时会出现死锁。</p>
<p>首先ReentrantLock和NonReentrantLock都继承父类AQS，其父类AQS中维护了一个同步状态status来计数重入次数，status初始值为0。<br>当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status == 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。而非可重入锁是直接去获取并尝试更新当前status的值，如果status != 0的话会导致其获取锁失败，当前线程阻塞。<br>释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。如果status-1 == 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。而非可重入锁则是在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放。</p>
<p><img data-src="https://xuemingde.com/pages/image/others/1607409655969-5a4ef5f7-f90d-4230-8a83-6456744c9c10.png" alt=""></p>
<h3 id="独享锁-VS-共享锁"><a href="#独享锁-VS-共享锁" class="headerlink" title="独享锁 VS 共享锁"></a>独享锁 VS 共享锁</h3><blockquote>
<p>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</p>
</blockquote>
<h4 id="独享锁概念"><a href="#独享锁概念" class="headerlink" title="独享锁概念"></a>独享锁概念</h4><p>也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。在上面的公平锁和非公平锁，添加的锁都是独享锁。</p>
<h4 id="共享锁概念"><a href="#共享锁概念" class="headerlink" title="共享锁概念"></a>共享锁概念</h4><p>指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</p>
<h4 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h4><p>对于ReentrantLock而言，ReentrantLock是一个独享锁，即公平锁与非公平锁时独享锁。而对ReadWriteLock而言，它的读是一个共享锁，而写是一个独享锁。读锁作为一个共享锁可以保证并发是的高可读性。独享锁，和共享锁都是通过AQS来实现的，实现不同方法来实现独享，和共享。</p>
<h3 id="无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁"><a href="#无锁-VS-偏向锁-VS-轻量级锁-VS-重量级锁" class="headerlink" title="无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁"></a>无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁</h3><blockquote>
<p>这四种锁是指锁的状态，专门针对synchronized的，涉及到锁升级过程。</p>
</blockquote>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/01/1018U4Z9UP.png" alt="1018U4Z9UP"></p>
<h4 id="java对象头"><a href="#java对象头" class="headerlink" title="java对象头"></a>java对象头</h4><p>在说java对象头之前，先提一个问题，Object obi = new Object();占几个字符？<br>答案是：</p>
<ul>
<li>未开启指针压缩<br><strong>占用大小为：8(Mark Word)+8(Klass Point)=16字节</strong></li>
<li>开启了指针压缩(默认是开启的)<br>开启指针压缩后，Class Pointer会被压缩为4字节，</li>
</ul>
<p><strong>最终大小为：8(Mark Word)+4(Klass Point)+4(对齐填充)=16字节</strong><br><img data-src="https://xuemingde.com/pages/image/2022/06/01/1019vwqqFi.png" alt="1019vwqqFi"><br>java对象头的组成：</p>
<ul>
<li>Mark Word</li>
<li>Klass Point</li>
<li>对齐填充（在Mark Word占有字节数 + Klass Point占有字节数 = 8的倍数时，此出占有字节数为0）</li>
</ul>
<p><strong>Mark Word</strong>：默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。<br>锁的信息就存储在<strong>Mark Word里面。</strong></p>
<p><strong>Klass Point</strong>：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。（Object.class 信息，对象里设置的信息也会存放在这里）</p>
<h4 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h4><p>Monitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。<br>Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。<br>现在话题回到synchronized，synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。<br>如同我们在自旋锁中提到的“阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长”。这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”，JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。<br>所以目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。</p>
<h4 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h4><p>无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。<br>无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。<br>也有一种说法，此处是刚new 出一个新对象，没有任何操作。</p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。<br>在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。<br>当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。<br>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。<br>偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。<br>此处也可以说说无锁态，因为只有一个线程，没有产生锁竞争的问题。</p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。<br>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。<br>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。<br>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。<br>如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。<br>若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。<br>此处是有多个线程产生了锁竞争，自旋的次数过多，等待时间过度，就会进入队列，升级为重量级锁。</p>
<h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。<br>进入重量级锁之后，等待锁的线程会进入队列，不在自旋等待获取锁，释放了cpu，但是持有锁的线程释放锁之后，需要操作系统那调取某个线程。</p>
<h3 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h3><h4 id="Synchronized的使用"><a href="#Synchronized的使用" class="headerlink" title="Synchronized的使用"></a>Synchronized的使用</h4><p>有三种使用方法分别对应三种不同的作用域</p>
<ol>
<li><p>修饰普通同步方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//写法一</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写法二</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="comment">// todo</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>作用域：写法一和写法二十等价的，锁住得是整个方法的内容。</p>
</li>
<li><p>修饰静态方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//写法三</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作用域：<br>写法三与前面两个不一样，因为static方法是针对类而不是实例。但是我们注意到任何一个类都有一个由JVM自动创建的Class实例，因此，对static方法添加synchronized，锁住的是该类的Class实例。上述synchronized static方法实际上相当于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Counter.class) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li>修饰代码块<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//写法一 锁住的是method这个方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="comment">// todo</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写法二 锁住的是Counter这个类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Counter.class) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="Synchronized的实现原理"><a href="#Synchronized的实现原理" class="headerlink" title="Synchronized的实现原理"></a>Synchronized的实现原理</h4><p>Java对象头和monitor是实现synchronized的基础。<br>synchronized的信息存放在java对象头的Mark Word里面。<br>(关于monitor 的解释，看资料看不懂，就不多做多解释了，文章地址：<span class="exturl" data-url="aHR0cHM6Ly94aWFvbWktaW5mby5naXRodWIuaW8vMjAyMC8wMy8yNC9zeW5jaHJvbml6ZWQv">文章一<i class="fa fa-external-link-alt"></i></span>，文章来自小米团队)</p>
<h4 id="synchronized和lock-的区别"><a href="#synchronized和lock-的区别" class="headerlink" title="synchronized和lock 的区别"></a>synchronized和lock 的区别</h4><ul>
<li>Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现；</li>
<li>synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</li>
<li>Lock可以让等待锁的线程响应中断，而synchronized却不行，使用synchronized时，等待的线程会一直等待下去，不能够响应中断；</li>
<li>通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</li>
<li>Lock可以提高多个线程进行读操作的效率。（可以通过readwritelock实现读写分离）</li>
<li>性能上来说，在资源竞争不激烈的情形下，Lock性能稍微比synchronized差点（编译程序通常会尽可能的进行优化synchronized）。但是当同步非常激烈的时候，synchronized的性能一下子能下降好几十倍。而ReentrantLock确还能维持常态。</li>
</ul>
<h4 id="synchronized与volatile的区别"><a href="#synchronized与volatile的区别" class="headerlink" title="synchronized与volatile的区别"></a>synchronized与volatile的区别</h4><p>volatile的作用有两个，一个是使变量具有可见性，另一个是禁止指令重排序。</p>
<ol>
<li>volatile仅能使用在变量级别；  synchronized则可以使用在变量、方法、和类级别的</li>
<li>volatile仅能实现变量的修改可见性，并不能保证原子性；synchronized则可以保证变量的修改可见性和原子性</li>
<li>volatile不会造成线程的阻塞； synchronized可能会造成线程的阻塞。</li>
<li>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化</li>
</ol>
<h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><blockquote>
<p>参考文章：<span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xNzQ1MzEz">文章一<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h4 id="volatile关键字的特性"><a href="#volatile关键字的特性" class="headerlink" title="volatile关键字的特性"></a>volatile关键字的特性</h4><ul>
<li>保证了不同线程对该变量操作的内存可见性;（但是不能保证原子性）</li>
<li>禁止指令重排序；</li>
</ul>
<h4 id="什么是内存可见性"><a href="#什么是内存可见性" class="headerlink" title="什么是内存可见性"></a>什么是内存可见性</h4><p>可见性就是，多线程环境中，对共享变量的修改对于其他线程是否立即可见。</p>
<h4 id="为什么volatile能够保证内存可见性"><a href="#为什么volatile能够保证内存可见性" class="headerlink" title="为什么volatile能够保证内存可见性"></a>为什么volatile能够保证内存可见性</h4><p>线程对变量操作时会从主内存中读取到自己的工作内存中，当线程对变量进行了修改后，那么其他已经读取了此变量的线程中的变量副本就会失效，这样其他线程在使用变量的时候，发现已经失效，那么就会去主内存中重新获取，这样获取到的就只最新的值了。<br>因为一台计算机有多台CPU，同一个变量，在多个CPU中缓存的值有可能不一样，那么以谁缓存的值为准呢？<br>既然大家都有自己的值，那么各个CPU间就产生了一种协议，来保证按照一定的规律为准，来确定共享变量的准确值，这样各个CPU在读写共享变量时都按照协议来操作。<br>这就是缓存一致性协议。</p>
<p>最著名的缓存一致性协议就是Intel的MESI了，说MESI时，先解释一下，缓存行：</p>
<blockquote>
<p> 缓存行（cache line）：CPU高速缓存的中可以分配的最小存储单位，高速缓存中的变量都是存在缓存行中的。  </p>
</blockquote>
<p>MESI的核心思想就是，当CPU对变量进行写操作时发现，变量是共享变量，那么就会通知其他CPU中将该变量的缓存行设置为无效状态。当其他CPU在操作变量时发现此变量在的缓存行已经无效，那么就会去主内存中重新读取最新的变量。</p>
<p>CPU和其他部件的进行通信是通过总线来进行的，所以每个CPU通过嗅探总线上的传播数据，来检查自己缓存的值是不是过期了，当处理器发现自己换成行对应的内存地址被修改后，就会将自己工作内存中的缓存行设置成无须状态，当CPU对此变量进行修改时会重新从系统主内存中读取变量。</p>
<h4 id="什么是指令重排序"><a href="#什么是指令重排序" class="headerlink" title="什么是指令重排序"></a>什么是指令重排序</h4><p>一般来说，我们写程序的时候，都是要把先代码从上往下写，默认的认为程序是自顶向下顺序执行的，但是CPU为了提高效率，在保证最终结果准确的情况下，是会对指令进行重新排序的。就是说写在前的代码不一定先执行，在后面的也不一定晚执行。<br>JMM在是允许指令重排序的，在保证最后结果正确的情况下，处理器可以尽情的发挥，提高执行效率。<br>当多个线程执行代码的时候重排序的情况就更为突出了，各个CPU为了提高自己的效率，有可能会产生竞争情况，这样就有可能导致最终执行的正确性。<br>所以为了保证在多个线程下最终执行的正确性，将变量用volatile进行修饰，这样就会达到禁止指令重排序的效果（其实也可以通过加锁，还有一些其他已知规则来实现禁止指令重排序，但是我们这里只讨论volatile的实现方式）</p>
<h4 id="volatile是如何实现指令重排序的呢"><a href="#volatile是如何实现指令重排序的呢" class="headerlink" title="volatile是如何实现指令重排序的呢"></a>volatile是如何实现指令重排序的呢</h4><p><strong>内存屏障</strong><br><em>内存屏障是一组CPU指令，用于实现对内存操作的顺序限制。</em><br>（内存屏障就不做多解释，太深奥，看资料有些蒙蔽）</p>
<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><h4 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h4><p>AbstractQueueSynchronized的缩写，也叫抽象的队列式同步器。定义了一套多线程访问共享资源的同步器框架。</p>
<h4 id="从ReentrantLock的实现看AQS的原理及应用"><a href="#从ReentrantLock的实现看AQS的原理及应用" class="headerlink" title="从ReentrantLock的实现看AQS的原理及应用"></a>从ReentrantLock的实现看AQS的原理及应用</h4><p><img data-src="https://xuemingde.com/pages/image/others/1607411662289-d43558c2-7ed3-4594-a93b-ef44d3bc6e12.png" alt=""></p>
<h4 id="ReentrantLock与Synchronized-区别"><a href="#ReentrantLock与Synchronized-区别" class="headerlink" title="ReentrantLock与Synchronized 区别"></a>ReentrantLock与Synchronized 区别</h4><p><img data-src="https://xuemingde.com/pages/image/others/1607411766822-17c6529f-8c0d-4801-b6fa-57d498b4084e.png" alt=""></p>
<p>代码区别示例：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// **************************Synchronized的使用方式**************************</span></span><br><span class="line"><span class="comment">// 1.用于代码块</span></span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;&#125;</span><br><span class="line"><span class="comment">// 2.用于对象</span></span><br><span class="line"><span class="keyword">synchronized</span> (object) &#123;&#125;</span><br><span class="line"><span class="comment">// 3.用于方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span> <span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 4.可重入</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// **************************ReentrantLock的使用方式**************************</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span> <span class="params">()</span> throw Exception </span>&#123;</span><br><span class="line">	<span class="comment">// 1.初始化选择公平锁、非公平锁</span></span><br><span class="line">	ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">	<span class="comment">// 2.可用于代码块</span></span><br><span class="line">	lock.lock();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 3.支持多种加锁方式，比较灵活; 具有可重入特性</span></span><br><span class="line">			<span class="keyword">if</span>(lock.tryLock(<span class="number">100</span>, TimeUnit.MILLISECONDS))&#123; &#125;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">// 4.手动释放锁</span></span><br><span class="line">			lock.unlock()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		lock.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>更多资料请看：<span class="exturl" data-url="aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMTkvMTIvMDUvYXFzLXRoZW9yeS1hbmQtYXBwbHkuaHRtbA==">https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html<i class="fa fa-external-link-alt"></i></span><br>来自美团团队</p>
</blockquote>
<h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><h4 id="什么是CSA"><a href="#什么是CSA" class="headerlink" title="什么是CSA"></a>什么是CSA</h4><p>CAS是英文单词CompareAndSwap的缩写，中文意思是：比较并替换。CAS需要有3个操作数：内存地址V，旧的预期值A，即将要更新的目标值B。<br>CAS指令执行时，当且仅当内存地址V的值与预期值A相等时，将内存地址V的值修改为B，否则就什么都不做。整个比较并替换的操作是一个原子操作。</p>
<h4 id="CAS的底层实现"><a href="#CAS的底层实现" class="headerlink" title="CAS的底层实现"></a>CAS的底层实现</h4><p>CAS的底层其实是通过一条硬件指令来实现的。理论上我们可以使用同步锁的方式来达到相同的效果，但是这并不是我们想要的效果（性能高、线程安全）。因此我们只能从硬件指令上着手考虑。通过硬件指令，我们可以让看起来多步的操作只需要一条指令就可以完成。</p>
<blockquote>
<p>具体可以查看源码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">10</span>);</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            atomicInteger.getAndIncrement();</span><br><span class="line">        &#125;,<span class="string">&quot;zhonghu&quot;</span>).start();</span><br><span class="line">        atomicInteger.getAndIncrement();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, delta);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> var5;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">        &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="CAS的优点"><a href="#CAS的优点" class="headerlink" title="CAS的优点"></a>CAS的优点</h4><p>保证原子性的方式只有加锁，无论是<strong>内置锁(synchronized),</strong>还是<strong>显示锁(ReentrantLock),</strong>加锁意味着线程阻塞，如果竞争激烈，很可能导致频繁的线程上下文切换，从而大大降低了性能。<br>CAS机制是一种乐观锁，可以避免这些问题，使得执行效率很大的提高。</p>
<h4 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h4><p>CAS虽然很高效的解决原子操作，但是CAS仍然存在三大问题。ABA问题，循环时间长开销大和只能保证一个共享变量的原子操作。</p>
<ol>
<li>ABA问题</li>
</ol>
<p>CAS操作需要检查当前内存的变量值是否和刚刚读取的值相同，假设一个变量是A，变成了B，之后又变成了A，所以在进行CAS操作的时候检查到它的值没有发生变化。ABA的解决方案就是加上版本号1A-&gt;2B-&gt;3A，类似这种。<br>java先行者们也给我们提供了<strong>AtomicStampedReference</strong>来解决ABA的问题，其中的预期标志也类似于版本号的功能。</p>
<ol>
<li>循环时间长开销大</li>
</ol>
<p>多线程竞争激烈的情况下进行CAS操作，会导致某些线程长时间空循环，也就是说它什么都没做，只是不停地在浪费处理器的处理时间而已。</p>
<ol>
<li>只能保证一个共享变量的原子操作</li>
</ol>
<p>一个共享变量的操作可以用CAS保证其原子性，多个共享变量的操作，循环CAS是无法保证其原子性的。有个取巧的办法，java先行者设计的AtomicReference类，我们可以通过将多个变量放到一个对象里面，然后由AtomicReference进行原子性地更新。</p>
<h4 id="CAS典型应用场景"><a href="#CAS典型应用场景" class="headerlink" title="CAS典型应用场景"></a><strong>CAS典型应用场景</strong></h4><p>1、乐观锁思想<br>CAS解决并发的思路可以在很多场景中借鉴，在数据库使用中，可以采用这种方式来避免加锁操作，比如大家学习Hibernate时候的乐观锁。<br>2、Java Concurren<br>Java Concurrent包下大量使用CAS实现并发控制，比如Atomic*，ReentrantLock等。<br>比如AtomicInteger中，就使用CAS。<br>Java无法直接访问底层操作系统，而是通过本地（native）方法来访问。JVM开了一个后门，JDK中有一个类Unsafe，它提供了硬件级别的原子操作。</p>
]]></content>
      <categories>
        <category>并发与多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>C</tag>
        <tag>内存</tag>
        <tag>数据库</tag>
        <tag>栈</tag>
        <tag>CPU</tag>
        <tag>指针</tag>
        <tag>全局</tag>
        <tag>变量</tag>
        <tag>锁</tag>
        <tag>并发</tag>
        <tag>算法</tag>
        <tag>多线程</tag>
        <tag>Widget</tag>
      </tags>
  </entry>
  <entry>
    <title>图解Java中那18 把锁</title>
    <url>/posts/33GA963.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在线查看：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYWxpeXVuZHJpdmUuY29tL3MveHZ0SzRTQkV5bUM=">阿里云盘<i class="fa fa-external-link-alt"></i></span></p>
<hr>
<p>原文：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvMmp4ek5ueUdXREZvbDRROVIyYV9ZZw==">https://mp.weixin.qq.com/s/2jxzNnyGWDFol4Q9R2a_Yg<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>并发与多线程</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程面试题</title>
    <url>/posts/19HRP15.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="为什么用多线程"><a href="#为什么用多线程" class="headerlink" title="为什么用多线程"></a>为什么用多线程</h3><p><img data-src="https://xuemingde.com/pages/image/others/1616753915503-beba6051-7a3c-4800-888b-1c0e30b0d075.png" alt="image.png"></p>
<h3 id="多线程难在哪里"><a href="#多线程难在哪里" class="headerlink" title="多线程难在哪里"></a>多线程难在哪里</h3><p><img data-src="https://xuemingde.com/pages/image/others/1616753985651-23314499-41bb-4aee-8378-a93880a5b4ea.png" alt="image.png"></p>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p><img data-src="https://xuemingde.com/pages/image/others/1616754358431-3b693713-b77e-453e-a625-9fb19218cdb4.png" alt="image.png"></p>
<h3 id="并发编程三要素-线程三大特性"><a href="#并发编程三要素-线程三大特性" class="headerlink" title="并发编程三要素(线程三大特性)"></a>并发编程三要素(<strong>线程三大特性)</strong></h3><p><img data-src="https://xuemingde.com/pages/image/others/1616742879894-0c6a8553-ed51-47d9-b51b-5873a1dcff99.png" alt="image.png"></p>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p><img data-src="https://xuemingde.com/pages/image/others/1616742935797-7fd1f67d-2ed5-43d3-b002-3f7f0e445dae.png" alt="image.png"></p>
<h3 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h3><p><img data-src="https://xuemingde.com/pages/image/others/1616743152283-9fe6dc0d-be88-4afb-890b-6ba41d8f7536.png" alt="image.png"></p>
<h3 id="sleep-和-wait-有什么区别"><a href="#sleep-和-wait-有什么区别" class="headerlink" title="sleep() 和 wait() 有什么区别"></a>sleep() 和 wait() 有什么区别</h3><p><img data-src="https://xuemingde.com/pages/image/others/1616743263844-b9f0d7c1-2fe3-42a3-a223-2520310d3b72.png" alt="image.png"></p>
<h3 id="notify-和-notifyAll-有什么区别"><a href="#notify-和-notifyAll-有什么区别" class="headerlink" title="notify()和 notifyAll()有什么区别"></a>notify()和 notifyAll()有什么区别</h3><p><img data-src="https://xuemingde.com/pages/image/others/1616743363073-f2ce093d-9516-458d-83e1-945a17fa402c.png" alt="image.png"></p>
<h3 id="线程的-run-和-start-有什么区别"><a href="#线程的-run-和-start-有什么区别" class="headerlink" title="线程的 run() 和 start() 有什么区别"></a>线程的 run() 和 start() 有什么区别</h3><p><img data-src="https://xuemingde.com/pages/image/others/1616743427075-517036be-30d9-4740-9936-712af15c7dec.png" alt="image.png"></p>
<h3 id="Runnable接口和Callable接口的区别"><a href="#Runnable接口和Callable接口的区别" class="headerlink" title="Runnable接口和Callable接口的区别"></a>Runnable接口和Callable接口的区别</h3><p><img data-src="https://xuemingde.com/pages/image/others/1616743922435-e652d3af-43cf-4fc9-a76f-8d860c690b97.png" alt="image.png"></p>
<h3 id="是继承Thread类好还是实现Runnable接口好"><a href="#是继承Thread类好还是实现Runnable接口好" class="headerlink" title="是继承Thread类好还是实现Runnable接口好"></a><strong>是继承Thread类好还是实现Runnable接口好</strong></h3><p><img data-src="https://xuemingde.com/pages/image/others/1616743491031-d0b135be-0612-4b83-bdfe-e1604884203b.png" alt="image.png"></p>
<h3 id="你在哪里用到了多线程"><a href="#你在哪里用到了多线程" class="headerlink" title="你在哪里用到了多线程"></a><strong>你在哪里用到了多线程</strong></h3><p><img data-src="https://xuemingde.com/pages/image/others/1616743535203-b009aa06-d60d-4882-aa43-ad6c520d8c17.png" alt="image.png"></p>
<h3 id="什么是多线程安全"><a href="#什么是多线程安全" class="headerlink" title="什么是多线程安全"></a><strong>什么是多线程安全</strong></h3><p><img data-src="https://xuemingde.com/pages/image/others/1616743584207-ad80f7d1-9e52-4a98-98bf-c131a4cbe73d.png" alt="image.png"></p>
<h3 id="如何解决多线程之间线程安全问题"><a href="#如何解决多线程之间线程安全问题" class="headerlink" title="如何解决多线程之间线程安全问题"></a><strong>如何解决多线程之间线程安全问题</strong></h3><p><img data-src="https://xuemingde.com/pages/image/others/1616743610784-a8182ec6-137b-43bc-bb85-b670aaee7822.png" alt="image.png"></p>
<h3 id="为什么使用线程同步或使用锁能解决线程安全问题呢"><a href="#为什么使用线程同步或使用锁能解决线程安全问题呢" class="headerlink" title="为什么使用线程同步或使用锁能解决线程安全问题呢"></a><strong>为什么使用线程同步或使用锁能解决线程安全问题呢</strong></h3><p><strong><img data-src="https://xuemingde.com/pages/image/others/1616743630368-d976d2aa-c92a-46eb-b641-bebf175eceb1.png" alt="image.png"></strong></p>
<h3 id="什么是多线程之间同步"><a href="#什么是多线程之间同步" class="headerlink" title="什么是多线程之间同步"></a><strong>什么是多线程之间同步</strong></h3><p><strong><img data-src="https://xuemingde.com/pages/image/others/1616743664618-143f085f-eedb-49f3-ac9f-1524694e78c6.png" alt="image.png"></strong></p>
<h3 id="什么是守护线程"><a href="#什么是守护线程" class="headerlink" title="什么是守护线程"></a><strong>什么是守护线程</strong></h3><p><strong><img data-src="https://xuemingde.com/pages/image/others/1616743763161-15013e3e-1da7-4a54-a5cd-c09b3668cb11.png" alt="image.png"></strong></p>
<h3 id="多线程有什么用"><a href="#多线程有什么用" class="headerlink" title="多线程有什么用"></a>多线程有什么用</h3><p><img data-src="https://xuemingde.com/pages/image/others/1616743875593-187d3c43-c445-4b8b-8382-5b0a8ff0c64b.png" alt="image.png"></p>
<h3 id="SynchronizedMap和ConcurrentHashMap有什么区别"><a href="#SynchronizedMap和ConcurrentHashMap有什么区别" class="headerlink" title="SynchronizedMap和ConcurrentHashMap有什么区别"></a>SynchronizedMap和ConcurrentHashMap有什么区别</h3><p><img data-src="https://xuemingde.com/pages/image/others/1616744623358-a86c68a3-0fc4-40c1-8a74-ccf59f3daa4f.png" alt="image.png"></p>
<h3 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h3><p><img data-src="https://xuemingde.com/pages/image/others/1616756131905-064eeb18-999a-4591-92eb-1fa2ba9a552e.png" alt="image.png"></p>
<p>  <img data-src="https://xuemingde.com/pages/image/others/1616744842066-01213030-08c0-4440-96ec-f956be4ddcd4.png" alt="image.png"></p>
<h3 id="线程安全的类一定所有的操作都线程安全吗"><a href="#线程安全的类一定所有的操作都线程安全吗" class="headerlink" title="线程安全的类一定所有的操作都线程安全吗"></a>线程安全的类一定所有的操作都线程安全吗</h3><p><img data-src="https://xuemingde.com/pages/image/others/1616756345550-319c055c-1e72-434e-ad0e-87338c82014d.png" alt="image.png"></p>
<h3 id="Thread类中的yield方法有什么作用"><a href="#Thread类中的yield方法有什么作用" class="headerlink" title="Thread类中的yield方法有什么作用"></a>Thread类中的yield方法有什么作用</h3><p><img data-src="https://xuemingde.com/pages/image/others/1616744930139-355d5f4c-cf41-43b0-8220-6787558c9269.png" alt="image.png"></p>
<blockquote>
<p>相关文章：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLjUxY3RvLmNvbS8xNDk3NTA3My8yNTkxMDI5">文章1<i class="fa fa-external-link-alt"></i></span>  </p>
</blockquote>
]]></content>
      <categories>
        <category>并发与多线程</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>锁</tag>
        <tag>并发</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot 使用线程池的方式之一</title>
    <url>/posts/1BH7TR1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="线程池配置"><a href="#线程池配置" class="headerlink" title="线程池配置"></a>线程池配置</h3><p><img data-src="https://xuemingde.com/pages/image/others/1617091122646-78d04495-37eb-42cf-a0a7-28974f23647b.png" alt="image.png"></p>
<h3 id="Async"><a href="#Async" class="headerlink" title="@Async"></a>@Async</h3><p><img data-src="https://xuemingde.com/pages/image/others/1617091219237-0779b4d5-3184-49fb-a2de-e9c6dc0be764.png" alt="image.png"></p>
<h3 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h3><p><img data-src="https://xuemingde.com/pages/image/others/1617090980456-5220d9d1-6b4e-4833-a138-f4be428fbcd2.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>并发与多线程</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的CAS</title>
    <url>/posts/364DCDS.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="CAS的执行过程"><a href="#CAS的执行过程" class="headerlink" title="CAS的执行过程"></a>CAS的执行过程</h1><p>​    <img data-src="https://xuemingde.com/pages/image/others/Foqp87.png" alt=""></p>
<h1 id="CAS中存在的问题"><a href="#CAS中存在的问题" class="headerlink" title="CAS中存在的问题"></a>CAS中存在的问题</h1><h2 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h2><p>ABA问题是指在CAS操作时，其他线程将变量值A改为了B，但是又被改回了A，等到本线程使用期望值A与当前变量进行比较时，发现变量A没有变，于是CAS就将A值进行了交换操作，但是实际上该值已经被其他线程改变过。</p>
<p><strong>解决方式</strong>：加版本号 </p>
<p>在JDK的 <em>java.util.concurrent.atomic</em> 包中提供了 <code>AtomicStampedReference</code> 来解决ABA问题，该类的compareAndSet是该类的核心方法，实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 V   newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> newStamp)</span> </span>&#123;</span><br><span class="line">        Pair&lt;V&gt; current = pair;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">            expectedReference == current.reference &amp;&amp;</span><br><span class="line">            expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">            ((newReference == current.reference &amp;&amp;</span><br><span class="line">              newStamp == current.stamp) ||</span><br><span class="line">             casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://xuemingde.com/pages/image/others/bkYcDR.png" alt="bkYcDR"></p>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9lbHNlZi5jb20vMjAyMC8wMy8wOC8lRTUlQTYlODIlRTQlQkQlOTUlRTclOTAlODYlRTglQTclQTNBQkElRTklOTclQUUlRTklQTIlOTgv">参考文章<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h2 id="修改值时的原子性问题"><a href="#修改值时的原子性问题" class="headerlink" title="修改值时的原子性问题"></a>修改值时的原子性问题</h2><p>底层的最终实现是使用了lock cmpxchg 指令来保证的。</p>
<p> <img data-src="https://xuemingde.com/pages/image/others/VV5fET.png" alt="VV5fET"></p>
]]></content>
      <categories>
        <category>并发与多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>变量</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发常见知识点&amp;面试题总结_进阶篇</title>
    <url>/posts/WTSYSE.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h2><h3 id="说一说自己对于-synchronized-关键字的了解"><a href="#说一说自己对于-synchronized-关键字的了解" class="headerlink" title="说一说自己对于 synchronized 关键字的了解"></a>说一说自己对于 synchronized 关键字的了解</h3><p><strong><code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性，<code>synchronized</code>关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</strong></p>
<p>另外，在 Java 早期版本中，<code>synchronized</code> 属于 <strong>重量级锁</strong>，效率低下。</p>
<p><strong>为什么呢？</strong></p>
<p>因为监视器锁（monitor）是依赖于底层的操作系统的 <code>Mutex Lock</code> 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。</p>
<p>庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对 <code>synchronized</code> 较大优化，所以现在的 <code>synchronized</code> 锁效率也优化得很不错了。JDK1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p>
<p>所以，你会发现目前的话，不论是各种开源框架还是 JDK 源码都大量使用了 <code>synchronized</code> 关键字。</p>
<h3 id="1-2-说说自己是怎么使用-synchronized-关键字"><a href="#1-2-说说自己是怎么使用-synchronized-关键字" class="headerlink" title="1.2. 说说自己是怎么使用 synchronized 关键字"></a>1.2. 说说自己是怎么使用 synchronized 关键字</h3><p><strong>synchronized 关键字最主要的三种使用方式：</strong></p>
<p><strong>1.修饰实例方法:</strong> 作用于当前对象实例加锁，进入同步代码前要获得 <strong>当前对象实例的锁</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.修饰静态方法:</strong> 也就是给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 <strong>当前 class 的锁</strong>。因为静态成员不属于任何一个实例对象，是类成员（ <em>static 表明这是该类的一个静态资源，不管 new 了多少个对象，只有一份</em>）。所以，如果一个线程 A 调用一个实例对象的非静态 <code>synchronized</code> 方法，而线程 B 需要调用这个实例对象所属类的静态 <code>synchronized</code> 方法，是允许的，不会发生互斥现象，<strong>因为访问静态 <code>synchronized</code> 方法占用的锁是当前类的锁，而访问非静态 <code>synchronized</code> 方法占用的锁是当前实例对象锁</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.修饰代码块</strong> ：指定加锁对象，对给定对象/类加锁。<code>synchronized(this|object)</code> 表示进入同步代码库前要获得<strong>给定对象的锁</strong>。<code>synchronized(类.class)</code> 表示进入同步代码前要获得 <strong>当前 class 的锁</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<ul>
<li><code>synchronized</code> 关键字加到 <code>static</code> 静态方法和 <code>synchronized(class)</code> 代码块上都是是给 Class 类上锁。</li>
<li><code>synchronized</code> 关键字加到实例方法上是给对象实例上锁。</li>
<li>尽量不要使用 <code>synchronized(String a)</code> 因为 JVM 中，字符串常量池具有缓存功能！</li>
</ul>
<p>下面我以一个常见的面试题为例讲解一下 <code>synchronized</code> 关键字的具体使用。</p>
<p>面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单例模式的原理呗！”</p>
<p><strong>双重校验锁实现对象单例（线程安全）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，需要注意 <code>uniqueInstance</code> 采用 <code>volatile</code> 关键字修饰也是很有必要。</p>
<p><code>uniqueInstance</code> 采用 <code>volatile</code> 关键字修饰也是很有必要的， <code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p>
<ol>
<li>为 <code>uniqueInstance</code> 分配内存空间</li>
<li>初始化 <code>uniqueInstance</code></li>
<li>将 <code>uniqueInstance</code> 指向分配的内存地址</li>
</ol>
<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getUniqueInstance</code>() 后发现 <code>uniqueInstance</code> 不为空，因此返回 <code>uniqueInstance</code>，但此时 <code>uniqueInstance</code> 还未被初始化。</p>
<p>使用 <code>volatile</code> 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p>
<h3 id="1-3-构造方法可以使用-synchronized-关键字修饰么？"><a href="#1-3-构造方法可以使用-synchronized-关键字修饰么？" class="headerlink" title="1.3. 构造方法可以使用 synchronized 关键字修饰么？"></a>1.3. 构造方法可以使用 synchronized 关键字修饰么？</h3><p>先说结论：<strong>构造方法不能使用 synchronized 关键字修饰。</strong></p>
<p>构造方法本身就属于线程安全的，不存在同步的构造方法一说。</p>
<h3 id="1-3-讲一下-synchronized-关键字的底层原理"><a href="#1-3-讲一下-synchronized-关键字的底层原理" class="headerlink" title="1.3. 讲一下 synchronized 关键字的底层原理"></a>1.3. 讲一下 synchronized 关键字的底层原理</h3><p><strong>synchronized 关键字底层原理属于 JVM 层面。</strong></p>
<h4 id="1-3-1-synchronized-同步语句块的情况"><a href="#1-3-1-synchronized-同步语句块的情况" class="headerlink" title="1.3.1. synchronized 同步语句块的情况"></a>1.3.1. synchronized 同步语句块的情况</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;synchronized 代码块&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过 JDK 自带的 <code>javap</code> 命令查看 <code>SynchronizedDemo</code> 类的相关字节码信息：首先切换到类的对应目录执行 <code>javac SynchronizedDemo.java</code> 命令生成编译后的 .class 文件，然后执行<code>javap -c -s -v -l SynchronizedDemo.class</code>。</p>
<p><img data-src="https://xuemingde.com/pages/image/others/bdjTtP.png" alt="bdjTtP"></p>
<p>从上面我们可以看出：<strong><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</strong></p>
<p>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器 <code>monitor</code></strong> 的持有权。</p>
<blockquote>
<p>在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL29wZW5qZGstbWlycm9yL2pkazd1LWhvdHNwb3QvYmxvYi81MGJkZWZjM2FmZTk0NGNhNzRjMzA5M2U3NDQ4ZDZiODg5Y2QyMGQxL3NyYy9zaGFyZS92bS9ydW50aW1lL29iamVjdE1vbml0b3IuY3Bw">ObjectMonitor<i class="fa fa-external-link-alt"></i></span>实现的。每个对象中都内置了一个 <code>ObjectMonitor</code>对象。</p>
<p>另外，<code>wait/notify</code>等方法也依赖于<code>monitor</code>对象，这就是为什么只有在同步的块或者方法中才能调用<code>wait/notify</code>等方法，否则会抛出<code>java.lang.IllegalMonitorStateException</code>的异常的原因。</p>
</blockquote>
<p>在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。</p>
<p><img data-src="https://xuemingde.com/pages/image/others/FifalX.png" alt="FifalX"></p>
<p>对象锁的的拥有者线程才可以执行 <code>monitorexit</code> 指令来释放锁。在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。</p>
<p><img data-src="https://xuemingde.com/pages/image/others/fYZTIr.png" alt="fYZTIr"></p>
<p>如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p>
<h4 id="1-3-2-synchronized-修饰方法的的情况"><a href="#1-3-2-synchronized-修饰方法的的情况" class="headerlink" title="1.3.2. synchronized 修饰方法的的情况"></a>1.3.2. synchronized 修饰方法的的情况</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;synchronized 方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img data-src="https://xuemingde.com/pages/image/others/in4o5i.png" alt="in4o5i"></p>
<p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p>
<p>如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM 会尝试获取当前 class 的锁。</p>
<h4 id="1-3-3-总结"><a href="#1-3-3-总结" class="headerlink" title="1.3.3.总结"></a>1.3.3.总结</h4><p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p>
<p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取得代之的确实是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。</p>
<p><strong>不过两者的本质都是对对象监视器 monitor 的获取。</strong></p>
<p>相关推荐：<span class="exturl" data-url="aHR0cHM6Ly90ZWNoLnlvdXphbi5jb20vamF2YXN1by15dS14aWFuLWNoZW5nLWRlLW5hLXhpZS1zaGkv">Java锁与线程的那些事 - 有赞技术团队<i class="fa fa-external-link-alt"></i></span> 。</p>
<p>🧗🏻进阶一下：学有余力的小伙伴可以抽时间详细研究一下对象监视器 <code>monitor</code>。</p>
<h3 id="1-4-说说-JDK1-6-之后的-synchronized-关键字底层做了哪些优化，可以详细介绍一下这些优化吗"><a href="#1-4-说说-JDK1-6-之后的-synchronized-关键字底层做了哪些优化，可以详细介绍一下这些优化吗" class="headerlink" title="1.4. 说说 JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗"></a>1.4. 说说 JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗</h3><p>JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。</p>
<p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p>
<p>关于这几种优化的详细信息可以查看下面这篇文章：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vd3VxaW5nbG9uZy9wLzk5NDU2MTguaHRtbA==">Java6 及以上版本对 synchronized 的优化<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="1-5-谈谈-synchronized-和-ReentrantLock-的区别"><a href="#1-5-谈谈-synchronized-和-ReentrantLock-的区别" class="headerlink" title="1.5. 谈谈 synchronized 和 ReentrantLock 的区别"></a>1.5. 谈谈 synchronized 和 ReentrantLock 的区别</h3><h4 id="1-5-1-两者都是可重入锁"><a href="#1-5-1-两者都是可重入锁" class="headerlink" title="1.5.1. 两者都是可重入锁"></a>1.5.1. 两者都是可重入锁</h4><p><strong>“可重入锁”</strong> 指的是自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。</p>
<h4 id="1-5-2-synchronized-依赖于-JVM-而-ReentrantLock-依赖于-API"><a href="#1-5-2-synchronized-依赖于-JVM-而-ReentrantLock-依赖于-API" class="headerlink" title="1.5.2.synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API"></a>1.5.2.synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API</h4><p><code>synchronized</code> 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 <code>synchronized</code> 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。<code>ReentrantLock</code> 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p>
<h4 id="1-5-3-ReentrantLock-比-synchronized-增加了一些高级功能"><a href="#1-5-3-ReentrantLock-比-synchronized-增加了一些高级功能" class="headerlink" title="1.5.3.ReentrantLock 比 synchronized 增加了一些高级功能"></a>1.5.3.ReentrantLock 比 synchronized 增加了一些高级功能</h4><p>相比<code>synchronized</code>，<code>ReentrantLock</code>增加了一些高级功能。主要来说主要有三点：</p>
<ul>
<li><strong>等待可中断</strong> : <code>ReentrantLock</code>提供了一种能够中断等待锁的线程的机制，通过 <code>lock.lockInterruptibly()</code> 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li>
<li><strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。<code>ReentrantLock</code>默认情况是非公平的，可以通过 <code>ReentrantLock</code>类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li>
<li><strong>可实现选择性通知（锁可以绑定多个条件）</strong>: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>/<code>notifyAll()</code>方法相结合可以实现等待/通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</li>
</ul>
<blockquote>
<p><code>Condition</code>是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个<code>Lock</code>对象中可以创建多个<code>Condition</code>实例（即对象监视器），<strong>线程对象可以注册在指定的<code>Condition</code>中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用<code>notify()/notifyAll()</code>方法进行通知时，被通知的线程是由 JVM 选择的，用<code>ReentrantLock</code>类结合<code>Condition</code>实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是 Condition 接口默认提供的。而<code>synchronized</code>关键字就相当于整个 Lock 对象中只有一个<code>Condition</code>实例，所有的线程都注册在它一个身上。如果执行<code>notifyAll()</code>方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而<code>Condition</code>实例的<code>signalAll()</code>方法 只会唤醒注册在该<code>Condition</code>实例中的所有等待线程。</p>
</blockquote>
<p><strong>如果你想使用上述功能，那么选择 ReentrantLock 是一个不错的选择。性能已不是选择标准</strong></p>
<h2 id="2-volatile-关键字"><a href="#2-volatile-关键字" class="headerlink" title="2. volatile 关键字"></a>2. volatile 关键字</h2><p>我们先要从 <strong>CPU 缓存模型</strong> 说起！</p>
<h3 id="2-1-CPU-缓存模型"><a href="#2-1-CPU-缓存模型" class="headerlink" title="2.1. CPU 缓存模型"></a>2.1. CPU 缓存模型</h3><p><strong>为什么要弄一个 CPU 高速缓存呢？</strong></p>
<p>类比我们开发网站后台系统使用的缓存（比如 Redis）是为了解决程序处理速度和访问常规关系型数据库速度不对等的问题。 <strong>CPU 缓存则是为了解决 CPU 处理速度和内存处理速度不对等的问题。</strong></p>
<p>我们甚至可以把 <strong>内存可以看作外存的高速缓存</strong>，程序运行的时候我们把外存的数据复制到内存，由于内存的处理速度远远高于外存，这样提高了处理速度。</p>
<p>总结：<strong>CPU Cache 缓存的是内存数据用于解决 CPU 处理速度和内存不匹配的问题，内存缓存的是硬盘数据用于解决硬盘访问速度过慢的问题。</strong></p>
<p>为了更好地理解，我画了一个简单的 CPU Cache 示意图如下（实际上，现代的 CPU Cache 通常分为三层，分别叫 L1,L2,L3 Cache）:</p>
<p><img data-src="https://xuemingde.com/pages/image/others/MaaTKn.png" alt="MaaTKn"></p>
<p><strong>CPU Cache 的工作方式：</strong></p>
<p>先复制一份数据到 CPU Cache 中，当 CPU 需要用到的时候就可以直接从 CPU Cache 中读取数据，当运算完成后，再将运算得到的数据写回 Main Memory 中。但是，这样存在 <strong>内存缓存不一致性的问题</strong> ！比如我执行一个 i++操作的话，如果两个线程同时执行的话，假设两个线程从 CPU Cache 中读取的 i=1，两个线程做了 1++运算完之后再写回 Main Memory 之后 i=2，而正确结果应该是 i=3。</p>
<p><strong>CPU 为了解决内存缓存不一致性问题可以通过制定缓存一致协议或者其他手段来解决。</strong></p>
<h3 id="2-2-讲一下-JMM-Java-内存模型"><a href="#2-2-讲一下-JMM-Java-内存模型" class="headerlink" title="2.2. 讲一下 JMM(Java 内存模型)"></a>2.2. 讲一下 JMM(Java 内存模型)</h3><p>Java 内存模型抽象了线程和主内存之间的关系，就比如说线程之间的共享变量必须存储在主内存中。Java 内存模型主要目的是为了屏蔽系统和硬件的差异，避免一套代码在不同的平台下产生的效果不一致。</p>
<p>在 JDK1.2 之前，Java 的内存模型实现总是从<strong>主存</strong>（即共享内存）读取变量，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存<strong>本地内存</strong>（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成<strong>数据的不一致</strong>。</p>
<blockquote>
<ul>
<li><strong>主内存</strong> ：所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)</li>
<li><strong>本地内存</strong> ：每个线程都有一个私有的本地内存来存储共享变量的副本，并且，每个线程只能访问自己的本地内存，无法访问其他线程的本地内存。本地内存是 JMM 抽象出来的一个概念，存储了主内存中的共享变量副本。</li>
</ul>
</blockquote>
<p><img data-src="https://xuemingde.com/pages/image/others/IDxmST.png" alt="IDxmST"></p>
<p>要解决这个问题，就需要把变量声明为 <strong><code>volatile</code></strong> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p>
<p>所以，<strong><code>volatile</code> 关键字 除了防止 JVM 的指令重排 ，还有一个重要的作用就是保证变量的可见性。</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/others/lnKsIF.png" alt="lnKsIF"></p>
<h3 id="2-3-并发编程的三个重要特性"><a href="#2-3-并发编程的三个重要特性" class="headerlink" title="2.3. 并发编程的三个重要特性"></a>2.3. 并发编程的三个重要特性</h3><ol>
<li><strong>原子性</strong> : 一个的操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么所有的操作都执行，要么都不执行。<code>synchronized</code> 可以保证代码片段的原子性。</li>
<li><strong>可见性</strong> ：当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。<code>volatile</code> 关键字可以保证共享变量的可见性。</li>
<li><strong>有序性</strong> ：代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。<code>volatile</code> 关键字可以禁止指令进行重排序优化。</li>
</ol>
<h3 id="2-4-说说-synchronized-关键字和-volatile-关键字的区别"><a href="#2-4-说说-synchronized-关键字和-volatile-关键字的区别" class="headerlink" title="2.4. 说说 synchronized 关键字和 volatile 关键字的区别"></a>2.4. 说说 synchronized 关键字和 volatile 关键字的区别</h3><p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在！</p>
<ul>
<li><strong><code>volatile</code> 关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以 <strong><code>volatile</code>性能肯定比<code>synchronized</code>关键字要好</strong> 。但是 <strong><code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块</strong> 。</li>
<li><strong><code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</strong></li>
<li><strong><code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</strong></li>
</ul>
<h2 id="3-ThreadLocal"><a href="#3-ThreadLocal" class="headerlink" title="3. ThreadLocal"></a>3. ThreadLocal</h2><h3 id="3-1-ThreadLocal-简介"><a href="#3-1-ThreadLocal-简介" class="headerlink" title="3.1. ThreadLocal 简介"></a>3.1. ThreadLocal 简介</h3><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<strong>如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</strong> JDK 中提供的<code>ThreadLocal</code>类正是为了解决这样的问题。 <strong><code>ThreadLocal</code>类主要解决的就是让每个线程绑定自己的值，可以将<code>ThreadLocal</code>类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</strong></p>
<p><strong>如果你创建了一个<code>ThreadLocal</code>变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是<code>ThreadLocal</code>变量名的由来。他们可以使用 <code>get（）</code> 和 <code>set（）</code> 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</strong></p>
<p>再举个简单的例子：</p>
<p>比如有两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么 ThreadLocal 就是用来避免这两个线程竞争的。</p>
<h3 id="3-2-ThreadLocal-示例"><a href="#3-2-ThreadLocal-示例" class="headerlink" title="3.2. ThreadLocal 示例"></a>3.2. ThreadLocal 示例</h3><p>相信看了上面的解释，大家已经搞懂 ThreadLocal 类是个什么东西了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalExample</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// SimpleDateFormat 不是线程安全的，所以每个线程都要有自己独立的副本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; formatter = ThreadLocal.withInitial(() -&gt; <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyyMMdd HHmm&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadLocalExample obj = <span class="keyword">new</span> ThreadLocalExample();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(obj, <span class="string">&quot;&quot;</span>+i);</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Thread Name= &quot;</span>+Thread.currentThread().getName()+<span class="string">&quot; default Formatter = &quot;</span>+formatter.get().toPattern());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//formatter pattern is changed here by thread, but it won&#x27;t reflect to other threads</span></span><br><span class="line">        formatter.set(<span class="keyword">new</span> SimpleDateFormat());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Thread Name= &quot;</span>+Thread.currentThread().getName()+<span class="string">&quot; formatter = &quot;</span>+formatter.get().toPattern());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><span class="line">Thread <span class="attr">Name=</span> <span class="number">0</span> default <span class="attr">Formatter</span> = yyyyMMdd HHmm</span><br><span class="line">Thread <span class="attr">Name=</span> <span class="number">0</span> <span class="attr">formatter</span> = yy-M-d ah:mm</span><br><span class="line">Thread <span class="attr">Name=</span> <span class="number">1</span> default <span class="attr">Formatter</span> = yyyyMMdd HHmm</span><br><span class="line">Thread <span class="attr">Name=</span> <span class="number">2</span> default <span class="attr">Formatter</span> = yyyyMMdd HHmm</span><br><span class="line">Thread <span class="attr">Name=</span> <span class="number">1</span> <span class="attr">formatter</span> = yy-M-d ah:mm</span><br><span class="line">Thread <span class="attr">Name=</span> <span class="number">3</span> default <span class="attr">Formatter</span> = yyyyMMdd HHmm</span><br><span class="line">Thread <span class="attr">Name=</span> <span class="number">2</span> <span class="attr">formatter</span> = yy-M-d ah:mm</span><br><span class="line">Thread <span class="attr">Name=</span> <span class="number">4</span> default <span class="attr">Formatter</span> = yyyyMMdd HHmm</span><br><span class="line">Thread <span class="attr">Name=</span> <span class="number">3</span> <span class="attr">formatter</span> = yy-M-d ah:mm</span><br><span class="line">Thread <span class="attr">Name=</span> <span class="number">4</span> <span class="attr">formatter</span> = yy-M-d ah:mm</span><br><span class="line">Thread <span class="attr">Name=</span> <span class="number">5</span> default <span class="attr">Formatter</span> = yyyyMMdd HHmm</span><br><span class="line">Thread <span class="attr">Name=</span> <span class="number">5</span> <span class="attr">formatter</span> = yy-M-d ah:mm</span><br><span class="line">Thread <span class="attr">Name=</span> <span class="number">6</span> default <span class="attr">Formatter</span> = yyyyMMdd HHmm</span><br><span class="line">Thread <span class="attr">Name=</span> <span class="number">6</span> <span class="attr">formatter</span> = yy-M-d ah:mm</span><br><span class="line">Thread <span class="attr">Name=</span> <span class="number">7</span> default <span class="attr">Formatter</span> = yyyyMMdd HHmm</span><br><span class="line">Thread <span class="attr">Name=</span> <span class="number">7</span> <span class="attr">formatter</span> = yy-M-d ah:mm</span><br><span class="line">Thread <span class="attr">Name=</span> <span class="number">8</span> default <span class="attr">Formatter</span> = yyyyMMdd HHmm</span><br><span class="line">Thread <span class="attr">Name=</span> <span class="number">9</span> default <span class="attr">Formatter</span> = yyyyMMdd HHmm</span><br><span class="line">Thread <span class="attr">Name=</span> <span class="number">8</span> <span class="attr">formatter</span> = yy-M-d ah:mm</span><br><span class="line">Thread <span class="attr">Name=</span> <span class="number">9</span> <span class="attr">formatter</span> = yy-M-d ah:mm</span><br></pre></td></tr></table></figure>
<p>从输出中可以看出，Thread-0 已经改变了 formatter 的值，但仍然是 thread-2 默认格式化程序与初始化值相同，其他线程也一样。</p>
<p>上面有一段代码用到了创建 <code>ThreadLocal</code> 变量的那段代码用到了 Java8 的知识，它等于下面这段代码，如果你写了下面这段代码的话，IDEA 会提示你转换为 Java8 的格式(IDEA 真的不错！)。因为 ThreadLocal 类在 Java 8 中扩展，使用一个新的方法<code>withInitial()</code>，将 Supplier 功能接口作为参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;SimpleDateFormat&gt; formatter = <span class="keyword">new</span> ThreadLocal&lt;SimpleDateFormat&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SimpleDateFormat <span class="title">initialValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyyMMdd HHmm&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-ThreadLocal-原理"><a href="#3-3-ThreadLocal-原理" class="headerlink" title="3.3. ThreadLocal 原理"></a>3.3. ThreadLocal 原理</h3><p>从 <code>Thread</code>类源代码入手。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">//与此线程有关的ThreadLocal值。由ThreadLocal类维护</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面<code>Thread</code>类 源代码可以看出<code>Thread</code> 类中有一个 <code>threadLocals</code> 和 一个 <code>inheritableThreadLocals</code> 变量，它们都是 <code>ThreadLocalMap</code> 类型的变量,我们可以把 <code>ThreadLocalMap</code> 理解为<code>ThreadLocal</code> 类实现的定制化的 <code>HashMap</code>。默认情况下这两个变量都是 null，只有当前线程调用 <code>ThreadLocal</code> 类的 <code>set</code>或<code>get</code>方法时才创建它们，实际上调用这两个方法的时候，我们调用的是<code>ThreadLocalMap</code>类对应的 <code>get()</code>、<code>set()</code>方法。</p>
<p><code>ThreadLocal</code>类的<code>set()</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面这些内容，我们足以通过猜测得出结论：<strong>最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 <code>ThreadLocal</code> 上，<code>ThreadLocal</code> 可以理解为只是<code>ThreadLocalMap</code>的封装，传递了变量值。</strong> <code>ThrealLocal</code> 类中可以通过<code>Thread.currentThread()</code>获取到当前线程对象后，直接通过<code>getMap(Thread t)</code>可以访问到该线程的<code>ThreadLocalMap</code>对象。</p>
<p><strong>每个<code>Thread</code>中都具备一个<code>ThreadLocalMap</code>，而<code>ThreadLocalMap</code>可以存储以<code>ThreadLocal</code>为 key ，Object 对象为 value 的键值对。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如我们在同一个线程中声明了两个 <code>ThreadLocal</code> 对象的话，会使用 <code>Thread</code>内部都是使用仅有那个<code>ThreadLocalMap</code> 存放数据的，<code>ThreadLocalMap</code>的 key 就是 <code>ThreadLocal</code>对象，value 就是 <code>ThreadLocal</code> 对象调用<code>set</code>方法设置的值。</p>
<p><img data-src="https://xuemingde.com/pages/image/others/Ri8u1H.jpg" alt="Ri8u1H"></p>
<p><code>ThreadLocalMap</code>是<code>ThreadLocal</code>的静态内部类。</p>
<p><img data-src="https://xuemingde.com/pages/image/others/zEspZE.jpg" alt="zEspZE"></p>
<h3 id="3-4-ThreadLocal-内存泄露问题"><a href="#3-4-ThreadLocal-内存泄露问题" class="headerlink" title="3.4. ThreadLocal 内存泄露问题"></a>3.4. ThreadLocal 内存泄露问题</h3><p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用,而 value 是强引用。所以，如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后 最好手动调用<code>remove()</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>弱引用介绍：</strong></p>
<blockquote>
<p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p>
<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
</blockquote>
<h2 id="4-线程池"><a href="#4-线程池" class="headerlink" title="4. 线程池"></a>4. 线程池</h2><h3 id="4-1-为什么要用线程池？"><a href="#4-1-为什么要用线程池？" class="headerlink" title="4.1. 为什么要用线程池？"></a>4.1. 为什么要用线程池？</h3><blockquote>
<p><strong>池化技术想必大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</strong></p>
</blockquote>
<p><strong>线程池</strong>提供了一种限制和管理资源（包括执行一个任务）。 每个<strong>线程池</strong>还维护一些基本统计信息，例如已完成任务的数量。</p>
<p>这里借用《Java 并发编程的艺术》提到的来说一下<strong>使用线程池的好处</strong>：</p>
<ul>
<li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<h3 id="4-2-实现-Runnable-接口和-Callable-接口的区别"><a href="#4-2-实现-Runnable-接口和-Callable-接口的区别" class="headerlink" title="4.2. 实现 Runnable 接口和 Callable 接口的区别"></a>4.2. 实现 Runnable 接口和 Callable 接口的区别</h3><p><code>Runnable</code>自 Java 1.0 以来一直存在，但<code>Callable</code>仅在 Java 1.5 中引入,目的就是为了来处理<code>Runnable</code>不支持的用例。<strong><code>Runnable</code> 接口</strong> 不会返回结果或抛出检查异常，但是 <strong><code>Callable</code> 接口</strong> 可以。所以，如果任务不需要返回结果或抛出异常推荐使用 <strong><code>Runnable</code> 接口</strong> ，这样代码看起来会更加简洁。</p>
<p>工具类 <code>Executors</code> 可以实现将 <code>Runnable</code> 对象转换成 <code>Callable</code> 对象。（<code>Executors.callable(Runnable task)</code> 或 <code>Executors.callable(Runnable task, Object result)</code>）。</p>
<p><code>Runnable.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 被线程执行，没有返回值也无法抛出异常</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Callable.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算结果，或在无法这样做时抛出异常。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 计算得出的结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> 如果无法计算结果，则抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-执行-execute-方法和-submit-方法的区别是什么呢？"><a href="#4-3-执行-execute-方法和-submit-方法的区别是什么呢？" class="headerlink" title="4.3. 执行 execute()方法和 submit()方法的区别是什么呢？"></a>4.3. 执行 execute()方法和 submit()方法的区别是什么呢？</h3><ol>
<li><strong><code>execute()</code>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</strong></li>
<li><strong><code>submit()</code>方法用于提交需要返回值的任务。线程池会返回一个 <code>Future</code> 类型的对象，通过这个 <code>Future</code> 对象可以判断任务是否执行成功</strong>，并且可以通过 <code>Future</code> 的 <code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞当前线程直到任务完成，而使用 <code>get(long timeout，TimeUnit unit)</code>方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li>
</ol>
<p>我们以 <strong><code>AbstractExecutorService</code> 接口</strong> 中的一个 <code>submit</code> 方法为例子来看看源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面方法调用的 <code>newTaskFor</code> 方法返回了一个 <code>FutureTask</code> 对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再来看看<code>execute()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-4-如何创建线程池"><a href="#4-4-如何创建线程池" class="headerlink" title="4.4. 如何创建线程池"></a>4.4. 如何创建线程池</h3><p>《阿里巴巴 Java 开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p>
<blockquote>
<p>Executors 返回线程池对象的弊端如下：</p>
<ul>
<li><strong>FixedThreadPool 和 SingleThreadExecutor</strong> ： 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致 OOM。</li>
<li><strong>CachedThreadPool 和 ScheduledThreadPool</strong> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</li>
</ul>
</blockquote>
<p><strong>方式一：通过构造方法实现</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/others/paxN3T.jpg" alt="paxN3T"></p>
<p><strong>方式二：通过 Executor 框架的工具类 Executors 来实现</strong></p>
<p>我们可以创建三种类型的 ThreadPoolExecutor：</p>
<ul>
<li><strong>FixedThreadPool</strong> ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li>
<li><strong>SingleThreadExecutor：</strong> 方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li>
<li><strong>CachedThreadPool：</strong> 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li>
</ul>
<p>对应 Executors 工具类中的方法如图所示：</p>
<p><img data-src="https://xuemingde.com/pages/image/others/D2pTvO.jpg" alt="D2pTvO"></p>
<h3 id="4-5-ThreadPoolExecutor-类分析"><a href="#4-5-ThreadPoolExecutor-类分析" class="headerlink" title="4.5 ThreadPoolExecutor 类分析"></a>4.5 ThreadPoolExecutor 类分析</h3><p><code>ThreadPoolExecutor</code> 类中提供的四个构造方法。我们来看最长的那个，其余三个都是在这个构造方法的基础上产生（其他几个构造方法说白点都是给定某些默认参数的构造方法比如默认制定拒绝策略是什么），这里就不贴代码讲了，比较简单。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用给定的初始参数创建一个新的ThreadPoolExecutor。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                      TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                      BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                      ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                      RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>下面这些对创建 非常重要，在后面使用线程池的过程中你一定会用到！所以，务必拿着小本本记清楚。</strong></p>
<h4 id="4-5-1-ThreadPoolExecutor构造函数重要参数分析"><a href="#4-5-1-ThreadPoolExecutor构造函数重要参数分析" class="headerlink" title="4.5.1 ThreadPoolExecutor构造函数重要参数分析"></a>4.5.1 <code>ThreadPoolExecutor</code>构造函数重要参数分析</h4><p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p>
<ul>
<li><strong><code>corePoolSize</code> :</strong> 核心线程数定义了最小可以同时运行的线程数量。</li>
<li><strong><code>maximumPoolSize</code> :</strong> 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
<li><strong><code>workQueue</code>:</strong> 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>
</ul>
<p><code>ThreadPoolExecutor</code>其他常见参数:</p>
<ol>
<li><strong><code>keepAliveTime</code></strong>:当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li>
<li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li>
<li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li>
<li><strong><code>handler</code></strong> :饱和策略。关于饱和策略下面单独介绍一下。</li>
</ol>
<h4 id="4-5-2-ThreadPoolExecutor-饱和策略"><a href="#4-5-2-ThreadPoolExecutor-饱和策略" class="headerlink" title="4.5.2 ThreadPoolExecutor 饱和策略"></a>4.5.2 <code>ThreadPoolExecutor</code> 饱和策略</h4><p><strong><code>ThreadPoolExecutor</code> 饱和策略定义:</strong></p>
<p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，<code>ThreadPoolTaskExecutor</code> 定义一些策略:</p>
<ul>
<li><strong><code>ThreadPoolExecutor.AbortPolicy</code>：</strong> 抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</li>
<li><strong><code>ThreadPoolExecutor.CallerRunsPolicy</code>：</strong> 调用执行自己的线程运行任务，也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。</li>
<li><strong><code>ThreadPoolExecutor.DiscardPolicy</code>：</strong> 不处理新任务，直接丢弃掉。</li>
<li><strong><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：</strong> 此策略将丢弃最早的未处理的任务请求。</li>
</ul>
<p>举个例子： Spring 通过 <code>ThreadPoolTaskExecutor</code> 或者我们直接通过 <code>ThreadPoolExecutor</code> 的构造函数创建线程池的时候，当我们不指定 <code>RejectedExecutionHandler</code> 饱和策略的话来配置线程池的时候默认使用的是 <code>ThreadPoolExecutor.AbortPolicy</code>。在默认情况下，<code>ThreadPoolExecutor</code> 将抛出 <code>RejectedExecutionException</code> 来拒绝新来的任务 ，这代表你将丢失对这个任务的处理。 对于可伸缩的应用程序，建议使用 <code>ThreadPoolExecutor.CallerRunsPolicy</code>。当最大池被填满时，此策略为我们提供可伸缩队列。（这个直接查看 <code>ThreadPoolExecutor</code> 的构造函数源码就可以看出，比较简单的原因，这里就不贴代码了）</p>
<h3 id="4-6-一个简单的线程池-Demo"><a href="#4-6-一个简单的线程池-Demo" class="headerlink" title="4.6 一个简单的线程池 Demo"></a>4.6 一个简单的线程池 Demo</h3><p>为了让大家更清楚上面的面试题中的一些概念，我写了一个简单的线程池 Demo。</p>
<p>首先创建一个 <code>Runnable</code> 接口的实现类（当然也可以是 <code>Callable</code> 接口，我们上面也说了两者的区别。）</p>
<p><code>MyRunnable.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是一个简单的Runnable类，需要大约5秒钟来执行其任务。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> shuang.kou</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String command;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRunnable</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; Start. Time = &quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">        processCommand();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; End. Time = &quot;</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.command;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>编写测试程序，我们这里以阿里巴巴推荐的使用 <code>ThreadPoolExecutor</code> 构造函数自定义参数的方式来创建线程池。</p>
<p><code>ThreadPoolExecutorDemo.java</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CORE_POOL_SIZE = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QUEUE_CAPACITY = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Long KEEP_ALIVE_TIME = <span class="number">1L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用阿里巴巴推荐的创建线程池的方式</span></span><br><span class="line">        <span class="comment">//通过ThreadPoolExecutor构造函数自定义参数创建</span></span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                CORE_POOL_SIZE,</span><br><span class="line">                MAX_POOL_SIZE,</span><br><span class="line">                KEEP_ALIVE_TIME,</span><br><span class="line">                TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(QUEUE_CAPACITY),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//创建WorkerThread对象（WorkerThread类实现了Runnable 接口）</span></span><br><span class="line">            Runnable worker = <span class="keyword">new</span> MyRunnable(<span class="string">&quot;&quot;</span> + i);</span><br><span class="line">            <span class="comment">//执行Runnable</span></span><br><span class="line">            executor.execute(worker);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//终止线程池</span></span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executor.isTerminated()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Finished all threads&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到我们上面的代码指定了：</p>
<ol>
<li><code>corePoolSize</code>: 核心线程数为 5。</li>
<li><code>maximumPoolSize</code> ：最大线程数 10</li>
<li><code>keepAliveTime</code> : 等待时间为 1L。</li>
<li><code>unit</code>: 等待时间的单位为 TimeUnit.SECONDS。</li>
<li><code>workQueue</code>：任务队列为 <code>ArrayBlockingQueue</code>，并且容量为 100;</li>
<li><code>handler</code>:饱和策略为 <code>CallerRunsPolicy</code>。</li>
</ol>
<p><strong>Output：</strong></p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">pool</span>-<span class="number">1</span>-thread-<span class="number">3</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">37</span> CST <span class="number">2020</span></span><br><span class="line"><span class="attribute">pool</span>-<span class="number">1</span>-thread-<span class="number">5</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">37</span> CST <span class="number">2020</span></span><br><span class="line"><span class="attribute">pool</span>-<span class="number">1</span>-thread-<span class="number">2</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">37</span> CST <span class="number">2020</span></span><br><span class="line"><span class="attribute">pool</span>-<span class="number">1</span>-thread-<span class="number">1</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">37</span> CST <span class="number">2020</span></span><br><span class="line"><span class="attribute">pool</span>-<span class="number">1</span>-thread-<span class="number">4</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">37</span> CST <span class="number">2020</span></span><br><span class="line"><span class="attribute">pool</span>-<span class="number">1</span>-thread-<span class="number">3</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line"><span class="attribute">pool</span>-<span class="number">1</span>-thread-<span class="number">4</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line"><span class="attribute">pool</span>-<span class="number">1</span>-thread-<span class="number">1</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line"><span class="attribute">pool</span>-<span class="number">1</span>-thread-<span class="number">5</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line"><span class="attribute">pool</span>-<span class="number">1</span>-thread-<span class="number">1</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line"><span class="attribute">pool</span>-<span class="number">1</span>-thread-<span class="number">2</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line"><span class="attribute">pool</span>-<span class="number">1</span>-thread-<span class="number">5</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line"><span class="attribute">pool</span>-<span class="number">1</span>-thread-<span class="number">4</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line"><span class="attribute">pool</span>-<span class="number">1</span>-thread-<span class="number">3</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line"><span class="attribute">pool</span>-<span class="number">1</span>-thread-<span class="number">2</span> Start. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">42</span> CST <span class="number">2020</span></span><br><span class="line"><span class="attribute">pool</span>-<span class="number">1</span>-thread-<span class="number">1</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">47</span> CST <span class="number">2020</span></span><br><span class="line"><span class="attribute">pool</span>-<span class="number">1</span>-thread-<span class="number">4</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">47</span> CST <span class="number">2020</span></span><br><span class="line"><span class="attribute">pool</span>-<span class="number">1</span>-thread-<span class="number">5</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">47</span> CST <span class="number">2020</span></span><br><span class="line"><span class="attribute">pool</span>-<span class="number">1</span>-thread-<span class="number">3</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">47</span> CST <span class="number">2020</span></span><br><span class="line"><span class="attribute">pool</span>-<span class="number">1</span>-thread-<span class="number">2</span> End. Time = Sun Apr <span class="number">12</span> <span class="number">11</span>:<span class="number">14</span>:<span class="number">47</span> CST <span class="number">2020</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4-7-线程池原理分析"><a href="#4-7-线程池原理分析" class="headerlink" title="4.7 线程池原理分析"></a>4.7 线程池原理分析</h3><p>承接 4.6 节，我们通过代码输出结果可以看出：<strong>线程池首先会先执行 5 个任务，然后这些任务有任务被执行完的话，就会去拿新的任务执行。</strong> 大家可以先通过上面讲解的内容，分析一下到底是咋回事？（自己独立思考一会）</p>
<p>现在，我们就分析上面的输出内容来简单分析一下线程池原理。</p>
<p><strong>为了搞懂线程池的原理，我们需要首先分析一下 <code>execute</code>方法。</strong> 在 4.6 节中的 Demo 中我们使用 <code>executor.execute(worker)</code>来提交一个任务到线程池中去，这个方法非常重要，下面我们来看看它的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存放线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c &amp; CAPACITY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果任务为null，则抛出异常。</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// ctl 中保存的线程池当前的一些状态信息</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  下面会涉及到 3 步 操作</span></span><br><span class="line">    <span class="comment">// 1.首先判断当前线程池中执行的任务数量是否小于 corePoolSize</span></span><br><span class="line">    <span class="comment">// 如果小于的话，通过addWorker(command, true)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2.如果当前执行的任务数量大于等于 corePoolSize 的时候就会走到这里</span></span><br><span class="line">    <span class="comment">// 通过 isRunning 方法判断线程池状态，线程池处于 RUNNING 状态并且队列可以加入任务，该任务才会被加入进去</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 再次获取线程池状态，如果线程池状态不是 RUNNING 状态就需要从任务队列中移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略。</span></span><br><span class="line">        <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">            <span class="comment">// 如果当前线程池为空就新创建一个线程并执行。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 通过addWorker(command, false)新建一个线程，并将任务(command)添加到该线程中；然后，启动该线程从而执行任务。</span></span><br><span class="line">    <span class="comment">//如果addWorker(command, false)执行失败，则通过reject()执行相应的拒绝策略的内容。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过下图可以更好的对上面这 3 步做一个展示，下图是我为了省事直接从网上找到，原地址不明。</p>
<p><img data-src="https://xuemingde.com/pages/image/others/namkx5.jpg" alt="namkx5"></p>
<p>现在，让我们在回到 4.6 节我们写的 Demo， 现在是不是很容易就可以搞懂它的原理了呢？</p>
<p>没搞懂的话，也没关系，可以看看我的分析：</p>
<blockquote>
<p>我们在代码中模拟了 10 个任务，我们配置的核心线程数为 5 、等待队列容量为 100 ，所以每次只可能存在 5 个任务同时执行，剩下的 5 个任务会被放到等待队列中去。当前的5个任务中如果有任务被执行完了，线程池就会去拿新的任务执行。</p>
</blockquote>
<h2 id="5-Atomic-原子类"><a href="#5-Atomic-原子类" class="headerlink" title="5. Atomic 原子类"></a>5. Atomic 原子类</h2><h3 id="5-1-介绍一下-Atomic-原子类"><a href="#5-1-介绍一下-Atomic-原子类" class="headerlink" title="5.1. 介绍一下 Atomic 原子类"></a>5.1. 介绍一下 Atomic 原子类</h3><p><code>Atomic</code> 翻译成中文是原子的意思。在化学上，我们知道原子是构成一般物质的最小单位，在化学反应中是不可分割的。在我们这里 Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。</p>
<p>所以，所谓原子类说简单点就是具有原子/原子操作特征的类。</p>
<p>并发包 <code>java.util.concurrent</code> 的原子类都存放在<code>java.util.concurrent.atomic</code>下,如下图所示。</p>
<p><img data-src="https://xuemingde.com/pages/image/others/ViBcdS.jpg" alt="ViBcdS"></p>
<h3 id="5-2-JUC-包中的原子类是哪-4-类"><a href="#5-2-JUC-包中的原子类是哪-4-类" class="headerlink" title="5.2. JUC 包中的原子类是哪 4 类?"></a>5.2. JUC 包中的原子类是哪 4 类?</h3><p><strong>基本类型</strong></p>
<p>使用原子的方式更新基本类型</p>
<ul>
<li><code>AtomicInteger</code>：整形原子类</li>
<li><code>AtomicLong</code>：长整型原子类</li>
<li><code>AtomicBoolean</code>：布尔型原子类</li>
</ul>
<p><strong>数组类型</strong></p>
<p>使用原子的方式更新数组里的某个元素</p>
<ul>
<li><code>AtomicIntegerArray</code>：整形数组原子类</li>
<li><code>AtomicLongArray</code>：长整形数组原子类</li>
<li><code>AtomicReferenceArray</code>：引用类型数组原子类</li>
</ul>
<p><strong>引用类型</strong></p>
<ul>
<li><code>AtomicReference</code>：引用类型原子类</li>
<li><code>AtomicStampedReference</code>：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li>
<li><code>AtomicMarkableReference</code> ：原子更新带有标记位的引用类型</li>
</ul>
<p><strong>对象的属性修改类型</strong></p>
<ul>
<li><code>AtomicIntegerFieldUpdater</code>：原子更新整形字段的更新器</li>
<li><code>AtomicLongFieldUpdater</code>：原子更新长整形字段的更新器</li>
<li><code>AtomicReferenceFieldUpdater</code>：原子更新引用类型字段的更新器</li>
</ul>
<h3 id="5-3-讲讲-AtomicInteger-的使用"><a href="#5-3-讲讲-AtomicInteger-的使用" class="headerlink" title="5.3. 讲讲 AtomicInteger 的使用"></a>5.3. 讲讲 AtomicInteger 的使用</h3><p><strong>AtomicInteger 类常用方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> <span class="comment">//获取当前的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span><span class="comment">//获取当前的值，并设置新的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span><span class="comment">//获取当前的值，并自增</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">()</span> <span class="comment">//获取当前的值，并自减</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> <span class="comment">//获取当前的值，并加上预期的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> <span class="comment">//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(<span class="keyword">int</span> newValue)</span><span class="comment">//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span></span><br></pre></td></tr></table></figure>
<p><strong>AtomicInteger 类的使用示例</strong></p>
<p>使用 AtomicInteger 之后，不用对 increment() 方法加锁也可以保证线程安全。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="comment">//使用AtomicInteger之后，不需要对该方法加锁，也可以实现线程安全。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="5-4-能不能给我简单介绍一下-AtomicInteger-类的原理"><a href="#5-4-能不能给我简单介绍一下-AtomicInteger-类的原理" class="headerlink" title="5.4. 能不能给我简单介绍一下 AtomicInteger 类的原理"></a>5.4. 能不能给我简单介绍一下 AtomicInteger 类的原理</h3><p>AtomicInteger 线程安全原理简单分析</p>
<p>AtomicInteger 类的部分源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField(<span class="string">&quot;value&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure>
<p>AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。</p>
<p>CAS 的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个 volatile 变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</p>
<p>关于 Atomic 原子类这部分更多内容可以查看我的这篇文章：并发编程面试必备：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpnMk9UQTBOamswT0E9PSZhbXA7bWlkPTIyNDc0ODQ4MzQmYW1wO2lkeD0xJmFtcDtzbj03ZDM4MzUwOTFhZjgxMjVjMTNmYzZkYjc2NWY0YzViZCZhbXA7c291cmNlPTQxI3dlY2hhdF9yZWRpcmVjdA==">JUC 中的 Atomic 原子类总结<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="6-AQS"><a href="#6-AQS" class="headerlink" title="6. AQS"></a>6. AQS</h2><h3 id="6-1-AQS-介绍"><a href="#6-1-AQS-介绍" class="headerlink" title="6.1. AQS 介绍"></a>6.1. AQS 介绍</h3><p>AQS 的全称为（<code>AbstractQueuedSynchronizer</code>），这个类在<code>java.util.concurrent.locks</code>包下面。</p>
<p><img data-src="https://xuemingde.com/pages/image/others/7yDVXQ.jpg" alt="7yDVXQ"></p>
<p>AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出大量应用广泛的同步器，比如我们提到的 <code>ReentrantLock</code>，<code>Semaphore</code>，其他的诸如 <code>ReentrantReadWriteLock</code>，<code>SynchronousQueue</code>，<code>FutureTask</code> 等等皆是基于 AQS 的。当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器。</p>
<h3 id="6-2-AQS-原理分析"><a href="#6-2-AQS-原理分析" class="headerlink" title="6.2. AQS 原理分析"></a>6.2. AQS 原理分析</h3><p>AQS 原理这部分参考了部分博客，在 6.2 节末尾放了链接。</p>
<blockquote>
<p>在面试中被问到并发知识的时候，大多都会被问到“请你说一下自己对于 AQS 原理的理解”。下面给大家一个示例供大家参加，面试不是背题，大家一定要加入自己的思想，即使加入不了自己的思想也要保证自己能够通俗的讲出来而不是背出来。</p>
</blockquote>
<p>下面大部分内容其实在 AQS 类注释上已经给出了，不过是英语看着比较吃力一点，感兴趣的话可以看看源码。</p>
<h4 id="6-2-1-AQS-原理概览"><a href="#6-2-1-AQS-原理概览" class="headerlink" title="6.2.1. AQS 原理概览"></a>6.2.1. AQS 原理概览</h4><p><strong>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong></p>
<blockquote>
<p>CLH(Craig,Landin and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</p>
</blockquote>
<p>看个 AQS(AbstractQueuedSynchronizer)原理图：</p>
<p><img data-src="https://xuemingde.com/pages/image/others/oZcrm2.jpg" alt="oZcrm2"></p>
<p>AQS 使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;<span class="comment">//共享变量，使用volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure>
<p>状态信息通过 protected 类型的 getState，setState，compareAndSetState 进行操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置同步状态的值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-2-2-AQS-对资源的共享方式"><a href="#6-2-2-AQS-对资源的共享方式" class="headerlink" title="6.2.2. AQS 对资源的共享方式"></a>6.2.2. AQS 对资源的共享方式</h4><p><strong>AQS 定义两种资源共享方式</strong></p>
<ul>
<li><strong>Exclusive</strong>（独占）：只有一个线程能执行，如 <code>ReentrantLock</code>。又可分为公平锁和非公平锁：<ul>
<li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li>
<li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li>
</ul>
</li>
<li><strong>Share</strong>（共享）：多个线程可同时执行，如<code>CountDownLatch</code>、<code>Semaphore</code>、 <code>CyclicBarrier</code>、<code>ReadWriteLock</code> 我们都会在后面讲到。</li>
</ul>
<p><code>ReentrantReadWriteLock</code> 可以看成是组合式，因为 <code>ReentrantReadWriteLock</code> 也就是读写锁允许多个线程同时对某一资源进行读。</p>
<p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS 已经在顶层实现好了。</p>
<h4 id="6-2-3-AQS-底层使用了模板方法模式"><a href="#6-2-3-AQS-底层使用了模板方法模式" class="headerlink" title="6.2.3. AQS 底层使用了模板方法模式"></a>6.2.3. AQS 底层使用了模板方法模式</h4><p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p>
<ol>
<li>使用者继承 <code>AbstractQueuedSynchronizer</code> 并重写指定的方法。（这些重写方法很简单，无非是对于共享资源 state 的获取和释放）</li>
<li>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li>
</ol>
<p>这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。</p>
<p><strong>AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的钩子方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span>)</span><span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span>)</span><span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span>)</span><span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span>)</span><span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span><span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span></span><br></pre></td></tr></table></figure>
<p><strong>什么是钩子方法呢？</strong> 钩子方法是一种被声明在抽象类中的方法，它可以是空方法（由子类实现），也可以是默认实现的方法。模板设计模式通过钩子方法控制固定步骤的实现。</p>
<p>除了上面提到的钩子方法之外，AQS 类中的其他方法都是 <code>final</code> ，所以无法被其他类重写。</p>
<p>以 <code>ReentrantLock</code> 为例，state 初始化为 0，表示未锁定状态。A 线程 <code>lock()</code> 时，会调用 <code>tryAcquire()</code> 独占该锁并将 <code>state+1</code> 。此后，其他线程再 <code>tryAcquire()</code> 时就会失败，直到 A 线程 <code>unlock()</code> 到 <code>state=</code>0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多少次，这样才能保证 state 是能回到零态的。</p>
<p>再以 <code>CountDownLatch</code> 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后<code>countDown()</code> 一次，state 会 CAS(Compare and Swap) 减 1。等到所有子线程都执行完后(即 <code>state=0</code> )，会 <code>unpark()</code> 主调用线程，然后主调用线程就会从 <code>await()</code> 函数返回，继续后余动作。</p>
<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现<code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。</p>
<p>推荐两篇 AQS 原理和相关源码分析的文章：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vd2F0ZXJ5c3RvbmUvcC80OTIwNzk3Lmh0bWw=">https://www.cnblogs.com/waterystone/p/4920797.html<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vY2hlbmd4aWFvL2FyY2hpdmUvMjAxNy8wNy8yNC83MTQxMTYwLmh0bWw=">https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h3 id="6-3-AQS-组件总结"><a href="#6-3-AQS-组件总结" class="headerlink" title="6.3. AQS 组件总结"></a>6.3. AQS 组件总结</h3><ul>
<li><strong><code>Semaphore</code>(信号量)-允许多个线程同时访问：</strong> <code>synchronized</code> 和 <code>ReentrantLock</code> 都是一次只允许一个线程访问某个资源，<code>Semaphore</code>(信号量)可以指定多个线程同时访问某个资源。</li>
<li><strong><code>CountDownLatch</code>（倒计时器）：</strong>  <code>CountDownLatch</code> 是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</li>
<li><strong><code>CyclicBarrier</code>(循环栅栏)：</strong> <code>CyclicBarrier</code> 和 <code>CountDownLatch</code> 非常类似，它也可以实现线程间的技术等待，但是它的功能比 <code>CountDownLatch</code> 更加复杂和强大。主要应用场景和 <code>CountDownLatch</code> 类似。<code>CyclicBarrier</code> 的字面意思是可循环使用（<code>Cyclic</code>）的屏障（<code>Barrier</code>）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。<code>CyclicBarrier</code> 默认的构造方法是 <code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程调用 <code>await()</code> 方法告诉 <code>CyclicBarrier</code> 我已经到达了屏障，然后当前线程被阻塞。</li>
</ul>
<h3 id="6-4-用过-CountDownLatch-么？什么场景下用的？"><a href="#6-4-用过-CountDownLatch-么？什么场景下用的？" class="headerlink" title="6.4. 用过 CountDownLatch 么？什么场景下用的？"></a>6.4. 用过 CountDownLatch 么？什么场景下用的？</h3><p><code>CountDownLatch</code> 的作用就是 允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。之前在项目中，有一个使用多线程读取多个文件处理的场景，我用到了 <code>CountDownLatch</code> 。具体场景是下面这样的：</p>
<p>我们要读取处理 6 个文件，这 6 个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这几个文件的处理的结果进行统计整理。</p>
<p>为此我们定义了一个线程池和 count 为 6 的<code>CountDownLatch</code>对象 。使用线程池处理读取任务，每一个线程处理完之后就将 count-1，调用<code>CountDownLatch</code>对象的 <code>await()</code>方法，直到所有文件读取完之后，才会接着执行后面的逻辑。</p>
<p>伪代码是下面这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchExample1</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理文件的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> threadCount = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个具有固定线程数量的线程池对象（推荐使用构造方法创建）</span></span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadCount);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> threadnum = i;</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//处理文件的业务操作</span></span><br><span class="line">                    <span class="comment">//......</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//表示一个文件已经被完成</span></span><br><span class="line">                    countDownLatch.countDown();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">        System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>有没有可以改进的地方呢？</strong></p>
<p>可以使用 <code>CompletableFuture</code> 类来改进！Java8 的 <code>CompletableFuture</code> 提供了很多对多线程友好的方法，使用它可以很方便地为我们编写多线程程序，什么异步、串行、并行或者等待所有线程执行完任务什么的都非常方便。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; task1 =</span><br><span class="line">    CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">        <span class="comment">//自定义业务操作</span></span><br><span class="line">    &#125;);</span><br><span class="line">......</span><br><span class="line">CompletableFuture&lt;Void&gt; task6 =</span><br><span class="line">    CompletableFuture.supplyAsync(()-&gt;&#123;</span><br><span class="line">    <span class="comment">//自定义业务操作</span></span><br><span class="line">    &#125;);</span><br><span class="line">......</span><br><span class="line">CompletableFuture&lt;Void&gt; headerFuture=CompletableFuture.allOf(task1,.....,task6);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    headerFuture.join();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;all done. &quot;</span>);</span><br></pre></td></tr></table></figure>
<p>上面的代码还可以接续优化，当任务过多的时候，把每一个 task 都列出来不太现实，可以考虑通过循环来添加任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//文件夹位置</span></span><br><span class="line">List&lt;String&gt; filePaths = Arrays.asList(...)</span><br><span class="line"><span class="comment">// 异步处理所有文件</span></span><br><span class="line">List&lt;CompletableFuture&lt;String&gt;&gt; fileFutures = filePaths.stream()</span><br><span class="line">    .map(filePath -&gt; doSomeThing(filePath))</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line"><span class="comment">// 将他们合并起来</span></span><br><span class="line">CompletableFuture&lt;Void&gt; allFutures = CompletableFuture.allOf(</span><br><span class="line">    fileFutures.toArray(<span class="keyword">new</span> CompletableFuture[fileFutures.size()])</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="7-Reference"><a href="#7-Reference" class="headerlink" title="7 Reference"></a>7 Reference</h2><ul>
<li>《深入理解 Java 虚拟机》</li>
<li>《实战 Java 高并发程序设计》</li>
<li>《Java 并发编程的艺术》</li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vd2F0ZXJ5c3RvbmUvcC80OTIwNzk3Lmh0bWw=">https://www.cnblogs.com/waterystone/p/4920797.html<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vY2hlbmd4aWFvL2FyY2hpdmUvMjAxNy8wNy8yNC83MTQxMTYwLmh0bWw=">https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuam91cm5hbGRldi5jb20vMTA3Ni9qYXZhLXRocmVhZGxvY2FsLWV4YW1wbGU=">https://www.journaldev.com/1076/java-threadlocal-example<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<p>查看原文:</p>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1NuYWlsY2xpbWIvSmF2YUd1aWRlL2Jsb2IvbWFpbi9kb2NzL2phdmEvY29uY3VycmVudC9qYXZhLWNvbmN1cnJlbnQtcXVlc3Rpb25zLTAyLm1k">https://github.com/Snailclimb/JavaGuide/blob/main/docs/java/concurrent/java-concurrent-questions-02.md<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
]]></content>
      <categories>
        <category>并发与多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>C</tag>
        <tag>内存</tag>
        <tag>Spring</tag>
        <tag>GC</tag>
        <tag>数据库</tag>
        <tag>堆</tag>
        <tag>函数</tag>
        <tag>数组</tag>
        <tag>C++</tag>
        <tag>CPU</tag>
        <tag>局部</tag>
        <tag>变量</tag>
        <tag>面试</tag>
        <tag>线程池</tag>
        <tag>锁</tag>
        <tag>Redis</tag>
        <tag>并发</tag>
        <tag>多线程</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>JUC线程池 FutureTask详解</title>
    <url>/posts/2HQQX90.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>原文：<span class="exturl" data-url="aHR0cHM6Ly9wZGFpLnRlY2gvbWQvamF2YS90aHJlYWQvamF2YS10aHJlYWQteC1qdWMtZXhlY3V0b3ItRnV0dXJlVGFzay5odG1s">https://pdai.tech/md/java/thread/java-thread-x-juc-executor-FutureTask.html<i class="fa fa-external-link-alt"></i></span></p>
<p>Future 表示了一个任务的生命周期，是一个可取消的异步运算，可以把它看作是一个异步操作的结果的占位符，它将在未来的某个时刻完成，并提供对其结果的访问。在并发包中许多异步任务类都继承自Future，其中最典型的就是 FutureTask。@pdai</p>
</blockquote>
<h2 id="带着BAT大厂的面试问题去理解FutureTask"><a href="#带着BAT大厂的面试问题去理解FutureTask" class="headerlink" title="带着BAT大厂的面试问题去理解FutureTask"></a>带着BAT大厂的面试问题去理解FutureTask</h2><blockquote>
<p>TIP</p>
<p>请带着这些问题继续后文，会很大程度上帮助你更好的理解FutureTask。@pdai</p>
</blockquote>
<ul>
<li>FutureTask用来解决什么问题的? 为什么会出现?</li>
<li>FutureTask类结构关系怎么样的?</li>
<li>FutureTask的线程安全是由什么保证的?</li>
<li>FutureTask结果返回机制?</li>
<li>FutureTask内部运行状态的转变?</li>
<li>FutureTask通常会怎么用? 举例说明。</li>
</ul>
<h2 id="FutureTask简介"><a href="#FutureTask简介" class="headerlink" title="FutureTask简介"></a>FutureTask简介</h2><p>FutureTask 为 Future 提供了基础实现，如获取任务执行结果(get)和取消任务(cancel)等。如果任务尚未完成，获取任务执行结果时将会阻塞。一旦执行结束，任务就不能被重启或取消(除非使用runAndReset执行计算)。FutureTask 常用来封装 Callable 和 Runnable，也可以作为一个任务提交到线程池中执行。除了作为一个独立的类之外，此类也提供了一些功能性函数供我们创建自定义 task 类使用。FutureTask 的线程安全由CAS来保证。</p>
<h2 id="FutureTask类关系"><a href="#FutureTask类关系" class="headerlink" title="FutureTask类关系"></a>FutureTask类关系</h2><p><img data-src="https://xuemingde.com/pages/image/2022/03/07/xQvul5.png" alt="xQvul5"></p>
<p>可以看到,FutureTask实现了RunnableFuture接口，则RunnableFuture接口继承了Runnable接口和Future接口，所以FutureTask既能当做一个Runnable直接被Thread执行，也能作为Future用来得到Callable的计算结果。</p>
<h2 id="FutureTask源码解析"><a href="#FutureTask源码解析" class="headerlink" title="FutureTask源码解析"></a>FutureTask源码解析</h2><h3 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h3><p>Callable是个泛型接口，泛型V就是要call()方法返回的类型。对比Runnable接口，Runnable不会返回数据也不能抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h3><p>Future接口代表异步计算的结果，通过Future接口提供的方法可以查看异步计算是否执行完成，或者等待执行结果并获取执行结果，同时还可以取消执行。Future接口的定义如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>cancel()</code>:cancel()方法用来取消异步任务的执行。如果异步任务已经完成或者已经被取消，或者由于某些原因不能取消，则会返回false。如果任务还没有被执行，则会返回true并且异步任务不会被执行。如果任务已经开始执行了但是还没有执行完成，若mayInterruptIfRunning为true，则会立即中断执行任务的线程并返回true，若mayInterruptIfRunning为false，则会返回true且不会中断任务执行线程。</p>
<p><code>isCanceled()</code>:判断任务是否被取消，如果任务在结束(正常执行结束或者执行异常结束)前被取消则返回true，否则返回false。</p>
<p><code>isDone()</code>:判断任务是否已经完成，如果完成则返回true，否则返回false。需要注意的是：任务执行过程中发生异常、任务被取消也属于任务已完成，也会返回true。</p>
<p><code>get()</code>:获取任务执行结果，如果任务还没完成则会阻塞等待直到任务执行完成。如果任务被取消则会抛出CancellationException异常，如果任务执行过程发生异常则会抛出ExecutionException异常，如果阻塞等待过程中被中断则会抛出InterruptedException异常。</p>
<p><code>get(long timeout,Timeunit unit)</code>:带超时时间的get()版本，如果阻塞等待过程中超时则会抛出TimeoutException异常。</p>
<h3 id="核心属性"><a href="#核心属性" class="headerlink" title="核心属性"></a>核心属性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//内部持有的callable任务，运行完毕后置空</span></span><br><span class="line"><span class="keyword">private</span> Callable&lt;V&gt; callable;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从get()中返回的结果或抛出的异常</span></span><br><span class="line"><span class="keyword">private</span> Object outcome; <span class="comment">// non-volatile, protected by state reads/writes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//运行callable的线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Thread runner;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Treiber栈保存等待线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br><span class="line"></span><br><span class="line"><span class="comment">//任务状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中需要注意的是state是volatile类型的，也就是说只要有任何一个线程修改了这个变量，那么其他所有的线程都会知道最新的值。7种状态具体表示：</p>
<ul>
<li><code>NEW</code>:表示是个新的任务或者还没被执行完的任务。这是初始状态。</li>
<li><code>COMPLETING</code>:任务已经执行完成或者执行任务的时候发生异常，但是任务执行结果或者异常原因还没有保存到outcome字段(outcome字段用来保存任务执行结果，如果发生异常，则用来保存异常原因)的时候，状态会从NEW变更到COMPLETING。但是这个状态会时间会比较短，属于中间状态。</li>
<li><code>NORMAL</code>:任务已经执行完成并且任务执行结果已经保存到outcome字段，状态会从COMPLETING转换到NORMAL。这是一个最终态。</li>
<li><code>EXCEPTIONAL</code>:任务执行发生异常并且异常原因已经保存到outcome字段中后，状态会从COMPLETING转换到EXCEPTIONAL。这是一个最终态。</li>
<li><code>CANCELLED</code>:任务还没开始执行或者已经开始执行但是还没有执行完成的时候，用户调用了cancel(false)方法取消任务且不中断任务执行线程，这个时候状态会从NEW转化为CANCELLED状态。这是一个最终态。</li>
<li><code>INTERRUPTING</code>: 任务还没开始执行或者已经执行但是还没有执行完成的时候，用户调用了cancel(true)方法取消任务并且要中断任务执行线程但是还没有中断任务执行线程之前，状态会从NEW转化为INTERRUPTING。这是一个中间状态。</li>
<li><code>INTERRUPTED</code>:调用interrupt()中断任务执行线程之后状态会从INTERRUPTING转换到INTERRUPTED。这是一个最终态。有一点需要注意的是，所有值大于COMPLETING的状态都表示任务已经执行完成(任务正常执行完成，任务执行异常或者任务被取消)。</li>
</ul>
<p>各个状态之间的可能转换关系如下图所示:</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/07/mDqN15.png" alt="mDqN15"></p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul>
<li><p>FutureTask(Callable<V> callable)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.callable = callable;</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个构造函数会把传入的Callable变量保存在this.callable字段中，该字段定义为<code>private Callable&lt;V&gt; callable</code>;用来保存底层的调用，在被执行完成以后会指向null,接着会初始化state字段为NEW。</p>
</li>
<li><p>FutureTask(Runnable runnable, V result)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个构造函数会把传入的Runnable封装成一个Callable对象保存在callable字段中，同时如果任务执行成功的话就会返回传入的result。这种情况下如果不需要返回值的话可以传入一个null。</p>
</li>
</ul>
<p>顺带看下Executors.callable()这个方法，这个方法的功能是把Runnable转换成Callable，代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Callable&lt;T&gt; <span class="title">callable</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RunnableAdapter&lt;T&gt;(task, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到这里采用的是适配器模式，调用<code>RunnableAdapter&lt;T&gt;(task, result)</code>方法来适配，实现如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableAdapter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Runnable task;</span><br><span class="line">    <span class="keyword">final</span> T result;</span><br><span class="line">    RunnableAdapter(Runnable task, T result) &#123;</span><br><span class="line">        <span class="keyword">this</span>.task = task;</span><br><span class="line">        <span class="keyword">this</span>.result = result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        task.run();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这个适配器很简单，就是简单的实现了Callable接口，在call()实现中调用Runnable.run()方法，然后把传入的result作为任务的结果返回。</p>
<p>在new了一个FutureTask对象之后，接下来就是在另一个线程中执行这个Task,无论是通过直接new一个Thread还是通过线程池，执行的都是run()方法，接下来就看看run()方法的实现。</p>
<h3 id="核心方法-run"><a href="#核心方法-run" class="headerlink" title="核心方法 - run()"></a>核心方法 - run()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//新建任务，CAS替换runner为当前线程</span></span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</span><br><span class="line">                                     <span class="keyword">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            <span class="keyword">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = c.call();</span><br><span class="line">                ran = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                result = <span class="keyword">null</span>;</span><br><span class="line">                ran = <span class="keyword">false</span>;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                set(result);<span class="comment">//设置执行结果</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// runner must be non-null until state is settled to</span></span><br><span class="line">        <span class="comment">// prevent concurrent calls to run()</span></span><br><span class="line">        runner = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// state must be re-read after nulling runner to prevent</span></span><br><span class="line">        <span class="comment">// leaked interrupts</span></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);<span class="comment">//处理中断逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ul>
<li><p>运行任务，如果任务状态为NEW状态，则利用CAS修改为当前线程。执行完毕调用set(result)方法设置执行结果。set(result)源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome = v;</span><br><span class="line">        UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, NORMAL); <span class="comment">// final state</span></span><br><span class="line">        finishCompletion();<span class="comment">//执行完毕，唤醒等待线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>首先利用cas修改state状态为COMPLETING，设置返回结果，然后使用 lazySet(UNSAFE.putOrderedInt)的方式设置state状态为NORMAL。结果设置完毕后，调用finishCompletion()方法唤醒等待线程，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert state &gt; COMPLETING;</span></span><br><span class="line">    <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, q, <span class="keyword">null</span>)) &#123;<span class="comment">//移除等待线程</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;<span class="comment">//自旋遍历等待线程</span></span><br><span class="line">                Thread t = q.thread;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    q.thread = <span class="keyword">null</span>;</span><br><span class="line">                    LockSupport.unpark(t);<span class="comment">//唤醒等待线程</span></span><br><span class="line">                &#125;</span><br><span class="line">                WaitNode next = q.next;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                q.next = <span class="keyword">null</span>; <span class="comment">// unlink to help gc</span></span><br><span class="line">                q = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//任务完成后调用函数，自定义扩展</span></span><br><span class="line">    done();</span><br><span class="line"></span><br><span class="line">    callable = <span class="keyword">null</span>;        <span class="comment">// to reduce footprint</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>回到run方法，如果在 run 期间被中断，此时需要调用handlePossibleCancellationInterrupt方法来处理中断逻辑，确保任何中断(例如cancel(true))只停留在当前run或runAndReset的任务中，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handlePossibleCancellationInterrupt</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在中断者中断线程之前可能会延迟，所以我们只需要让出CPU时间片自旋等待</span></span><br><span class="line">    <span class="keyword">if</span> (s == INTERRUPTING)</span><br><span class="line">        <span class="keyword">while</span> (state == INTERRUPTING)</span><br><span class="line">            Thread.yield(); <span class="comment">// wait out pending interrupt</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="核心方法-get"><a href="#核心方法-get" class="headerlink" title="核心方法 - get()"></a>核心方法 - get()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取执行结果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = state;</span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>说明：FutureTask 通过get()方法获取任务执行结果。如果任务处于未完成的状态(<code>state &lt;= COMPLETING</code>)，就调用awaitDone方法(后面单独讲解)等待任务完成。任务完成后，通过report方法获取执行结果或抛出执行期间的异常。report源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回执行结果或抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">    Object x = outcome;</span><br><span class="line">    <span class="keyword">if</span> (s == NORMAL)</span><br><span class="line">        <span class="keyword">return</span> (V)x;</span><br><span class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="核心方法-awaitDone-boolean-timed-long-nanos"><a href="#核心方法-awaitDone-boolean-timed-long-nanos" class="headerlink" title="核心方法 - awaitDone(boolean timed, long nanos)"></a>核心方法 - awaitDone(boolean timed, long nanos)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">    WaitNode q = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;<span class="comment">//自旋</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;<span class="comment">//获取并清除中断状态</span></span><br><span class="line">            removeWaiter(q);<span class="comment">//移除等待WaitNode</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> s = state;</span><br><span class="line">        <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q != <span class="keyword">null</span>)</span><br><span class="line">                q.thread = <span class="keyword">null</span>;<span class="comment">//置空等待节点的线程</span></span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</span><br><span class="line">            q = <span class="keyword">new</span> WaitNode();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">            <span class="comment">//CAS修改waiter</span></span><br><span class="line">            queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,</span><br><span class="line">                                                 q.next = waiters, q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                removeWaiter(q);<span class="comment">//超时，移除等待节点</span></span><br><span class="line">                <span class="keyword">return</span> state;</span><br><span class="line">            &#125;</span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanos);<span class="comment">//阻塞当前线程</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);<span class="comment">//阻塞当前线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>说明：awaitDone用于等待任务完成，或任务因为中断或超时而终止。返回任务的完成状态。函数执行逻辑如下：</p>
<p>如果线程被中断，首先清除中断状态，调用removeWaiter移除等待节点，然后抛出InterruptedException。removeWaiter源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeWaiter</span><span class="params">(WaitNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.thread = <span class="keyword">null</span>;<span class="comment">//首先置空线程</span></span><br><span class="line">        retry:</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;          <span class="comment">// restart on removeWaiter race</span></span><br><span class="line">            <span class="comment">//依次遍历查找</span></span><br><span class="line">            <span class="keyword">for</span> (WaitNode pred = <span class="keyword">null</span>, q = waiters, s; q != <span class="keyword">null</span>; q = s) &#123;</span><br><span class="line">                s = q.next;</span><br><span class="line">                <span class="keyword">if</span> (q.thread != <span class="keyword">null</span>)</span><br><span class="line">                    pred = q;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    pred.next = s;</span><br><span class="line">                    <span class="keyword">if</span> (pred.thread == <span class="keyword">null</span>) <span class="comment">// check for race</span></span><br><span class="line">                        <span class="keyword">continue</span> retry;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,q, s)) <span class="comment">//cas替换</span></span><br><span class="line">                    <span class="keyword">continue</span> retry;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>如果当前状态为结束状态(state&gt;COMPLETING),则根据需要置空等待节点的线程，并返回 Future 状态；</li>
<li>如果当前状态为正在完成(COMPLETING)，说明此时 Future 还不能做出超时动作，为任务让出CPU执行时间片；</li>
<li>如果state为NEW，先新建一个WaitNode，然后CAS修改当前waiters；</li>
<li>如果等待超时，则调用removeWaiter移除等待节点，返回任务状态；如果设置了超时时间但是尚未超时，则park阻塞当前线程；</li>
<li>其他情况直接阻塞当前线程。</li>
</ul>
<h3 id="核心方法-cancel-boolean-mayInterruptIfRunning"><a href="#核心方法-cancel-boolean-mayInterruptIfRunning" class="headerlink" title="核心方法 - cancel(boolean mayInterruptIfRunning)"></a>核心方法 - cancel(boolean mayInterruptIfRunning)</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果当前Future状态为NEW，根据参数修改Future状态为INTERRUPTING或CANCELLED</span></span><br><span class="line">    <span class="keyword">if</span> (!(state == NEW &amp;&amp;</span><br><span class="line">          UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW,</span><br><span class="line">              mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;    <span class="comment">// in case call to interrupt throws exception</span></span><br><span class="line">        <span class="keyword">if</span> (mayInterruptIfRunning) &#123;<span class="comment">//可以在运行时中断</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread t = runner;</span><br><span class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>)</span><br><span class="line">                    t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123; <span class="comment">// final state</span></span><br><span class="line">                UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, INTERRUPTED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        finishCompletion();<span class="comment">//移除并唤醒所有等待线程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>说明：尝试取消任务。如果任务已经完成或已经被取消，此操作会失败。</p>
<ul>
<li>如果当前Future状态为NEW，根据参数修改Future状态为INTERRUPTING或CANCELLED。</li>
<li>如果当前状态不为NEW，则根据参数mayInterruptIfRunning决定是否在任务运行中也可以中断。中断操作完成后，调用finishCompletion移除并唤醒所有等待线程。</li>
</ul>
<h2 id="FutureTask示例"><a href="#FutureTask示例" class="headerlink" title="FutureTask示例"></a>FutureTask示例</h2><p><strong>常用使用方式：</strong></p>
<ul>
<li>第一种方式: Future + ExecutorService</li>
<li>第二种方式: FutureTask + ExecutorService</li>
<li>第三种方式: FutureTask + Thread</li>
</ul>
<h3 id="Future使用示例"><a href="#Future使用示例" class="headerlink" title="Future使用示例"></a>Future使用示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureDemo</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">          ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">          Future future = executorService.submit(<span class="keyword">new</span> Callable&lt;Object&gt;() &#123;</span><br><span class="line">              <span class="meta">@Override</span></span><br><span class="line">              <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                  Long start = System.currentTimeMillis();</span><br><span class="line">                  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                      Long current = System.currentTimeMillis();</span><br><span class="line">                     <span class="keyword">if</span> ((current - start) &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">                         <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">  </span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             Integer result = (Integer)future.get();</span><br><span class="line">             System.out.println(result);</span><br><span class="line">         &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="FutureTask-Thread例子"><a href="#FutureTask-Thread例子" class="headerlink" title="FutureTask+Thread例子"></a>FutureTask+Thread例子</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallDemo</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第一种方式:Future + ExecutorService</span></span><br><span class="line"><span class="comment">         * Task task = new Task();</span></span><br><span class="line"><span class="comment">         * ExecutorService service = Executors.newCachedThreadPool();</span></span><br><span class="line"><span class="comment">         * Future&lt;Integer&gt; future = service.submit(task1);</span></span><br><span class="line"><span class="comment">         * service.shutdown();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第二种方式: FutureTask + ExecutorService</span></span><br><span class="line"><span class="comment">         * ExecutorService executor = Executors.newCachedThreadPool();</span></span><br><span class="line"><span class="comment">         * Task task = new Task();</span></span><br><span class="line"><span class="comment">         * FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(task);</span></span><br><span class="line"><span class="comment">         * executor.submit(futureTask);</span></span><br><span class="line"><span class="comment">         * executor.shutdown();</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第三种方式:FutureTask + Thread</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 2. 新建FutureTask,需要一个实现了Callable接口的类的实例作为构造函数参数</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(<span class="keyword">new</span> Task());</span><br><span class="line">        <span class="comment">// 3. 新建Thread对象并启动</span></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        thread.setName(<span class="string">&quot;Task thread&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;Thread [&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;] is running&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 4. 调用isDone()判断任务是否结束</span></span><br><span class="line">        <span class="keyword">if</span>(!futureTask.isDone()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Task is not done&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 5. 调用get()方法获取任务结果,如果任务没有执行完成则阻塞等待</span></span><br><span class="line">            result = futureTask.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        System.out.println(<span class="string">&quot;result is &quot;</span> + result);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 1. 继承Callable接口,实现call()方法,泛型参数为要返回的类型</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span>  <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread [&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;] is running&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>;++i) &#123;</span><br><span class="line">                result += i;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="例子3"><a href="#例子3" class="headerlink" title="例子3"></a>例子3</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">fdsg</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ThreadFactory namedThreadFactory = <span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(<span class="string">&quot;thread-start-runner-%d&quot;</span>).build();</span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        ExecutorService taskExe= <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">10</span>,<span class="number">20</span>,<span class="number">800L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">100</span>),namedThreadFactory);</span><br><span class="line">        <span class="comment">//任务列表</span></span><br><span class="line">        List&lt;FutureTask&lt;Integer&gt;&gt; taskList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//任务一</span></span><br><span class="line">        TestDemo testDemo = <span class="keyword">new</span> TestDemo();</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(testDemo);</span><br><span class="line">        taskExe.submit(futureTask);</span><br><span class="line">        <span class="comment">//submit多次，但也只执行一次</span></span><br><span class="line">        taskExe.submit(futureTask);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       TestDemo3 testDemo3 = <span class="keyword">new</span> TestDemo3();</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask3 = <span class="keyword">new</span> FutureTask&lt;&gt;(testDemo3);</span><br><span class="line">        taskExe.submit(futureTask3);</span><br><span class="line">        taskExe.submit(futureTask3);</span><br><span class="line"></span><br><span class="line">        taskList.add(futureTask3);</span><br><span class="line">        taskList.add(futureTask);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (FutureTask&lt;Integer&gt; futureTasks : taskList) &#123;</span><br><span class="line">            <span class="comment">//获取结果，如果任务没有执行完成，get会阻塞</span></span><br><span class="line">            Integer integer = futureTasks.get();</span><br><span class="line">            i += integer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭线程池</span></span><br><span class="line">        taskExe.shutdown();</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//模拟多次请求，但每次返回结果一样</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            Integer fdsg = fdsg();</span><br><span class="line">            System.out.println(fdsg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">21</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo3</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">24</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><p>本文主要参考了 <span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbGluZ2h1LWphdmEvcC84OTkxODI0Lmh0bWw=">https://www.cnblogs.com/linghu-java/p/8991824.html<i class="fa fa-external-link-alt"></i></span> </p>
<p>以及</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9kNjFkN2ZmYTZhYmM=">https://www.jianshu.com/p/d61d7ffa6abc<i class="fa fa-external-link-alt"></i></span></p>
<p>在此基础上增改</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbmd6aG9uZzEyOC9hcnRpY2xlL2RldGFpbHMvODA1NTM3ODk=">https://blog.csdn.net/xingzhong128/article/details/80553789<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
]]></content>
      <categories>
        <category>并发与多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>GC</tag>
        <tag>栈</tag>
        <tag>函数</tag>
        <tag>CPU</tag>
        <tag>变量</tag>
        <tag>面试</tag>
        <tag>线程池</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java锁的四种状态及锁升级过程</title>
    <url>/posts/1J4DQP7.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="锁的四种状态"><a href="#锁的四种状态" class="headerlink" title="锁的四种状态"></a>锁的四种状态</h1><p><strong>Java锁的四种状态就是Synchronized的升级过程</strong></p>
<ol>
<li>刚new出来没有锁的状态</li>
<li>偏向锁 </li>
<li>轻量级锁</li>
<li>重量级锁</li>
</ol>
<h2 id="刚new出来没有锁的状态"><a href="#刚new出来没有锁的状态" class="headerlink" title="刚new出来没有锁的状态"></a>刚new出来没有锁的状态</h2><p>也有人称为无锁状态，但是要慎用。</p>
<p>无锁原来的意思是没有重量级锁，偏向锁，CAS都被称为无锁。其实都是概念上的问题，没必要纠结。</p>
<blockquote>
<p>新new出来的对象布局，可看 <strong>Java对象布局</strong> 这篇文章</p>
</blockquote>
<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>偏向锁严格来说不是一种锁。</p>
<p>不存在所竞争的过程，当第一个线程来了，这把锁就属于这个线程的，在这个线程持有这把锁的时候，有另一个线程来了，就会产生锁竞争的关系，于是就是进行锁升级，升级为轻量级锁，CAS。</p>
<p><strong>为什么要有偏向锁？</strong></p>
<p>如果一段代码百分七八十的时间都是一个线程在请求，每一次请求都会经过锁竞争的过程，这样会降低效率。如果有了偏向锁，就会减少锁竞争，可以提高效率。如果一旦出现了锁竞争，就会进行锁升级。</p>
<h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>偏向锁考虑的是有同步无竞争时程序的效率，而轻量级锁考虑的是竞争锁对象的线程不多，而且线程持有锁的时间也不长的情景。</p>
<p><strong>什么时候偏向锁升级为轻量级锁？</strong></p>
<p>当发生了锁竞争的时候，偏向锁就会升级为轻量级锁。</p>
<h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>竞争锁的线程太多，就会被进入队列里，升级为重量级锁。</p>
<p><strong>什么时候轻量级锁升级为重量级锁？</strong></p>
<ol>
<li>判断循环次数。</li>
<li>判断竞争锁的线程数。</li>
</ol>
<h2 id="锁对比"><a href="#锁对比" class="headerlink" title="锁对比"></a>锁对比</h2><p> <img data-src="https://xuemingde.com/pages/image/others/L03Qu6.png" alt="L03Qu6"></p>
<h1 id="锁升级过程"><a href="#锁升级过程" class="headerlink" title="锁升级过程"></a>锁升级过程</h1><p><img data-src="https://xuemingde.com/pages/image/others/EYimRi.png" alt="EYimRi"></p>
<blockquote>
<p>可参考文章</p>
<ol>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbWluZ3l1ZXl5L3AvMTMwNTQyOTYuaHRtbA==">https://www.cnblogs.com/mingyueyy/p/13054296.html<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vd3pqNDg1OC9wLzgyMTUzNjkuaHRtbA==">https://www.cnblogs.com/wzj4858/p/8215369.html<i class="fa fa-external-link-alt"></i></span></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>并发与多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程池实现原理及其在美团业务中的实践</title>
    <url>/posts/GHVA1Q.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在线查看：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYWxpeXVuZHJpdmUuY29tL3MvdFJ6VGR4ejZpeW4=">阿里云盘<i class="fa fa-external-link-alt"></i></span></p>
<hr>
<p>原文：<span class="exturl" data-url="aHR0cHM6Ly90ZWNoLm1laXR1YW4uY29tLzIwMjAvMDQvMDIvamF2YS1wb29saW5nLXByYXRpY2UtaW4tbWVpdHVhbi5odG1s">Java线程池实现原理及其在美团业务中的实践<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>并发与多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized 实现原理</title>
    <url>/posts/3RHZNJS.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>众所周知 <code>synchronized</code> 锁在 <code>Java</code> 中经常使用它的源码是 <code>C++</code> 实现的，它的实现原理是怎样的呢？本文以 <code>OpenJDK 8</code> 为例探究以下内容。</p>
<ul>
<li>synchronized 是如何工作的</li>
<li>synchronized 锁升级过程</li>
<li>重量级锁的队列之间协作过程和策略</li>
</ul>
<h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><p>对象头的内容非常多这里我们只做简单介绍以引出后文。在 JVM 中对象布局分为三块区域：</p>
<ul>
<li>对象头</li>
<li>实例数据</li>
<li>对齐填充</li>
</ul>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8717c4d733c14f779beb08f512df6ba4~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>当线程访问同步块时首先需要获得锁并把相关信息存储在对象头中。所以 <code>wait</code>、<code>notify</code>、<code>notifyAll</code> 这些方法为什么被设计在 <code>Object</code> 中或许你已经找到答案了。</p>
<p>Hotspot 有两种对象头：</p>
<ul>
<li>数组类型，使用 <code>arrayOopDesc</code> 来描述对象头</li>
<li>其它，使用 <code>instanceOopDesc</code> 来描述对象头</li>
</ul>
<p>对象头由两部分组成</p>
<ul>
<li>Mark Word：存储自身的运行时数据，例如 HashCode、GC 年龄、锁相关信息等内容。</li>
<li>Klass Pointer：类型指针指向它的类元数据的指针。</li>
</ul>
<p>64 位虚拟机 Mark Word 是 64bit 其结构如下：</p>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/64a3a006a4654ed188a882d8c1ebc7a8~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<p>在 JDK 6 中虚拟机团队对锁进行了重要改进，优化了其性能引入了 <code>偏向锁</code>、<code>轻量级锁</code>、<code>适应性自旋</code>、<code>锁消除</code>、<code>锁粗化</code>等实现，其中 <code>锁消除</code>和<code>锁粗化</code>本文不做详细讨论其余内容我们将对其进行逐一探究。</p>
<p>总体上来说锁状态升级流程如下：</p>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ed79382a64647fe96fab8285094a3eb~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>当线程访问同步块并获取锁时处理流程如下：</p>
<ol>
<li>检查 <code>mark word</code> 的<code>线程 id</code> 。</li>
<li>如果为空则设置 CAS 替换当前线程 id。如果替换成功则获取锁成功，如果失败则撤销偏向锁。</li>
<li>如果不为空则检查 <code>线程 id</code>为是否为本线程。如果是则获取锁成功，如果失败则撤销偏向锁。</li>
</ol>
<p>持有偏向锁的线程以后每次进入这个锁相关的同步块时，只需比对一下 mark word 的线程 id 是否为本线程，如果是则获取锁成功。</p>
<p>如果发生线程竞争发生 2、3 步失败的情况则需要撤销偏向锁。</p>
<h3 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h3><ol>
<li>偏向锁的撤销动作必须等待全局安全点</li>
<li>暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态</li>
<li>撤销偏向锁恢复到无锁（标志位为 01）或轻量级锁（标志位为 00）的状态</li>
</ol>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>只有一个线程执行同步块时进一步提高性能，适用于一个线程反复获得同一锁的情况。偏向锁可以提高带有同步但无竞争的程序性能。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>如果存在竞争会带来额外的锁撤销操作。</p>
<h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><p>多个线程竞争偏向锁导致偏向锁升级为轻量级锁</p>
<ol>
<li>JVM 在当前线程的栈帧中创建 Lock Reocrd，并将对象头中的 Mark Word 复制到 Lock Reocrd 中。（Displaced Mark Word）</li>
<li>线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向 Lock Reocrd 的指针。如果成功则获得锁，如果失败则先检查对象的 Mark Word 是否指向当前线程的栈帧如果是则说明已经获取锁，否则说明其它线程竞争锁则膨胀为重量级锁。</li>
</ol>
<h3 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h3><ol>
<li>使用 CAS 操作将 Mark Word 还原</li>
<li>如果第 1 步执行成功则释放完成</li>
<li>如果第 1 步执行失败则膨胀为重量级锁。</li>
</ol>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>其性能提升的依据是对于绝大部分的锁在整个生命周期内都是不会存在竞争。在多线程交替执行同步块的情况下，可以避免重量级锁引起的性能消耗。</p>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>在有多线程竞争的情况下轻量级锁增加了额外开销。</p>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>自旋是一种获取锁的机制并不是一个锁状态。在膨胀为重量级锁的过程中或重入时会多次尝试自旋获取锁以避免线程唤醒的开销，但是它会占用 CPU 的时间因此如果同步代码块执行时间很短自旋等待的效果就很好，反之则浪费了 CPU 资源。默认情况下自旋次数是 10 次用户可以使用参数 <code>-XX : PreBlockSpin</code> 来更改。那么如何优化来避免此情况发生呢？我们来看适应性自旋。</p>
<h3 id="适应性自旋锁"><a href="#适应性自旋锁" class="headerlink" title="适应性自旋锁"></a>适应性自旋锁</h3><p>JDK 6 引入了自适应自旋锁，意味着自旋的次数不在固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果对于某个锁很少自旋成功那么以后有可能省略掉自旋过程以避免资源浪费。有了自适应自旋随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越准确，虛拟机就会变得越来越“聪明”了。</p>
<h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><p>竞争的线程不会阻塞挂起，提高了程序响应速度。避免重量级锁引起的性能消耗。</p>
<h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><p>如果线程始终无法获取锁，自旋消耗 CPU 最终会膨胀为重量级锁。</p>
<h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>在重量级锁中没有竞争到锁的对象会 park 被挂起，退出同步块时 unpark 唤醒后续线程。唤醒操作涉及到操作系统调度会有额外的开销。</p>
<p><code>ObjectMonitor</code> 中包含一个同步队列（由 <code>_cxq</code> 和 <code>_EntryList</code> 组成）一个等待队列（ <code>_WaitSet</code> ）。</p>
<ul>
<li>被<code>notify</code>或 <code>notifyAll</code> 唤醒时根据 <code>policy</code> 策略选择加入的队列（policy 默认为 0）</li>
<li>退出同步块时根据 <code>QMode</code> 策略来唤醒下一个线程（QMode 默认为 0）</li>
</ul>
<p>这里稍微提及一下<strong>管程</strong>这个概念。synchronized 关键字及 <code>wait</code>、<code>notify</code>、<code>notifyAll</code> 这三个方法都是管程的组成部分。可以说管程就是一把解决并发问题的万能钥匙。有两大核心问题管程都是能够解决的：</p>
<ul>
<li><strong>互斥</strong>：即同一时刻只允许一个线程访问共享资源；</li>
<li><strong>同步</strong>：即线程之间如何通信、协作。</li>
</ul>
<p><code>synchronized</code> 的 <code>monitor</code>锁机制和 JDK 并发包中的 <code>AQS</code> 是很相似的，只不过 <code>AQS</code> 中是一个同步队列多个等待队列。熟悉 <code>AQS</code> 的同学可以拿来做个对比。</p>
<h3 id="队列协作流程图"><a href="#队列协作流程图" class="headerlink" title="队列协作流程图"></a>队列协作流程图</h3><p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d42e3a85b00d4ba88fbb04bfa64e9d4a~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>在 HotSpot 中 monitor 是由 ObjectMonitor 实现的。其源码是用 c++来实现的源文件是 ObjectMonitor.hpp 主要数据结构如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = <span class="literal">NULL</span>;</span><br><span class="line">    _count        = <span class="number">0</span>;</span><br><span class="line">    _waiters      = <span class="number">0</span>,       <span class="comment">// 等待中的线程数</span></span><br><span class="line">    _recursions   = <span class="number">0</span>;       <span class="comment">// 线程重入次数</span></span><br><span class="line">    _object       = <span class="literal">NULL</span>;    <span class="comment">// 存储该 monitor 的对象</span></span><br><span class="line">    _owner        = <span class="literal">NULL</span>;    <span class="comment">// 指向拥有该 monitor 的线程</span></span><br><span class="line">    _WaitSet      = <span class="literal">NULL</span>;    <span class="comment">// 等待线程 双向循环链表_WaitSet 指向第一个节点</span></span><br><span class="line">    _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">    _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">    _succ         = <span class="literal">NULL</span> ;</span><br><span class="line">    _cxq          = <span class="literal">NULL</span> ;   <span class="comment">// 多线程竞争锁时的单向链表</span></span><br><span class="line">    FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">    _EntryList    = <span class="literal">NULL</span> ;   <span class="comment">// _owner 从该双向循环链表中唤醒线程，</span></span><br><span class="line">    _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">    _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">    _previous_owner_tid = <span class="number">0</span>; <span class="comment">// 前一个拥有此监视器的线程 ID</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>_owner：初始时为 NULL。当有线程占有该 monitor 时 owner 标记为该线程的 ID。当线程释放 monitor 时 owner 恢复为 NULL。owner 是一个临界资源 JVM 是通过 CAS 操作来保证其线程安全的。</li>
<li>_cxq：竞争队列所有请求锁的线程首先会被放在这个队列中（单向）。_cxq 是一个临界资源 JVM 通过 CAS 原子指令来修改_cxq 队列。\<br>每当有新来的节点入队，它的 next 指针总是指向之前队列的头节点，而_cxq 指针会指向该新入队的节点，所以是后来居上。</li>
<li>_EntryList： _cxq 队列中有资格成为候选资源的线程会被移动到该队列中。</li>
<li>_WaitSet: 等待队列因为调用 wait 方法而被阻塞的线程会被放在该队列中。</li>
</ol>
</blockquote>
<h3 id="monitor-竞争过程"><a href="#monitor-竞争过程" class="headerlink" title="monitor 竞争过程"></a>monitor 竞争过程</h3><blockquote>
<ol>
<li>通过 CAS 尝试把 monitor 的 owner 字段设置为当前线程。</li>
<li>如果设置之前的 owner 指向当前线程，说明当前线程再次进入 monitor，即重入锁执行 recursions ++ , 记录重入的次数。</li>
<li>如果当前线程是第一次进入该 monitor, 设置 recursions 为 1,_owner 为当前线程，该线程成功获得锁并返回。</li>
<li>如果获取锁失败，则等待锁的释放。</li>
</ol>
</blockquote>
<p>执行 <code>monitorenter</code> 指令时 调用以下代码</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">IRT_ENTRY_NO_ASYNC(<span class="keyword">void</span>, InterpreterRuntime::monitorenter(JavaThread* thread, BasicObjectLock* elem))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ASSERT</span></span><br><span class="line">  thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (PrintBiasedLockingStatistics) &#123;</span><br><span class="line">    Atomic::inc(BiasedLocking::slow_path_entry_count_addr());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">Handle <span class="title">h_obj</span><span class="params">(thread, elem-&gt;obj())</span></span>;</span><br><span class="line">  assert(Universe::heap()-&gt;is_in_reserved_or_null(h_obj()),<span class="string">&quot;must be NULL or an object&quot;</span>);</span><br><span class="line"><span class="comment">// 是否使用偏向锁  JVM 启动时设置的偏向锁-XX:-UseBiasedLocking=false/true</span></span><br><span class="line">  <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">    <span class="comment">// Retry fast entry if bias is revoked to avoid unnecessary inflation</span></span><br><span class="line">    ObjectSynchronizer::fast_enter(h_obj, elem-&gt;lock(), <span class="literal">true</span>, CHECK);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 轻量级锁</span></span><br><span class="line">    ObjectSynchronizer::slow_enter(h_obj, elem-&gt;lock(), CHECK);</span><br><span class="line">  &#125;</span><br><span class="line">  assert(Universe::heap()-&gt;is_in_reserved_or_null(elem-&gt;obj()),</span><br><span class="line">         <span class="string">&quot;must be NULL or an object&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ASSERT</span></span><br><span class="line">  thread-&gt;last_frame().interpreter_frame_verify_monitor(elem);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">IRT_END</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>slow_enter</code> 方法主要是轻量级锁的一些操作，如果操作失败则会膨胀为重量级锁，过程前面已经描述比较清楚此处不在赘述。<code>enter</code> 方法则为重量级锁的入口源码如下</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> ATTR <span class="title">ObjectMonitor::enter</span><span class="params">(TRAPS)</span> </span>&#123;</span><br><span class="line">  Thread * <span class="keyword">const</span> Self = THREAD ;</span><br><span class="line">  <span class="keyword">void</span> * cur ;</span><br><span class="line">  <span class="comment">// 省略部分代码</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 通过 CAS 操作尝试把 monitor 的_owner 字段设置为当前线程</span></span><br><span class="line">  cur = Atomic::cmpxchg_ptr (Self, &amp;_owner, <span class="literal">NULL</span>) ;</span><br><span class="line">  <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) &#123;</span><br><span class="line">     assert (_recursions == <span class="number">0</span>   , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     assert (_owner      == Self, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 线程重入，recursions++</span></span><br><span class="line">  <span class="keyword">if</span> (cur == Self) &#123;</span><br><span class="line">     _recursions ++ ;</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前线程是第一次进入该 monitor, 设置_recursions 为 1,_owner 为当前线程</span></span><br><span class="line">  <span class="keyword">if</span> (Self-&gt;is_lock_owned ((address)cur)) &#123;</span><br><span class="line">    assert (_recursions == <span class="number">0</span>, <span class="string">&quot;internal state error&quot;</span>);</span><br><span class="line">    _recursions = <span class="number">1</span> ;</span><br><span class="line">    _owner = Self ;</span><br><span class="line">    OwnerIsThread = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      jt-&gt;set_suspend_equivalent();</span><br><span class="line">        <span class="comment">// 如果获取锁失败，则等待锁的释放；</span></span><br><span class="line">      EnterI (THREAD) ;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!ExitSuspendEquivalent(jt)) <span class="keyword">break</span> ;</span><br><span class="line">          _recursions = <span class="number">0</span> ;</span><br><span class="line">      _succ = <span class="literal">NULL</span> ;</span><br><span class="line">      <span class="built_in">exit</span> (<span class="literal">false</span>, Self) ;</span><br><span class="line"></span><br><span class="line">      jt-&gt;java_suspend_self();</span><br><span class="line">    &#125;</span><br><span class="line">    Self-&gt;set_current_pending_monitor(<span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="monitor-等待"><a href="#monitor-等待" class="headerlink" title="monitor 等待"></a>monitor 等待</h3><blockquote>
<ol>
<li>当前线程被封装成 ObjectWaiter 对象 node，状态设置成 ObjectWaiter::TS_CXQ。</li>
<li>for 循环通过 CAS 把 node 节点 push 到<code>_cxq</code>列表中，同一时刻可能有多个线程把自己的 node 节点 push 到<code>_cxq</code>列表中。</li>
<li>node 节点 push 到_cxq 列表之后，通过自旋尝试获取锁，如果还是没有获取到锁则通过 park 将当前线程挂起等待被唤醒。</li>
<li>当该线程被唤醒时会从挂起的点继续执行，通过 ObjectMonitor::TryLock 尝试获取锁。</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 省略部分代码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> ATTR <span class="title">ObjectMonitor::EnterI</span> <span class="params">(TRAPS)</span> </span>&#123;</span><br><span class="line">    Thread * Self = THREAD ;</span><br><span class="line">    assert (Self-&gt;is_Java_thread(), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">    assert (((JavaThread *) Self)-&gt;thread_state() == _thread_blocked   , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try lock 尝试获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (TryLock (Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        assert (_succ != Self              , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">        assert (_owner == Self             , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">        assert (_Responsible != Self       , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">        <span class="comment">// 如果获取成功则退出，避免 park unpark 系统调度的开销</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自旋获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (TrySpin(Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        assert (_owner == Self, <span class="string">&quot;invariant&quot;</span>);</span><br><span class="line">        assert (_succ != Self, <span class="string">&quot;invariant&quot;</span>);</span><br><span class="line">        assert (_Responsible != Self, <span class="string">&quot;invariant&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前线程被封装成 ObjectWaiter 对象 node, 状态设置成 ObjectWaiter::TS_CXQ</span></span><br><span class="line">    <span class="function">ObjectWaiter <span class="title">node</span><span class="params">(Self)</span> </span>;</span><br><span class="line">    Self-&gt;_ParkEvent-&gt;reset() ;</span><br><span class="line">    node._prev   = (ObjectWaiter *) <span class="number">0xBAD</span> ;</span><br><span class="line">    node.TState  = ObjectWaiter::TS_CXQ ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 CAS 把 node 节点 push 到_cxq 列表中</span></span><br><span class="line">    ObjectWaiter * nxt ;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        node._next = nxt = _cxq ;</span><br><span class="line">        <span class="keyword">if</span> (Atomic::cmpxchg_ptr (&amp;node, &amp;_cxq, nxt) == nxt) <span class="keyword">break</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再次 tryLock</span></span><br><span class="line">        <span class="keyword">if</span> (TryLock (Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            assert (_succ != Self         , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">            assert (_owner == Self        , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">            assert (_Responsible != Self  , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 本段代码的主要思想和 AQS 中相似可以类比来看</span></span><br><span class="line">        <span class="comment">// 再次尝试</span></span><br><span class="line">        <span class="keyword">if</span> (TryLock (Self) &gt; <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">        assert (_owner != Self, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((SyncFlags &amp; <span class="number">2</span>) &amp;&amp; _Responsible == <span class="literal">NULL</span>) &#123;</span><br><span class="line">           Atomic::cmpxchg_ptr (Self, &amp;_Responsible, <span class="literal">NULL</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 满足条件则 park self</span></span><br><span class="line">        <span class="keyword">if</span> (_Responsible == Self || (SyncFlags &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">            TEVENT (Inflated enter - park TIMED) ;</span><br><span class="line">            Self-&gt;_ParkEvent-&gt;park ((jlong) RecheckInterval) ;</span><br><span class="line">            <span class="comment">// Increase the RecheckInterval, but clamp the value.</span></span><br><span class="line">            RecheckInterval *= <span class="number">8</span> ;</span><br><span class="line">            <span class="keyword">if</span> (RecheckInterval &gt; <span class="number">1000</span>) RecheckInterval = <span class="number">1000</span> ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            TEVENT (Inflated enter - park UNTIMED) ;</span><br><span class="line">            <span class="comment">// 通过 park 将当前线程挂起，等待被唤醒</span></span><br><span class="line">            Self-&gt;_ParkEvent-&gt;park() ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (TryLock(Self) &gt; <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">        <span class="comment">// 再次尝试自旋</span></span><br><span class="line">        <span class="keyword">if</span> ((Knob_SpinAfterFutile &amp; <span class="number">1</span>) &amp;&amp; TrySpin(Self) &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="monitor-释放"><a href="#monitor-释放" class="headerlink" title="monitor 释放"></a>monitor 释放</h3><blockquote>
<p>当某个持有锁的线程执行完同步代码块时，会释放锁并 <code>unpark</code> 后续线程（由于篇幅只保留重要代码）。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> ATTR <span class="title">ObjectMonitor::exit</span><span class="params">(<span class="keyword">bool</span> not_suspended, TRAPS)</span> </span>&#123;</span><br><span class="line">   Thread * Self = THREAD ;</span><br><span class="line">  </span><br><span class="line">   <span class="keyword">if</span> (_recursions != <span class="number">0</span>) &#123;</span><br><span class="line">     _recursions--;        <span class="comment">// this is simple recursive enter</span></span><br><span class="line">     TEVENT (Inflated <span class="built_in">exit</span> - recursive) ;</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">      ObjectWaiter * w = <span class="literal">NULL</span> ;</span><br><span class="line">      <span class="keyword">int</span> QMode = Knob_QMode ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接绕过 EntryList 队列，从 cxq 队列中获取线程用于竞争锁</span></span><br><span class="line">      <span class="keyword">if</span> (QMode == <span class="number">2</span> &amp;&amp; _cxq != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          w = _cxq ;</span><br><span class="line">          assert (w != <span class="literal">NULL</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">          assert (w-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">          ExitEpilog (Self, w) ;</span><br><span class="line">          <span class="keyword">return</span> ;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// cxq 队列插入 EntryList 尾部</span></span><br><span class="line">      <span class="keyword">if</span> (QMode == <span class="number">3</span> &amp;&amp; _cxq != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          w = _cxq ;</span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">             assert (w != <span class="literal">NULL</span>, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">             ObjectWaiter * u = (ObjectWaiter *) Atomic::cmpxchg_ptr (<span class="literal">NULL</span>, &amp;_cxq, w) ;</span><br><span class="line">             <span class="keyword">if</span> (u == w) <span class="keyword">break</span> ;</span><br><span class="line">             w = u ;</span><br><span class="line">          &#125;</span><br><span class="line">          ObjectWaiter * q = <span class="literal">NULL</span> ;</span><br><span class="line">          ObjectWaiter * p ;</span><br><span class="line">          <span class="keyword">for</span> (p = w ; p != <span class="literal">NULL</span> ; p = p-&gt;_next) &#123;</span><br><span class="line">              guarantee (p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">              p-&gt;TState = ObjectWaiter::TS_ENTER ;</span><br><span class="line">              p-&gt;_prev = q ;</span><br><span class="line">              q = p ;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          ObjectWaiter * Tail ;</span><br><span class="line">          <span class="keyword">for</span> (Tail = _EntryList ; Tail != <span class="literal">NULL</span> &amp;&amp; Tail-&gt;_next != <span class="literal">NULL</span> ; Tail = Tail-&gt;_next) ;</span><br><span class="line">          <span class="keyword">if</span> (Tail == <span class="literal">NULL</span>) &#123;</span><br><span class="line">              _EntryList = w ;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              Tail-&gt;_next = w ;</span><br><span class="line">              w-&gt;_prev = Tail ;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cxq 队列插入到_EntryList 头部</span></span><br><span class="line">      <span class="keyword">if</span> (QMode == <span class="number">4</span> &amp;&amp; _cxq != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="comment">// 把 cxq 队列放入 EntryList</span></span><br><span class="line">          <span class="comment">// 此策略确保最近运行的线程位于 EntryList 的头部</span></span><br><span class="line">          w = _cxq ;</span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">             assert (w != <span class="literal">NULL</span>, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">             ObjectWaiter * u = (ObjectWaiter *) Atomic::cmpxchg_ptr (<span class="literal">NULL</span>, &amp;_cxq, w) ;</span><br><span class="line">             <span class="keyword">if</span> (u == w) <span class="keyword">break</span> ;</span><br><span class="line">             w = u ;</span><br><span class="line">          &#125;</span><br><span class="line">          assert (w != <span class="literal">NULL</span>              , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line"></span><br><span class="line">          ObjectWaiter * q = <span class="literal">NULL</span> ;</span><br><span class="line">          ObjectWaiter * p ;</span><br><span class="line">          <span class="keyword">for</span> (p = w ; p != <span class="literal">NULL</span> ; p = p-&gt;_next) &#123;</span><br><span class="line">              guarantee (p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">              p-&gt;TState = ObjectWaiter::TS_ENTER ;</span><br><span class="line">              p-&gt;_prev = q ;</span><br><span class="line">              q = p ;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (_EntryList != <span class="literal">NULL</span>) &#123;</span><br><span class="line">              q-&gt;_next = _EntryList ;</span><br><span class="line">              _EntryList-&gt;_prev = q ;</span><br><span class="line">          &#125;</span><br><span class="line">          _EntryList = w ;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      w = _EntryList  ;</span><br><span class="line">      <span class="keyword">if</span> (w != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          assert (w-&gt;TState == ObjectWaiter::TS_ENTER, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">          ExitEpilog (Self, w) ;</span><br><span class="line">          <span class="keyword">return</span> ;</span><br><span class="line">      &#125;</span><br><span class="line">      w = _cxq ;</span><br><span class="line">      <span class="keyword">if</span> (w == <span class="literal">NULL</span>) <span class="keyword">continue</span> ;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">          assert (w != <span class="literal">NULL</span>, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">          ObjectWaiter * u = (ObjectWaiter *) Atomic::cmpxchg_ptr (<span class="literal">NULL</span>, &amp;_cxq, w) ;</span><br><span class="line">          <span class="keyword">if</span> (u == w) <span class="keyword">break</span> ;</span><br><span class="line">          w = u ;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (QMode == <span class="number">1</span>) &#123;</span><br><span class="line">         <span class="comment">// QMode == 1 : 把 cxq 倾倒入 EntryList 逆序</span></span><br><span class="line">         ObjectWaiter * s = <span class="literal">NULL</span> ;</span><br><span class="line">         ObjectWaiter * t = w ;</span><br><span class="line">         ObjectWaiter * u = <span class="literal">NULL</span> ;</span><br><span class="line">         <span class="keyword">while</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">             guarantee (t-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">             t-&gt;TState = ObjectWaiter::TS_ENTER ;</span><br><span class="line">             u = t-&gt;_next ;</span><br><span class="line">             t-&gt;_prev = u ;</span><br><span class="line">             t-&gt;_next = s ;</span><br><span class="line">             s = t;</span><br><span class="line">             t = u ;</span><br><span class="line">         &#125;</span><br><span class="line">         _EntryList  = s ;</span><br><span class="line">         assert (s != <span class="literal">NULL</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// QMode == 0 or QMode == 2</span></span><br><span class="line">         _EntryList = w ;</span><br><span class="line">         ObjectWaiter * q = <span class="literal">NULL</span> ;</span><br><span class="line">         ObjectWaiter * p ;</span><br><span class="line">          <span class="comment">// 将单向链表构造成双向环形链表；</span></span><br><span class="line">         <span class="keyword">for</span> (p = w ; p != <span class="literal">NULL</span> ; p = p-&gt;_next) &#123;</span><br><span class="line">             guarantee (p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">             p-&gt;TState = ObjectWaiter::TS_ENTER ;</span><br><span class="line">             p-&gt;_prev = q ;</span><br><span class="line">             q = p ;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (_succ != <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">      w = _EntryList  ;</span><br><span class="line">      <span class="keyword">if</span> (w != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          guarantee (w-&gt;TState == ObjectWaiter::TS_ENTER, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">          ExitEpilog (Self, w) ;</span><br><span class="line">          <span class="keyword">return</span> ;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="notify-唤醒"><a href="#notify-唤醒" class="headerlink" title="notify 唤醒"></a>notify 唤醒</h3><blockquote>
<p>notify 或者 notifyAll 方法可以唤醒同一个锁监视器下调用 wait 挂起的线程，具体实现如下</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ObjectMonitor::notify</span><span class="params">(TRAPS)</span> </span>&#123;</span><br><span class="line">    CHECK_OWNER();</span><br><span class="line">    <span class="keyword">if</span> (_WaitSet == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        TEVENT (Empty - Notify);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    DTRACE_MONITOR_PROBE(notify, <span class="keyword">this</span>, object(), THREAD);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> Policy = Knob_MoveNotifyee;</span><br><span class="line"></span><br><span class="line">    Thread::SpinAcquire(&amp;_WaitSetLock, <span class="string">&quot;WaitSet - notify&quot;</span>);</span><br><span class="line">    ObjectWaiter *iterator = DequeueWaiter();</span><br><span class="line">    <span class="keyword">if</span> (iterator != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 省略一些代码</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 头插 EntryList</span></span><br><span class="line">        <span class="keyword">if</span> (Policy == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (List == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                iterator-&gt;_next = iterator-&gt;_prev = <span class="literal">NULL</span>;</span><br><span class="line">                _EntryList = iterator;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                List-&gt;_prev = iterator;</span><br><span class="line">                iterator-&gt;_next = List;</span><br><span class="line">                iterator-&gt;_prev = <span class="literal">NULL</span>;</span><br><span class="line">                _EntryList = iterator;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Policy == <span class="number">1</span>) &#123;      <span class="comment">// 尾插 EntryList</span></span><br><span class="line">            <span class="keyword">if</span> (List == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                iterator-&gt;_next = iterator-&gt;_prev = <span class="literal">NULL</span>;</span><br><span class="line">                _EntryList = iterator;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ObjectWaiter *Tail;</span><br><span class="line">                <span class="keyword">for</span> (Tail = List; Tail-&gt;_next != <span class="literal">NULL</span>; Tail = Tail-&gt;_next);</span><br><span class="line">                assert (Tail != <span class="literal">NULL</span> &amp;&amp; Tail-&gt;_next == <span class="literal">NULL</span>, <span class="string">&quot;invariant&quot;</span>);</span><br><span class="line">                Tail-&gt;_next = iterator;</span><br><span class="line">                iterator-&gt;_prev = Tail;</span><br><span class="line">                iterator-&gt;_next = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Policy == <span class="number">2</span>) &#123;      <span class="comment">// 头插 cxq</span></span><br><span class="line">            <span class="comment">// prepend to cxq</span></span><br><span class="line">            <span class="keyword">if</span> (List == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                iterator-&gt;_next = iterator-&gt;_prev = <span class="literal">NULL</span>;</span><br><span class="line">                _EntryList = iterator;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                iterator-&gt;TState = ObjectWaiter::TS_CXQ;</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                    ObjectWaiter *Front = _cxq;</span><br><span class="line">                    iterator-&gt;_next = Front;</span><br><span class="line">                    <span class="keyword">if</span> (Atomic::cmpxchg_ptr(iterator, &amp;_cxq, Front) == Front) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Policy == <span class="number">3</span>) &#123;      <span class="comment">// 尾插 cxq</span></span><br><span class="line">            iterator-&gt;TState = ObjectWaiter::TS_CXQ;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                ObjectWaiter *Tail;</span><br><span class="line">                Tail = _cxq;</span><br><span class="line">                <span class="keyword">if</span> (Tail == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    iterator-&gt;_next = <span class="literal">NULL</span>;</span><br><span class="line">                    <span class="keyword">if</span> (Atomic::cmpxchg_ptr(iterator, &amp;_cxq, <span class="literal">NULL</span>) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (Tail-&gt;_next != <span class="literal">NULL</span>) Tail = Tail-&gt;_next;</span><br><span class="line">                    Tail-&gt;_next = iterator;</span><br><span class="line">                    iterator-&gt;_prev = Tail;</span><br><span class="line">                    iterator-&gt;_next = <span class="literal">NULL</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ParkEvent *ev = iterator-&gt;_event;</span><br><span class="line">            iterator-&gt;TState = ObjectWaiter::TS_RUN;</span><br><span class="line">            OrderAccess::fence();</span><br><span class="line">            ev-&gt;unpark();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Policy &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            iterator-&gt;wait_reenter_begin(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自旋释放</span></span><br><span class="line">    Thread::SpinRelease(&amp;_WaitSetLock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iterator != <span class="literal">NULL</span> &amp;&amp; ObjectMonitor::_sync_Notifications != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ObjectMonitor::_sync_Notifications-&gt;inc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了 <code>synchronized</code> 工作原理和锁升级的过程。其中锁队列的协作流程较复杂，本文配了详细的流程图可以参照。最后附上了一部分重要代码的解析，理解 <code>synchronized</code> 原理之后便于写出性能更高的代码。</p>
<p>简单的来说偏向锁通过对比 Mark Word thread id 解决加锁问题。而轻量级锁是通过用 CAS 操作 Mark Word 和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。</p>
<blockquote>
<p>本文转自：<span class="exturl" data-url="aHR0cHM6Ly94aWFvbWktaW5mby5naXRodWIuaW8vMjAyMC8wMy8yNC9zeW5jaHJvbml6ZWQv">https://xiaomi-info.github.io/2020/03/24/synchronized/<i class="fa fa-external-link-alt"></i></span><br><strong>[作者简介]</strong> 张庆波，小米信息技术部架构组</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><span class="exturl" data-url="aHR0cDovL29wZW5qZGsuamF2YS5uZXQvZ3JvdXBzL2hvdHNwb3QvZG9jcy9Ib3RTcG90R2xvc3NhcnkuaHRtbA==">HotSpot Glossary of Terms<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cub3JhY2xlLmNvbS90ZWNobmV0d29yay9qYXZhLzYtcGVyZm9ybWFuY2UtMTM3MjM2Lmh0bWw=">Java SE 6 Performance White Paper<i class="fa fa-external-link-alt"></i></span></li>
</ul>
]]></content>
      <categories>
        <category>并发与多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>C</tag>
        <tag>GC</tag>
        <tag>const</tag>
        <tag>栈</tag>
        <tag>数组</tag>
        <tag>C++</tag>
        <tag>CPU</tag>
        <tag>指针</tag>
        <tag>全局</tag>
        <tag>锁</tag>
        <tag>并发</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库异常智能分析与诊断</title>
    <url>/posts/2TEE5S1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>原文：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvUG1NVkJqQXpqZUpZV0JKSTM5Z2ZfZw==">数据库异常智能分析与诊断<i class="fa fa-external-link-alt"></i></span></p>
<p>DAS（Database Autonomy Service,  数据库自治服务）面向研发和DBA，是一款为用户提供数据库性能分析、故障诊断、安全管理等功能的数据库自治服务。DAS利用大数据手段、机器学习、专家经验，帮助用户消除数据库管理的复杂性及人工操作引发的服务故障，有效保障数据库服务的稳定和高效运行。本文主要讲述DAS的历史背景、演进策略、重要功能及实现思路，希望能对从事相关开发的同学有所帮助或者启发。</p>
</blockquote>
<h2 id="1-现状与问题"><a href="#1-现状与问题" class="headerlink" title="1 现状与问题"></a>1 现状与问题</h2><h3 id="1-1-规模增长与运维能力发展之间的不平衡问题凸显"><a href="#1-1-规模增长与运维能力发展之间的不平衡问题凸显" class="headerlink" title="1.1 规模增长与运维能力发展之间的不平衡问题凸显"></a>1.1 规模增长与运维能力发展之间的不平衡问题凸显</h3><p>伴随着最近几年美团业务的快速发展，数据库的规模也保持着高速增长。而作为整个业务系统的“神经末梢”，数据库一旦出现问题，对业务造成的损失就会非常大。同时，因数据库规模的快速增长，出现问题的数量也大大增加，完全依靠人力的被动分析与定位已经不堪重负。下图是当时数据库实例近年来的增长趋势：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/05/2201-CyBaFC.png" alt="数据库实例增长趋势"></p>
<p>图1 数据库实例增长趋势</p>
<h3 id="1-2-理想很丰满，现实很骨感"><a href="#1-2-理想很丰满，现实很骨感" class="headerlink" title="1.2 理想很丰满，现实很骨感"></a>1.2 理想很丰满，现实很骨感</h3><p>美团数据库团队当前面临的主要矛盾是：实例规模增长与运维能力发展之间的不平衡，而主要矛盾体现在数据库稳定性要求较高与关键数据缺失。由于产品能力不足，只能依赖专业DBA手动排查问题，异常处理时间较长。因此，我们决定补齐关键信息，提供自助或自动定位问题的能力，缩短处理时长。</p>
<p>我们复盘了过去一段时间内的故障和告警，深入分析了这些问题的根因，发现任何一个异常其实都可以按时间拆分为异常预防、异常处理和异常复盘三阶段。针对这三阶段，结合MTTR的定义，然后调研了美团内部及业界的解决方案，我们做了一张涵盖数据库异常处理方案的全景图。如下图所示：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/05/2201-5X6GWC.png" alt="运维能力的现状"></p>
<p>图2 运维能力的现状</p>
<p>通过对比，我们发现：</p>
<ul>
<li>每个环节我们都有相关的工具支撑，但能力又不够强，相比头部云厂商大概20%～30%左右的能力，短板比较明显。</li>
<li>自助化和自动化能力也不足，工具虽多，但整个链条没有打通，未形成合力。</li>
</ul>
<p>那如何解决这一问题呢？团队成员经过深入分析和讨论后，我们提出了一种比较符合当前发展阶段的解决思路。</p>
<h2 id="2-解决的思路"><a href="#2-解决的思路" class="headerlink" title="2 解决的思路"></a>2 解决的思路</h2><h3 id="2-1-既解决短期矛盾，也立足长远发展"><a href="#2-1-既解决短期矛盾，也立足长远发展" class="headerlink" title="2.1 既解决短期矛盾，也立足长远发展"></a>2.1 既解决短期矛盾，也立足长远发展</h3><p>从对历史故障的复盘来看，80%故障中80%的时间都花在分析和定位上。解决异常分析和定位效率短期的ROI（投资回报率）最高。长期来看，只有完善能力版图，才能持续不断地提升整个数据库的稳定性及保障能力。因此，我们当时的一个想法就是既要解决短期矛盾，又要立足长远发展（Think Big Picture, Think Long Term）。新的方案要为未来留足足够的发展空间，不能只是“头痛医头、脚痛医脚”。</p>
<p>在宏观层面，我们希望能将更多的功能做到自动定位，基于自动定位来自助或自动地处理变更，从而提高异常恢复的效率，最终提升用户体验。将异常处理效率提高和用户体验提升后，运维人员（主要是DBA）的沟通成本将会极大被降低，这样运维人员就有更多时间进行技术投入，能将更多“人肉处理”的异常变成自助或自动处理，从而形成“飞轮效应”。最终达成高效的稳定性保障的目标。</p>
<p>在微观层面，我们基于已有的数据，通过结构化的信息输出，提升可观测性，补齐关键数据缺失的短板。同时，我们基于完善的信息输出，通过规则（专家经验）和AI的配合，提供自助或自动定位的能力，缩短处理时长。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/05/2202-JGcrs3.png" alt="宏观和微观">图3 宏观和微观</p>
<h3 id="2-2-夯实基础能力，赋能上层业务，实现数据库自治"><a href="#2-2-夯实基础能力，赋能上层业务，实现数据库自治" class="headerlink" title="2.2 夯实基础能力，赋能上层业务，实现数据库自治"></a>2.2 夯实基础能力，赋能上层业务，实现数据库自治</h3><p>有了明确的指导思想，我们该采取怎样的发展策略和路径呢？就当时团队的人力情况来看，没有同学有过类似异常自治的开发经验，甚至对数据库的异常分析的能力都还不具备，人才结构不能满足产品的终极目标。所谓“天下大事必作于细，天下难事必作于易”。我们思路是从小功能和容易的地方入手，先完指标监控、慢查询、活跃会话这些简单的功能，再逐步深入到全量SQL、异常根因分析和慢查询优化建议等这些复杂的功能，通过这些基础工作来“借假修真”，不断提升团队攻坚克难的能力，同时也可以为智能化打下一个良好的基础。</p>
<p>以下便是我们根据当时人才结构以及未来目标设定的2年路径规划（实现数据自治目标规划在2022以后的启动，下图会省略掉这部分）：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/05/2202-wGE2o5.png" alt="演进策略">图4 演进策略</p>
<h3 id="2-3-建立科学的评估体系，持续的跟踪产品质量"><a href="#2-3-建立科学的评估体系，持续的跟踪产品质量" class="headerlink" title="2.3 建立科学的评估体系，持续的跟踪产品质量"></a>2.3 建立科学的评估体系，持续的跟踪产品质量</h3><p>美国著名管理学者卡普兰说过：“没有度量就没有管理”。只有建立科学的评估体系，才能推进产品不断迈向更高峰，怎样评估产品的质量并持续改善呢？之前我们也做过很多指标，但都不可控，没有办法指导我们的工作。比如，我们最开始考虑根因定位使用的是结果指标准确率和召回率，但结果指标不可控难以指导我们的日常工作。这就需要找其中的可控因素，并不断改善。</p>
<p>我们在学习亚马逊的时候，刚好发现他们有一个可控输入和输出指标的方法论，就很好地指导了我们的工作。只要在正确的可控输入指标上不断优化和提升，最终我们的输出指标也能够得到提升（这也印证了曾国藩曾说过的一句话：“在因上致力，但在果上随缘”）。</p>
<p>以下是我们关于根因定位的指标设计和技术实现思路（在模拟环境不断提升可控的部分，最终线上的实际效果也会得到提升。主要包括“根因定位可控输入和输出指标设计思路”和“根因定位可控输入指标获取的技术实现思路”）。</p>
<p><strong>根因定位可控输入和输出指标设计思路</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/05/2202-23JWut.png" alt="图5 可控输入与输出指标设计"></p>
<p><strong>根因定位可控输入指标获取的技术实现思路</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/05/2204-gZVnC7.png" alt="可控输入与输出指标技术设计"></p>
<p>在图5中，我们通过场景复现方式，用技术手段来模拟一些用低成本就能实现的异常（绝大部份异常）。在对于复现成本比较高的异常（极少部分），比如机器异常、硬件故障等，我们目前的思路是通过“人肉运营”的方式，发现和优化问题，等到下次线上异常重复发生后，根据优化后诊断的结果，通过和预期比较来确定验收是否通过。</p>
<p>未来我们会建立回溯系统，将发生问题时刻的异常指标保存，通过异常指标输入給回溯系统后的输出结果，判断系统改进的有效性，从而构建更加轻量和更广覆盖的复现方式。图6是复现系统的具体技术实现思路。</p>
<p>有了指导思想，符合当前发展阶段的路径规划以及科学的评估体系后，接下来聊聊技术方案的构思。</p>
<h2 id="3-技术方案"><a href="#3-技术方案" class="headerlink" title="3 技术方案"></a>3 技术方案</h2><h3 id="3-1-技术架构的顶层设计"><a href="#3-1-技术架构的顶层设计" class="headerlink" title="3.1 技术架构的顶层设计"></a>3.1 技术架构的顶层设计</h3><p>在技术架构顶层设计上，我们秉承平台化、自助化、智能化和自动化四步走的演进策略。</p>
<p>首先，我们要完善可观测的能力，通过关键信息的展示，构建一个易用的数据库监控平台。然后我们根据这些关键信息为变更（比如数据变更和索引变更等）提供赋能，将一部分高频运维工作通过这些结构化的关键信息（比如索引变更，可以监测近期是否有访问流量，来确保变更安全性）让用户自主决策，也就是自助化。接下来，我们加入一些智能的元素（专家经验+AI），进一步覆盖自助化的场景，并逐步将部分低风险的功能自动化，最终通过系统的不断完善，走到高级或完全自动化的阶段。</p>
<p>为什么我们将自动化放在智能化之后？因为我们认为智能化的目标也是为了自动化，智能化是自动化的前提，自动化是智能化的结果。只有不断提升智能化，才能达到高级或者完全自动化。下图便是我们的顶层架构设计（左侧是演进策略，右侧是技术架构的顶层设计以及2021年底的现状）：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/05/2205-iCsfIF.png" alt="图7 架构顶层设计"></p>
<p>顶层设计只是“万里长征第一步”，接下来我们将自底向上逐步介绍我们基于顶层设计开展的具体工作，将从数据采集层的设计、计算存储层的设计和分析决策层的设计逐步展开。</p>
<h3 id="3-2-数据采集层的设计"><a href="#3-2-数据采集层的设计" class="headerlink" title="3.2 数据采集层的设计"></a>3.2 数据采集层的设计</h3><p>这上面的架构图里，数据采集层是所有链路的最底层和最重要的环节，采集数据的质量直接决定了整个系统的能力。同时，它和数据库实例直接打交道，任何设计上的缺陷都将可能导致大规模的故障。所以，技术方案上必须兼顾数据采集质量和实例稳定性，在二者无法平衡的情况下，宁可牺牲掉采集质量也要保证数据库的稳定性。</p>
<p>在数据采集上，业界都采取基于内核的方式，但美团自研内核较晚，而且部署周期长，所以我们短期的方式是采用抓包的方式做一个过渡，等基于内核的采集部署到一定规模后再逐步切换过来。以下是我们基于抓包思路的技术方案调研：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/05/2206-YI2cBB.png" alt="图片"></p>
<p>从调研上我们可以看到，基于pf_ring和dpdk的方案都有较大的依赖性，短期难以实现，之前也没有经验。但是，基于pcap的方式没有依赖，我们也有过一定的经验，之前美团酒旅团队基于抓包的方式做过全量SQL数据采集的工具，并经过了1年时间的验证。因此，我们最终采取了基于pcap抓包方式的技术方案。以下是采集层方案的架构图和采集质量以及对数据库性能带来的影响情况。</p>
<p><strong>Agent的技术设计</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/05/2210-geH61R.png" alt="图8 Agent的技术设计"></p>
<p><strong>对数据库的影响</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/05/2206-Sy4oxH.png" alt="图9 Agent对数据库的影响测试"></p>
<h3 id="3-3-计算存储层的设计"><a href="#3-3-计算存储层的设计" class="headerlink" title="3.3 计算存储层的设计"></a>3.3 计算存储层的设计</h3><p>由于美团整个数据库实例数量和流量巨大，而且随着业务的快速发展，还呈现出快速增长的态势。所以，我们的设计不仅要满足当前，还要考虑未来5年及更长的时间也能够满足要求。同时，对数据库故障分析来说，数据的实时性和完备性是快速和高效定位问题的关键，而保证数据实时性和完备性需要的容量成本也不容忽视。因此，结合上述要求和其他方面的一些考虑，我们对该部分设计提出了一些原则，主要包括：</p>
<ul>
<li><strong>全内存计算</strong>：确保所有的计算都在单线程内或单进程内做纯内存的操作，追求性能跟吞吐量的极致。</li>
<li><strong>上报原始数据</strong>：MySQL实例上报的数据尽量维持原始数据状态，不做或者尽量少做数据加工。<br><strong>数据压缩</strong>：由于上报量巨大，需要保障上报的数据进行极致的压缩。</li>
<li><strong>内存消耗可控</strong>：通过理论和实际压测保障几乎不可能会发生内存溢出。</li>
<li><strong>最小化对MySQL实例的影响</strong>：计算尽量后置，不在Agent上做复杂计算，确保不对RDS实例生产较大影响。以下是具体的架构图：</li>
</ul>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/05/2210-fPWx39.png" alt="图10 Agent对数据库的影响测试"></p>
<p>全量SQL（所有访问数据库的SQL）是整个系统最具挑战的功能，也是数据库异常分析最重要的信息之一，因此会就全量SQL的聚合方式、聚合和压缩的效果和补偿设计做一些重点的介绍。</p>
<h4 id="3-3-1-全量SQL的聚合方式"><a href="#3-3-1-全量SQL的聚合方式" class="headerlink" title="3.3.1 全量SQL的聚合方式"></a>3.3.1 全量SQL的聚合方式</h4><p>由于明细数据巨大，我们采取了聚合的方式。消费线程会对相同模板SQL的消息按分钟粒度进行聚合计算，以“RDSIP+DBName+SQL模版ID+SQL查询结束时间所在分钟数”为聚合键。聚合健的计算公式为：Aggkey=RDS_IP_DBName_SQL_Template_ID_Time_Minute （Time_Minute的值取自SQL查询结束时间所在的“年、月、日、时、分钟”）</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/05/2206-PL7fzf.png" alt="图11 SQL模版聚合设计"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/05/2209-w25SD2.png" alt="图12 SQL模版聚合方法"></p>
<h4 id="3-3-2-全量SQL数据聚合和压缩的效果"><a href="#3-3-2-全量SQL数据聚合和压缩的效果" class="headerlink" title="3.3.2 全量SQL数据聚合和压缩的效果"></a>3.3.2 全量SQL数据聚合和压缩的效果</h4><p>在数据压缩方面，遵循层层减流原则，使用消息压缩、预聚合、字典化、分钟级聚合的手段，保证流量在经过每个组件时进行递减，最终达到节省带宽减少存储量的目的。以下是相关的压缩环节和测试数据表现情况（敏感数据做了脱敏，不代表美团实际的情况）：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/05/2209-kJtMW2.png" alt="图13 全量SQL压缩设计与效果"></p>
<h4 id="3-3-3-全量SQL数据补偿机制"><a href="#3-3-3-全量SQL数据补偿机制" class="headerlink" title="3.3.3 全量SQL数据补偿机制"></a>3.3.3 全量SQL数据补偿机制</h4><p>如上所述，在数据聚合端是按一分钟进行聚合，并允许额外一分钟的消息延迟，如果消息延迟超过1分钟会被直接丢弃掉，这样在业务高峰期延迟比较严重的场景下，会丢失比较大量的数据，从而对后续数据库异常分析的准确性造成较大的影响。</p>
<p>因此，我们增加了延迟消息补偿机制，对过期的数据发入补偿队列（采用的是美团消息队列服务Mafka），通过过期数据补偿的方式，保证延迟久的消息也能正常存储，通过最终一致性保证了后续的数据库异常分析的准确性。以下是数据补偿机制的设计方案：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/05/2209-Qa04g2.png" alt="图14 全量SQL补全技术设计"></p>
<h3 id="3-4-分析决策层的设计"><a href="#3-4-分析决策层的设计" class="headerlink" title="3.4 分析决策层的设计"></a>3.4 分析决策层的设计</h3><p>在有了比较全的数据之后，接下来就是基于数据进行决策，推断出可能的根因。这部分我们使用了基于专家经验结合AI的方式。我们把演进路径化分为了四个阶段：</p>
<ul>
<li><strong>第一阶段</strong>：完全以规则为主，积累领域经验，探索可行的路径。</li>
<li><strong>第二阶段</strong>：探索AI场景，但以专家经验为主，在少量低频场景上使用AI算法，验证AI能力。</li>
<li><strong>第三阶段</strong>：在专家经验和AI上齐头并进，专家经验继续在已有的场景上迭代和延伸，AI在新的场景上进行落地，通过双轨制保证原有能力不退化。</li>
<li><strong>第四阶段</strong>：完成AI对大部分专家经验的替换，以AI为主专家经验为辅，极致发挥AI能力。</li>
</ul>
<p>以下是分析决策部分整体的技术设计（我们参考了华为一篇文章：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpBd016Y3hORE00TWc9PSZhbXA7bWlkPTI2NDkwNzk4MzMmYW1wO2lkeD0xJmFtcDtzbj1mMTMxZGU1MWRlZmUxZTNhNjEyNWYxZjBkMGYxMTdlNyZhbXA7c2NlbmU9MjEjd2VjaGF0X3JlZGlyZWN0">《网络云根因智荐的探索与实践》<i class="fa fa-external-link-alt"></i></span>）：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/05/2208-O1SL2x.png" alt="图15 分析决策的技术设计"></p>
<p>在决策分析层，我们主要采取了专家经验和AI两者方式，接下来会介绍专家经验（基于规则的方式）和AI方式（基于AI算法的方式）的相关实现。</p>
<h4 id="3-4-1-基于规则的方式"><a href="#3-4-1-基于规则的方式" class="headerlink" title="3.4.1 基于规则的方式"></a>3.4.1 基于规则的方式</h4><p>专家经验部分，我们采取了GRAI（Goal、Result、Analysis和Insight的简称）的复盘方法论来指导工作，通过持续、大量、高频的复盘，我们提炼了一些靠谱的规则，并通过持续的迭代，不断提升准确率和召回率。下面例举的是主从延迟的规则提炼过程：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/05/2207-5DEpsK.png" alt="图16 专家经验的复盘和改进"></p>
<h4 id="3-4-2-基于AI算法的方式"><a href="#3-4-2-基于AI算法的方式" class="headerlink" title="3.4.2 基于AI算法的方式"></a>3.4.2 基于AI算法的方式</h4><p><strong>异常数据库指标检测</strong></p>
<p>数据库核心指标的异常检测依赖于对指标历史数据的合理建模，通过将离线过程的定期建模与实时过程的流检测相结合，将有助于在数据库实例存在故障或风险的情况下，有效地定位根本问题所在，从而实现及时有效地解决问题。</p>
<p>建模过程主要分为3个流程。首先，我们通过一些前置的模块对指标的历史数据进行预处理，包含缺失数值填充，数据的平滑与聚合等过程。随后，我们通过分类模块创建了后续的不同分支，针对不同类型的指标运用不同的手段来建模。最终，将模型进行序列化存储后提供Flink任务读取实现流检测。</p>
<p><strong>以下是检测的设计图</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/05/2206-scJKSt.png" alt="图17 基于AI的异常检测设计"></p>
<p><strong>根因诊断（构建中）</strong></p>
<p>订阅告警消息（基于规则或者异常检测触发），触发诊断流程，采集、分析数据，推断出根因并筛选出有效信息辅助用户解决。诊断结果通过大象通知用户，并提供诊断诊断详情页面，用户可通过标注来优化诊断准确性。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/05/2207-BlS0lM.png" alt="图18 基于AI的异常检测设计"></p>
<ul>
<li><strong>数据采集</strong>：采集数据库性能指标、数据库状态抓取、系统指标、硬件问题、日志、记录等数据。</li>
<li><strong>特征提取</strong>：从各类数据中提取特征，包括算法提取的时序特征、文本特征以及利用数据库知识提取的领域特征等。</li>
<li><strong>根因分类</strong>：包括特征预处理、特征筛选、算法分类、根因排序等部分。</li>
<li><strong>根因扩展</strong>：基于根因类别进行相关信息的深入挖掘，提高用户处理问题的效率。具体包括SQL行为分析、专家规则、指标关联、维度下钻、日志分析等功能模块。</li>
</ul>
<p><strong>4 建设成果</strong></p>
<p><strong>4.1 指标表现</strong></p>
<p>我们目前主要是通过“梳理触发告警场景-&gt;模拟复现场景-&gt;根因分析和诊断-&gt;改进计划-&gt;验收改进质量-&gt;梳理触发告警场景”的闭环方法（详情请参考前文<strong>建立科学的评估体系，持续的跟踪产品质量</strong>部分），持续不断的进行优化和迭代。通过可控输入指标的提升，来优化改善线上的输出指标，从而保证系统不断的朝着正确的方向发展。以下是近期根因召回率和准确率指标表现情况。</p>
<p><strong>用户告警根因反馈准确率</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/05/2207-ujdjsQ.png" alt="图19 用户反馈准确率"></p>
<p><strong>告警诊断分析总体召回率</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/05/2206-qrXR5n.png" alt="图20 根因分析召回率"></p>
<h3 id="4-2-用户案例"><a href="#4-2-用户案例" class="headerlink" title="4.2 用户案例"></a>4.2 用户案例</h3><p>在根因结果推送上，我们和美团内部的IM系统（大象）进行了打通，出现问题后通过告警发现异常-&gt;大象推送诊断根因-&gt;点击诊断链接详情查看详细信息-&gt;一键预案处理-&gt;跟踪反馈处理的效果-&gt;执行成功或者回滚，来完成异常的发现、定位、确认和处理的闭环。以下是活跃会话规则触发告警后根因分析的一个案例。</p>
<p><strong>自动拉群，并给出根因</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/05/2206-H2dlf3.png" alt="图21 锁阻塞导致活跃会话过高"></p>
<p><strong>点击诊断报告，查看详情</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/05/2206-zWL0uT.png" alt="图22 锁阻塞导致活跃会话过高"></p>
<p>以下是出现Load告警后，我们的一个慢查询优化建议推送案例（脱敏原因，采用了测试环境模拟的案例）。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/05/2206-IbCL8r.png" alt="图23 慢查询优化建议"></p>
<h2 id="5-总结与未来展望"><a href="#5-总结与未来展望" class="headerlink" title="5 总结与未来展望"></a>5 总结与未来展望</h2><p>数据库自治服务经过2年左右的发展，已基本夯实了基础能力，在部分业务场景上完成了初步赋能（比如针对问题SQL，业务服务上线发布前自动识别，提示潜在风险；针对索引误变更，工单执行前自动检测索引近期访问流量，阻断误变更等）。接下来，我们的目标除了在已完成工作上继续深耕，提升能力外，重点会瞄准数据库自治能力。主要的工作规划将围绕以下3个方向：</p>
<p><strong>（1）计算存储能力增强</strong>：随着数据库实例和业务流量的持续高速增长，以及采集的信息的不断丰富，亟需对现有数据通道能力进行增强，确保能支撑未来3-5年的处理能力。</p>
<p><strong>（2）自治能力在少部分场景上落地</strong>：数据库自治能力上，会采取三步走的策略：</p>
<ul>
<li>第一步：建立根因诊断和SOP文档的关联，将诊断和处理透明化；</li>
<li>第二步：SOP文档平台化，将诊断和处理流程化；</li>
<li>第三步：部分低风险无人干预，将诊断和处理自动化，逐步实现数据库自治。</li>
</ul>
<p><strong>（3）更灵活的异常回溯系统</strong>：某个场景根因定位算法在上线前或者改进后的验证非常关键，我们会完善验证体系，建立灵活的异常回溯系统，通过基于现场信息的回放来不断优化和提升系统定位准确率。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>内存</tag>
        <tag>sql</tag>
        <tag>GC</tag>
        <tag>数据库</tag>
        <tag>Mysql</tag>
        <tag>锁</tag>
        <tag>索引</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法习题01：二分查找</title>
    <url>/posts/32V7A68.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>算法图解：二分查找</p>
<blockquote>
<p>截图来自《算法图解》这本书</p>
</blockquote>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/16/14261657952726.png" alt="14261657952726"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/16/14091657952829.png" alt="14091657952829"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/16/14231657952843.png" alt="14231657952843"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/16/14381657952858.png" alt="14381657952858"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/16/14521657952872.png" alt="14521657952872"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/16/14071657952887.png" alt="14071657952887"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/16/14591657953479.png" alt="14591657953479"></p>
<p>练习代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 需要的值是否存在</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> ints 数组</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> low 开始下下标</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> height 结束下标</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> need 基准值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">searchBoo</span><span class="params">(Integer[] ints, Integer low, Integer height,Integer need)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (low &gt; height)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">if</span> (ints[mid].equals(need)) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span> (ints[mid] &gt; need) &#123;</span><br><span class="line">           <span class="keyword">return</span> searchBoo(ints, low, mid -<span class="number">1</span>, need);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ints[mid] &lt; need) &#123;</span><br><span class="line">           <span class="keyword">return</span> searchBoo(ints, mid + <span class="number">1</span>, height, need);</span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 需要值的下标</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> ints 数组</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> low 开始下下标</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> height 结束下标</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> need 基准值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">searchindex</span><span class="params">(Integer[] ints, Integer low, Integer height,Integer need)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (low &gt; height)&#123;</span><br><span class="line">           <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">       <span class="keyword">if</span> (ints[mid].equals(need)) &#123;</span><br><span class="line">           <span class="keyword">return</span> mid;</span><br><span class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span> (ints[mid] &gt; need) &#123;</span><br><span class="line">           <span class="keyword">return</span> searchindex(ints, low, mid -<span class="number">1</span>, need);</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ints[mid] &lt; need) &#123;</span><br><span class="line">           <span class="keyword">return</span> searchindex(ints, mid + <span class="number">1</span>, height, need);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> mid;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这是一个经典的话题，如何计算二分查找中的中值？大家一般给出了两种计算方法：</p>
<ul>
<li>算法一： <code>mid = (low + high) / 2</code></li>
<li>算法二： <code>mid = low + (high – low)/2</code></li>
</ul>
<p>乍看起来，算法一简洁，算法二提取之后，跟算法一没有什么区别。但是实际上，区别是存在的。算法一的做法，在极端情况下，(low + high)存在着溢出的风险，进而得到错误的mid结果，导致程序错误。而算法二能够保证计算出来的mid，一定大于low，小于high，不存在溢出的问题。</p>
<p>二分查找法的缺陷</p>
<p>二分查找法的O(log n)让它成为十分高效的算法。不过它的缺陷却也是那么明显的。就在它的限定之上：<code>必须有序</code>，我们很难保证我们的数组都是有序的。当然可以在构建数组的时候进行排序，可是又落到了第二个瓶颈上：它必须是数组。</p>
<p>数组读取效率是O(1)，可是它的插入和删除某个元素的效率却是O(n)。因而导致构建有序数组变成低效的事情。</p>
<p>解决这些缺陷问题更好的方法应该是使用二叉查找树了，最好自然是自平衡二叉查找树了，既能高效的（O(n log n)）构建有序元素集合，又能如同二分查找法一样快速（O(log n)）的搜寻目标数。</p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>集合</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>算法习题02：选择排序</title>
    <url>/posts/13M04H2.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>算法图解：选择排序</p>
<blockquote>
<p>截图来自《算法图解》这本书</p>
</blockquote>
<p>它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/18/20031658147403.png" alt="20031658147403"> </p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/18/20241658147424.png" alt="20241658147424"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/18/20441658147444.png" alt="20441658147444"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/18/20001658147460.png" alt="20001658147460"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/18/20221658147482.png" alt="20221658147482"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/18/20471658147507.png" alt="20471658147507"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/18/20071658147527.png" alt="20071658147527"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/18/20241658147544.png" alt="20241658147544"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/18/20401658147560.png" alt="20401658147560"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/18/20531658147573.png" alt="20531658147573"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/18/20061658145726.png" alt="20061658145726"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/18/20011658145781.png" alt="20011658145781"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/18/20181658145798.png" alt="20181658145798"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/18/20421658145822.png" alt="20421658145822"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从小到大排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ints</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] test(<span class="keyword">int</span>[] ints)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ints.length -<span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> floor =  ints[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; ints.length - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ints[j] &lt; floor)&#123;</span><br><span class="line">                floor = ints[j];</span><br><span class="line">                ints[j] = ints[i];</span><br><span class="line">                ints[i] = floor;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ints;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>算法习题03：快速排序</title>
    <url>/posts/1AQHRFA.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>算法图解：快速排序</p>
<blockquote>
<p>截图来自《算法图解》这本书</p>
</blockquote>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/20/195249laWVly.png" alt="195249laWVly"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/20/19531762PXaC.png" alt="19531762PXaC"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/20/195332L4J7MK.png" alt="195332L4J7MK"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/20/195358ruyCMZ.png" alt="195358ruyCMZ"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/20/195416wXeqVW.png" alt="195416wXeqVW"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/20/195429YFQ2fz.png" alt="195429YFQ2fz"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/20/195440LvEIGd.png" alt="195440LvEIGd"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/20/195535lzuGZv.png" alt="195535lzuGZv"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/20/195551BTRPgc.png" alt="195551BTRPgc"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/20/1956043TNZAG.png" alt="1956043TNZAG"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/20/195617LrPWyW.png" alt="195617LrPWyW"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/20/195631KgQV8d.png" alt="195631KgQV8d"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/20/195643EqMOlZ.png" alt="195643EqMOlZ"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/20/195703LI4krg.png" alt="195703LI4krg"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/20/195714NG7uG0.png" alt="195714NG7uG0"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/20/195737m3moV0.png" alt="195737m3moV0"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/20/195747uaEadK.png" alt="195747uaEadK"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/20/195815v3FnsY.png" alt="195815v3FnsY"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/20/1958503zdsy5.png" alt="1958503zdsy5"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/20/195902YEM3ez.png" alt="195902YEM3ez"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/20/195918yAVu0f.png" alt="195918yAVu0f"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/20/195929zahbRL.png" alt="195929zahbRL"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/20/195948OjCc86.png" alt="195948OjCc86"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/20/200001a5rCU8.png" alt="200001a5rCU8"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/20/200015Ike3ZU.png" alt="200015Ike3ZU"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/20/200025IJ0idg.png" alt="200025IJ0idg"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/20/200048wGM9ya.png" alt="200048wGM9ya"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/20/2000587Nv61z.png" alt="2000587Nv61z"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/20/20010955S8yy.png" alt="20010955S8yy"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/20/200123bdbhKB.png" alt="200123bdbhKB"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/20/200135vcMWW5.png" alt="200135vcMWW5"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] quickSort(<span class="keyword">int</span>[] ints, <span class="keyword">int</span> start, <span class="keyword">int</span> end)&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end)&#123;</span><br><span class="line">            <span class="keyword">return</span> ints;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//基点，第一个数</span></span><br><span class="line">        <span class="keyword">int</span> pivot = ints[start];</span><br><span class="line">        <span class="comment">//左指针</span></span><br><span class="line">        <span class="keyword">int</span> left = start;</span><br><span class="line">        <span class="keyword">int</span> right = end;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">while</span> (ints[right] &gt;= pivot &amp;&amp; left &lt; right)&#123;</span><br><span class="line">                right --;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (ints[left] &lt;= pivot &amp;&amp; left &lt; right)&#123;</span><br><span class="line">                left ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (left &lt; right)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = ints[right];</span><br><span class="line">                ints[right] = ints[left];</span><br><span class="line">                ints[left] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ints[start] = ints[left];</span><br><span class="line">        ints[left] = pivot;</span><br><span class="line">        quickSort(ints, start, left -<span class="number">1</span>);</span><br><span class="line">        quickSort(ints, left + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> ints;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">81</span>, <span class="number">65</span>, <span class="number">17</span>, <span class="number">1</span>, <span class="number">71</span>, <span class="number">9</span>, <span class="number">26</span>, <span class="number">12</span>, <span class="number">93</span>, <span class="number">30</span>, <span class="number">55</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] ints = quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(JSON.toJSONString(ints));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>过程讲解：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/20/200753QulpGX.png" alt="200753QulpGX"></p>
<p>选出基准值，可以随意选择，但一般会选择最后一个数或者第一个数作为基准值。</p>
<p>这里选择第一个数作为基准值。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/20/201103yMNh2N.png" alt="201103yMNh2N"></p>
<p>指定两个指针，left和right，left从左边开始寻找，right从右边开始寻找。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/20/203454umR7Nz.png" alt="203454umR7Nz"></p>
<p>left找出一个比基准值大的值停止寻找。</p>
<p>right找出一个比基准值小的值停止寻找。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/20/2036174K7KXq.png" alt="2036174K7KXq"></p>
<p>然后两个值进行交换。（93和55交换）</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/20/203733pbEHaG.png" alt="203733pbEHaG"></p>
<p>继续往下寻找。。</p>
<p>当left和right相等时，left（right）对应值与基准值进行交换。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/20/203945EvOhLB.png" alt="203945EvOhLB"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/20/204045Xq22Cy.png" alt="204045Xq22Cy"></p>
<p>以81为分界线，分为两段继续进行排序。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/20/204205gS1UXp.png" alt="204205gS1UXp"></p>
<p>第一段的开始值为start 和 left-1（或right-1）</p>
<p>第一段的开始值为left+1（或right+1）和 end</p>
<p>(此时left为它与right相等时的下表，这个下标的值与基准值交换后，就是基准值了，基准值左边的是比自己小的，右边是比自己大的)</p>
<p>使用递归，第一段和第二段继续排序。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/20/205246klKkwE.png" alt="205246klKkwE"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/20/205316SJaJHO.png" alt="205316SJaJHO"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/20/205421Qsyffc.png" alt="205421Qsyffc"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/20/205625yqLzjZ.png" alt="205625yqLzjZ"></p>
<p>……</p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>GC</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>算法习题04：图的基本介绍与代码实现</title>
    <url>/posts/FG06ED.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="为什么要有图"><a href="#为什么要有图" class="headerlink" title="为什么要有图"></a>为什么要有图</h2><p>当我们需要表示多对多的关系时，就需要用到图了。</p>
<h2 id="图的基本介绍"><a href="#图的基本介绍" class="headerlink" title="图的基本介绍"></a>图的基本介绍</h2><p>图是一种数据结构，其中节点可以具有零个或多个相邻的元素。两个结点之间的连接称为边，结点也可以称为顶点。</p>
<p>如图：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/25/191018Js8nmL.png" alt=""></p>
<h2 id="图常用的概念"><a href="#图常用的概念" class="headerlink" title="图常用的概念"></a>图常用的概念</h2><ol>
<li><p>顶点（vertex）</p>
</li>
<li><p>边（edge）</p>
</li>
<li><p>路径</p>
</li>
<li><p>无向图（下图）</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/25/19113911Detb.png" alt=""></p>
</li>
<li><p>有向图</p>
</li>
<li><p>带权图</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/25/191335SjaTNn.png" alt=""></p>
</li>
</ol>
<h2 id="图的表示方式"><a href="#图的表示方式" class="headerlink" title="图的表示方式"></a>图的表示方式</h2><h3 id="二维数组表示"><a href="#二维数组表示" class="headerlink" title="二维数组表示"></a>二维数组表示</h3><blockquote>
<p>也叫 邻接矩阵</p>
</blockquote>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/25/191511zV3dCd.png" alt=""></p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><blockquote>
<p>也叫 邻接表</p>
</blockquote>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/25/191856rJoe0q.png" alt=""></p>
<h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h2><p><img data-src="https://xuemingde.com/pages/image/2022/07/25/192058HQQfyN.png" alt=""></p>
<h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><ol>
<li>存储顶点，使用ArrayList  </li>
<li>保存矩阵，使用int[][] adges  </li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.algorithm.graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yons</span></span><br><span class="line"><span class="comment"> * 无边向</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储顶点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertexList;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储图对应的邻接矩阵</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] edges;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示边的数目</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numOfEdges;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//结点个数</span></span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">        <span class="comment">//顶点值</span></span><br><span class="line">        String[] vertexs = &#123;<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;D&quot;</span>,<span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//创建图对象</span></span><br><span class="line">        Graph graph = <span class="keyword">new</span> Graph(n);</span><br><span class="line">        <span class="comment">//循环添加顶点</span></span><br><span class="line">        <span class="keyword">for</span> (String vertex : vertexs) &#123;</span><br><span class="line">            graph.insertVertex(vertex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加边</span></span><br><span class="line">        <span class="comment">//A-B A-C B-C B-D B-E</span></span><br><span class="line">        graph.insertEdge(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//显式邻接矩阵</span></span><br><span class="line">        graph.showGraph();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 顶点个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="comment">//初始化矩阵和vertexList</span></span><br><span class="line">        vertexList = <span class="keyword">new</span> ArrayList&lt;&gt;(n);</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回结点个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumOfVertex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回边的数目</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumOfEdges</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numOfEdges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回下标所对应的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getVertexByIndex</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.get(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显式邻接矩阵</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGraph</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(edge));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回两个顶点之间的权值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vertex 顶点名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">insertVertex</span><span class="params">(String vertex)</span></span>&#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加边</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1 第一个顶点的下标 (第几个顶点)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2 第二个顶点的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight 两个顶点之间的距离</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertEdge</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2,<span class="keyword">int</span> weight)</span></span>&#123;</span><br><span class="line">        edges[v1][v2] = weight;</span><br><span class="line">        edges[v2][v1] = weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p>[0, 1, 1, 0, 0]<br>[1, 0, 1, 1, 1]<br>[1, 1, 0, 0, 0]<br>[0, 1, 0, 0, 0]<br>[0, 1, 0, 0, 0]</p>
<p>如果在设置边的时候，设置如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加边</span></span><br><span class="line"><span class="comment">//A-B A-C B-C B-D B-E</span></span><br><span class="line">graph.insertEdge(<span class="number">0</span>,<span class="number">1</span>,<span class="number">23</span>);</span><br><span class="line">graph.insertEdge(<span class="number">0</span>,<span class="number">2</span>,<span class="number">12</span>);</span><br><span class="line">graph.insertEdge(<span class="number">1</span>,<span class="number">2</span>,<span class="number">34</span>);</span><br><span class="line">graph.insertEdge(<span class="number">1</span>,<span class="number">3</span>,<span class="number">56</span>);</span><br><span class="line">graph.insertEdge(<span class="number">1</span>,<span class="number">4</span>,<span class="number">41</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>边的权值设置为实际长度，输出的结果为：</p>
<p>[0, 23, 12, 0, 0]<br>[23, 0, 34, 56, 41]<br>[12, 34, 0, 0, 0]<br>[0, 56, 0, 0, 0]<br>[0, 41, 0, 0, 0]  </p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>算法习题05：图的深度优先遍历</title>
    <url>/posts/WERGR1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="图遍历介绍"><a href="#图遍历介绍" class="headerlink" title="图遍历介绍"></a>图遍历介绍</h2><p>所谓图的遍历，即是对结点的访问，一个图有那么多个结点，如何遍历这些结点，需要特定策略，一般有两种访问策略：1)深度优先遍历（DFS）   2）广度优先遍历</p>
<h2 id="深度优先遍历基本思想"><a href="#深度优先遍历基本思想" class="headerlink" title="深度优先遍历基本思想"></a>深度优先遍历基本思想</h2><p><img data-src="https://xuemingde.com/pages/image/2022/07/26/2010331AnzNH.png" alt=""></p>
<h2 id="深度优先遍历算法步骤"><a href="#深度优先遍历算法步骤" class="headerlink" title="深度优先遍历算法步骤"></a>深度优先遍历算法步骤</h2><p><img data-src="https://xuemingde.com/pages/image/2022/07/26/201220ynLLps.png" alt=""></p>
<p>在链表里的数据的存放顺序如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/26/201957m8ESZu.png" alt=""></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dfs</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储顶点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertexList;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储图对应的邻接矩阵</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] edges;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示边的数目</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numOfEdges;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录某个顶点是否被访问</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] isVisited;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//结点个数</span></span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">        <span class="comment">//顶点值</span></span><br><span class="line">        String[] vertexs = &#123;<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;D&quot;</span>,<span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//创建图对象</span></span><br><span class="line">        Dfs graph = <span class="keyword">new</span> Dfs(n);</span><br><span class="line">        <span class="comment">//循环添加顶点</span></span><br><span class="line">        <span class="keyword">for</span> (String vertex : vertexs) &#123;</span><br><span class="line">            graph.insertVertex(vertex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加边</span></span><br><span class="line">        <span class="comment">//A-B A-C B-C B-D B-E</span></span><br><span class="line">        graph.insertEdge(<span class="number">0</span>,<span class="number">1</span>,<span class="number">23</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">0</span>,<span class="number">2</span>,<span class="number">12</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>,<span class="number">2</span>,<span class="number">34</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>,<span class="number">3</span>,<span class="number">56</span>);</span><br><span class="line">        graph.insertEdge(<span class="number">1</span>,<span class="number">4</span>,<span class="number">41</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//显式邻接矩阵</span></span><br><span class="line">        graph.showGraph();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        graph.dfs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 顶点个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="comment">//初始化矩阵和vertexList</span></span><br><span class="line">        vertexList = <span class="keyword">new</span> ArrayList&lt;&gt;(n);</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到第一个邻接结点的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFirstNeighbor</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexList.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[index][i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据前一个邻接结点的下标获取下一个邻接结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNextNeighbor</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = v2 + <span class="number">1</span>; i &lt; vertexList.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[v1][i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 深度优先遍历算法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isVisited</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i i第一个就是0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">boolean</span>[] isVisited,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        System.out.println(getVertexByIndex(i));</span><br><span class="line">        <span class="comment">//将结点设置为已访问</span></span><br><span class="line">        isVisited[i] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查找结点i的第一个邻接结点</span></span><br><span class="line">        <span class="keyword">int</span> w = getFirstNeighbor(i);</span><br><span class="line">        <span class="comment">//w != -1 说明有</span></span><br><span class="line">        <span class="keyword">while</span> (w != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//返回下标是否被访问</span></span><br><span class="line">            <span class="keyword">if</span> (!isVisited[w])&#123;</span><br><span class="line">                dfs(isVisited,w);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果被访问过，查找邻接结点的下一个</span></span><br><span class="line">            w = getNextNeighbor(i,w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对dfs进行重载，遍历所有的结点，并进行dfs</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//遍历所有结点，进行dfs</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getNumOfVertex(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isVisited[i])&#123;</span><br><span class="line">                dfs(isVisited,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回结点个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumOfVertex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回边的数目</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumOfEdges</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numOfEdges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回下标所对应的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getVertexByIndex</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.get(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显式邻接矩阵</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGraph</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(edge));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回两个顶点之间的权值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vertex 顶点名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">insertVertex</span><span class="params">(String vertex)</span></span>&#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加边</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1 第一个顶点的下标 (第几个顶点)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2 第二个顶点的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight 两个顶点之间的距离</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertEdge</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2,<span class="keyword">int</span> weight)</span></span>&#123;</span><br><span class="line">        edges[v1][v2] = weight;</span><br><span class="line">        edges[v2][v1] = weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法习题06：图的广度优先遍历</title>
    <url>/posts/2RH55VS.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="图的广度优先遍历介绍"><a href="#图的广度优先遍历介绍" class="headerlink" title="图的广度优先遍历介绍"></a>图的广度优先遍历介绍</h2><p><img data-src="https://xuemingde.com/pages/image/2022/07/29/191431HBzi5Q.png" alt=""></p>
<h2 id="广度优先遍历算法步骤"><a href="#广度优先遍历算法步骤" class="headerlink" title="广度优先遍历算法步骤"></a>广度优先遍历算法步骤</h2><p><img data-src="https://xuemingde.com/pages/image/2022/07/31/104235EOyGJY.png" alt=""></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>示例：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/31/105030TOl6ph.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 广度优先遍历</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：XMD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 31.7.22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bfs</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储顶点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertexList;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储图对应的邻接矩阵</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] edges;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 表示边的数目</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numOfEdges;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录某个顶点是否被访问</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] isVisited;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//结点个数</span></span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">        <span class="comment">//顶点值</span></span><br><span class="line">        String[] vertexs = &#123;<span class="string">&quot;A&quot;</span>,<span class="string">&quot;B&quot;</span>,<span class="string">&quot;C&quot;</span>,<span class="string">&quot;D&quot;</span>,<span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//创建图对象</span></span><br><span class="line">        Bfs bfs = <span class="keyword">new</span> Bfs(n);</span><br><span class="line">        <span class="comment">//循环添加顶点</span></span><br><span class="line">        <span class="keyword">for</span> (String vertex : vertexs) &#123;</span><br><span class="line">            bfs.insertVertex(vertex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加边</span></span><br><span class="line">        <span class="comment">//A-B A-C B-C B-D B-E</span></span><br><span class="line">        bfs.insertEdge(<span class="number">0</span>,<span class="number">1</span>,<span class="number">23</span>);</span><br><span class="line">        bfs.insertEdge(<span class="number">0</span>,<span class="number">2</span>,<span class="number">12</span>);</span><br><span class="line">        bfs.insertEdge(<span class="number">1</span>,<span class="number">2</span>,<span class="number">34</span>);</span><br><span class="line">        bfs.insertEdge(<span class="number">1</span>,<span class="number">3</span>,<span class="number">56</span>);</span><br><span class="line">        bfs.insertEdge(<span class="number">1</span>,<span class="number">4</span>,<span class="number">41</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//显式邻接矩阵</span></span><br><span class="line">        bfs.showGraph();</span><br><span class="line"></span><br><span class="line">        bfs.bfs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对一个结点进行广度优先遍历</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isVisited</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">boolean</span>[] isVisited, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="comment">//表示队列的头结点对应下标</span></span><br><span class="line">        <span class="keyword">int</span> u;</span><br><span class="line">        <span class="comment">//邻接结点</span></span><br><span class="line">        <span class="keyword">int</span> w;</span><br><span class="line">        <span class="comment">//队列，记录结点访问的顺序</span></span><br><span class="line">        LinkedList queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="comment">//访问结点，输出结点信息</span></span><br><span class="line">        System.out.print(getVertexByIndex(i) + <span class="string">&quot;=&gt;&quot;</span>);</span><br><span class="line">        <span class="comment">//标记为已访问</span></span><br><span class="line">        isVisited[i] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//将结点假如队列</span></span><br><span class="line">        queue.addLast(i);</span><br><span class="line">        <span class="keyword">if</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//取出队列的头结点下标</span></span><br><span class="line">            u = (Integer) queue.removeFirst();</span><br><span class="line">            <span class="comment">//得到第一个邻接结点的下标W</span></span><br><span class="line">            w =getFirstNeighbor(u);</span><br><span class="line">            <span class="keyword">if</span> (w != -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!isVisited[w])&#123;</span><br><span class="line">                    System.out.print(getVertexByIndex(w) + <span class="string">&quot;&gt;&quot;</span>);</span><br><span class="line">                    isVisited[w] = <span class="keyword">true</span>;</span><br><span class="line">                    queue.addLast(w);</span><br><span class="line">                &#125;</span><br><span class="line">                w = getNextNeighbor(u,w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getNumOfVertex(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isVisited[i])&#123;</span><br><span class="line">                bfs(isVisited,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到第一个邻接结点的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFirstNeighbor</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexList.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[index][i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据前一个邻接结点的下标获取下一个邻接结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNextNeighbor</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = v2 + <span class="number">1</span>; i &lt; vertexList.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[v1][i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 顶点个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bfs</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="comment">//初始化矩阵和vertexList</span></span><br><span class="line">        vertexList = <span class="keyword">new</span> ArrayList&lt;&gt;(n);</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回结点个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumOfVertex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回边的数目</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumOfEdges</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numOfEdges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回下标所对应的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getVertexByIndex</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.get(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显式邻接矩阵</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGraph</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(edge));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回两个顶点之间的权值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入顶点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vertex 顶点名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">insertVertex</span><span class="params">(String vertex)</span></span>&#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加边</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1 第一个顶点的下标 (第几个顶点)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2 第二个顶点的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight 两个顶点之间的距离</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertEdge</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2,<span class="keyword">int</span> weight)</span></span>&#123;</span><br><span class="line">        edges[v1][v2] = weight;</span><br><span class="line">        edges[v2][v1] = weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="广度优先遍历与深度优先遍历的区别"><a href="#广度优先遍历与深度优先遍历的区别" class="headerlink" title="广度优先遍历与深度优先遍历的区别"></a>广度优先遍历与深度优先遍历的区别</h2><p><img data-src="https://xuemingde.com/pages/image/2022/07/31/114020161lLl.png" alt=""></p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础01：数据结构</title>
    <url>/posts/115VK9R.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="线性结构和非线性结构"><a href="#线性结构和非线性结构" class="headerlink" title="线性结构和非线性结构"></a>线性结构和非线性结构</h3><p>数据结构包括：线性结构和非线性结构</p>
<h4 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h4><p><img data-src="https://xuemingde.com/pages/image/2022/08/02/205234vyW01t.png" alt=""></p>
<h4 id="非线性结构"><a href="#非线性结构" class="headerlink" title="非线性结构"></a>非线性结构</h4><p><img data-src="https://xuemingde.com/pages/image/2022/08/02/205255beJVS8.png" alt=""></p>
<h3 id="稀疏数组和队列"><a href="#稀疏数组和队列" class="headerlink" title="稀疏数组和队列"></a>稀疏数组和队列</h3><h4 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h4><p><img data-src="https://xuemingde.com/pages/image/2022/08/02/210019VxIeCY.png" alt=""></p>
<h5 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h5><p><img data-src="https://xuemingde.com/pages/image/2022/08/02/210151yfViBE.png" alt=""></p>
<h5 id="一个案例"><a href="#一个案例" class="headerlink" title="一个案例"></a>一个案例</h5><p><img data-src="https://xuemingde.com/pages/image/2022/08/02/211449hVbNZ3.png" alt=""></p>
<h5 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h5><p><img data-src="https://xuemingde.com/pages/image/2022/08/02/212140bOHFIE.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/08/02/2125320zRHrg.png" alt=""></p>
<p>稀疏数组是要保存到磁盘中去。当需要时，从磁盘中获取稀疏数组，解析为二维数组，输出为自己想要的数据。</p>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><p><img data-src="https://xuemingde.com/pages/image/2022/08/03/1901023VmxQZ.png" alt=""></p>
<p><strong>原始的二维数组</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpareArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] chassArr1 =<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">        chassArr1[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        chassArr1[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : chassArr1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> anInt : ints) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span> ,anInt);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/08/03/190157fPUSns.png" alt=""></p>
<p><strong>转化为稀疏数组</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpareArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//生产原始二维数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] chassArr1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">        chassArr1[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        chassArr1[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产原始二维数组---&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : chassArr1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> anInt : ints) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>, anInt);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将二维数组 转 稀疏数组</span></span><br><span class="line">        <span class="comment">//1。先遍历二维数组 得到非0的个数</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//        for (int[] ints : chassArr1) &#123;</span></span><br><span class="line"><span class="comment">//            for (int anInt : ints) &#123;</span></span><br><span class="line"><span class="comment">//                if (anInt != 0)&#123;</span></span><br><span class="line"><span class="comment">//                    sum ++;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chassArr1.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; chassArr1.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chassArr1[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建对应的稀疏数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] sparseArr = <span class="keyword">new</span> <span class="keyword">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//设置第一行数据</span></span><br><span class="line">        <span class="comment">//多少行</span></span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">        <span class="comment">//多少列</span></span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">        <span class="comment">//有效数据个数</span></span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录递增的行</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chassArr1.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; chassArr1.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chassArr1[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    count ++;</span><br><span class="line">                    sparseArr[count][<span class="number">0</span>] = i;</span><br><span class="line">                    sparseArr[count][<span class="number">1</span>] = j;</span><br><span class="line">                    sparseArr[count][<span class="number">2</span>] = chassArr1[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;稀疏数组---&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : sparseArr) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> anInt : ints) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>, anInt);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;稀疏数组---&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] ints = sparseArr[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sparseArr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> anInt = ints[j];</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>, anInt);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>打印：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/08/03/192721TfgGyq.png" alt=""></p>
<p><strong>稀疏数组转化为二维数组</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpareArray</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//生产原始二维数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] chassArr1 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>][<span class="number">11</span>];</span><br><span class="line">        chassArr1[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        chassArr1[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产原始二维数组---&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : chassArr1) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> anInt : ints) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>, anInt);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将二维数组 转 稀疏数组</span></span><br><span class="line">        <span class="comment">//1。先遍历二维数组 得到非0的个数</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//        for (int[] ints : chassArr1) &#123;</span></span><br><span class="line"><span class="comment">//            for (int anInt : ints) &#123;</span></span><br><span class="line"><span class="comment">//                if (anInt != 0)&#123;</span></span><br><span class="line"><span class="comment">//                    sum ++;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chassArr1.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; chassArr1.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chassArr1[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建对应的稀疏数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] sparseArr = <span class="keyword">new</span> <span class="keyword">int</span>[sum + <span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//设置第一行数据</span></span><br><span class="line">        <span class="comment">//多少行</span></span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">        <span class="comment">//多少列</span></span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">        <span class="comment">//有效数据个数</span></span><br><span class="line">        sparseArr[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录递增的行</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chassArr1.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; chassArr1.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (chassArr1[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    count ++;</span><br><span class="line">                    sparseArr[count][<span class="number">0</span>] = i;</span><br><span class="line">                    sparseArr[count][<span class="number">1</span>] = j;</span><br><span class="line">                    sparseArr[count][<span class="number">2</span>] = chassArr1[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;稀疏数组---&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : sparseArr) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> anInt : ints) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>, anInt);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;稀疏数组---&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] ints = sparseArr[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sparseArr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> anInt = ints[j];</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>, anInt);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//稀疏数组转化为二维数组</span></span><br><span class="line">        <span class="comment">//1.先读取稀疏数组的第一行。根据第一行数据，创建原始的二维数组</span></span><br><span class="line">        <span class="comment">//2.在读取稀疏数组后几行的数据，并赋予原始二维数组即可</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] inta = sparseArr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[][] chaessArr2 = <span class="keyword">new</span> <span class="keyword">int</span>[inta[<span class="number">0</span>]][inta[<span class="number">1</span>]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; sparseArr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] ints = sparseArr[i];</span><br><span class="line">            chaessArr2[ints[<span class="number">0</span>]][ints[<span class="number">1</span>]] = ints[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//输出恢复后的二维数组</span></span><br><span class="line">        System.out.println(<span class="string">&quot;恢复后的二维数组 ----&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : chaessArr2) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> anInt : ints) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>, anInt);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>打印：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/08/03/193809XDU3By.png" alt=""></p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础02：数据结构</title>
    <url>/posts/1NSAYEA.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="队列的使用场景"><a href="#队列的使用场景" class="headerlink" title="队列的使用场景"></a>队列的使用场景</h3><p><img data-src="https://xuemingde.com/pages/image/2022/08/03/194624FrqCQT.png" alt=""></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><img data-src="https://xuemingde.com/pages/image/2022/08/03/194957pPQxAk.png" alt=""></p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p><img data-src="https://xuemingde.com/pages/image/2022/08/03/195453GCvSFH.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/08/03/195627MDzwYH.png" alt=""></p>
<h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span></span>&#123;</span><br><span class="line">    <span class="comment">//队列最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="comment">//队列尾</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line">    <span class="comment">//队列头</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear;</span><br><span class="line">    <span class="comment">//存放数据的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建队列的构造器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arrMaxSize</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> arrMaxSize)</span></span>&#123;</span><br><span class="line">        maxSize = arrMaxSize;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[arrMaxSize];</span><br><span class="line">        <span class="comment">//指向队列头部，分析出指向的是队列头的前一个位置。即第一个数据的前一个位置</span></span><br><span class="line">        front = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//指向队列尾部数据，即最后一个数据的位置</span></span><br><span class="line">        rear = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断队列是否满了</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == maxSize -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断队列是否为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断队列是否满了</span></span><br><span class="line">        <span class="keyword">if</span> (isFull())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列满了。。。&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[rear++] = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断队列是否空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列是空的&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[front++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显式队列的所有数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断队列是否空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列是空的。。。&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;arr[%d]=%d\n&quot;</span>,i,arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取头部数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断队列是否空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列是空的。。。&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列是空的&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[front + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个数组,最大为3</span></span><br><span class="line">        ArrayQueue queue = <span class="keyword">new</span> ArrayQueue(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">char</span> key = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">boolean</span> boo = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (boo)&#123;</span><br><span class="line">            key = scanner.next().charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">switch</span> (key)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                    queue.showQueue();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;输出一个数&quot;</span>);</span><br><span class="line">                    <span class="keyword">int</span> value = scanner.nextInt();</span><br><span class="line">                    queue.addQueue(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> queue1 = queue.getQueue();</span><br><span class="line">                        System.out.println(<span class="string">&quot;取出的数据是：&quot;</span> +queue1);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> queue1 = queue.headQueue();</span><br><span class="line">                        System.out.println(<span class="string">&quot;头数据是：&quot;</span> +queue1);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        System.out.println(e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    boo = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="存在问题及分析优化"><a href="#存在问题及分析优化" class="headerlink" title="存在问题及分析优化"></a>存在问题及分析优化</h5><ol>
<li>目前数组使用一次就不能再次使用了，没有达到复用的效果。</li>
<li>将这个数组使用算法，改进成一个环形数组。</li>
</ol>
<h4 id="数组模拟环形队列"><a href="#数组模拟环形队列" class="headerlink" title="数组模拟环形队列"></a>数组模拟环形队列</h4><p>对前面的数组模拟队列的优化，充分利用数组，因此将数组看做是一个环形的。（通过<strong>取模的方式来实现</strong>即可）</p>
<h5 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h5><p><img data-src="https://xuemingde.com/pages/image/2022/08/04/195220r0xXyF.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/08/04/194901LEhJgm.png" alt=""></p>
<h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleQueue</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列最大容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="comment">//队列头，指向队列的第一个元素的位置，初始值0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> front;</span><br><span class="line">    <span class="comment">//队列尾，指向最后一个元素的后一个位置，初始值0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rear;</span><br><span class="line">    <span class="comment">//存放数据的数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CircleQueue</span><span class="params">(<span class="keyword">int</span> arrMaxSize)</span></span>&#123;</span><br><span class="line">        maxSize = arrMaxSize;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断队列是否满了</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (rear + <span class="number">1</span>) % maxSize == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断队列是否为空</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rear == front;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断队列是否满了</span></span><br><span class="line">        <span class="keyword">if</span> (isFull())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列满了。。。&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//直接加入</span></span><br><span class="line">        arr[rear] = n;</span><br><span class="line">        <span class="comment">//rear后移,这里必须考虑取模</span></span><br><span class="line">        rear = (rear + <span class="number">1</span>) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断队列是否空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列是空的&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里需要分析出front是指向队列的第一个元素</span></span><br><span class="line">        <span class="comment">//1.先把front对应的值保存到一个临时的变量</span></span><br><span class="line">        <span class="comment">//2将front后移，考虑取模</span></span><br><span class="line">        <span class="comment">//3.将临时变量返回</span></span><br><span class="line">        <span class="keyword">int</span> value = arr[front];</span><br><span class="line">        front = (front + <span class="number">1</span>) % maxSize;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显式队列的所有数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断队列是否空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列是空的。。。&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从front开始遍历，</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = front; i &lt; front + size(); i++) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;arr[%d]=%d\n&quot;</span>,i % maxSize,arr[i % maxSize]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 求出当前队列的有效数据的个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (rear + maxSize - front) % maxSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取头部数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">headQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断队列是否空</span></span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;队列是空的。。。&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;队列是空的&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[front];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试一把</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个数组,最大为3,设置为4</span></span><br><span class="line">    CircleQueue queue = <span class="keyword">new</span> CircleQueue(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">char</span> key = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">boolean</span> boo = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (boo)&#123;</span><br><span class="line">        key = scanner.next().charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">switch</span> (key)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                queue.showQueue();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;输出一个数&quot;</span>);</span><br><span class="line">                <span class="keyword">int</span> value = scanner.nextInt();</span><br><span class="line">                queue.addQueue(value);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;g&#x27;</span>:</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> queue1 = queue.getQueue();</span><br><span class="line">                    System.out.println(<span class="string">&quot;取出的数据是：&quot;</span> +queue1);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> queue1 = queue.headQueue();</span><br><span class="line">                    System.out.println(<span class="string">&quot;头数据是：&quot;</span> +queue1);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    System.out.println(e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">                scanner.close();</span><br><span class="line">                boo = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>GC</tag>
        <tag>数组</tag>
        <tag>变量</tag>
        <tag>Qt</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础03：单向链表</title>
    <url>/posts/1V420XP.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>链表介绍</p>
<p>链表是<strong>有序的</strong>列表，但是他在内存中是存储如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/08/08/195746Lpx3YG.png" alt=""></p>
<blockquote>
<p>分为带头节点的链表和 不带头节点的链表</p>
<p>根据实际需求确定</p>
</blockquote>
<p><img data-src="https://xuemingde.com/pages/image/2022/08/08/2007566E83CW.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/08/08/200700pNYFGl.png" alt=""></p>
<h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><p><img data-src="https://xuemingde.com/pages/image/2022/08/08/200909BkF6i4.png" alt=""></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h3><h4 id="第一种，顺序添加"><a href="#第一种，顺序添加" class="headerlink" title="第一种，顺序添加"></a>第一种，顺序添加</h4><p><img data-src="https://xuemingde.com/pages/image/2022/08/08/210705SatuKz.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单项链表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：XMD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 8.8.22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先创建节点</span></span><br><span class="line">        HeroNode heroNode1 = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        HeroNode heroNode2 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        HeroNode heroNode3 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        HeroNode heroNode4 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>, <span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建链表</span></span><br><span class="line">        SingleLinkedList singleLinkedList = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line">        singleLinkedList.add(heroNode1);</span><br><span class="line">        singleLinkedList.add(heroNode2);</span><br><span class="line">        singleLinkedList.add(heroNode3);</span><br><span class="line">        singleLinkedList.add(heroNode4);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//显式</span></span><br><span class="line">        singleLinkedList.list();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义SingleLinkedList管理我们的英雄</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先初始化一个头节点，头节点不要动，不存放具体数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode head = <span class="keyword">new</span> HeroNode(<span class="number">0</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 思路，当不考虑编号顺序时</span></span><br><span class="line"><span class="comment">     * 1.找到当前链表的最后节点</span></span><br><span class="line"><span class="comment">     * 2.将最后这个节点的next指向新的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heroNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode heroNode)</span></span>&#123;</span><br><span class="line">        <span class="comment">//因为head节点不能动，因此我们需要一个辅助变量temp</span></span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="comment">//遍历链表，找到最后</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//找到链表的最后</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果没有找到，将temp后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当退出while循环时，temp就指向了链表的最后</span></span><br><span class="line">        <span class="comment">//将最后的结点的next指向新的节点</span></span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显式链表（遍历）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为头节点不能动，因为我们需要一个辅助变量来遍历</span></span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//判断是否到链表的最后</span></span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出结点信息</span></span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            <span class="comment">//将节点后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义heroNode,每个heroNode对象就是一个节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span> HeroNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name, String nickname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;no=&quot;</span> + no + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;, nickname=&quot;</span> + nickname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印信息</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="attribute">no</span>=1, <span class="attribute">name</span>=宋江, <span class="attribute">nickname</span>=及时雨</span><br><span class="line"></span><br><span class="line"><span class="attribute">no</span>=4, <span class="attribute">name</span>=林冲, <span class="attribute">nickname</span>=豹子头</span><br><span class="line"></span><br><span class="line"><span class="attribute">no</span>=2, <span class="attribute">name</span>=卢俊义, <span class="attribute">nickname</span>=玉麒麟</span><br><span class="line"></span><br><span class="line"><span class="attribute">no</span>=3, <span class="attribute">name</span>=吴用, <span class="attribute">nickname</span>=智多星</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面代码是直接添加到链表尾部， 是根据插入顺序而排序，不会根据序号排序。如果插入顺序改变，打印的顺序就会改变。</p>
</blockquote>
<h4 id="第二种，乱序插入"><a href="#第二种，乱序插入" class="headerlink" title="第二种，乱序插入"></a>第二种，乱序插入</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单项链表</span></span><br><span class="line"><span class="comment"> * 直接添加到链表尾部</span></span><br><span class="line"><span class="comment"> * 是根据插入顺序而排序，不会根据序号排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 8.8.22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先创建节点</span></span><br><span class="line">        HeroNode heroNode1 = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        HeroNode heroNode2 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        HeroNode heroNode3 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        HeroNode heroNode4 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>, <span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建链表</span></span><br><span class="line">        SingleLinkedList singleLinkedList = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line"><span class="comment">//        singleLinkedList.add(heroNode1);</span></span><br><span class="line"><span class="comment">//        singleLinkedList.add(heroNode2);</span></span><br><span class="line"><span class="comment">//        singleLinkedList.add(heroNode3);</span></span><br><span class="line"><span class="comment">//        singleLinkedList.add(heroNode4);</span></span><br><span class="line"></span><br><span class="line">        singleLinkedList.addByOrder(heroNode1);</span><br><span class="line">        singleLinkedList.addByOrder(heroNode4);</span><br><span class="line">        singleLinkedList.addByOrder(heroNode2);</span><br><span class="line">        singleLinkedList.addByOrder(heroNode3);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//显式</span></span><br><span class="line">        singleLinkedList.list();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义SingleLinkedList管理我们的英雄</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先初始化一个头节点，头节点不要动，不存放具体数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode head = <span class="keyword">new</span> HeroNode(<span class="number">0</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第一种添加方式</span></span><br><span class="line"><span class="comment">     * 思路，当不考虑编号顺序时</span></span><br><span class="line"><span class="comment">     * 1.找到当前链表的最后节点</span></span><br><span class="line"><span class="comment">     * 2.将最后这个节点的next指向新的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heroNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode heroNode)</span></span>&#123;</span><br><span class="line">        <span class="comment">//因为head节点不能动，因此我们需要一个辅助变量temp</span></span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="comment">//遍历链表，找到最后</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//找到链表的最后</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果没有找到，将temp后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当退出while循环时，temp就指向了链表的最后</span></span><br><span class="line">        <span class="comment">//将最后的结点的next指向新的节点</span></span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第二种添加方式，根据排名将英雄插入指定位置</span></span><br><span class="line"><span class="comment">     * 如果有这个排名，则添加失败，并给出提示</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heroNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(HeroNode heroNode)</span></span>&#123;</span><br><span class="line">        <span class="comment">//因为head节点不能动，因此我们需要一个辅助变量temp</span></span><br><span class="line">        <span class="comment">//因为单链表，因为我们找的temp是位于添加位置的前一个节点，是否插入不了</span></span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="comment">//标志添加的编号是否存在，默认为false</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//说明到链表的最后了</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//位置找到，就在temp的后面插入</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next.no &gt; heroNode.no)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no)&#123;</span><br><span class="line">                <span class="comment">//添加的节点已经存在</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//后移动</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;节点已经存在&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            heroNode.next = temp.next;</span><br><span class="line">            temp.next = heroNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显式链表（遍历）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为头节点不能动，因为我们需要一个辅助变量来遍历</span></span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//判断是否到链表的最后</span></span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出结点信息</span></span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            <span class="comment">//将节点后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义heroNode,每个heroNode对象就是一个节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span> HeroNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name, String nickname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;no=&quot;</span> + no + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;, nickname=&quot;</span> + nickname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="attribute">no</span>=1, <span class="attribute">name</span>=宋江, <span class="attribute">nickname</span>=及时雨</span><br><span class="line"><span class="attribute">no</span>=2, <span class="attribute">name</span>=卢俊义, <span class="attribute">nickname</span>=玉麒麟</span><br><span class="line"><span class="attribute">no</span>=3, <span class="attribute">name</span>=吴用, <span class="attribute">nickname</span>=智多星</span><br><span class="line"><span class="attribute">no</span>=4, <span class="attribute">name</span>=林冲, <span class="attribute">nickname</span>=豹子头</span><br></pre></td></tr></table></figure>
<h3 id="修改链表数据"><a href="#修改链表数据" class="headerlink" title="修改链表数据"></a>修改链表数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.algorithm.linkedlist;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单项链表</span></span><br><span class="line"><span class="comment"> * 直接添加到链表尾部</span></span><br><span class="line"><span class="comment"> * 是根据插入顺序而排序，不会根据序号排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 8.8.22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先创建节点</span></span><br><span class="line">        HeroNode heroNode1 = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        HeroNode heroNode2 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        HeroNode heroNode3 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        HeroNode heroNode4 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>, <span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建链表</span></span><br><span class="line">        SingleLinkedList singleLinkedList = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line"><span class="comment">//        singleLinkedList.add(heroNode1);</span></span><br><span class="line"><span class="comment">//        singleLinkedList.add(heroNode2);</span></span><br><span class="line"><span class="comment">//        singleLinkedList.add(heroNode3);</span></span><br><span class="line"><span class="comment">//        singleLinkedList.add(heroNode4);</span></span><br><span class="line"></span><br><span class="line">        singleLinkedList.addByOrder(heroNode1);</span><br><span class="line">        singleLinkedList.addByOrder(heroNode4);</span><br><span class="line">        singleLinkedList.addByOrder(heroNode2);</span><br><span class="line">        singleLinkedList.addByOrder(heroNode2);</span><br><span class="line">        singleLinkedList.addByOrder(heroNode3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//显式</span></span><br><span class="line">        singleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        HeroNode newHeroNode4 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">&quot;小炉子&quot;</span>, <span class="string">&quot;玉观音&quot;</span>);</span><br><span class="line">        singleLinkedList.update(newHeroNode4);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        singleLinkedList.list();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义SingleLinkedList管理我们的英雄</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先初始化一个头节点，头节点不要动，不存放具体数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode head = <span class="keyword">new</span> HeroNode(<span class="number">0</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第一种添加方式</span></span><br><span class="line"><span class="comment">     * 思路，当不考虑编号顺序时</span></span><br><span class="line"><span class="comment">     * 1.找到当前链表的最后节点</span></span><br><span class="line"><span class="comment">     * 2.将最后这个节点的next指向新的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heroNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode heroNode)</span></span>&#123;</span><br><span class="line">        <span class="comment">//因为head节点不能动，因此我们需要一个辅助变量temp</span></span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="comment">//遍历链表，找到最后</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//找到链表的最后</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果没有找到，将temp后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当退出while循环时，temp就指向了链表的最后</span></span><br><span class="line">        <span class="comment">//将最后的结点的next指向新的节点</span></span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第二种添加方式，根据排名将英雄插入指定位置</span></span><br><span class="line"><span class="comment">     * 如果有这个排名，则添加失败，并给出提示</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heroNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(HeroNode heroNode)</span></span>&#123;</span><br><span class="line">        <span class="comment">//因为head节点不能动，因此我们需要一个辅助变量temp</span></span><br><span class="line">        <span class="comment">//因为单链表，因为我们找的temp是位于添加位置的前一个节点，是否插入不了</span></span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="comment">//标志添加的编号是否存在，默认为false</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//说明到链表的最后了</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//位置找到，就在temp的后面插入</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next.no &gt; heroNode.no)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no)&#123;</span><br><span class="line">                <span class="comment">//添加的节点已经存在</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//后移动</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;节点已经存在&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            heroNode.next = temp.next;</span><br><span class="line">            temp.next = heroNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改结点信息，根据no编号修改，no不能修改</span></span><br><span class="line"><span class="comment">     * 说明</span></span><br><span class="line"><span class="comment">     * 1.根据newHeroNode的no来修改即可</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newHeroNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">update</span><span class="params">(HeroNode newHeroNode)</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//已经遍历完</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.no == newHeroNode.no)&#123;</span><br><span class="line">                <span class="comment">//找到</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据flag判断是否找到</span></span><br><span class="line">        <span class="keyword">if</span> (flag)&#123;</span><br><span class="line">            temp.name = newHeroNode.name;</span><br><span class="line">            temp.nickname = newHeroNode.nickname;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有找到&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显式链表（遍历）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为头节点不能动，因为我们需要一个辅助变量来遍历</span></span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//判断是否到链表的最后</span></span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出结点信息</span></span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            <span class="comment">//将节点后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义heroNode,每个heroNode对象就是一个节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span> HeroNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name, String nickname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;no=&quot;</span> + no + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;, nickname=&quot;</span> + nickname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="attribute">no</span>=1, <span class="attribute">name</span>=宋江, <span class="attribute">nickname</span>=及时雨</span><br><span class="line"><span class="attribute">no</span>=2, <span class="attribute">name</span>=卢俊义, <span class="attribute">nickname</span>=玉麒麟</span><br><span class="line"><span class="attribute">no</span>=3, <span class="attribute">name</span>=吴用, <span class="attribute">nickname</span>=智多星</span><br><span class="line"><span class="attribute">no</span>=4, <span class="attribute">name</span>=林冲, <span class="attribute">nickname</span>=豹子头</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class="line"><span class="attribute">no</span>=1, <span class="attribute">name</span>=宋江, <span class="attribute">nickname</span>=及时雨</span><br><span class="line"><span class="attribute">no</span>=2, <span class="attribute">name</span>=小炉子, <span class="attribute">nickname</span>=玉观音</span><br><span class="line"><span class="attribute">no</span>=3, <span class="attribute">name</span>=吴用, <span class="attribute">nickname</span>=智多星</span><br><span class="line"><span class="attribute">no</span>=4, <span class="attribute">name</span>=林冲, <span class="attribute">nickname</span>=豹子头</span><br></pre></td></tr></table></figure>
<h3 id="删除结点"><a href="#删除结点" class="headerlink" title="删除结点"></a>删除结点</h3><p><img data-src="https://xuemingde.com/pages/image/2022/08/10/211000QuH5Sg.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.algorithm.linkedlist;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单项链表</span></span><br><span class="line"><span class="comment"> * 直接添加到链表尾部</span></span><br><span class="line"><span class="comment"> * 是根据插入顺序而排序，不会根据序号排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：XMD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 8.8.22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先创建节点</span></span><br><span class="line">        HeroNode heroNode1 = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        HeroNode heroNode2 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        HeroNode heroNode3 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        HeroNode heroNode4 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>, <span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建链表</span></span><br><span class="line">        SingleLinkedList singleLinkedList = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line"><span class="comment">//        singleLinkedList.add(heroNode1);</span></span><br><span class="line"><span class="comment">//        singleLinkedList.add(heroNode2);</span></span><br><span class="line"><span class="comment">//        singleLinkedList.add(heroNode3);</span></span><br><span class="line"><span class="comment">//        singleLinkedList.add(heroNode4);</span></span><br><span class="line"></span><br><span class="line">        singleLinkedList.addByOrder(heroNode1);</span><br><span class="line">        singleLinkedList.addByOrder(heroNode4);</span><br><span class="line">        singleLinkedList.addByOrder(heroNode2);</span><br><span class="line">        singleLinkedList.addByOrder(heroNode2);</span><br><span class="line">        singleLinkedList.addByOrder(heroNode3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//显式</span></span><br><span class="line">        singleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        HeroNode newHeroNode4 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">&quot;小炉子&quot;</span>, <span class="string">&quot;玉观音&quot;</span>);</span><br><span class="line">        singleLinkedList.update(newHeroNode4);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;-&quot;</span>);</span><br><span class="line"></span><br><span class="line">        singleLinkedList.list();</span><br><span class="line">        System.out.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;-&quot;</span>);</span><br><span class="line"></span><br><span class="line">        singleLinkedList.delete(<span class="number">1</span>);</span><br><span class="line">        singleLinkedList.delete(<span class="number">3</span>);</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义SingleLinkedList管理我们的英雄</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先初始化一个头节点，头节点不要动，不存放具体数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode head = <span class="keyword">new</span> HeroNode(<span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第一种添加方式</span></span><br><span class="line"><span class="comment">     * 思路，当不考虑编号顺序时</span></span><br><span class="line"><span class="comment">     * 1.找到当前链表的最后节点</span></span><br><span class="line"><span class="comment">     * 2.将最后这个节点的next指向新的节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heroNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//因为head节点不能动，因此我们需要一个辅助变量temp</span></span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="comment">//遍历链表，找到最后</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//找到链表的最后</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果没有找到，将temp后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当退出while循环时，temp就指向了链表的最后</span></span><br><span class="line">        <span class="comment">//将最后的结点的next指向新的节点</span></span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第二种添加方式，根据排名将英雄插入指定位置</span></span><br><span class="line"><span class="comment">     * 如果有这个排名，则添加失败，并给出提示</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heroNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//因为head节点不能动，因此我们需要一个辅助变量temp</span></span><br><span class="line">        <span class="comment">//因为单链表，因为我们找的temp是位于添加位置的前一个节点，是否插入不了</span></span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="comment">//标志添加的编号是否存在，默认为false</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//说明到链表的最后了</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//位置找到，就在temp的后面插入</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next.no &gt; heroNode.no) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;</span><br><span class="line">                <span class="comment">//添加的节点已经存在</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//后移动</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;节点已经存在&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            heroNode.next = temp.next;</span><br><span class="line">            temp.next = heroNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改结点信息，根据no编号修改，no不能修改</span></span><br><span class="line"><span class="comment">     * 说明</span></span><br><span class="line"><span class="comment">     * 1.根据newHeroNode的no来修改即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newHeroNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode newHeroNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//已经遍历完</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.no == newHeroNode.no) &#123;</span><br><span class="line">                <span class="comment">//找到</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据flag判断是否找到</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.name = newHeroNode.name;</span><br><span class="line">            temp.nickname = newHeroNode.nickname;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有找到&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除节点</span></span><br><span class="line"><span class="comment">     * 1。head不能动，因此我们需要一个temp辅助节点找到需要删除的前一个节点</span></span><br><span class="line"><span class="comment">     * 2.说用我们在比较时，是temp。next.no 和需要删除的节点的no比较</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="keyword">boolean</span> boo = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//已经到最后</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (temp.next.no == no) &#123;</span><br><span class="line">                <span class="comment">//找到需要删除的前一个节点</span></span><br><span class="line">                boo = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (boo) &#123;</span><br><span class="line">            temp.next = temp.next.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有找到这个节点&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显式链表（遍历）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为头节点不能动，因为我们需要一个辅助变量来遍历</span></span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//判断是否到链表的最后</span></span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出结点信息</span></span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            <span class="comment">//将节点后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义heroNode,每个heroNode对象就是一个节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span> HeroNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name, String nickname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;no=&quot;</span> + no + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;, nickname=&quot;</span> + nickname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">节点已经存在</span><br><span class="line"><span class="attribute">no</span>=1, <span class="attribute">name</span>=宋江, <span class="attribute">nickname</span>=及时雨</span><br><span class="line"><span class="attribute">no</span>=2, <span class="attribute">name</span>=卢俊义, <span class="attribute">nickname</span>=玉麒麟</span><br><span class="line"><span class="attribute">no</span>=3, <span class="attribute">name</span>=吴用, <span class="attribute">nickname</span>=智多星</span><br><span class="line"><span class="attribute">no</span>=4, <span class="attribute">name</span>=林冲, <span class="attribute">nickname</span>=豹子头</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;-</span><br><span class="line"><span class="attribute">no</span>=1, <span class="attribute">name</span>=宋江, <span class="attribute">nickname</span>=及时雨</span><br><span class="line"><span class="attribute">no</span>=2, <span class="attribute">name</span>=小炉子, <span class="attribute">nickname</span>=玉观音</span><br><span class="line"><span class="attribute">no</span>=3, <span class="attribute">name</span>=吴用, <span class="attribute">nickname</span>=智多星</span><br><span class="line"><span class="attribute">no</span>=4, <span class="attribute">name</span>=林冲, <span class="attribute">nickname</span>=豹子头</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;-</span><br><span class="line"><span class="attribute">no</span>=2, <span class="attribute">name</span>=小炉子, <span class="attribute">nickname</span>=玉观音</span><br><span class="line"><span class="attribute">no</span>=4, <span class="attribute">name</span>=林冲, <span class="attribute">nickname</span>=豹子头</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>内存</tag>
        <tag>变量</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础04：单链表面试题</title>
    <url>/posts/1KK9G1G.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>单链表几个面试题  </p>
<h3 id="求单链表中有效节点个数"><a href="#求单链表中有效节点个数" class="headerlink" title="求单链表中有效节点个数"></a>求单链表中有效节点个数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.algorithm.linkedlist;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单项链表</span></span><br><span class="line"><span class="comment"> * 直接添加到链表尾部</span></span><br><span class="line"><span class="comment"> * 是根据插入顺序而排序，不会根据序号排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：XMD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 8.8.22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先创建节点</span></span><br><span class="line">        HeroNode heroNode1 = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        HeroNode heroNode2 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        HeroNode heroNode3 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        HeroNode heroNode4 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>, <span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建链表</span></span><br><span class="line">        SingleLinkedList singleLinkedList = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line"><span class="comment">//        singleLinkedList.add(heroNode1);</span></span><br><span class="line"><span class="comment">//        singleLinkedList.add(heroNode2);</span></span><br><span class="line"><span class="comment">//        singleLinkedList.add(heroNode3);</span></span><br><span class="line"><span class="comment">//        singleLinkedList.add(heroNode4);</span></span><br><span class="line"></span><br><span class="line">        singleLinkedList.addByOrder(heroNode1);</span><br><span class="line">        singleLinkedList.addByOrder(heroNode4);</span><br><span class="line">        singleLinkedList.addByOrder(heroNode2);</span><br><span class="line">        singleLinkedList.addByOrder(heroNode2);</span><br><span class="line">        singleLinkedList.addByOrder(heroNode3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//显式</span></span><br><span class="line">        singleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        HeroNode newHeroNode4 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">&quot;小炉子&quot;</span>, <span class="string">&quot;玉观音&quot;</span>);</span><br><span class="line">        singleLinkedList.update(newHeroNode4);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        singleLinkedList.list();</span><br><span class="line">        System.out.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        singleLinkedList.delete(<span class="number">2</span>);</span><br><span class="line">        singleLinkedList.delete(<span class="number">4</span>);</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> length = getLength(singleLinkedList.getHead());</span><br><span class="line">        System.out.println(length);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法，获取单链表的节点个数（如果是待头节点的链表，需求不需要统计）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(HeroNode heroNode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (heroNode.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//说明为空链表</span></span><br><span class="line">            <span class="keyword">return</span> length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里没有统计头节点</span></span><br><span class="line">        HeroNode cur = heroNode.next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义SingleLinkedList管理我们的英雄</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先初始化一个头节点，头节点不要动，不存放具体数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode head = <span class="keyword">new</span> HeroNode(<span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第一种添加方式</span></span><br><span class="line"><span class="comment">     * 思路，当不考虑编号顺序时</span></span><br><span class="line"><span class="comment">     * 1.找到当前链表的最后节点</span></span><br><span class="line"><span class="comment">     * 2.将最后这个节点的next指向新的节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heroNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//因为head节点不能动，因此我们需要一个辅助变量temp</span></span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="comment">//遍历链表，找到最后</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//找到链表的最后</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果没有找到，将temp后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当退出while循环时，temp就指向了链表的最后</span></span><br><span class="line">        <span class="comment">//将最后的结点的next指向新的节点</span></span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第二种添加方式，根据排名将英雄插入指定位置</span></span><br><span class="line"><span class="comment">     * 如果有这个排名，则添加失败，并给出提示</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heroNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//因为head节点不能动，因此我们需要一个辅助变量temp</span></span><br><span class="line">        <span class="comment">//因为单链表，因为我们找的temp是位于添加位置的前一个节点，是否插入不了</span></span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="comment">//标志添加的编号是否存在，默认为false</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//说明到链表的最后了</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//位置找到，就在temp的后面插入</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next.no &gt; heroNode.no) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;</span><br><span class="line">                <span class="comment">//添加的节点已经存在</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//后移动</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;节点已经存在&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            heroNode.next = temp.next;</span><br><span class="line">            temp.next = heroNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改结点信息，根据no编号修改，no不能修改</span></span><br><span class="line"><span class="comment">     * 说明</span></span><br><span class="line"><span class="comment">     * 1.根据newHeroNode的no来修改即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newHeroNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode newHeroNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//已经遍历完</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.no == newHeroNode.no) &#123;</span><br><span class="line">                <span class="comment">//找到</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据flag判断是否找到</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.name = newHeroNode.name;</span><br><span class="line">            temp.nickname = newHeroNode.nickname;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有找到&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除节点</span></span><br><span class="line"><span class="comment">     * 1。head不能动，因此我们需要一个temp辅助节点找到需要删除的前一个节点</span></span><br><span class="line"><span class="comment">     * 2.说用我们在比较时，是temp。next.no 和需要删除的节点的no比较</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="keyword">boolean</span> boo = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//已经到最后</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (temp.next.no == no) &#123;</span><br><span class="line">                <span class="comment">//找到需要删除的前一个节点</span></span><br><span class="line">                boo = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (boo) &#123;</span><br><span class="line">            temp.next = temp.next.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有找到这个节点&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显式链表（遍历）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为头节点不能动，因为我们需要一个辅助变量来遍历</span></span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//判断是否到链表的最后</span></span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出结点信息</span></span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            <span class="comment">//将节点后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义heroNode,每个heroNode对象就是一个节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span> HeroNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name, String nickname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;no=&quot;</span> + no + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;, nickname=&quot;</span> + nickname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="查找单链表中的倒数第K个结点"><a href="#查找单链表中的倒数第K个结点" class="headerlink" title="查找单链表中的倒数第K个结点"></a>查找单链表中的倒数第K个结点</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.algorithm.linkedlist;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单项链表</span></span><br><span class="line"><span class="comment"> * 直接添加到链表尾部</span></span><br><span class="line"><span class="comment"> * 是根据插入顺序而排序，不会根据序号排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：XMD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 8.8.22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先创建节点</span></span><br><span class="line">        HeroNode heroNode1 = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        HeroNode heroNode2 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        HeroNode heroNode3 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        HeroNode heroNode4 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>, <span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建链表</span></span><br><span class="line">        SingleLinkedList singleLinkedList = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line"><span class="comment">//        singleLinkedList.add(heroNode1);</span></span><br><span class="line"><span class="comment">//        singleLinkedList.add(heroNode2);</span></span><br><span class="line"><span class="comment">//        singleLinkedList.add(heroNode3);</span></span><br><span class="line"><span class="comment">//        singleLinkedList.add(heroNode4);</span></span><br><span class="line"></span><br><span class="line">        singleLinkedList.addByOrder(heroNode1);</span><br><span class="line">        singleLinkedList.addByOrder(heroNode4);</span><br><span class="line">        singleLinkedList.addByOrder(heroNode2);</span><br><span class="line">        singleLinkedList.addByOrder(heroNode2);</span><br><span class="line">        singleLinkedList.addByOrder(heroNode3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//显式</span></span><br><span class="line">        singleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        HeroNode newHeroNode4 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">&quot;小炉子&quot;</span>, <span class="string">&quot;玉观音&quot;</span>);</span><br><span class="line">        singleLinkedList.update(newHeroNode4);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        singleLinkedList.list();</span><br><span class="line">        System.out.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        singleLinkedList.delete(2);</span></span><br><span class="line"><span class="comment">//        singleLinkedList.delete(4);</span></span><br><span class="line"><span class="comment">//        singleLinkedList.list();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;);</span></span><br><span class="line">        <span class="keyword">int</span> length = getLength(singleLinkedList.getHead());</span><br><span class="line">        System.out.println(length);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>);</span><br><span class="line">        HeroNode heroNode = findHeroNodeByIndex(singleLinkedList.getHead(), <span class="number">3</span>);</span><br><span class="line">        System.out.println(heroNode);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法，获取单链表的节点个数（如果是待头节点的链表，需求不需要统计）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(HeroNode heroNode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (heroNode.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//说明为空链表</span></span><br><span class="line">            <span class="keyword">return</span> length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里没有统计头节点</span></span><br><span class="line">        HeroNode cur = heroNode.next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找单链表中的倒数第K个结点【新浪面试题】</span></span><br><span class="line"><span class="comment">     * 思路</span></span><br><span class="line"><span class="comment">     * 1，编写一个方法，接收head节点，同时接收一个index</span></span><br><span class="line"><span class="comment">     * 2.index表示是倒数第index个结点</span></span><br><span class="line"><span class="comment">     * 3.先把链表从头到尾遍历，得到链表的总长度</span></span><br><span class="line"><span class="comment">     * 4.得到size后，我们从链表的第一个开始遍历（size-index）个，就可以得到</span></span><br><span class="line"><span class="comment">     * 5.如果找到，则返回节点，否则返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HeroNode <span class="title">findHeroNodeByIndex</span><span class="params">(HeroNode head,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//没有找到</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//链表的长度</span></span><br><span class="line">        <span class="keyword">int</span> size = getLength(head);</span><br><span class="line">        <span class="comment">//如果index等于0，或者index的长度大于链表的长度，就返回null</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt;= <span class="number">0</span> || index &gt; size)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义辅助变量</span></span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - index; i++) &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义SingleLinkedList管理我们的英雄</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先初始化一个头节点，头节点不要动，不存放具体数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode head = <span class="keyword">new</span> HeroNode(<span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第一种添加方式</span></span><br><span class="line"><span class="comment">     * 思路，当不考虑编号顺序时</span></span><br><span class="line"><span class="comment">     * 1.找到当前链表的最后节点</span></span><br><span class="line"><span class="comment">     * 2.将最后这个节点的next指向新的节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heroNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//因为head节点不能动，因此我们需要一个辅助变量temp</span></span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="comment">//遍历链表，找到最后</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//找到链表的最后</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果没有找到，将temp后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当退出while循环时，temp就指向了链表的最后</span></span><br><span class="line">        <span class="comment">//将最后的结点的next指向新的节点</span></span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第二种添加方式，根据排名将英雄插入指定位置</span></span><br><span class="line"><span class="comment">     * 如果有这个排名，则添加失败，并给出提示</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heroNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//因为head节点不能动，因此我们需要一个辅助变量temp</span></span><br><span class="line">        <span class="comment">//因为单链表，因为我们找的temp是位于添加位置的前一个节点，是否插入不了</span></span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="comment">//标志添加的编号是否存在，默认为false</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//说明到链表的最后了</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//位置找到，就在temp的后面插入</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next.no &gt; heroNode.no) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;</span><br><span class="line">                <span class="comment">//添加的节点已经存在</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//后移动</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;节点已经存在&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            heroNode.next = temp.next;</span><br><span class="line">            temp.next = heroNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改结点信息，根据no编号修改，no不能修改</span></span><br><span class="line"><span class="comment">     * 说明</span></span><br><span class="line"><span class="comment">     * 1.根据newHeroNode的no来修改即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newHeroNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode newHeroNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//已经遍历完</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.no == newHeroNode.no) &#123;</span><br><span class="line">                <span class="comment">//找到</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据flag判断是否找到</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.name = newHeroNode.name;</span><br><span class="line">            temp.nickname = newHeroNode.nickname;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有找到&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除节点</span></span><br><span class="line"><span class="comment">     * 1。head不能动，因此我们需要一个temp辅助节点找到需要删除的前一个节点</span></span><br><span class="line"><span class="comment">     * 2.说用我们在比较时，是temp。next.no 和需要删除的节点的no比较</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="keyword">boolean</span> boo = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//已经到最后</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (temp.next.no == no) &#123;</span><br><span class="line">                <span class="comment">//找到需要删除的前一个节点</span></span><br><span class="line">                boo = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (boo) &#123;</span><br><span class="line">            temp.next = temp.next.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有找到这个节点&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显式链表（遍历）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为头节点不能动，因为我们需要一个辅助变量来遍历</span></span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//判断是否到链表的最后</span></span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出结点信息</span></span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            <span class="comment">//将节点后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义heroNode,每个heroNode对象就是一个节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span> HeroNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name, String nickname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;no=&quot;</span> + no + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;, nickname=&quot;</span> + nickname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="但链表的反转"><a href="#但链表的反转" class="headerlink" title="但链表的反转"></a>但链表的反转</h3><p><img data-src="https://xuemingde.com/pages/image/2022/08/10/221541xqbqu6.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.algorithm.linkedlist;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单项链表</span></span><br><span class="line"><span class="comment"> * 直接添加到链表尾部</span></span><br><span class="line"><span class="comment"> * 是根据插入顺序而排序，不会根据序号排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：XMD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 8.8.22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先创建节点</span></span><br><span class="line">        HeroNode heroNode1 = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        HeroNode heroNode2 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        HeroNode heroNode3 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        HeroNode heroNode4 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>, <span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建链表</span></span><br><span class="line">        SingleLinkedList singleLinkedList = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line"><span class="comment">//        singleLinkedList.add(heroNode1);</span></span><br><span class="line"><span class="comment">//        singleLinkedList.add(heroNode2);</span></span><br><span class="line"><span class="comment">//        singleLinkedList.add(heroNode3);</span></span><br><span class="line"><span class="comment">//        singleLinkedList.add(heroNode4);</span></span><br><span class="line"></span><br><span class="line">        singleLinkedList.addByOrder(heroNode1);</span><br><span class="line">        singleLinkedList.addByOrder(heroNode4);</span><br><span class="line">        singleLinkedList.addByOrder(heroNode2);</span><br><span class="line">        singleLinkedList.addByOrder(heroNode2);</span><br><span class="line">        singleLinkedList.addByOrder(heroNode3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//显式</span></span><br><span class="line">        singleLinkedList.list();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        HeroNode newHeroNode4 = new HeroNode(2, &quot;小炉子&quot;, &quot;玉观音&quot;);</span></span><br><span class="line"><span class="comment">//        singleLinkedList.update(newHeroNode4);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        singleLinkedList.list();</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        singleLinkedList.delete(2);</span></span><br><span class="line"><span class="comment">//        singleLinkedList.delete(4);</span></span><br><span class="line"><span class="comment">//        singleLinkedList.list();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;);</span></span><br><span class="line"><span class="comment">//        int length = getLength(singleLinkedList.getHead());</span></span><br><span class="line"><span class="comment">//        System.out.println(length);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;);</span></span><br><span class="line"><span class="comment">//        HeroNode heroNode = findHeroNodeByIndex(singleLinkedList.getHead(), 6);</span></span><br><span class="line"><span class="comment">//        System.out.println(heroNode);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>);</span><br><span class="line">        reversetList(singleLinkedList.getHead());</span><br><span class="line">        singleLinkedList.list();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法，获取单链表的节点个数（如果是待头节点的链表，需求不需要统计）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(HeroNode heroNode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (heroNode.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//说明为空链表</span></span><br><span class="line">            <span class="keyword">return</span> length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里没有统计头节点</span></span><br><span class="line">        HeroNode cur = heroNode.next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将链表反转</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reversetList</span><span class="params">(HeroNode head)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果当前链表为空或者只有一个节点，无需反转</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义一个辅助指针，帮助我们遍历原来的俩链表</span></span><br><span class="line">        HeroNode cur = head.next;</span><br><span class="line">        <span class="comment">//指向当前节点cur的下一个节点</span></span><br><span class="line">        HeroNode next;</span><br><span class="line">        HeroNode  reversetHead = <span class="keyword">new</span> HeroNode(<span class="number">0</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reversetHead的最前端</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//先暂时保存当前节点的下一个节点，因为后面需要使用</span></span><br><span class="line">            next = cur.next;</span><br><span class="line">            <span class="comment">//将cur的下一个节点指向新的链表的最前端</span></span><br><span class="line">            cur.next = reversetHead.next;</span><br><span class="line">            reversetHead.next = cur;</span><br><span class="line">            <span class="comment">//cur后移</span></span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将head.next指向reversetHead.next，实现单链表的反转</span></span><br><span class="line">        head.next = reversetHead.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找单链表中的倒数第K个结点【新浪面试题】</span></span><br><span class="line"><span class="comment">     * 思路</span></span><br><span class="line"><span class="comment">     * 1，编写一个方法，接收head节点，同时接收一个index</span></span><br><span class="line"><span class="comment">     * 2.index表示是倒数第index个结点</span></span><br><span class="line"><span class="comment">     * 3.先把链表从头到尾遍历，得到链表的总长度</span></span><br><span class="line"><span class="comment">     * 4.得到size后，我们从链表的第一个开始遍历（size-index）个，就可以得到</span></span><br><span class="line"><span class="comment">     * 5.如果找到，则返回节点，否则返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HeroNode <span class="title">findHeroNodeByIndex</span><span class="params">(HeroNode head,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//没有找到</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//链表的长度</span></span><br><span class="line">        <span class="keyword">int</span> size = getLength(head);</span><br><span class="line">        <span class="comment">//如果index等于0，或者index的长度大于链表的长度，就返回null</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt;= <span class="number">0</span> || index &gt; size)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义辅助变量</span></span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - index; i++) &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义SingleLinkedList管理我们的英雄</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先初始化一个头节点，头节点不要动，不存放具体数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode head = <span class="keyword">new</span> HeroNode(<span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第一种添加方式</span></span><br><span class="line"><span class="comment">     * 思路，当不考虑编号顺序时</span></span><br><span class="line"><span class="comment">     * 1.找到当前链表的最后节点</span></span><br><span class="line"><span class="comment">     * 2.将最后这个节点的next指向新的节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heroNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//因为head节点不能动，因此我们需要一个辅助变量temp</span></span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="comment">//遍历链表，找到最后</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//找到链表的最后</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果没有找到，将temp后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当退出while循环时，temp就指向了链表的最后</span></span><br><span class="line">        <span class="comment">//将最后的结点的next指向新的节点</span></span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第二种添加方式，根据排名将英雄插入指定位置</span></span><br><span class="line"><span class="comment">     * 如果有这个排名，则添加失败，并给出提示</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heroNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//因为head节点不能动，因此我们需要一个辅助变量temp</span></span><br><span class="line">        <span class="comment">//因为单链表，因为我们找的temp是位于添加位置的前一个节点，是否插入不了</span></span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="comment">//标志添加的编号是否存在，默认为false</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//说明到链表的最后了</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//位置找到，就在temp的后面插入</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next.no &gt; heroNode.no) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;</span><br><span class="line">                <span class="comment">//添加的节点已经存在</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//后移动</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;节点已经存在&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            heroNode.next = temp.next;</span><br><span class="line">            temp.next = heroNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改结点信息，根据no编号修改，no不能修改</span></span><br><span class="line"><span class="comment">     * 说明</span></span><br><span class="line"><span class="comment">     * 1.根据newHeroNode的no来修改即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newHeroNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode newHeroNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//已经遍历完</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.no == newHeroNode.no) &#123;</span><br><span class="line">                <span class="comment">//找到</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据flag判断是否找到</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.name = newHeroNode.name;</span><br><span class="line">            temp.nickname = newHeroNode.nickname;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有找到&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除节点</span></span><br><span class="line"><span class="comment">     * 1。head不能动，因此我们需要一个temp辅助节点找到需要删除的前一个节点</span></span><br><span class="line"><span class="comment">     * 2.说用我们在比较时，是temp。next.no 和需要删除的节点的no比较</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="keyword">boolean</span> boo = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//已经到最后</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (temp.next.no == no) &#123;</span><br><span class="line">                <span class="comment">//找到需要删除的前一个节点</span></span><br><span class="line">                boo = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (boo) &#123;</span><br><span class="line">            temp.next = temp.next.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有找到这个节点&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显式链表（遍历）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为头节点不能动，因为我们需要一个辅助变量来遍历</span></span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//判断是否到链表的最后</span></span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出结点信息</span></span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            <span class="comment">//将节点后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义heroNode,每个heroNode对象就是一个节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span> HeroNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name, String nickname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;no=&quot;</span> + no + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;, nickname=&quot;</span> + nickname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">节点已经存在</span><br><span class="line"><span class="attribute">no</span>=1, <span class="attribute">name</span>=宋江, <span class="attribute">nickname</span>=及时雨</span><br><span class="line"><span class="attribute">no</span>=2, <span class="attribute">name</span>=卢俊义, <span class="attribute">nickname</span>=玉麒麟</span><br><span class="line"><span class="attribute">no</span>=3, <span class="attribute">name</span>=吴用, <span class="attribute">nickname</span>=智多星</span><br><span class="line"><span class="attribute">no</span>=4, <span class="attribute">name</span>=林冲, <span class="attribute">nickname</span>=豹子头</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class="line"><span class="attribute">no</span>=4, <span class="attribute">name</span>=林冲, <span class="attribute">nickname</span>=豹子头</span><br><span class="line"><span class="attribute">no</span>=3, <span class="attribute">name</span>=吴用, <span class="attribute">nickname</span>=智多星</span><br><span class="line"><span class="attribute">no</span>=2, <span class="attribute">name</span>=卢俊义, <span class="attribute">nickname</span>=玉麒麟</span><br><span class="line"><span class="attribute">no</span>=1, <span class="attribute">name</span>=宋江, <span class="attribute">nickname</span>=及时雨</span><br></pre></td></tr></table></figure>
<h3 id="从尾到头打印单链表"><a href="#从尾到头打印单链表" class="headerlink" title="从尾到头打印单链表"></a>从尾到头打印单链表</h3><p><img data-src="https://xuemingde.com/pages/image/2022/08/11/214147TglUE7.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.algorithm.linkedlist;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单项链表</span></span><br><span class="line"><span class="comment"> * 直接添加到链表尾部</span></span><br><span class="line"><span class="comment"> * 是根据插入顺序而排序，不会根据序号排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：XMD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 8.8.22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先创建节点</span></span><br><span class="line">        HeroNode heroNode1 = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        HeroNode heroNode2 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        HeroNode heroNode3 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        HeroNode heroNode4 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>, <span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建链表</span></span><br><span class="line">        SingleLinkedList singleLinkedList = <span class="keyword">new</span> SingleLinkedList();</span><br><span class="line"><span class="comment">//        singleLinkedList.add(heroNode1);</span></span><br><span class="line"><span class="comment">//        singleLinkedList.add(heroNode2);</span></span><br><span class="line"><span class="comment">//        singleLinkedList.add(heroNode3);</span></span><br><span class="line"><span class="comment">//        singleLinkedList.add(heroNode4);</span></span><br><span class="line"></span><br><span class="line">        singleLinkedList.addByOrder(heroNode1);</span><br><span class="line">        singleLinkedList.addByOrder(heroNode4);</span><br><span class="line">        singleLinkedList.addByOrder(heroNode2);</span><br><span class="line">        singleLinkedList.addByOrder(heroNode2);</span><br><span class="line">        singleLinkedList.addByOrder(heroNode3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//显式</span></span><br><span class="line">        singleLinkedList.list();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        HeroNode newHeroNode4 = new HeroNode(2, &quot;小炉子&quot;, &quot;玉观音&quot;);</span></span><br><span class="line"><span class="comment">//        singleLinkedList.update(newHeroNode4);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        singleLinkedList.list();</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        singleLinkedList.delete(2);</span></span><br><span class="line"><span class="comment">//        singleLinkedList.delete(4);</span></span><br><span class="line"><span class="comment">//        singleLinkedList.list();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;);</span></span><br><span class="line"><span class="comment">//        int length = getLength(singleLinkedList.getHead());</span></span><br><span class="line"><span class="comment">//        System.out.println(length);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;);</span></span><br><span class="line"><span class="comment">//        HeroNode heroNode = findHeroNodeByIndex(singleLinkedList.getHead(), 6);</span></span><br><span class="line"><span class="comment">//        System.out.println(heroNode);</span></span><br><span class="line">        System.out.println(<span class="string">&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&quot;</span>);</span><br><span class="line"><span class="comment">//        reversetList(singleLinkedList.getHead());</span></span><br><span class="line"><span class="comment">//        singleLinkedList.list();</span></span><br><span class="line"></span><br><span class="line">        reversetPrint(singleLinkedList.getHead());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 可以利用栈这个数据结构，将各个节点压入到栈中，然后利用栈的先进后出的特点，就能实现逆序打印的效果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reversetPrint</span><span class="params">(HeroNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">        Stack&lt;HeroNode&gt; stack= <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        HeroNode cur = head.next;</span><br><span class="line">        <span class="comment">//将链表的所有节点压入栈</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将栈中的节点打印。pop 出栈</span></span><br><span class="line">        <span class="keyword">while</span> (stack.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法，获取单链表的节点个数（如果是待头节点的链表，需求不需要统计）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getLength</span><span class="params">(HeroNode heroNode)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (heroNode.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//说明为空链表</span></span><br><span class="line">            <span class="keyword">return</span> length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里没有统计头节点</span></span><br><span class="line">        HeroNode cur = heroNode.next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            length++;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将链表反转</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> head</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reversetList</span><span class="params">(HeroNode head)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果当前链表为空或者只有一个节点，无需反转</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义一个辅助指针，帮助我们遍历原来的俩链表</span></span><br><span class="line">        HeroNode cur = head.next;</span><br><span class="line">        <span class="comment">//指向当前节点cur的下一个节点</span></span><br><span class="line">        HeroNode next;</span><br><span class="line">        HeroNode  reversetHead = <span class="keyword">new</span> HeroNode(<span class="number">0</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历原来的链表，每遍历一个节点，就将其取出，并放在新的链表reversetHead的最前端</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//先暂时保存当前节点的下一个节点，因为后面需要使用</span></span><br><span class="line">            next = cur.next;</span><br><span class="line">            <span class="comment">//将cur的下一个节点指向新的链表的最前端</span></span><br><span class="line">            cur.next = reversetHead.next;</span><br><span class="line">            reversetHead.next = cur;</span><br><span class="line">            <span class="comment">//cur后移</span></span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将head.next指向reversetHead.next，实现单链表的反转</span></span><br><span class="line">        head.next = reversetHead.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找单链表中的倒数第K个结点【新浪面试题】</span></span><br><span class="line"><span class="comment">     * 思路</span></span><br><span class="line"><span class="comment">     * 1，编写一个方法，接收head节点，同时接收一个index</span></span><br><span class="line"><span class="comment">     * 2.index表示是倒数第index个结点</span></span><br><span class="line"><span class="comment">     * 3.先把链表从头到尾遍历，得到链表的总长度</span></span><br><span class="line"><span class="comment">     * 4.得到size后，我们从链表的第一个开始遍历（size-index）个，就可以得到</span></span><br><span class="line"><span class="comment">     * 5.如果找到，则返回节点，否则返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HeroNode <span class="title">findHeroNodeByIndex</span><span class="params">(HeroNode head,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//没有找到</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//链表的长度</span></span><br><span class="line">        <span class="keyword">int</span> size = getLength(head);</span><br><span class="line">        <span class="comment">//如果index等于0，或者index的长度大于链表的长度，就返回null</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt;= <span class="number">0</span> || index &gt; size)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义辅助变量</span></span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size - index; i++) &#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义SingleLinkedList管理我们的英雄</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先初始化一个头节点，头节点不要动，不存放具体数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode head = <span class="keyword">new</span> HeroNode(<span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第一种添加方式</span></span><br><span class="line"><span class="comment">     * 思路，当不考虑编号顺序时</span></span><br><span class="line"><span class="comment">     * 1.找到当前链表的最后节点</span></span><br><span class="line"><span class="comment">     * 2.将最后这个节点的next指向新的节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heroNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//因为head节点不能动，因此我们需要一个辅助变量temp</span></span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="comment">//遍历链表，找到最后</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//找到链表的最后</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果没有找到，将temp后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当退出while循环时，temp就指向了链表的最后</span></span><br><span class="line">        <span class="comment">//将最后的结点的next指向新的节点</span></span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 第二种添加方式，根据排名将英雄插入指定位置</span></span><br><span class="line"><span class="comment">     * 如果有这个排名，则添加失败，并给出提示</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heroNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addByOrder</span><span class="params">(HeroNode heroNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//因为head节点不能动，因此我们需要一个辅助变量temp</span></span><br><span class="line">        <span class="comment">//因为单链表，因为我们找的temp是位于添加位置的前一个节点，是否插入不了</span></span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="comment">//标志添加的编号是否存在，默认为false</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//说明到链表的最后了</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//位置找到，就在temp的后面插入</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next.no &gt; heroNode.no) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.next.no == heroNode.no) &#123;</span><br><span class="line">                <span class="comment">//添加的节点已经存在</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//后移动</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;节点已经存在&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            heroNode.next = temp.next;</span><br><span class="line">            temp.next = heroNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改结点信息，根据no编号修改，no不能修改</span></span><br><span class="line"><span class="comment">     * 说明</span></span><br><span class="line"><span class="comment">     * 1.根据newHeroNode的no来修改即可</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newHeroNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode newHeroNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//已经遍历完</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.no == newHeroNode.no) &#123;</span><br><span class="line">                <span class="comment">//找到</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据flag判断是否找到</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.name = newHeroNode.name;</span><br><span class="line">            temp.nickname = newHeroNode.nickname;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有找到&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除节点</span></span><br><span class="line"><span class="comment">     * 1。head不能动，因此我们需要一个temp辅助节点找到需要删除的前一个节点</span></span><br><span class="line"><span class="comment">     * 2.说用我们在比较时，是temp。next.no 和需要删除的节点的no比较</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        HeroNode temp = head;</span><br><span class="line">        <span class="keyword">boolean</span> boo = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//已经到最后</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (temp.next.no == no) &#123;</span><br><span class="line">                <span class="comment">//找到需要删除的前一个节点</span></span><br><span class="line">                boo = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (boo) &#123;</span><br><span class="line">            temp.next = temp.next.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有找到这个节点&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显式链表（遍历）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为头节点不能动，因为我们需要一个辅助变量来遍历</span></span><br><span class="line">        HeroNode temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//判断是否到链表的最后</span></span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出结点信息</span></span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            <span class="comment">//将节点后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义heroNode,每个heroNode对象就是一个节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="keyword">public</span> HeroNode next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name, String nickname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;no=&quot;</span> + no + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;, nickname=&quot;</span> + nickname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="attribute">no</span>=1, <span class="attribute">name</span>=宋江, <span class="attribute">nickname</span>=及时雨</span><br><span class="line"><span class="attribute">no</span>=2, <span class="attribute">name</span>=卢俊义, <span class="attribute">nickname</span>=玉麒麟</span><br><span class="line"><span class="attribute">no</span>=3, <span class="attribute">name</span>=吴用, <span class="attribute">nickname</span>=智多星</span><br><span class="line"><span class="attribute">no</span>=4, <span class="attribute">name</span>=林冲, <span class="attribute">nickname</span>=豹子头</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span><br><span class="line"><span class="attribute">no</span>=4, <span class="attribute">name</span>=林冲, <span class="attribute">nickname</span>=豹子头</span><br><span class="line"><span class="attribute">no</span>=3, <span class="attribute">name</span>=吴用, <span class="attribute">nickname</span>=智多星</span><br><span class="line"><span class="attribute">no</span>=2, <span class="attribute">name</span>=卢俊义, <span class="attribute">nickname</span>=玉麒麟</span><br><span class="line"><span class="attribute">no</span>=1, <span class="attribute">name</span>=宋江, <span class="attribute">nickname</span>=及时雨</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>栈</tag>
        <tag>指针</tag>
        <tag>变量</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础05：双向链表</title>
    <url>/posts/2K0EYDH.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>双向链表的应用实例</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/08/11/221252y5Xw06.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/08/13/112215fDsuEl.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/08/13/100328tY8WKv.png" alt=""></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.algorithm.linkedlist;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TODO</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：XMD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 13.8.22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//测试</span></span><br><span class="line">        <span class="comment">//先创建节点</span></span><br><span class="line">        HeroNode2 heroNode1 = <span class="keyword">new</span> HeroNode2(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>, <span class="string">&quot;及时雨&quot;</span>);</span><br><span class="line">        HeroNode2 heroNode2 = <span class="keyword">new</span> HeroNode2(<span class="number">2</span>, <span class="string">&quot;卢俊义&quot;</span>, <span class="string">&quot;玉麒麟&quot;</span>);</span><br><span class="line">        HeroNode2 heroNode3 = <span class="keyword">new</span> HeroNode2(<span class="number">3</span>, <span class="string">&quot;吴用&quot;</span>, <span class="string">&quot;智多星&quot;</span>);</span><br><span class="line">        HeroNode2 heroNode4 = <span class="keyword">new</span> HeroNode2(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>, <span class="string">&quot;豹子头&quot;</span>);</span><br><span class="line"></span><br><span class="line">        DoubleLinkedList doubleLinkedList = <span class="keyword">new</span> DoubleLinkedList();</span><br><span class="line">        doubleLinkedList.add(heroNode1);</span><br><span class="line">        doubleLinkedList.add(heroNode2);</span><br><span class="line">        doubleLinkedList.add(heroNode3);</span><br><span class="line">        doubleLinkedList.add(heroNode4);</span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HeroNode2 newHeroNode4 = <span class="keyword">new</span> HeroNode2(<span class="number">4</span>, <span class="string">&quot;孙大圣&quot;</span>, <span class="string">&quot;悟空&quot;</span>);</span><br><span class="line">        doubleLinkedList.update(newHeroNode4);</span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line">        doubleLinkedList.delete(<span class="number">3</span>);</span><br><span class="line">        doubleLinkedList.list();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkedList</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 先初始化一个头节点，头节点不要动，不存放具体数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode2 head = <span class="keyword">new</span> HeroNode2(<span class="number">0</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode2 <span class="title">getHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显式链表（遍历）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为头节点不能动，因为我们需要一个辅助变量来遍历</span></span><br><span class="line">        HeroNode2 temp = head.next;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//判断是否到链表的最后</span></span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//输出结点信息</span></span><br><span class="line">            System.out.println(temp);</span><br><span class="line">            <span class="comment">//将节点后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加一个节点到双向链表的最后</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> heroNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(HeroNode2 heroNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//因为head节点不能动，因此我们需要一个辅助变量temp</span></span><br><span class="line">        HeroNode2 temp = head;</span><br><span class="line">        <span class="comment">//遍历链表，找到最后</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//找到链表的最后</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果没有找到，将temp后移</span></span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当退出while循环时，temp就指向了链表的最后</span></span><br><span class="line">        <span class="comment">//形成一个双向；链表</span></span><br><span class="line">        temp.next = heroNode;</span><br><span class="line">        heroNode.pre = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改双向链表的一个节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newHeroNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(HeroNode2 newHeroNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HeroNode2 temp = head.next;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//已经遍历完</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp.no == newHeroNode.no) &#123;</span><br><span class="line">                <span class="comment">//找到</span></span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据flag判断是否找到</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp.name = newHeroNode.name;</span><br><span class="line">            temp.nickname = newHeroNode.nickname;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有找到&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除双向链表的一个节点</span></span><br><span class="line"><span class="comment">     * 1 对于双向链表，我们可以直接找到要删除的节点</span></span><br><span class="line"><span class="comment">     * 2 找到后自我删除即可</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> no</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//辅助变量</span></span><br><span class="line">        HeroNode2 temp = head.next;</span><br><span class="line">        <span class="keyword">boolean</span> boo = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//已经到最后</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (temp.no == no) &#123;</span><br><span class="line">                <span class="comment">//找到需要删除的前一个节点</span></span><br><span class="line">                boo = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (boo) &#123;</span><br><span class="line">            temp.pre.next = temp.next;</span><br><span class="line">            <span class="comment">//不加判断，如果最后一个会揣想那空指针异常</span></span><br><span class="line">            <span class="keyword">if</span> (temp.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">                temp.next.pre = temp.pre;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有找到这个节点&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义heroNode,每个heroNode对象就是一个节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String nickname;</span><br><span class="line">    <span class="comment">//指向后一个节点,默认null</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode2 next;</span><br><span class="line">    <span class="comment">//指向前一个节点,默认null</span></span><br><span class="line">    <span class="keyword">public</span> HeroNode2 pre;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode2</span><span class="params">(<span class="keyword">int</span> no, String name, String nickname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.nickname = nickname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;no=&quot;</span> + no + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;, nickname=&quot;</span> + nickname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>指针</tag>
        <tag>变量</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础06：单向环形链表</title>
    <url>/posts/2N1HMJH.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>单向环形链表应用场景</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/08/13/114236wIibMx.png" alt=""></p>
<h2 id="Josephu问题"><a href="#Josephu问题" class="headerlink" title="Josephu问题"></a>Josephu问题</h2><p><img data-src="https://xuemingde.com/pages/image/2022/08/13/123242vU8n9W.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/08/13/123752CZlCYR.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/08/13/123948KFsizm.png" alt=""></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p><strong>添加和遍历思路</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/08/13/125048nnMQb3.png" alt=""></p>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.algorithm.linkedlist;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 约瑟夫问题</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：XMD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 13.8.22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Josephu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CircleSingleLinkedList list = <span class="keyword">new</span> CircleSingleLinkedList();</span><br><span class="line">        list.addBoy(<span class="number">5</span>);</span><br><span class="line">        list.showBoy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建环形单向链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleSingleLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个first节点，当前没有编号</span></span><br><span class="line">    <span class="keyword">private</span> Boy first = <span class="keyword">new</span> Boy(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加小孩节点，构建成一个环形链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBoy</span><span class="params">(<span class="keyword">int</span> nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对nums判断</span></span><br><span class="line">        <span class="keyword">if</span> (nums &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;nums 值不正确&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//辅助节点。帮助构建环形链表</span></span><br><span class="line">        Boy curBoy = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums; i++) &#123;</span><br><span class="line">            <span class="comment">//根据编号创建小孩节点</span></span><br><span class="line">            Boy boy = <span class="keyword">new</span> Boy(i);</span><br><span class="line">            <span class="comment">//如果是第一个小孩</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                first = boy;</span><br><span class="line">                <span class="comment">//构成一个环</span></span><br><span class="line">                first.setNext(first);</span><br><span class="line">                curBoy = first;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curBoy.setNext(boy);</span><br><span class="line">                boy.setNext(first);</span><br><span class="line">                curBoy = boy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历当前环形链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showBoy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为first不能动，因此我们仍然使用一个辅助指针完成遍历</span></span><br><span class="line">        Boy curBoy = first;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;小孩编号：&quot;</span> + curBoy.getNo());</span><br><span class="line">            <span class="keyword">if</span> (curBoy.getNext() == first) &#123;</span><br><span class="line">                <span class="comment">//说明遍历结束</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curBoy = curBoy.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> Boy next;<span class="comment">//指向下一个节点</span></span><br><span class="line"></span><br><span class="line">    Boy(<span class="keyword">int</span> no) &#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boy <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Boy next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">小孩编号：1</span><br><span class="line">小孩编号：2</span><br><span class="line">小孩编号：3</span><br><span class="line">小孩编号：4</span><br><span class="line">小孩编号：5</span><br></pre></td></tr></table></figure>
<p><strong>出圈顺序的逻辑思路</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/08/13/145234Hq8ixq.png" alt=""></p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.algorithm.linkedlist;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 约瑟夫问题</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：XMD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 13.8.22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Josephu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CircleSingleLinkedList list = <span class="keyword">new</span> CircleSingleLinkedList();</span><br><span class="line">        list.addBoy(<span class="number">125</span>);</span><br><span class="line">        list.showBoy();</span><br><span class="line">        System.out.println(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>);</span><br><span class="line">        list.countBoy(<span class="number">10</span>,<span class="number">20</span>,<span class="number">215</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建环形单向链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleSingleLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个first节点，当前没有编号</span></span><br><span class="line">    <span class="keyword">private</span> Boy first = <span class="keyword">new</span> Boy(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加小孩节点，构建成一个环形链表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBoy</span><span class="params">(<span class="keyword">int</span> nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对nums判断</span></span><br><span class="line">        <span class="keyword">if</span> (nums &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;nums 值不正确&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//辅助节点。帮助构建环形链表</span></span><br><span class="line">        Boy curBoy = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= nums; i++) &#123;</span><br><span class="line">            <span class="comment">//根据编号创建小孩节点</span></span><br><span class="line">            Boy boy = <span class="keyword">new</span> Boy(i);</span><br><span class="line">            <span class="comment">//如果是第一个小孩</span></span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                first = boy;</span><br><span class="line">                <span class="comment">//构成一个环</span></span><br><span class="line">                first.setNext(first);</span><br><span class="line">                curBoy = first;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curBoy.setNext(boy);</span><br><span class="line">                boy.setNext(first);</span><br><span class="line">                curBoy = boy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历当前环形链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showBoy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//链表是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//因为first不能动，因此我们仍然使用一个辅助指针完成遍历</span></span><br><span class="line">        Boy curBoy = first;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;小孩编号：&quot;</span> + curBoy.getNo());</span><br><span class="line">            <span class="keyword">if</span> (curBoy.getNext() == first) &#123;</span><br><span class="line">                <span class="comment">//说明遍历结束</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curBoy = curBoy.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户的输入，计算出小孩出圈的顺序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startNum 从第几个小孩开始数数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> countNum 表示几下</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nums     表示最初有多少个小孩在圈中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countBoy</span><span class="params">(<span class="keyword">int</span> startNum, <span class="keyword">int</span> countNum, <span class="keyword">int</span> nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span> || startNum &lt; <span class="number">1</span> || startNum &gt; nums) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;输入数据有误&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建要给辅助指针帮助完成小孩出圈</span></span><br><span class="line">        Boy helper = first;</span><br><span class="line">        <span class="comment">//创建一个辅助指针helper，事先应该指向环形链表的最后这个节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (helper.getNext() == first) &#123;</span><br><span class="line">                <span class="comment">//说明helper指向最后小孩节点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            helper = helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//小孩报数前，先让first和helper移动k-1次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; startNum - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            first = first.getNext();</span><br><span class="line">            helper = helper.getNext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当小孩报数时，让first和helper指针同时的移动 m-1次，然后出圈</span></span><br><span class="line">        <span class="comment">//这里是一个循环操作，直到圈中只有一个节点</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (helper == first) &#123;</span><br><span class="line">                <span class="comment">//说明圈中只有一个节点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//让first helper 指针同时移动 countNum-1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; countNum - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                first = first.getNext();</span><br><span class="line">                helper = helper.getNext();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//这时first指向的节点 就是要出圈的小孩节点</span></span><br><span class="line">            System.out.println(<span class="string">&quot;小孩&quot;</span> + first.getNo() + <span class="string">&quot;出圈&quot;</span>);</span><br><span class="line"></span><br><span class="line">            first = first.getNext();</span><br><span class="line">            helper.setNext(first);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;最后留在圈中的小孩：&quot;</span> + first.getNo());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> Boy next;<span class="comment">//指向下一个节点</span></span><br><span class="line"></span><br><span class="line">    Boy(<span class="keyword">int</span> no) &#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boy <span class="title">getNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Boy next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>指针</tag>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础07：栈及实现简单计算器</title>
    <url>/posts/246RPYZ.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>栈的实际需求</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/08/13/161426iIfTT7.png" alt=""></p>
<h2 id="栈的介绍"><a href="#栈的介绍" class="headerlink" title="栈的介绍"></a>栈的介绍</h2><p><img data-src="https://xuemingde.com/pages/image/2022/08/23/194602A0WnRP.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/08/23/1948497ScOkz.png" alt=""></p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p><img data-src="https://xuemingde.com/pages/image/2022/08/23/195206UOMgkA.png" alt=""></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><p><img data-src="https://xuemingde.com/pages/image/2022/08/23/195729UyPAWX.png" alt=""></p>
<h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><p><img data-src="https://xuemingde.com/pages/image/2022/08/23/200037Mw5yfC.png" alt=""></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.algorithm.stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TODO</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：XMD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 23.8.22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStackDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayStack arrayStack = <span class="keyword">new</span> ArrayStack(<span class="number">5</span>);</span><br><span class="line">        String key = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">boolean</span> loop = <span class="keyword">true</span>;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (loop) &#123;</span><br><span class="line">            key = scanner.next();</span><br><span class="line">            <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;show&quot;</span>:</span><br><span class="line">                    arrayStack.show();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;push&quot;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;输入&quot;</span>);</span><br><span class="line">                    <span class="keyword">int</span> value = scanner.nextInt();</span><br><span class="line">                    arrayStack.push(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;pop&quot;</span>:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">int</span> res = arrayStack.pop();</span><br><span class="line">                        System.out.println(<span class="string">&quot;pop:&quot;</span> + res);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;exit&quot;</span>:</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    loop = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;结束&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span> </span>&#123;</span><br><span class="line">    <span class="comment">//栈的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="comment">//数组，模拟栈，存放数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] stack;</span><br><span class="line">    <span class="comment">//栈顶，默认-1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == maxSize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull())&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈满&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;栈空&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> value = stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = top; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            System.out.println(stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="实现综合计算器"><a href="#实现综合计算器" class="headerlink" title="实现综合计算器"></a>实现综合计算器</h2><p><img data-src="https://xuemingde.com/pages/image/2022/08/23/202920kNJff7.png" alt=""></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><img data-src="https://xuemingde.com/pages/image/2022/08/23/205436e23CzC.png" alt=""></p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.algorithm.stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 栈实现综合计算器 （单位数的加减乘除）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：XMD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 23.8.22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String exp = <span class="string">&quot;70+2*60-4&quot;</span>;</span><br><span class="line">        ArrayStack2 numStack = <span class="keyword">new</span> ArrayStack2(<span class="number">10</span>);</span><br><span class="line">        ArrayStack2 operStack = <span class="keyword">new</span> ArrayStack2(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//定义需要的变量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//用于扫描</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num1;</span><br><span class="line">        <span class="keyword">int</span> num2;</span><br><span class="line">        <span class="keyword">int</span> oper;</span><br><span class="line">        <span class="keyword">int</span> res;</span><br><span class="line">        <span class="comment">//将每次扫描得到的char保存到ch</span></span><br><span class="line">        <span class="keyword">char</span> ch = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        String keepNum = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            ch = exp.substring(index, index + <span class="number">1</span>).charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//如果是运算法</span></span><br><span class="line">            <span class="keyword">if</span> (operStack.isOper(ch)) &#123;</span><br><span class="line">                <span class="comment">//判断符号栈是否为空</span></span><br><span class="line">                <span class="keyword">if</span> (operStack.isEmpty()) &#123;</span><br><span class="line">                    <span class="comment">//直接入符合栈</span></span><br><span class="line">                    operStack.push(ch);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//进行比较，如果当前操作符优先级小于等于女栈中的优先级，就需要从栈中pop出两个数</span></span><br><span class="line">                    <span class="comment">//再从符号栈中pop出一个符号，进行运算，将得到的结果，入数栈，然后将当前的操作符入符号栈</span></span><br><span class="line">                    <span class="keyword">if</span> (operStack.priority(ch) &lt;= operStack.priority(operStack.peek())) &#123;</span><br><span class="line">                        num1 = numStack.pop();</span><br><span class="line">                        num2 = numStack.pop();</span><br><span class="line">                        oper = operStack.pop();</span><br><span class="line">                        res = numStack.cal(num1, num2, oper);</span><br><span class="line">                        numStack.push(res);</span><br><span class="line">                        operStack.push(ch);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//如果当前操作符的优先级大于栈中的操作符，就直接入符号栈</span></span><br><span class="line">                        <span class="comment">//为什么要减48，需要看ASCII表，十进制</span></span><br><span class="line">                        operStack.push(ch);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果是数，直接入数栈</span></span><br><span class="line">               <span class="comment">// numStack.push(ch - 48);</span></span><br><span class="line">                <span class="comment">//思路分析</span></span><br><span class="line">                <span class="comment">//1.当处理多为数是，不能发现是一个数就立即入栈，因为可能是多位数</span></span><br><span class="line">                <span class="comment">//2.在处理数时。需要向exp的表达式的index后再看一位，如果是数就进行扫描，如果是符号就入栈</span></span><br><span class="line">                <span class="comment">//3.因此需要定义一个变量字符串keepNum，用于拼接</span></span><br><span class="line">                keepNum += ch;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果ch是最后一位，就直接入栈</span></span><br><span class="line">                <span class="keyword">if</span> (index == exp.length() -<span class="number">1</span>)&#123;</span><br><span class="line">                    numStack.push(Integer.parseInt(keepNum));</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//判断下一个字符是不是数字，如果是数字就继续扫描，如果是运算符，就入栈</span></span><br><span class="line">                    <span class="comment">//注意只是看后一位，不是出栈</span></span><br><span class="line">                    <span class="keyword">if</span> (operStack.isOper(exp.substring(index+<span class="number">1</span>,index+<span class="number">2</span>).charAt(<span class="number">0</span>)))&#123;</span><br><span class="line">                        <span class="comment">//如果后一位是运算符，就入栈</span></span><br><span class="line">                        numStack.push(Integer.parseInt(keepNum));</span><br><span class="line">                        <span class="comment">//keepNum清空</span></span><br><span class="line">                        keepNum = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//让index + 1 ，并判断是否扫描到exp最后</span></span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= exp.length()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当表达式扫描完毕，就顺序的从数栈和符号栈中pop出相应的数和符号，并运行</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//如果符号栈为空，则计算到最后的结果，数栈中只有一个数组，就是结果</span></span><br><span class="line">            <span class="keyword">if</span> (operStack.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num1 = numStack.pop();</span><br><span class="line">            num2 = numStack.pop();</span><br><span class="line">            oper = operStack.pop();</span><br><span class="line">            res = numStack.cal(num1, num2, oper);</span><br><span class="line">            numStack.push(res);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;结果是：&quot;</span> + numStack.pop());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrayStack2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//栈的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="comment">//数组，模拟栈，存放数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] stack;</span><br><span class="line">    <span class="comment">//栈顶，默认-1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> top = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack2</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == maxSize - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> top == -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈满&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        top++;</span><br><span class="line">        stack[top] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;栈空&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> value = stack[top];</span><br><span class="line">        top--;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回栈顶数据，不出栈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;栈空&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> stack[top];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;栈空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = top; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            System.out.println(stack[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回运算符的优先级，优先级是程序员来确定，优先级使用数字表示</span></span><br><span class="line">    <span class="comment">//数字越大，优先级越高</span></span><br><span class="line">    <span class="comment">//假定表达式只有 + - * /</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">priority</span><span class="params">(<span class="keyword">int</span> oper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (oper == <span class="string">&#x27;*&#x27;</span> || oper == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&#x27;+&#x27;</span> || oper == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否是运算符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOper</span><span class="params">(<span class="keyword">char</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val == <span class="string">&#x27;+&#x27;</span> || val == <span class="string">&#x27;-&#x27;</span> || val == <span class="string">&#x27;*&#x27;</span> || val == <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2, <span class="keyword">int</span> oper)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//计算结果</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (oper) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                res = num1 + num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                res = num2 - num1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                res = num1 * num2;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">                res = num2 / num1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>数组</tag>
        <tag>变量</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础08：栈的三种表达式</title>
    <url>/posts/2XHCMQG.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>栈的三种表达式为：前缀，中缀，后缀</p>
</blockquote>
<h2 id="前缀表达式（波兰表达式）"><a href="#前缀表达式（波兰表达式）" class="headerlink" title="前缀表达式（波兰表达式）"></a>前缀表达式（波兰表达式）</h2><p><img data-src="https://xuemingde.com/pages/image/2022/08/24/184324bnytJJ.png" alt=""></p>
<h3 id="前缀表达式的计算机求值"><a href="#前缀表达式的计算机求值" class="headerlink" title="前缀表达式的计算机求值"></a>前缀表达式的计算机求值</h3><p><img data-src="https://xuemingde.com/pages/image/2022/08/24/184627LNYqSi.png" alt=""></p>
<h2 id="中缀表达式"><a href="#中缀表达式" class="headerlink" title="中缀表达式"></a>中缀表达式</h2><p><img data-src="https://xuemingde.com/pages/image/2022/08/24/185420GmxJJD.png" alt=""></p>
<h2 id="后缀表达式-（逆波兰表达式）"><a href="#后缀表达式-（逆波兰表达式）" class="headerlink" title="后缀表达式 （逆波兰表达式）"></a>后缀表达式 （逆波兰表达式）</h2><p><img data-src="https://xuemingde.com/pages/image/2022/08/24/185846Rsje3D.png" alt=""></p>
<h3 id="后缀表达式的计算机求值"><a href="#后缀表达式的计算机求值" class="headerlink" title="后缀表达式的计算机求值"></a>后缀表达式的计算机求值</h3><p><img data-src="https://xuemingde.com/pages/image/2022/08/24/190217UizigG.png" alt=""></p>
<h3 id="代码完成一个计算器（逆波兰计算器）"><a href="#代码完成一个计算器（逆波兰计算器）" class="headerlink" title="代码完成一个计算器（逆波兰计算器）"></a>代码完成一个计算器（逆波兰计算器）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.algorithm.stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逆波兰计算器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：XMD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 24.8.22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BackPolandCalculatorDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先定义一个逆波兰表达式</span></span><br><span class="line">        <span class="comment">//为了方便，表达式的数组和符号使用空格隔开</span></span><br><span class="line">        <span class="comment">//（30+4）* 5 -6  =&gt;  30 4 + 5 * 6 -</span></span><br><span class="line">        String expre = <span class="string">&quot;30 4 + 5 * 6 - &quot;</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 思路</span></span><br><span class="line"><span class="comment">         * 1.先将表达式当道ArrayList中</span></span><br><span class="line"><span class="comment">         * 2.将ArrayList传递给一个方法，遍历ArrayList配合栈完成计算</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        List&lt;String&gt; listString = getListString(expre);</span><br><span class="line">        System.out.println(listString);</span><br><span class="line">        <span class="keyword">int</span> calculate = calculate(listString);</span><br><span class="line">        System.out.println(calculate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将一个逆波兰表达式，依次将数据和运算符放到ArrayList中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getListString</span><span class="params">(String expre)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将表达式分割</span></span><br><span class="line">        String[] strings = expre.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        List&lt;String&gt; stringList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String string : strings) &#123;</span><br><span class="line">            stringList.add(string);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1)从左至右扫描，将3和4压入堆栈；</span></span><br><span class="line"><span class="comment">     * 2)遇到+运算符，因此弹出4和3(4为栈顶元素，3为次顶元素)，计算出3+4的值，得7，再将7入栈；</span></span><br><span class="line"><span class="comment">     * 3)将5入栈；</span></span><br><span class="line"><span class="comment">     * 4)接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；</span></span><br><span class="line"><span class="comment">     * 5)将6入栈；</span></span><br><span class="line"><span class="comment">     * 6)最后是-运算符，计算出35-6的值，即29，由此得出最终结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(List&lt;String&gt; stringList)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建一个栈，一个即可</span></span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String item : stringList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item.matches(<span class="string">&quot;\\d+&quot;</span>))&#123;</span><br><span class="line">                <span class="comment">//入栈</span></span><br><span class="line">                stack.push(item);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//pop出两个数并计算，计算后的数据入栈</span></span><br><span class="line">                <span class="keyword">int</span> num2 = Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="keyword">int</span> num1 = Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="keyword">int</span> res;</span><br><span class="line">                <span class="keyword">if</span> (item.equals(<span class="string">&quot;+&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 + num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;-&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 - num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;*&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 * num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 / num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;运算符有误&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(String.valueOf(res));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="中缀转后缀"><a href="#中缀转后缀" class="headerlink" title="中缀转后缀"></a>中缀转后缀</h2><p>大家看到，后缀表达式适合计算式进行运算，但是人却不太容易写出来，尤其是表达式很长的情况下，因此在开发中，我们需要将中缀表达式转成后缀表达式。</p>
<p>具体步骤如下：</p>
<ol>
<li>初始化两个栈：运算符栈s1和储存中间结果的栈s2；</li>
<li>从左至右扫描中缀表达式；</li>
<li>遇到操作数时，将其压s2；</li>
<li>遇到运算符时，比较其与s1栈顶运算符的优先级：<ol>
<li>如果s1为空，或栈顶运算符为左括号“(“，则直接将此运算符入栈；</li>
<li>否则，若优先级比栈顶运算符的高，也将运算符压入s1;</li>
<li>否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4-1)与s1中新的栈顶运算符相比较；</li>
</ol>
</li>
<li>遇到括号时：<ol>
<li>如果是左括号“(”，则直接压入s1</li>
<li>如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2,直到遇到左括号为止，此时将这一对括号丢弃</li>
</ol>
</li>
<li>重复步骤2至5，直到表达式的最右边</li>
<li>将s1中剩余的运算符依次弹出并压入s2</li>
<li>依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式 </li>
</ol>
<p>举例说明：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/08/24/195730XlflPp.png" alt=""></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.algorithm.stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 逆波兰计算器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：XMD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 24.8.22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BackPolandCalculatorDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 中缀表达式转后缀表达式</span></span><br><span class="line"><span class="comment">         * 1,1+((2+3)*4)-5=&gt;转成1 2 3 + 4 * + 5 -</span></span><br><span class="line"><span class="comment">         * 2,因为直接对str进行操作，不方便，因此先将&quot;1+((2+3)*4)-5”=》中缀的表达式对应的List</span></span><br><span class="line"><span class="comment">         *  即&quot;1+(2+3)*4)-5&quot;=&gt;ArrayList[1,+,(,(,2,+,3,),*,4,)-,5]</span></span><br><span class="line"><span class="comment">         * 3. 将中缀表达式list转为后缀表达式对应的list</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//中缀表达式</span></span><br><span class="line">        String exp = <span class="string">&quot;1+((2+3)*4)-5&quot;</span>;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = toInfixExpList(exp);</span><br><span class="line">        System.out.println(list);</span><br><span class="line">        List&lt;String&gt; list1 = parseSufExpList(list);</span><br><span class="line">        System.out.println(list1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        //先定义一个逆波兰表达式</span></span><br><span class="line"><span class="comment">//        //为了方便，表达式的数组和符号使用空格隔开</span></span><br><span class="line"><span class="comment">//        //（30+4）* 5 -6  =&gt;  30 4 + 5 * 6 -</span></span><br><span class="line"><span class="comment">//        String expre = &quot;30 4 + 5 * 6 - &quot;;</span></span><br><span class="line"><span class="comment">//        /**</span></span><br><span class="line"><span class="comment">//         * 思路</span></span><br><span class="line"><span class="comment">//         * 1.先将表达式当道ArrayList中</span></span><br><span class="line"><span class="comment">//         * 2.将ArrayList传递给一个方法，遍历ArrayList配合栈完成计算</span></span><br><span class="line"><span class="comment">//         */</span></span><br><span class="line"><span class="comment">//        List&lt;String&gt; listString = getListString(expre);</span></span><br><span class="line"><span class="comment">//        System.out.println(listString);</span></span><br><span class="line">        <span class="keyword">int</span> calculate = calculate(list1);</span><br><span class="line">        System.out.println(calculate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">parseSufExpList</span><span class="params">(List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定义两个栈</span></span><br><span class="line">        Stack&lt;String&gt; s1 = <span class="keyword">new</span> Stack&lt;&gt;();<span class="comment">//符号栈</span></span><br><span class="line">        <span class="comment">//说明：因为s2这个栈，在整个转换过程中，没有pop操作，而且后面我们还需要逆序输出</span></span><br><span class="line">        <span class="comment">//因此比较麻烦，这里我们就不用Stack&lt;String&gt;直接使用List&lt;String&gt; s2</span></span><br><span class="line">        List&lt;String&gt; s2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String item : list) &#123;</span><br><span class="line">            <span class="comment">//如果是数字</span></span><br><span class="line">            <span class="keyword">if</span> (item.matches(<span class="string">&quot;\\d+&quot;</span>))&#123;</span><br><span class="line">                s2.add(item);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;(&quot;</span>))&#123;</span><br><span class="line">                s1.push(item);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;)&quot;</span>))&#123;</span><br><span class="line">                <span class="keyword">while</span> (!s1.peek().equals(<span class="string">&quot;(&quot;</span>))&#123;</span><br><span class="line">                    s2.add(s1.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将(弹出</span></span><br><span class="line">                s1.pop();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//但item的运算符优先级小于等于s1栈顶的运算符，将s1栈顶的运算符弹出并加入到s2中，再次转到(4,1)与s1中新的栈顶运算符相比较</span></span><br><span class="line">                <span class="keyword">while</span> (s1.size() != <span class="number">0</span> &amp;&amp; Operation.getValue(s1.peek()) &gt;= Operation.getValue(item))&#123;</span><br><span class="line">                    s2.add(s1.pop());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将item压入栈中</span></span><br><span class="line">                s1.push(item);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将s1中剩余的运算符依次弹出并加入s2</span></span><br><span class="line">        <span class="keyword">while</span> (s1.size() != <span class="number">0</span>)&#123;</span><br><span class="line">            s2.add(s1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">toInfixExpList</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//存放中缀表达式对应的内容</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//指针，用于遍历中缀表达式字符串</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        String st;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//如果不是一个数字，加入list</span></span><br><span class="line">            <span class="keyword">if</span> ((c = str.charAt(i)) &lt; <span class="number">48</span> || (c = str.charAt(i)) &gt; <span class="number">57</span>) &#123;</span><br><span class="line">                list.add(String.valueOf(c));</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果是数字，需要考虑多位数</span></span><br><span class="line">                st = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; str.length() &amp;&amp; (c = str.charAt(i)) &gt;= <span class="number">48</span> &amp;&amp; (c = str.charAt(i)) &lt;= <span class="number">57</span>) &#123;</span><br><span class="line">                    st += c;</span><br><span class="line">                    list.add(st);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (i &lt; str.length());</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将一个逆波兰表达式，依次将数据和运算符放到ArrayList中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getListString</span><span class="params">(String expre)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将表达式分割</span></span><br><span class="line">        String[] strings = expre.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        List&lt;String&gt; stringList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String string : strings) &#123;</span><br><span class="line">            stringList.add(string);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stringList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1)从左至右扫描，将3和4压入堆栈；</span></span><br><span class="line"><span class="comment">     * 2)遇到+运算符，因此弹出4和3(4为栈顶元素，3为次顶元素)，计算出3+4的值，得7，再将7入栈；</span></span><br><span class="line"><span class="comment">     * 3)将5入栈；</span></span><br><span class="line"><span class="comment">     * 4)接下来是×运算符，因此弹出5和7，计算出7×5=35，将35入栈；</span></span><br><span class="line"><span class="comment">     * 5)将6入栈；</span></span><br><span class="line"><span class="comment">     * 6)最后是-运算符，计算出35-6的值，即29，由此得出最终结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(List&lt;String&gt; stringList)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个栈，一个即可</span></span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String item : stringList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item.matches(<span class="string">&quot;\\d+&quot;</span>)) &#123;</span><br><span class="line">                <span class="comment">//入栈</span></span><br><span class="line">                stack.push(item);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//pop出两个数并计算，计算后的数据入栈</span></span><br><span class="line">                <span class="keyword">int</span> num2 = Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="keyword">int</span> num1 = Integer.parseInt(stack.pop());</span><br><span class="line">                <span class="keyword">int</span> res;</span><br><span class="line">                <span class="keyword">if</span> (item.equals(<span class="string">&quot;+&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 + num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;-&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 - num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;*&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 * num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">                    res = num1 / num2;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;运算符有误&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(String.valueOf(res));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Operation</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ADD = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> SUB = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MUL = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> DIV = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">(String oper)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">switch</span> (oper)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                res = ADD;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                res = SUB;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                res = MUL;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                res = DIV;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;运算符有误&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>堆</tag>
        <tag>栈</tag>
        <tag>数组</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础09：递归</title>
    <url>/posts/1R0S1V1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>递归的应用场景</strong></p>
<p>实际应用场景，迷宫问题（回溯），递归(Recursion)</p>
<h2 id="递归的概念"><a href="#递归的概念" class="headerlink" title="递归的概念"></a>递归的概念</h2><p>简单的说：递归就是方法自己调用自己，每次调用时传入不同的变量递归有助于编程者解决复杂的问题，同时可以让代码变得简洁。</p>
<h3 id="递归的调用机制"><a href="#递归的调用机制" class="headerlink" title="递归的调用机制"></a>递归的调用机制</h3><p>我列举两个小案例，来帮助大家理解递归，部分学员己经学习过递归了，这里在给大家回顾一下递归调用机制</p>
<ol>
<li>打印问题</li>
<li>阶乘问题</li>
</ol>
<p><img data-src="https://xuemingde.com/pages/image/2022/08/25/195730M0MQxn.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/08/25/201645RDNcSa.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">2</span>)&#123;</span><br><span class="line">            test(n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出的结果为：2    3   4   5</p>
<h3 id="递归可以解决什么样的问题"><a href="#递归可以解决什么样的问题" class="headerlink" title="递归可以解决什么样的问题"></a>递归可以解决什么样的问题</h3><ol>
<li>各种数学问题如：8皇后问题，汉诺塔，阶乘问题，迷宫问题，球和篮子的问题(google编程大赛)</li>
<li>各种算法中也会使用到递归，比如快排，归并排序，二分查找，分治算法等。</li>
<li>将用栈解决的问题-&gt;第归代码比较简洁</li>
</ol>
<h3 id="递归要遵守的规则"><a href="#递归要遵守的规则" class="headerlink" title="递归要遵守的规则"></a>递归要遵守的规则</h3><ol>
<li>执行一个方法时，就创建一个新的受保护的独立空间（栈空间）</li>
<li>方法的局部变量是独立的，不会相互影响，比如变量</li>
<li>如果方法中使用的是引用类型变量（比如数组），就会共享该引用类型的数据</li>
<li>递归必须向退出递归的条件逼近，否则就是无限递归，出现StackOverflowError,死鱼了</li>
<li>当一个方法执行完毕，或者遇到return,就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。</li>
</ol>
<h2 id="迷宫问题"><a href="#迷宫问题" class="headerlink" title="迷宫问题"></a>迷宫问题</h2><p><img data-src="https://xuemingde.com/pages/image/2022/08/25/204418UqrqUN.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.algorithm.recursion;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 迷宫问题</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：XMD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 25.8.22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoGong</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>][<span class="number">7</span>];</span><br><span class="line">        <span class="comment">//使用1表示墙</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">7</span>; i++) &#123;</span><br><span class="line">            map[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">            map[<span class="number">7</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;<span class="number">8</span>; i++) &#123;</span><br><span class="line">            map[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            map[i][<span class="number">6</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> setWay = setWay(map, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(setWay);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : map) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> anInt : ints) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%d\t&quot;</span>, anInt);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 从[1][1] 开始找</span></span><br><span class="line"><span class="comment">     * 如果找到[4][3] 说明找到</span></span><br><span class="line"><span class="comment">     * 0表示没有吧走过的</span></span><br><span class="line"><span class="comment">     * 1表示墙，不可走</span></span><br><span class="line"><span class="comment">     * 2走过的路</span></span><br><span class="line"><span class="comment">     * 3该位置已经走过，走不通</span></span><br><span class="line"><span class="comment">     * 定义一个策略：下-右-上-左，走不通再回溯</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mapm 表示数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 从那个位置开始找</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果找到出路返回truye，没有返回false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">setWay</span><span class="params">(<span class="keyword">int</span>[][] mapm,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mapm[<span class="number">4</span>][<span class="number">3</span>] == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mapm[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//还没有走过，按策略走</span></span><br><span class="line">                <span class="comment">//假定可以走通</span></span><br><span class="line">                mapm[i][j] = <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (setWay(mapm, i + <span class="number">1</span>, j)) &#123;<span class="comment">//往下走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(mapm, i, j + <span class="number">1</span>)) &#123;<span class="comment">//往右走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(mapm, i - <span class="number">1</span>, j)) &#123;<span class="comment">//往上走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (setWay(mapm, i, j - <span class="number">1</span>)) &#123;<span class="comment">//往左走</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//说明该点走不通</span></span><br><span class="line">                    mapm[i][j] = <span class="number">3</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//不为0，就有可能为11，2，3</span></span><br><span class="line">                <span class="comment">//1是墙不能走，2已经走过，不要再走，3是死路，不可走，只能返回false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="八皇后问题"><a href="#八皇后问题" class="headerlink" title="八皇后问题"></a>八皇后问题</h2><p><img data-src="https://xuemingde.com/pages/image/2022/08/28/120229ATeqj9.png" alt=""></p>
<h3 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h3><ol>
<li>第一个皇后先放第一行第一列</li>
<li>第二个皇后放在第二行第一列、然后判断是否0K,如果不OK,继续放在第二列、第三列、依次把所有列都放完，找到一个合适</li>
<li>继续第三个皇后，还是第一列、第二列…直到第8个皇后也能放在一个不冲突的位置，算是找到了一个正确解</li>
<li>当得到一个正确解时，在栈回退到上一个栈时，就会开始回溯，即将第一个皇后，放到第一列的所有正确解，全部得到</li>
<li>然后回头继续第一个皇后放第二列，后面继续循环执行1,2,3,4的步骤【示意图】</li>
</ol>
<blockquote>
<p>说明：理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题，</p>
</blockquote>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.algorithm.recursion;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 八皇后问题</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：XMD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 28.8.22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue8</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = <span class="number">8</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 理论上应该创建一个二维数组来表示棋盘，但是实际上可以通过算法，用一个一维数组即可解决问题,arr[8]=</span></span><br><span class="line"><span class="comment">     * &#123;0,4,7,5,2,6,1,3&#125;/对应arr下标表示第几行，即第几个皇后，ar[)=val,val表示第i+1个皇后，放在第i+1</span></span><br><span class="line"><span class="comment">     * 行的第val+1列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[max];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Queue8 queue8 = <span class="keyword">new</span> Queue8();</span><br><span class="line">        queue8.check(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;共有：&quot;</span> + queue8.count);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查看当我们放置第个皇后，就去检测该皇后是否和前面已经摆放的皇后冲突</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 表示第n个皇后</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//array[i]==array[n]表示判断第n个皇后是否和前面的n-1个皇后在同一列</span></span><br><span class="line">            <span class="comment">//Math.abs(n-i)==Math,abs(array[n]-array[i])表示判断第n个皇后是否和第i皇后是否在同一斜线</span></span><br><span class="line">            <span class="keyword">if</span> (array[i] == array[n] || Math.abs(n - i) == Math.abs(array[n] - array[i])) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写一个方法，可以将皇后摆放的位置输出</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            System.out.print(array[i] + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编写一个方法，放置第n个皇后</span></span><br><span class="line"><span class="comment">     *  特别注意：check是每一次递归时，进入到check中都有for(int i=O;i&lt;max;i++),因此会有回崩</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == max) &#123;</span><br><span class="line">            <span class="comment">//8,其实8个皇后就既然放好</span></span><br><span class="line">            print();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">            <span class="comment">//先把当前这个皇后n,放到该行的第1列</span></span><br><span class="line">            array[n] = i;</span><br><span class="line">            <span class="comment">//判断当放置第n个皇后到i列时，是否冲突</span></span><br><span class="line">            <span class="keyword">if</span> (judge(n)) &#123;</span><br><span class="line">                <span class="comment">//不冲突 ， 接着放n+1个皇后，即开始递归</span></span><br><span class="line">                check(n + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果冲突，就继续执行array[n]=i;即将第n个皇后，放置在本行得后移的一个位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>栈</tag>
        <tag>数组</tag>
        <tag>局部</tag>
        <tag>变量</tag>
        <tag>MQ</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础10：排序算法</title>
    <url>/posts/FNQ9NS.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="排序算法介绍"><a href="#排序算法介绍" class="headerlink" title="排序算法介绍"></a>排序算法介绍</h2><p>排序也称排序算法(Sort Algorithm),排序是将一组数据，依指定的顺序进行排列的过程。<br>排序的分类：</p>
<ol>
<li><p>内部排序：</p>
<p>指将需要处理的所有数据都加载到内部存储器中进行排序。</p>
</li>
<li><p>外部排序法：</p>
<p>数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。</p>
</li>
<li><p>常见的排序算法分类（见下图）</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/08/28/143148UwG3e4.png" alt=""></p>
<blockquote>
<p>基础排序是桶排序的一个扩展</p>
</blockquote>
</li>
</ol>
<h2 id="算法的时间复杂度"><a href="#算法的时间复杂度" class="headerlink" title="算法的时间复杂度"></a>算法的时间复杂度</h2><p>度量一个程序执行时间的两种方法</p>
<ol>
<li><p>事后统计的方法</p>
<p>这种方法可行，但是有两个问题：一是要想对设计的算法的运行性能进行评测，需要实际运行该程序；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素，<strong>这种方式，要在同一台计算机的相同状态下运行，才能比较那个算法速度更快。</strong></p>
</li>
<li><p>事前估算的方法 </p>
<p>通过分析某个算法的时间复杂度来判断哪个算法更优</p>
</li>
</ol>
<h3 id="时间频度"><a href="#时间频度" class="headerlink" title="时间频度"></a>时间频度</h3><p>时间频度：一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T()。[举例说明]</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/08/28/150531rrbqjR.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/08/28/150734i8acJB.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/08/28/15105262TTar.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/08/28/151217CRXPdv.png" alt=""></p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ol>
<li><p>一般情况下，算法中的基本操作语句的重复执行次数是问题规模的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T(n)/fn)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=O(fn)),称O(fn)为算法的渐进时间复杂度，简称时间复杂度。</p>
</li>
<li><p>T(n)不同，但时间复杂度可能相同。如：</p>
<script type="math/tex; mode=display">
T(n)=n^2+7n+6</script><p>与</p>
<script type="math/tex; mode=display">
T(n)=3^2+2n+2</script><p>它们的T(n)不同，但时间复杂度相同，都为O(n²):</p>
</li>
<li><p>计算时间复杂度的方法：</p>
<ul>
<li>用常数1代替运行时间中的所有加法常数</li>
<li>修改后的运行次数函数中，只保留最高阶项</li>
<li>去除最高阶项的系数</li>
</ul>
</li>
</ol>
<p><strong>常见的时间复杂度</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/08/28/1528535XU7uw.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/08/28/1532521rv7uv.png" alt=""></p>
<h4 id="常数阶-O-1"><a href="#常数阶-O-1" class="headerlink" title="常数阶 O(1)"></a>常数阶 O(1)</h4><p>无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是0(1)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line">++i;</span><br><span class="line">j++;</span><br><span class="line"><span class="keyword">int</span> m = i + j;</span><br></pre></td></tr></table></figure>
<p>上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。</p>
<h4 id="对数阶"><a href="#对数阶" class="headerlink" title="对数阶"></a>对数阶</h4><script type="math/tex; mode=display">
log_2n</script><p><img data-src="https://xuemingde.com/pages/image/2022/08/28/154829pDrfWQ.png" alt=""></p>
<blockquote>
<script type="math/tex; mode=display">
2^{10} = 1024   <>  log_21024=10</script></blockquote>
<h4 id="线性阶-O-n"><a href="#线性阶-O-n" class="headerlink" title="线性阶 O(n)"></a>线性阶 O(n)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i1;i&lt;=n;++i)&#123;</span><br><span class="line">  j=i;</span><br><span class="line">  j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度</p>
<h4 id="线性对数阶"><a href="#线性对数阶" class="headerlink" title="线性对数阶"></a>线性对数阶</h4><script type="math/tex; mode=display">
O(nlog_2n)</script><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(m=<span class="number">1</span>;m&lt;n;m++)&#123;</span><br><span class="line">  i=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">    i=i*<span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：线性对数阶O(nlogN)其实非常容易理解，将时间复杂度为Olog)的代码循环N遍的<br>话，那么它的时间复杂度就是n*O(log_2 N),也就是了O(nlog_2 N)</p>
<h4 id="平方阶O-n²"><a href="#平方阶O-n²" class="headerlink" title="平方阶O(n²)"></a>平方阶O(n²)</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        j = i;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：平方阶O)就更容易理解了，如果把O)的代码再嵌套循环一遍，它的时间复杂度就是On),这段代码其实就是嵌套了2层n循环，它的时间复杂度就是O(n<em>n),即o(n)如果将其中一层循环的n改成m,那它的时间复杂度就变成了O(m</em>n)</p>
<h3 id="平均时间复杂度和最坏时间复杂度"><a href="#平均时间复杂度和最坏时间复杂度" class="headerlink" title="平均时间复杂度和最坏时间复杂度"></a>平均时间复杂度和最坏时间复杂度</h3><ol>
<li><p>平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，该算法的运行时间。</p>
</li>
<li><p>最坏情况下的时间复杂度称最坏时间复杂度。一般讨论的时间复杂度均是最坏情况下的时间复杂度。这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的界限，这就保证了算法的运行时间不会比最坏情况更长。</p>
</li>
<li><p>平均时间复杂度和最坏时间复杂度是否一致，和算法有关（如下图）。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/08/28/1605027MW9wk.png" alt=""></p>
</li>
</ol>
<h3 id="算法的空间复杂度"><a href="#算法的空间复杂度" class="headerlink" title="算法的空间复杂度"></a>算法的空间复杂度</h3><ol>
<li>类似于时间复杂度的讨论，一个算法的空间复杂度(Space Complexity)定义为该算法所耗费的存储空间，它也是问题规模的函数。</li>
<li>空间复杂度(Space Complexity)是对一个算法在运行过程中临时占用存储空间大小的量度。有的算法需要占用的临时工作单元数与解决问题的规模有关，它随着n的增大而增大，当较大时，将占用较多的存储单元，例如快速排序和归并排序算法就属于这种情况</li>
<li>在做算法分析时，<strong>主要讨论的是时间复杂度</strong>。从用户使用体验上看，更看重的程序执行的速度。一些缓存产品(redis,,memcache)和算法（基数排序）本质就是<strong>用空间换时间</strong></li>
</ol>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序(Bubble Sorting)的基本思想是：通过对待排序序列从前向后（从下标较小的元素开始），依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。</p>
<p>（优化）因为排序的过程中，各元素不断接近自己的位置，<strong>如果一趟比较下来没有进行过交换，就说明序列有序</strong>，因此要在排序过程中设置一个标志Iag判断元素是否进行过交换。从而减少不必要的比较。</p>
<p><strong>示例图解</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/08/29/1913255nc3lX.png" alt=""></p>
<p><strong>应用实例</strong></p>
<p>我们举一个具体的案例来说明冒泡法。我们将五个无序的数：3,9，-1,10,20使用冒泡排序法将其排成一个<strong>从小到大</strong>的有序数列。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/08/29/1923371sVLS6.png" alt=""></p>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 冒泡排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：XMD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 29.8.22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSorting</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = &#123;<span class="number">3</span>, <span class="number">9</span>, -<span class="number">1</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">int</span> tem = arr[j];</span><br><span class="line">                    arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = tem;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度为O(n²)，因为时嵌套循环</p>
</blockquote>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择式排序也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的。</p>
<p><strong>排序思想</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/08/30/183532CFMtb9.png" alt=""></p>
<p><strong>分析图</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/08/30/183900ZccTSA.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/08/30/184546DWw56J.png" alt=""></p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChooseSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从小到大排序</span></span><br><span class="line"><span class="comment">     * 时间复杂度为O(n^2)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ints</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span>[] ints)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ints.length -<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> minIndex = i;</span><br><span class="line">            <span class="keyword">int</span> min = ints[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; ints.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (min &gt; ints[j]) &#123;</span><br><span class="line">                    min = ints[j];</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (minIndex != i)&#123;</span><br><span class="line">                ints[minIndex] = ints[i];</span><br><span class="line">                ints[i] = min;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> random = RandomUtils.nextInt(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">            temp[i] = random;</span><br><span class="line">        &#125;</span><br><span class="line">        test(temp);</span><br><span class="line">        System.out.println(JSON.toJSONString(temp));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>时间复杂度为O(n²)，因为时嵌套循环</p>
</blockquote>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入式排序属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的。</p>
<p><strong>排序思想</strong></p>
<p>插入排序(Insertion Sorting)的基本思想是：把n个待排序的元素看成为一个有序表和一个无序表，<strong>开始时有序表中只包含一个元素，无序表中包含有n-1个元素</strong>，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排序码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表。</p>
<p><strong>图解</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/08/30/190652jgMKJp.png" alt=""></p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsetSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> random = RandomUtils.nextInt(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">            temp[i] = random;</span><br><span class="line">        &#125;</span><br><span class="line">        insetSort(temp);</span><br><span class="line">        System.out.println(JSON.toJSONString(temp));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insetSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> intsetVal = arr[i];</span><br><span class="line">            <span class="keyword">int</span> intsetIndex = i - <span class="number">1</span>;</span><br><span class="line">          <span class="comment">//如果改为从大到小，改成intsetVal &gt; arr[intsetIndex] 即可</span></span><br><span class="line">            <span class="keyword">while</span> (intsetIndex &gt;= <span class="number">0</span> &amp;&amp; intsetVal &lt; arr[intsetIndex])&#123;</span><br><span class="line">                arr[intsetIndex + <span class="number">1</span>] = arr[intsetIndex];</span><br><span class="line">                intsetIndex -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[intsetIndex + <span class="number">1</span>] = intsetVal;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img data-src="https://xuemingde.com/pages/image/2022/08/30/195017p1rYfu.png" alt=""></p>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p><strong>插入排序存在的问题</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/08/31/192300eurK9A.png" alt=""></p>
<p><strong>希尔排序介绍</strong></p>
<p>希尔排序是希尔(Donald Shell)于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为<strong>缩小增量排序</strong>。</p>
<p><strong>基本思想</strong></p>
<p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序：随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止</p>
<p>案例</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/08/31/192723bgjqiw.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/08/31/193124QImsM3.png" alt=""></p>
<p><strong>应用实例</strong></p>
<p>有两种方式</p>
<ol>
<li>希尔排序时，对有序序列在插入时采用交换法，并测试排序速度</li>
<li>希尔排序时，对有序序列在插入时采用移动法，并测试排序速度</li>
</ol>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 希尔排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：XMD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 31.8.22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SHellSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//自定义数组</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        shellSoret2(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对有序序列在插入时采用交换法,交换法的效率并不快</span></span><br><span class="line"><span class="comment">     * 8W个数据的希尔排序的交换法排序大约用时为：17秒</span></span><br><span class="line"><span class="comment">     * 8W个数据的插入算法排序数大约用时为5秒</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSoret</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        //第一轮排序</span></span><br><span class="line"><span class="comment">//        //因为第1轮排序，是将10个数据分成了5组</span></span><br><span class="line"><span class="comment">//        for (int i = 5; i &lt; arr.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//            //遍历各组中所有的元素（共5组，每组有2个元素），步长5</span></span><br><span class="line"><span class="comment">//            for (int j = i - 5; j &gt;= 0; j -= 5) &#123;</span></span><br><span class="line"><span class="comment">//                //如果当前元素大于加上步长后的那个元素，说明交换</span></span><br><span class="line"><span class="comment">//                if (arr[j] &gt; arr[j + 5]) &#123;</span></span><br><span class="line"><span class="comment">//                    temp = arr[j];</span></span><br><span class="line"><span class="comment">//                    arr[j] = arr[j + 5];</span></span><br><span class="line"><span class="comment">//                    arr[j + 5] = temp;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;第一轮结果：&quot; + Arrays.toString(arr));</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        //因为第2轮排序，是将10个数据分成了5/2 = 2组</span></span><br><span class="line"><span class="comment">//        for (int i = 2; i &lt; arr.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//            //遍历各组中所有的元素（共5组，每组有2个元素），步长5</span></span><br><span class="line"><span class="comment">//            for (int j = i - 2; j &gt;= 0; j -= 2) &#123;</span></span><br><span class="line"><span class="comment">//                //如果当前元素大于加上步长后的那个元素，说明交换</span></span><br><span class="line"><span class="comment">//                if (arr[j] &gt; arr[j + 2]) &#123;</span></span><br><span class="line"><span class="comment">//                    temp = arr[j];</span></span><br><span class="line"><span class="comment">//                    arr[j] = arr[j + 2];</span></span><br><span class="line"><span class="comment">//                    arr[j + 2] = temp;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;第二轮结果：&quot; + Arrays.toString(arr));</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        //因为第3轮排序，是将10个数据分成了5/2/2 = 1组</span></span><br><span class="line"><span class="comment">//        for (int i = 1; i &lt; arr.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//            //遍历各组中所有的元素（共5组，每组有2个元素），步长5</span></span><br><span class="line"><span class="comment">//            for (int j = i - 1; j &gt;= 0; j -= 1) &#123;</span></span><br><span class="line"><span class="comment">//                //如果当前元素大于加上步长后的那个元素，说明交换</span></span><br><span class="line"><span class="comment">//                if (arr[j] &gt; arr[j + 1]) &#123;</span></span><br><span class="line"><span class="comment">//                    temp = arr[j];</span></span><br><span class="line"><span class="comment">//                    arr[j] = arr[j + 1];</span></span><br><span class="line"><span class="comment">//                    arr[j + 1] = temp;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;第三轮结果：&quot; + Arrays.toString(arr));</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据逐步分析，使用循环处理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">                <span class="comment">//遍历各组中所有的元素（共gap组，每组有2个元素），步长gap</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i - gap; j &gt;= <span class="number">0</span>; j -= gap) &#123;</span><br><span class="line">                    <span class="comment">//如果当前元素大于加上步长后的那个元素，说明交换</span></span><br><span class="line">                    <span class="keyword">if</span> (arr[j] &gt; arr[j + gap]) &#123;</span><br><span class="line">                        temp = arr[j];</span><br><span class="line">                        arr[j] = arr[j + gap];</span><br><span class="line">                        arr[j + gap] = temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;希尔结果：&quot;</span> + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对有序序列在插入时采用移动法</span></span><br><span class="line"><span class="comment">     * 8W个数据的希尔排序的移动法排序大约用时为：1秒</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSoret2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> gap = arr.length / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i;</span><br><span class="line">                <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &lt; arr[j - gap]) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (j - gap &gt;= <span class="number">0</span> &amp;&amp; temp &lt; arr[j - gap]) &#123;</span><br><span class="line">                        arr[j] = arr[j - gap];</span><br><span class="line">                        j -= gap;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//当退出while后，就给temp找到插入的位置</span></span><br><span class="line">                    arr[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;希尔结果：&quot;</span> + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序(Quicksort)是对冒泡排序的一种改进。</p>
<p>基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列</p>
<p>示意图</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/08/31/202558UA14Xz.png" alt=""></p>
<p><strong>代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">80</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">80</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> random = RandomUtils.nextInt(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">            arr[i] = random;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        int[] arr = &#123;4, 1, 6, 5, 3, 9, 7, 5, 8, 2, 5&#125;;</span></span><br><span class="line">        <span class="keyword">long</span> millis = System.currentTimeMillis();</span><br><span class="line">        quickSort2(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(System.currentTimeMillis() - millis);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;快速排序：&quot;</span> + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//基准点位第一个数</span></span><br><span class="line">        <span class="keyword">int</span> pivot = arr[start];</span><br><span class="line">        <span class="comment">//开始左下标为开始前面的</span></span><br><span class="line">        <span class="keyword">int</span> l = start;</span><br><span class="line">        <span class="comment">//右下标</span></span><br><span class="line">        <span class="keyword">int</span> r = end;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//只要左边的下标小于右边下标就一直循环</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">while</span> (arr[l] &lt;= pivot &amp;&amp; l &lt; end) &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (arr[r] &gt;= pivot &amp;&amp; r &gt; start) &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (l &gt;= r) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp = arr[l];</span><br><span class="line">            arr[l] = arr[r];</span><br><span class="line">            arr[r] = temp;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果交换完后，发现这个arr[l]=pivot值 相等--，前移</span></span><br><span class="line">            <span class="keyword">if</span> (arr[l] == pivot) &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果交换完后，发现这个arr[r]=pivot值 相等--，后移</span></span><br><span class="line">            <span class="keyword">if</span> (arr[r] == pivot) &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        arr[start] = arr[r];</span><br><span class="line">        arr[r] = pivot;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (start &lt; r - <span class="number">1</span>) &#123;</span><br><span class="line">            quickSort(arr, start, r - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (end &gt; r + <span class="number">1</span>) &#123;</span><br><span class="line">            quickSort(arr, r + <span class="number">1</span>, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = left;</span><br><span class="line">        <span class="keyword">int</span> r = right;</span><br><span class="line">        <span class="keyword">int</span> pivot = arr[(left + right) / <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">while</span> (arr[l] &lt; pivot) &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (arr[r] &gt; pivot) &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l &gt;= r)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            temp = arr[l];</span><br><span class="line">            arr[l] = arr[r];</span><br><span class="line">            arr[r] = temp;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果交换完后，发现这个arr[l]=pivot值 相等--，前移</span></span><br><span class="line">            <span class="keyword">if</span> (arr[l] == pivot) &#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果交换完后，发现这个arr[r]=pivot值 相等--，后移</span></span><br><span class="line">            <span class="keyword">if</span> (arr[r] == pivot) &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &lt; r)&#123;</span><br><span class="line">            quickSort2(arr,left,r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &gt; l)&#123;</span><br><span class="line">            quickSort2(arr,l,right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序(MERGE-SORT)是利用归并的思想实现的排序方法，该算法采用经典的分治(divide-and-conquer)策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案”修补”在一起，即分而治之)。</p>
<p>基本思想</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/01/185314E9CAU5.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/01/185950yBC3dt.png" alt=""></p>
<blockquote>
<p>难理解</p>
</blockquote>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 归并排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：XMD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 1.9.22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergetSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="comment">//归并排序需要一个额外空间</span></span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        mergeSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, temp);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;归并排序:&quot;</span> + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分 + 合 方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temp</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;<span class="comment">//中间索引</span></span><br><span class="line">            <span class="comment">//向左递归分解</span></span><br><span class="line">            mergeSort(arr, left, mid, temp);</span><br><span class="line">            <span class="comment">//向右递归分解</span></span><br><span class="line">            mergeSort(arr, mid + <span class="number">1</span>, right, temp);</span><br><span class="line">            <span class="comment">//合并</span></span><br><span class="line">            merget(arr, left, mid, right, temp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 合并方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr   原始数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left  左边有序序列的初始索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mid   中间索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right 右边索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> temp  中转数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merget</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right, <span class="keyword">int</span>[] temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = left; <span class="comment">//初始化i 左边有序序列的初始索引</span></span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>; <span class="comment">//初始化j，右边有序序列的初始索引</span></span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;<span class="comment">//指向temp数组的当前索引</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一步</span></span><br><span class="line">        <span class="comment">//先把左右两边的数据按照规则填充到temp数组</span></span><br><span class="line">        <span class="comment">//直到左右两边的有序序列，又一遍处理完毕为止</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">            <span class="comment">//如果左边的有序序列的当前元素，小于等于右有序序列的当前元素</span></span><br><span class="line">            <span class="comment">//即将左边的当前元素，拷贝到temp数组</span></span><br><span class="line">            <span class="comment">//然后t++ i++</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">                temp[t] = arr[i];</span><br><span class="line">                t++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">////反之，将右边有序序列的当前元素，填充到temp数组</span></span><br><span class="line">                temp[t] = arr[j];</span><br><span class="line">                t++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二步</span></span><br><span class="line">        <span class="comment">//把有剩余数据的一边的数据依次全部填充到temp</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">            <span class="comment">////左边的有序序列还有剩余的元素，就全部填充到temp</span></span><br><span class="line">            temp[t] = arr[i];</span><br><span class="line">            t++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= right) &#123;</span><br><span class="line">            <span class="comment">////右边的有序序列还有剩余的元素，就全部填充到temp</span></span><br><span class="line">            temp[t] = arr[j];</span><br><span class="line">            t++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三步</span></span><br><span class="line">        <span class="comment">//将temp数组的元素拷贝到arr</span></span><br><span class="line">        <span class="comment">//注意，并不是每次都拷贝所有</span></span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tempLeft = left;</span><br><span class="line">        <span class="keyword">while</span> (tempLeft &lt;= right) &#123;</span><br><span class="line">            arr[tempLeft] = temp[t];</span><br><span class="line">            t++;</span><br><span class="line">            tempLeft++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><ol>
<li>基数排序(radix sort)属于“分配式排序”(distribution sort),又称“桶子法”(bucket sort)或bin sort,顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用</li>
<li>基数排序法是<strong>属于稳定性的排序</strong>，基数排序法的是<strong>效率高的稳定性排序法</strong></li>
<li><strong>基数排序(Radix Sort)是桶排序的扩展</strong></li>
<li>基数排序是1887年赫尔曼 · 何乐礼发明的。它是这样实现的：<strong>将整数按位数切割成不同的数字，然后按每个位数分别比较。</strong></li>
</ol>
<p><strong>基本思想</strong></p>
<ol>
<li>将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。</li>
<li>这样说明，比较难理解，下面我们看一个图文解释，理解基数排序的步骤</li>
</ol>
<p><strong>代码实现</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/01/2039115V4GVo.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基数排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：XMD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 1.9.22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">53</span>, <span class="number">3</span>, <span class="number">542</span>, <span class="number">748</span>, <span class="number">14</span>, <span class="number">214</span>&#125;;</span><br><span class="line">        radixSort(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//根据前面的推导过程，我们可以得到最终的基数排序代码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到数组中最大的数的位数</span></span><br><span class="line">        <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到最大数是几位数</span></span><br><span class="line">        <span class="keyword">int</span> maxLenght = (max + <span class="string">&quot;&quot;</span>).length();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一轮 针对每个元素的个位</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义一个二维数组，表示10个桶，每个桶就是一个数组</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//为了防止在放入数的时候，数据溢出，则每个一维数组（桶），大小定为arr.length</span></span><br><span class="line">        <span class="comment">//基数排序是使用空间换时间的经典算法</span></span><br><span class="line">        <span class="keyword">int</span>[][] bucket = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//为了记录每个桶中，实际存放了多少个数据，我们定义一个一维数组来记录各个桶的每次放入的数据个数</span></span><br><span class="line">        <span class="keyword">int</span>[] bucketElementCounts = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里我们使用循环将代码处理</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxLenght; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> digitOfElement = arr[j] / (<span class="keyword">int</span>)Math.pow(<span class="number">10</span>,i) % <span class="number">10</span>;</span><br><span class="line">                <span class="comment">//放入到对应的桶</span></span><br><span class="line">                bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span><br><span class="line">                bucketElementCounts[digitOfElement]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//&#x27;按照这个桶的顺序（一维数组的下标依次取出数据，放入原来数组</span></span><br><span class="line">            <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//遍历每一桶，并将桶中是数据，放入到原数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; bucketElementCounts.length; k++) &#123;</span><br><span class="line">                <span class="comment">//如果桶中，有数据，我们才放入到原数组</span></span><br><span class="line">                <span class="keyword">if</span> (bucketElementCounts[k] != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//循环该桶</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; bucketElementCounts[k]; l++) &#123;</span><br><span class="line">                        <span class="comment">//取出元素放入到arr</span></span><br><span class="line">                        arr[index++] = bucket[k][l];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//第1轮处理后，需要将每个bucketElementCounts[k] =0</span></span><br><span class="line">                bucketElementCounts[k] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span> + i + <span class="number">1</span> + <span class="string">&quot;轮 完成：&quot;</span> + Arrays.toString(arr));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        for (int j = 0; j &lt; arr.length; j++) &#123;</span></span><br><span class="line"><span class="comment">//            int digitOfElement = arr[j] % 10;</span></span><br><span class="line"><span class="comment">//            //放入到对应的桶</span></span><br><span class="line"><span class="comment">//            bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span></span><br><span class="line"><span class="comment">//            bucketElementCounts[digitOfElement]++;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        //&#x27;按照这个桶的顺序（一维数组的下标依次取出数据，放入原来数组</span></span><br><span class="line"><span class="comment">//        int index = 0;</span></span><br><span class="line"><span class="comment">//        //遍历每一桶，并将桶中是数据，放入到原数组</span></span><br><span class="line"><span class="comment">//        for (int k = 0; k &lt; bucketElementCounts.length; k++) &#123;</span></span><br><span class="line"><span class="comment">//            //如果桶中，有数据，我们才放入到原数组</span></span><br><span class="line"><span class="comment">//            if (bucketElementCounts[k] != 0) &#123;</span></span><br><span class="line"><span class="comment">//                //循环该桶</span></span><br><span class="line"><span class="comment">//                for (int l = 0; l &lt; bucketElementCounts[k]; l++) &#123;</span></span><br><span class="line"><span class="comment">//                    //取出元素放入到arr</span></span><br><span class="line"><span class="comment">//                    arr[index++] = bucket[k][l];</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            //第1轮处理后，需要将每个bucketElementCounts[k] =0</span></span><br><span class="line"><span class="comment">//            bucketElementCounts[k] = 0;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;第一轮 完成：&quot; + Arrays.toString(arr));</span></span><br><span class="line"><span class="comment">//        </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        //第二轮</span></span><br><span class="line"><span class="comment">//        for (int j = 0; j &lt; arr.length; j++) &#123;</span></span><br><span class="line"><span class="comment">//            int digitOfElement = arr[j] / 10 % 10;</span></span><br><span class="line"><span class="comment">//            //放入到对应的桶</span></span><br><span class="line"><span class="comment">//            bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span></span><br><span class="line"><span class="comment">//            bucketElementCounts[digitOfElement]++;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        //&#x27;按照这个桶的顺序（一维数组的下标依次取出数据，放入原来数组</span></span><br><span class="line"><span class="comment">//        index = 0;</span></span><br><span class="line"><span class="comment">//        //遍历每一桶，并将桶中是数据，放入到原数组</span></span><br><span class="line"><span class="comment">//        for (int k = 0; k &lt; bucketElementCounts.length; k++) &#123;</span></span><br><span class="line"><span class="comment">//            //如果桶中，有数据，我们才放入到原数组</span></span><br><span class="line"><span class="comment">//            if (bucketElementCounts[k] != 0) &#123;</span></span><br><span class="line"><span class="comment">//                //循环该桶</span></span><br><span class="line"><span class="comment">//                for (int l = 0; l &lt; bucketElementCounts[k]; l++) &#123;</span></span><br><span class="line"><span class="comment">//                    //取出元素放入到arr</span></span><br><span class="line"><span class="comment">//                    arr[index++] = bucket[k][l];</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            //第2轮处理后，需要将每个bucketElementCounts[k] =0</span></span><br><span class="line"><span class="comment">//            bucketElementCounts[k] = 0;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;第二轮 完成：&quot; + Arrays.toString(arr));</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        //第二轮</span></span><br><span class="line"><span class="comment">//        for (int j = 0; j &lt; arr.length; j++) &#123;</span></span><br><span class="line"><span class="comment">//            int digitOfElement = arr[j] / 100 % 10;</span></span><br><span class="line"><span class="comment">//            //放入到对应的桶</span></span><br><span class="line"><span class="comment">//            bucket[digitOfElement][bucketElementCounts[digitOfElement]] = arr[j];</span></span><br><span class="line"><span class="comment">//            bucketElementCounts[digitOfElement]++;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        //&#x27;按照这个桶的顺序（一维数组的下标依次取出数据，放入原来数组</span></span><br><span class="line"><span class="comment">//        index = 0;</span></span><br><span class="line"><span class="comment">//        //遍历每一桶，并将桶中是数据，放入到原数组</span></span><br><span class="line"><span class="comment">//        for (int k = 0; k &lt; bucketElementCounts.length; k++) &#123;</span></span><br><span class="line"><span class="comment">//            //如果桶中，有数据，我们才放入到原数组</span></span><br><span class="line"><span class="comment">//            if (bucketElementCounts[k] != 0) &#123;</span></span><br><span class="line"><span class="comment">//                //循环该桶</span></span><br><span class="line"><span class="comment">//                for (int l = 0; l &lt; bucketElementCounts[k]; l++) &#123;</span></span><br><span class="line"><span class="comment">//                    //取出元素放入到arr</span></span><br><span class="line"><span class="comment">//                    arr[index++] = bucket[k][l];</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            //第3轮处理后，需要将每个bucketElementCounts[k] =0</span></span><br><span class="line"><span class="comment">//            bucketElementCounts[k] = 0;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;第二轮 完成：&quot; + Arrays.toString(arr));</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>说明：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/01/211335LnpLji.png" alt=""></p>
<blockquote>
<p>如果有负数的数组，不用基数排序来排序</p>
</blockquote>
<h2 id="常用排序算法对比"><a href="#常用排序算法对比" class="headerlink" title="常用排序算法对比"></a>常用排序算法对比</h2><p><img data-src="https://xuemingde.com/pages/image/2022/09/01/200549PpYIxU.png" alt=""></p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>内存</tag>
        <tag>函数</tag>
        <tag>数组</tag>
        <tag>变量</tag>
        <tag>索引</tag>
        <tag>Redis</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础11：查找算法</title>
    <url>/posts/1MBYWYZ.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="线性查找算法"><a href="#线性查找算法" class="headerlink" title="线性查找算法"></a>线性查找算法</h2><p>从<code>线性数列中</code>的<code>起始位置依次比较</code>判断数列中<code>是否包含需要查找的数</code>，若<code>找到</code>了直接<code>返回下标</code></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/04/162226NlrtwV.png" alt=""></p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeqSearch</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> search = seqSearch(arr, <span class="number">7</span>);</span><br><span class="line">        <span class="keyword">if</span> (search == -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有找到&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;找到了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里我们实现的线性查找是找到一个满足条件的值，就返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">seqSearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == value) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="二分查找算法"><a href="#二分查找算法" class="headerlink" title="二分查找算法"></a>二分查找算法</h2><blockquote>
<p>查找的数组必须是有序的</p>
</blockquote>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/04/163006ImqIb6.png" alt=""></p>
<p>思路</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/04/164004FYIMqz.png" alt=""></p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：XMD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 4.9.22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">27</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> search = binarySearch(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, <span class="number">9</span>);</span><br><span class="line">        System.out.println(search);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left    左边的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right   右边的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> findVal 要查找的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果找到就返回下标，如果没有找到，就返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> findVal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> midVal = arr[mid];</span><br><span class="line">        <span class="keyword">if</span> (findVal &gt; midVal) &#123;</span><br><span class="line">            <span class="comment">//向右递归</span></span><br><span class="line">            <span class="keyword">return</span> binarySearch(arr, mid + <span class="number">1</span>, right, findVal);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (findVal &lt; midVal) &#123;</span><br><span class="line">            <span class="comment">//向右递归</span></span><br><span class="line">            <span class="keyword">return</span> binarySearch(arr, left, mid - <span class="number">1</span>, findVal);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上面代码存在问题，如果有重复数据，只会返回一个</p>
<p>优化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left    左边的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right   右边的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> findVal 要查找的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 如果找到就返回下标，如果没有找到，就返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">binarySearch2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> findVal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> midVal = arr[mid];</span><br><span class="line">    <span class="keyword">if</span> (findVal &gt; midVal) &#123;</span><br><span class="line">        <span class="comment">//向右递归</span></span><br><span class="line">        <span class="keyword">return</span> binarySearch2(arr, mid + <span class="number">1</span>, right, findVal);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (findVal &lt; midVal) &#123;</span><br><span class="line">        <span class="comment">//向右递归</span></span><br><span class="line">        <span class="keyword">return</span> binarySearch2(arr, left, mid - <span class="number">1</span>, findVal);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        思路分析</span></span><br><span class="line"><span class="comment">        1。在找到mid索引值，不要马上返回</span></span><br><span class="line"><span class="comment">        2。向mid索引值的左边扫描，将所有满足查询数字，的元素的下标，加入到集合ArrayList</span></span><br><span class="line"><span class="comment">        3。向mid索引值的右边扫描，将所有满足查询数字，的元素的下标，加入到集合ArrayList</span></span><br><span class="line"><span class="comment">        4.将Arraylist返回</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//索引值的左边扫描，将所有满足查询数字，的元素的下标，加入到集合ArrayList</span></span><br><span class="line">        <span class="keyword">int</span> temp = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp &lt; <span class="number">0</span> || arr[temp] != findVal) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//否则，就temp放入到list</span></span><br><span class="line">            list.add(temp);</span><br><span class="line">            temp--;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(mid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//向mid索引值的右边扫描，将所有满足查询数字,的元素的下标，加入到集合ArrayList</span></span><br><span class="line">        temp = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp &gt; arr.length - <span class="number">1</span> || arr[temp] != findVal) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//否则，就temp放入到list</span></span><br><span class="line">            list.add(temp);</span><br><span class="line">            temp++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插值查找算法"><a href="#插值查找算法" class="headerlink" title="插值查找算法"></a>插值查找算法</h2><p><img data-src="https://xuemingde.com/pages/image/2022/09/05/184209Hy0kLN.png" alt=""></p>
<p>公式：<code>int mid = left + (right -left) * (findVal - arr[left]) / (arr[right] - arr[left])</code></p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插值算法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：XMD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 5.9.22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsetValueSearch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">20</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            arr[i] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> search = insetValueSearch(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, <span class="number">15</span>);</span><br><span class="line">        System.out.println(search);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> findVal</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">insetValueSearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> findVal)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WWWWWW&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right || findVal &lt; arr[<span class="number">0</span>] || findVal &gt; arr[arr.length - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]);</span><br><span class="line">        <span class="keyword">int</span> midVal = arr[mid];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (findVal &gt; midVal) &#123;</span><br><span class="line">            <span class="comment">//向右递归</span></span><br><span class="line">            <span class="keyword">return</span> insetValueSearch(arr, mid + <span class="number">1</span>, right, findVal);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (findVal &lt; midVal) &#123;</span><br><span class="line">            <span class="comment">//向右递归</span></span><br><span class="line">            <span class="keyword">return</span> insetValueSearch(arr, left, mid - <span class="number">1</span>, findVal);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意事项</p>
<blockquote>
<ul>
<li>对于数据量较大，<strong>关键字分布比较均匀</strong>的查找表来说，采用插值查找，速度较快.</li>
<li>关键字分布不均匀的情况下，该方法不一定比折半查找要好</li>
</ul>
</blockquote>
<h2 id="斐波那契（黄金分割法）查找算法"><a href="#斐波那契（黄金分割法）查找算法" class="headerlink" title="斐波那契（黄金分割法）查找算法"></a>斐波那契（黄金分割法）查找算法</h2><ol>
<li>黄金分割点是指把一条线段分割为两部分，使其中一部分与全长之比等于另一部分与这部分之比。取其前三位数字的近似值是0.618。由于按此比例设计的造型十分美丽，因此称为黄金分割，也称为中外比。这是一个神奇的数字，会带来意向不大的效果。</li>
<li>斐波那契数列{1,1,2,3,5,8,13,21,34,55}发现斐波那契数列的两个相邻数的比例，无限接近黄金分割值0.618</li>
</ol>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/05/190728QRsCDP.png" alt=""></p>
<p><strong>工作原理</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/05/191108WLQsTB.png" alt=""></p>
<p><strong>斐波那契查找应用案例</strong><br>请对一个有序数组进行斐波那契查找{1,8,10,89,1000,1234}，输入一个数看看该数组是否存在此数，并且求出下标，如果没有就提示”没有这个数</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 斐波那契查找算法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：XMD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 5.9.22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FibonacciSearch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> maxSize = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">89</span>, <span class="number">1000</span>, <span class="number">1234</span>&#125;;</span><br><span class="line"><span class="comment">//        int[] fibo = fibo();</span></span><br><span class="line"><span class="comment">//        System.out.println(Arrays.toString(fibo));</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> search = fibSearch(arr, <span class="number">10</span>);</span><br><span class="line">        System.out.println(search);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为后面我们mid=1ow+F(k-1)-1,需要使用到斐波那契数列，因此我们需要先获取到一个斐波那契数列</span></span><br><span class="line">    <span class="comment">//非递归方法得到一个斐波那契数列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] fibo() &#123;</span><br><span class="line">        <span class="keyword">int</span>[] fb = <span class="keyword">new</span> <span class="keyword">int</span>[maxSize];</span><br><span class="line">        fb[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        fb[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; maxSize; i++) &#123;</span><br><span class="line">            fb[i] = fb[i - <span class="number">1</span>] + fb[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编写斐波那契查找算法</span></span><br><span class="line"><span class="comment">     * 使用非递归的方式编写算法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibSearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//表示斐波那契分割数值的下标</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid;</span><br><span class="line">        <span class="comment">//获取到斐波那契数列</span></span><br><span class="line">        <span class="keyword">int</span>[] f = fibo();</span><br><span class="line">        <span class="comment">//获取到斐波那契分割数值的下标</span></span><br><span class="line">        <span class="keyword">while</span> (high &gt; f[k] - <span class="number">1</span>) &#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">///因为f[k]值可能大于a的长度，因此我们需要使用Arrays类，构造一个新的数组，并指向temp[]</span></span><br><span class="line">        <span class="keyword">int</span>[] temp = Arrays.copyOf(arr, f[k]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实际上需求使用a数组最后的数填充temp</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = high + <span class="number">1</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">            temp[i] = arr[high];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用while来循环处理，找到我们的数key</span></span><br><span class="line">        <span class="comment">//只要这个条件满足，就可以找</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            mid = low + f[k - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//我们应该继续向数组的前面查找（左边）</span></span><br><span class="line">            <span class="keyword">if</span> (key &lt; temp[mid]) &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                //为什么是k--</span></span><br><span class="line"><span class="comment">                //说明</span></span><br><span class="line"><span class="comment">                //1,全部元素=前面的元素+后边元素</span></span><br><span class="line"><span class="comment">                //2.f[k]=f[k-1]+f[k-2]</span></span><br><span class="line"><span class="comment">                /因为前面有f[k-1]个元素，所以可以继续折分f[k-1]=f[k-2]+f[k-3]</span></span><br><span class="line"><span class="comment">                //即在f[k-1]的前面继续查找k--</span></span><br><span class="line"><span class="comment">                //即下次循环mid=f[k-1-1]-1</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                k--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; temp[mid]) &#123;</span><br><span class="line">                <span class="comment">//我们应该继续向数组的后面查找（右边）</span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                //为什么是k-=2</span></span><br><span class="line"><span class="comment">                //说明</span></span><br><span class="line"><span class="comment">                //1,全部元素=</span></span><br><span class="line"><span class="comment">                前面的元素+后边元素</span></span><br><span class="line"><span class="comment">                //2.f[k]=f[k-1]+f[k-2]</span></span><br><span class="line"><span class="comment">                //3.因为后面我们有f[k-2]所以可以继续拆分f[k-1]=f[k-3]+f[k-4]</span></span><br><span class="line"><span class="comment">                //4。即在f[k-2]的前面进行查找k-=2</span></span><br><span class="line"><span class="comment">                //5,即下次循环mid=f[k-1-2]-1</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                k -= <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//需要确定，返回的是娜个下标</span></span><br><span class="line">                <span class="keyword">if</span> (mid &lt;= high) &#123;</span><br><span class="line">                    <span class="keyword">return</span> mid;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> high;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有点难理解</p>
</blockquote>
]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>集合</tag>
        <tag>数组</tag>
        <tag>索引</tag>
        <tag>MQ</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础12：哈希表</title>
    <url>/posts/3B8XTQD.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>哈希表是一个数据结构，不是算法</p>
</blockquote>
<p>看一个实际需求，google公司的一个上机题：</p>
<blockquote>
<p>有一个公司，当有新的员工来报道时，要求将该员工的信息加入(id，性别，年龄，住址)，当输入该员工的id时，要求查找到该员工的所有信息.<br>要求：不使用数据库，尽量节省内存，速度越快越好=&gt;哈希表（散列）</p>
</blockquote>
<p><strong>基本介绍</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/05/204753yn8Epo.png" alt=""></p>
<p><strong>练习</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/05/205805UeJKmM.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/05/215905ul1eGQ.png" alt=""></p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈希表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：XMD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 5.9.22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashTabDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashTab hashTab = <span class="keyword">new</span> HashTab(<span class="number">7</span>);</span><br><span class="line">        String key = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;add:添加雇员&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;list:显示雇员&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;find:查找雇员&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;exit:退出系统&quot;</span>);</span><br><span class="line">            key = scanner.next();</span><br><span class="line">            <span class="keyword">switch</span> (key) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;add&quot;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;输入ID&quot;</span>);</span><br><span class="line">                    <span class="keyword">int</span> anInt = scanner.nextInt();</span><br><span class="line">                    System.out.println(<span class="string">&quot;输入名字&quot;</span>);</span><br><span class="line">                    String next = scanner.next();</span><br><span class="line">                    Emp emp = <span class="keyword">new</span> Emp(anInt, next);</span><br><span class="line">                    hashTab.add(emp);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;list&quot;</span>:</span><br><span class="line">                    hashTab.list();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;find&quot;</span>:</span><br><span class="line">                    System.out.println(<span class="string">&quot;输入查找的ID&quot;</span>);</span><br><span class="line">                    <span class="keyword">int</span> fid = scanner.nextInt();</span><br><span class="line">                    hashTab.findEmpById(fid);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;exit&quot;</span>:</span><br><span class="line">                    scanner.close();</span><br><span class="line">                    System.exit(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTab</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> EmpLinkedList[] empLinkedListArray;</span><br><span class="line">    <span class="comment">//链表个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashTab</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">this</span>.empLinkedListArray = <span class="keyword">new</span> EmpLinkedList[size];</span><br><span class="line">        <span class="comment">//分别初始化每个链表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            empLinkedListArray[i] = <span class="keyword">new</span> EmpLinkedList();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Emp emp)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//根据员工的id,得到该员工应当添加到哪条链表</span></span><br><span class="line">        <span class="keyword">int</span> empLinkedListNo = hashFun(emp.id);</span><br><span class="line">        <span class="comment">//将emp添加到对应的链表中</span></span><br><span class="line">        empLinkedListArray[empLinkedListNo].add(emp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历所有的链表，遍历hashtab</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            empLinkedListArray[i].list(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findEmpById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fun = hashFun(id);</span><br><span class="line">        Emp emp = empLinkedListArray[fun].findEmpById(id);</span><br><span class="line">        <span class="keyword">if</span> (emp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(emp.id + <span class="string">&quot;&gt;&gt;&quot;</span> + emp.name);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;没有找到&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashFun</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id % size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Emp</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="comment">//默认为空</span></span><br><span class="line">    <span class="keyword">public</span> Emp next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Emp</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建EmpLinkedList,表示链表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmpLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="comment">//头指针，执行第一个Emp,因此我们这个链表的head是直接指向第一个mp</span></span><br><span class="line">    <span class="keyword">public</span> Emp head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加雇员到链表</span></span><br><span class="line">    <span class="comment">//说明</span></span><br><span class="line">    <span class="comment">//1,假定，当添加雇员时，id是自增长，即id的分配总是从小到大</span></span><br><span class="line">    <span class="comment">//因此我们将该雇员直接加入到本链表的最后即可</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Emp emp)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果是添加第一个雇员</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            head = emp;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果不是第一个雇员，则使用一个辅助的指针，帮助定位到最后</span></span><br><span class="line">        Emp curEmp = head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curEmp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curEmp = curEmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//退出时直接将emp加入链表</span></span><br><span class="line">        curEmp.next = emp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历链表的雇员信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">list</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(no + <span class="string">&quot;个链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Emp curEmp = head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(no + <span class="string">&quot;--id = &quot;</span> + curEmp.id);</span><br><span class="line">            <span class="keyword">if</span> (curEmp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//说明curEmp已经是最后结点</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curEmp = curEmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果查找到，就返回Emp,如果没有找到，就返回nul1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Emp <span class="title">findEmpById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;链表为空&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Emp curEmp = head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curEmp.id == id) &#123;</span><br><span class="line">                <span class="comment">//说明curEmp已经是最后结点</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curEmp.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//说明curEmp已经是最后结点</span></span><br><span class="line">                curEmp = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curEmp = curEmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curEmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>内存</tag>
        <tag>数据库</tag>
        <tag>指针</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础13：数结构</title>
    <url>/posts/6ZR6PR.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h1><p><strong>为什么要学习树结构</strong></p>
<ol>
<li><p>数组存储方式的分析</p>
<p>优点：通过下标方式访问元素，速度快。对于有序数组，还可使用二分查找提高检素速度。</p>
<p>缺点：如果要检素具体某个值，或者插入值（按一定顺序）会整体移动，效率较低。</p>
</li>
<li><p>链式存储方式的分析</p>
<p>优点：在一定程度上对数组存储方式有优化（比如：插入一个数值节点，只需要将插入节点，链接到链表中即可，删除效率也很好)。</p>
<p>缺点：在进行检素时，效率仍然较低，比如（检素某个值，需要从头节点开始遍历）</p>
</li>
<li><p>树存储方式的分析</p>
<p>能提高数据存储，读取的效率，比如利用二叉排序树(Binary Sort Tree),既可以保证数据的检索速度，同时也可以保证数据的插入，别除，修改的速度。<br>案例：[7,3,10,1,5,9,12]</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/06/201523TcspG8.png" alt=""></p>
</li>
</ol>
<p><strong>常用术语</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/06/201638RTXrsk.png" alt=""></p>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p><img data-src="https://xuemingde.com/pages/image/2022/09/06/202515frPbXW.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/06/202729ET2zUk.png" alt=""></p>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>需求说明</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/07/192116LEWLMk.png" alt=""></p>
<p>二叉树的遍历思路分析</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/07/192943K6YAS2.png" alt=""></p>
<p><strong>前序遍历、中序遍历、后序遍历</strong>  代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BinaryTree binaryTree = <span class="keyword">new</span> BinaryTree();</span><br><span class="line">        HeroNode node1 = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>);</span><br><span class="line">        HeroNode node2 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">&quot;无用&quot;</span>);</span><br><span class="line">        HeroNode node3 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">&quot;卢俊义&quot;</span>);</span><br><span class="line">        HeroNode node4 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>);</span><br><span class="line"><span class="comment">//        HeroNode node5 = new HeroNode(5, &quot;关胜&quot;);</span></span><br><span class="line"></span><br><span class="line">        node1.setLeft(node2);</span><br><span class="line">        node1.setRight(node3);</span><br><span class="line">        node3.setRight(node4);</span><br><span class="line"><span class="comment">//        node3.setLeft(node5);</span></span><br><span class="line"></span><br><span class="line">        binaryTree.setRoot(node1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历&quot;</span>);</span><br><span class="line">        binaryTree.preOrder();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历&quot;</span>);</span><br><span class="line">        binaryTree.infixOrder();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历&quot;</span>);</span><br><span class="line">        binaryTree.postOrder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HeroNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(HeroNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root.preOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root.infixOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root.postOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HeroNode left;</span><br><span class="line">    <span class="keyword">private</span> HeroNode right;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(HeroNode left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(HeroNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先输出父节点</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//递归向左子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归向右子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归向左子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先输出父节点</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//递归向右子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归向左子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归向右子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先输出父节点</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<p>前序遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HeroNode&#123;no=<span class="number">1</span>, name=<span class="string">&#x27;宋江&#x27;</span>&#125;</span><br><span class="line">HeroNode&#123;no=<span class="number">2</span>, name=<span class="string">&#x27;无用&#x27;</span>&#125;</span><br><span class="line">HeroNode&#123;no=<span class="number">3</span>, name=<span class="string">&#x27;卢俊义&#x27;</span>&#125;</span><br><span class="line">HeroNode&#123;no=<span class="number">4</span>, name=<span class="string">&#x27;林冲&#x27;</span>&#125;</span><br><span class="line">中序遍历</span><br><span class="line">HeroNode&#123;no=<span class="number">2</span>, name=<span class="string">&#x27;无用&#x27;</span>&#125;</span><br><span class="line">HeroNode&#123;no=<span class="number">1</span>, name=<span class="string">&#x27;宋江&#x27;</span>&#125;</span><br><span class="line">HeroNode&#123;no=<span class="number">3</span>, name=<span class="string">&#x27;卢俊义&#x27;</span>&#125;</span><br><span class="line">HeroNode&#123;no=<span class="number">4</span>, name=<span class="string">&#x27;林冲&#x27;</span>&#125;</span><br><span class="line">中序遍历</span><br><span class="line">HeroNode&#123;no=<span class="number">2</span>, name=<span class="string">&#x27;无用&#x27;</span>&#125;</span><br><span class="line">HeroNode&#123;no=<span class="number">4</span>, name=<span class="string">&#x27;林冲&#x27;</span>&#125;</span><br><span class="line">HeroNode&#123;no=<span class="number">3</span>, name=<span class="string">&#x27;卢俊义&#x27;</span>&#125;</span><br><span class="line">HeroNode&#123;no=<span class="number">1</span>, name=<span class="string">&#x27;宋江&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的查找"><a href="#二叉树的查找" class="headerlink" title="二叉树的查找"></a>二叉树的查找</h2><p>需求说明</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/07/195957YmgYDW.png" alt=""></p>
<p>思路分析</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/07/201950DX4zby.png" alt=""></p>
<p><strong>前序查找、中序查找、后序查找</strong>  代码 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BinaryTree binaryTree = <span class="keyword">new</span> BinaryTree();</span><br><span class="line">        HeroNode node1 = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>);</span><br><span class="line">        HeroNode node2 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">&quot;无用&quot;</span>);</span><br><span class="line">        HeroNode node3 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">&quot;卢俊义&quot;</span>);</span><br><span class="line">        HeroNode node4 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>);</span><br><span class="line"><span class="comment">//        HeroNode node5 = new HeroNode(5, &quot;关胜&quot;);</span></span><br><span class="line"></span><br><span class="line">        node1.setLeft(node2);</span><br><span class="line">        node1.setRight(node3);</span><br><span class="line">        node3.setRight(node4);</span><br><span class="line"><span class="comment">//        node3.setLeft(node5);</span></span><br><span class="line"></span><br><span class="line">        binaryTree.setRoot(node1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;前序遍历&quot;);</span></span><br><span class="line"><span class="comment">//        binaryTree.preOrder();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;中序遍历&quot;);</span></span><br><span class="line"><span class="comment">//        binaryTree.infixOrder();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;中序遍历&quot;);</span></span><br><span class="line"><span class="comment">//        binaryTree.postOrder();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;前序遍历&quot;</span>);</span><br><span class="line">        HeroNode heroNode1 = binaryTree.preOrderSearch(<span class="number">2</span>);</span><br><span class="line">        System.out.println(heroNode1);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历&quot;</span>);</span><br><span class="line">        HeroNode heroNode2 =  binaryTree.infixOrderSearch(<span class="number">3</span>);</span><br><span class="line">        System.out.println(heroNode2);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历&quot;</span>);</span><br><span class="line">        HeroNode heroNode3 = binaryTree.postOrderSearch(<span class="number">4</span>);</span><br><span class="line">        System.out.println(heroNode3);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HeroNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(HeroNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root.preOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root.infixOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root.postOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">preOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        HeroNode heroNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            heroNode = <span class="keyword">this</span>.root.preOrderSearch(no);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法查找&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">infixOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        HeroNode heroNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            heroNode = <span class="keyword">this</span>.root.infixOrderSearch(no);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法查找&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">postOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        HeroNode heroNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            heroNode = <span class="keyword">this</span>.root.postOrderSearch(no);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法查找&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HeroNode left;</span><br><span class="line">    <span class="keyword">private</span> HeroNode right;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(HeroNode left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(HeroNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先输出父节点</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//递归向左子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归向右子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归向左子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先输出父节点</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//递归向右子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归向左子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归向右子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先输出父节点</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前序查找</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> no 查找条件 编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果返回节点信息 没有找到返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">preOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.no == no) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1,则判断当前结点的左子节点是否为空，如果不为空，则递归前序查找</span></span><br><span class="line">        <span class="comment">//2,如果左递归前序查找，找到结点，则返回</span></span><br><span class="line">        HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resNode = <span class="keyword">this</span>.left.preOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1,左递归前序查找，找到结点，则返回，否继续判断，</span></span><br><span class="line">        <span class="comment">//2,当前的结点的右子节点是否为空，如果不空，则继续向右递归前序查找</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resNode = <span class="keyword">this</span>.right.preOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中序查找</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> no 查找条件 编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果返回节点信息 没有找到返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">infixOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断当前结点的左子节点是否为空，如果不为空，则递归中序查找</span></span><br><span class="line">        HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resNode = <span class="keyword">this</span>.left.infixOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果找到，则返回，如果没有找到，就和当前结点比较，如果是则返回当前结点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.no == no) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resNode = <span class="keyword">this</span>.right.infixOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中序查找</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> no 查找条件 编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果返回节点信息 没有找到返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">postOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断当前结点的左子节点是否为空，如果不为空，则递归中序查找</span></span><br><span class="line">        HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resNode = <span class="keyword">this</span>.left.postOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resNode = <span class="keyword">this</span>.right.infixOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果找到，则返回，如果没有找到，就和当前结点比较，如果是则返回当前结点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.no == no) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="二叉树的删除结点"><a href="#二叉树的删除结点" class="headerlink" title="二叉树的删除结点"></a>二叉树的删除结点</h2><p>需求说明</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/07/2057448A2ekm.png" alt=""></p>
<p>思路分析</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/07/211914Blp8p5.png" alt=""></p>
<p>删除结点 代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTreeDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BinaryTree binaryTree = <span class="keyword">new</span> BinaryTree();</span><br><span class="line">        HeroNode node1 = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>);</span><br><span class="line">        HeroNode node2 = <span class="keyword">new</span> HeroNode(<span class="number">2</span>, <span class="string">&quot;无用&quot;</span>);</span><br><span class="line">        HeroNode node3 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">&quot;卢俊义&quot;</span>);</span><br><span class="line">        HeroNode node4 = <span class="keyword">new</span> HeroNode(<span class="number">4</span>, <span class="string">&quot;林冲&quot;</span>);</span><br><span class="line">        HeroNode node5 = <span class="keyword">new</span> HeroNode(<span class="number">5</span>, <span class="string">&quot;关胜&quot;</span>);</span><br><span class="line"></span><br><span class="line">        node1.setLeft(node2);</span><br><span class="line">        node1.setRight(node3);</span><br><span class="line">        node3.setRight(node4);</span><br><span class="line">        node3.setLeft(node5);</span><br><span class="line"></span><br><span class="line">        binaryTree.setRoot(node1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;前序遍历&quot;);</span></span><br><span class="line"><span class="comment">//        binaryTree.preOrder();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;中序遍历&quot;);</span></span><br><span class="line"><span class="comment">//        binaryTree.infixOrder();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;中序遍历&quot;);</span></span><br><span class="line"><span class="comment">//        binaryTree.postOrder();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(&quot;前序遍历&quot;);</span></span><br><span class="line"><span class="comment">//        HeroNode heroNode1 = binaryTree.preOrderSearch(2);</span></span><br><span class="line"><span class="comment">//        System.out.println(heroNode1);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;中序遍历&quot;);</span></span><br><span class="line"><span class="comment">//        HeroNode heroNode2 = binaryTree.infixOrderSearch(3);</span></span><br><span class="line"><span class="comment">//        System.out.println(heroNode2);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;中序遍历&quot;);</span></span><br><span class="line"><span class="comment">//        HeroNode heroNode3 = binaryTree.postOrderSearch(4);</span></span><br><span class="line"><span class="comment">//        System.out.println(heroNode3);</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;删除前&quot;</span>);</span><br><span class="line">        binaryTree.infixOrder();</span><br><span class="line">        binaryTree.delOrder(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;删除后&quot;</span>);</span><br><span class="line">        binaryTree.infixOrder();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HeroNode root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(HeroNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delOrder</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root.delNode(no);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法删除&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root.preOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root.infixOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root.postOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">preOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        HeroNode heroNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            heroNode = <span class="keyword">this</span>.root.preOrderSearch(no);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法查找&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">infixOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        HeroNode heroNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            heroNode = <span class="keyword">this</span>.root.infixOrderSearch(no);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法查找&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">postOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        HeroNode heroNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            heroNode = <span class="keyword">this</span>.root.postOrderSearch(no);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法查找&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HeroNode left;</span><br><span class="line">    <span class="keyword">private</span> HeroNode right;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(HeroNode left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(HeroNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归删除结点</span></span><br><span class="line">    <span class="comment">//1,如果删除的节点是叶子节点，则侧删除该节点</span></span><br><span class="line">    <span class="comment">//2,如果删除的节点是非叶子节点，则删除该子树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//思路</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1。因为我们的二叉树是单向的，所以我们是判断当前结点的子结点是否需要删除结点，而不能去判断当前这个结点是不是需要删除结，</span></span><br><span class="line"><span class="comment">        2。如果当前结点的左子结点不为空，并且左子结点就是要删除结点，就将this.1eft=null;并且就返回（结束递归删除）</span></span><br><span class="line"><span class="comment">        3,如果当前结点的右子结点不为空，并且右子结点就是要删除结点，就将this,right=ul1;并且就返回（结束递归删除）</span></span><br><span class="line"><span class="comment">        4。如果第2和第3步没有删除结点，那么我们就需要向左子树进行递归删除</span></span><br><span class="line"><span class="comment">        5。如果第4步也没有删除结点，则应当向右子树进行递归删除，</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">        <span class="comment">//2如果当前结点的左子结点不为空，并且左子结点就是要删除结点，就将this,1eft=nu11;并且就返回（结束递归删除）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.no == no)&#123;</span><br><span class="line">            <span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3,如果当前结点的右子结点不为空，并且右子结点就是要删除结点，就将this,right=nu11;并且就返回（结束递归删除）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.no == no)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4,我们就需要向左子树进行递归删除</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.left.delNode(no);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.right.delNode(no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先输出父节点</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//递归向左子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归向右子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归向左子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先输出父节点</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//递归向右子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归向左子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归向右子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先输出父节点</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前序查找</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> no 查找条件 编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果返回节点信息 没有找到返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">preOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.no == no) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1,则判断当前结点的左子节点是否为空，如果不为空，则递归前序查找</span></span><br><span class="line">        <span class="comment">//2,如果左递归前序查找，找到结点，则返回</span></span><br><span class="line">        HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resNode = <span class="keyword">this</span>.left.preOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1,左递归前序查找，找到结点，则返回，否继续判断，</span></span><br><span class="line">        <span class="comment">//2,当前的结点的右子节点是否为空，如果不空，则继续向右递归前序查找</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resNode = <span class="keyword">this</span>.right.preOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中序查找</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> no 查找条件 编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果返回节点信息 没有找到返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">infixOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断当前结点的左子节点是否为空，如果不为空，则递归中序查找</span></span><br><span class="line">        HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resNode = <span class="keyword">this</span>.left.infixOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果找到，则返回，如果没有找到，就和当前结点比较，如果是则返回当前结点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.no == no) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resNode = <span class="keyword">this</span>.right.infixOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中序查找</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> no 查找条件 编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果返回节点信息 没有找到返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">postOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断当前结点的左子节点是否为空，如果不为空，则递归中序查找</span></span><br><span class="line">        HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resNode = <span class="keyword">this</span>.left.postOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resNode = <span class="keyword">this</span>.right.infixOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果找到，则返回，如果没有找到，就和当前结点比较，如果是则返回当前结点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.no == no) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/07/213422ixm0gf.png" alt=""></p>
<h2 id="顺序存储二叉树"><a href="#顺序存储二叉树" class="headerlink" title="顺序存储二叉树"></a>顺序存储二叉树</h2><p><img data-src="https://xuemingde.com/pages/image/2022/09/13/181740Rp6xai.png" alt=""></p>
<p>要求：</p>
<ol>
<li>右图的二叉树的结点，要求以数组的方式来存放arr:[1,2,3,4,5,6,6]</li>
<li>要求在遍历数组arr时，仍然可以以前序遍历，中序遍历和后序遍历的方式完成结点的遍历</li>
</ol>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/13/182503Ult0Nu.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/13/185849piQtn5.png" alt=""></p>
<p><strong>代码实现 (前序遍历)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrBinaryTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line"></span><br><span class="line">        ArrBinaryTree arrBinaryTree = <span class="keyword">new</span> ArrBinaryTree(arr);</span><br><span class="line">        arrBinaryTree.preOrder();<span class="comment">//1 2 4 5 3 6 7</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//编写一个ArrayBinaryTree,实现顺序存储二叉树遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ArrBinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="comment">//存储数据节点的数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrBinaryTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arr = arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.preOrder(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编写一个方法，完成顺序存储二叉树的前序遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 数组下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果数组为空，或者arr,length=0</span></span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;数组为空，不能按照二叉树的前序遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出当前这个元素</span></span><br><span class="line">        System.out.println(arr[index]);</span><br><span class="line">        <span class="comment">//向左递归遍历</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="number">2</span> * index + <span class="number">1</span>) &lt; arr.length) &#123;</span><br><span class="line">            preOrder(<span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//向右递归遍历</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="number">2</span> * index + <span class="number">2</span>) &lt; arr.length) &#123;</span><br><span class="line">            preOrder(<span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>中序遍历、后序遍历 就不写了</p>
<p>顺序存储二叉树应用实例<br>八大排序算法中的堆排序，就会使用到顺序存储二叉树，关于堆排序，我们放在&lt;&lt;树结构实际应用&gt;&gt;章节讲解。</p>
</blockquote>
<h2 id="线索化二叉树"><a href="#线索化二叉树" class="headerlink" title="线索化二叉树"></a>线索化二叉树</h2><p><img data-src="https://xuemingde.com/pages/image/2022/09/13/191957qwNvEM.png" alt=""></p>
<p>问题分析：</p>
<ol>
<li>当我们对上面的二叉树进行中序遍历时，数列为8,3,10,1,6,14}</li>
<li>但是6,8,10,14这几个节点的左右指针，并没有完全的利用上</li>
<li>如果我们希望充分的利用各个节点的左右指针，让各个节点可以指向自己的前后节点怎么办？</li>
<li>解决方案  <strong>线索二又树</strong></li>
</ol>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/13/1928338bhLf8.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/13/193359WQaUvq.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/13/193859kKdS5g.png" alt=""></p>
<p><strong>代码实现（比较难理解）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreadedBinaryTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HeroNode node1 = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>);</span><br><span class="line">        HeroNode node3 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">&quot;吴用&quot;</span>);</span><br><span class="line">        HeroNode node6 = <span class="keyword">new</span> HeroNode(<span class="number">6</span>, <span class="string">&quot;卢俊义&quot;</span>);</span><br><span class="line">        HeroNode node8 = <span class="keyword">new</span> HeroNode(<span class="number">8</span>, <span class="string">&quot;林冲&quot;</span>);</span><br><span class="line">        HeroNode node10 = <span class="keyword">new</span> HeroNode(<span class="number">10</span>, <span class="string">&quot;关胜&quot;</span>);</span><br><span class="line">        HeroNode node14 = <span class="keyword">new</span> HeroNode(<span class="number">14</span>, <span class="string">&quot;武松&quot;</span>);</span><br><span class="line"></span><br><span class="line">        node1.setLeft(node3);</span><br><span class="line">        node1.setRight(node6);</span><br><span class="line"></span><br><span class="line">        node3.setLeft(node8);</span><br><span class="line">        node3.setRight(node10);</span><br><span class="line"></span><br><span class="line">        node6.setLeft(node14);</span><br><span class="line"></span><br><span class="line">        TreadedBinaryTree binaryTree = <span class="keyword">new</span> TreadedBinaryTree();</span><br><span class="line">        binaryTree.setRoot(node1);</span><br><span class="line">        binaryTree.treadedNodes();</span><br><span class="line"></span><br><span class="line">        HeroNode node10Left = node10.getLeft();</span><br><span class="line">        System.out.println(<span class="string">&quot;node10 前驱：&quot;</span> + node10Left);</span><br><span class="line"></span><br><span class="line">        HeroNode node10Right = node10.getRight();</span><br><span class="line">        System.out.println(<span class="string">&quot;node10 后驱：&quot;</span> + node10Right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreadedBinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HeroNode root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了实现线索化，需要创建要给指向当前结点的前驱结点的指针</span></span><br><span class="line">    <span class="comment">//在递归进行线索化时，pre总是保留前一个结点</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode pre = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(HeroNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">treadedNodes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.treadedNodes(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * //编写对二叉树进行中序线索化的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 就是当前需要线索化的结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">treadedNodes</span><span class="params">(HeroNode node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果node==nu1ll,不能线素化</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">///(一)先线素化左子树</span></span><br><span class="line">        treadedNodes(node.getLeft());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//(二)线素化当前结点[有难度]</span></span><br><span class="line">        <span class="comment">//处理当前结点的前驱结点</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeft() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//让当前结点的左指针指向前驱结点</span></span><br><span class="line">            node.setLeft(pre);</span><br><span class="line">            <span class="comment">//修改当前结点的左指针的类型</span></span><br><span class="line">            node.setLeftType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理后继结点</span></span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="keyword">null</span> &amp;&amp; pre.getRight() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            pre.setRight(node);</span><br><span class="line">            pre.setRightType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//!!!每处理一个结点后，让当前结点是下一个结点的前驱结点</span></span><br><span class="line">        pre = node;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//(三)在线索化右子树</span></span><br><span class="line">        treadedNodes(node.getRight());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delOrder</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root.delNode(no);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法删除&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root.preOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root.infixOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root.postOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">preOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        HeroNode heroNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            heroNode = <span class="keyword">this</span>.root.preOrderSearch(no);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法查找&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">infixOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        HeroNode heroNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            heroNode = <span class="keyword">this</span>.root.infixOrderSearch(no);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法查找&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">postOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        HeroNode heroNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            heroNode = <span class="keyword">this</span>.root.postOrderSearch(no);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法查找&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HeroNode left;</span><br><span class="line">    <span class="keyword">private</span> HeroNode right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//说明</span></span><br><span class="line">    <span class="comment">//1。如果1 eftType=0表示指向的是左子树，如果1则表示指向前驱结点</span></span><br><span class="line">    <span class="comment">//2,如果rightType=0表示指向是右子树，如果1表示指向后继结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> leftType;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rightType;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLeftType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeftType</span><span class="params">(<span class="keyword">int</span> leftType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.leftType = leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRightType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRightType</span><span class="params">(<span class="keyword">int</span> rightType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rightType = rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(HeroNode left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(HeroNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归删除结点</span></span><br><span class="line">    <span class="comment">//1,如果删除的节点是叶子节点，则侧删除该节点</span></span><br><span class="line">    <span class="comment">//2,如果删除的节点是非叶子节点，则删除该子树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//思路</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1。因为我们的二叉树是单向的，所以我们是判断当前结点的子结点是否需要删除结点，而不能去判断当前这个结点是不是需要删除结，</span></span><br><span class="line"><span class="comment">        2。如果当前结点的左子结点不为空，并且左子结点就是要删除结点，就将this.1eft=null;并且就返回（结束递归删除）</span></span><br><span class="line"><span class="comment">        3,如果当前结点的右子结点不为空，并且右子结点就是要删除结点，就将this,right=ul1;并且就返回（结束递归删除）</span></span><br><span class="line"><span class="comment">        4。如果第2和第3步没有删除结点，那么我们就需要向左子树进行递归删除</span></span><br><span class="line"><span class="comment">        5。如果第4步也没有删除结点，则应当向右子树进行递归删除，</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">        <span class="comment">//2如果当前结点的左子结点不为空，并且左子结点就是要删除结点，就将this,1eft=nu11;并且就返回（结束递归删除）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.no == no) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3,如果当前结点的右子结点不为空，并且右子结点就是要删除结点，就将this,right=nu11;并且就返回（结束递归删除）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.no == no) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4,我们就需要向左子树进行递归删除</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.delNode(no);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right.delNode(no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先输出父节点</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//递归向左子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归向右子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归向左子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先输出父节点</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//递归向右子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归向左子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归向右子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先输出父节点</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前序查找</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> no 查找条件 编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果返回节点信息 没有找到返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">preOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.no == no) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1,则判断当前结点的左子节点是否为空，如果不为空，则递归前序查找</span></span><br><span class="line">        <span class="comment">//2,如果左递归前序查找，找到结点，则返回</span></span><br><span class="line">        HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resNode = <span class="keyword">this</span>.left.preOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1,左递归前序查找，找到结点，则返回，否继续判断，</span></span><br><span class="line">        <span class="comment">//2,当前的结点的右子节点是否为空，如果不空，则继续向右递归前序查找</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resNode = <span class="keyword">this</span>.right.preOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中序查找</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> no 查找条件 编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果返回节点信息 没有找到返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">infixOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断当前结点的左子节点是否为空，如果不为空，则递归中序查找</span></span><br><span class="line">        HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resNode = <span class="keyword">this</span>.left.infixOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果找到，则返回，如果没有找到，就和当前结点比较，如果是则返回当前结点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.no == no) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resNode = <span class="keyword">this</span>.right.infixOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中序查找</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> no 查找条件 编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果返回节点信息 没有找到返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">postOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断当前结点的左子节点是否为空，如果不为空，则递归中序查找</span></span><br><span class="line">        HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resNode = <span class="keyword">this</span>.left.postOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resNode = <span class="keyword">this</span>.right.infixOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果找到，则返回，如果没有找到，就和当前结点比较，如果是则返回当前结点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.no == no) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/13/202622sU4fhU.png" alt=""></p>
<h3 id="遍历线索化二叉树"><a href="#遍历线索化二叉树" class="headerlink" title="遍历线索化二叉树"></a>遍历线索化二叉树</h3><p><img data-src="https://xuemingde.com/pages/image/2022/09/13/203618BcoVVK.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线索化二叉树</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：XMD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 13.9.22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreadedBinaryTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HeroNode node1 = <span class="keyword">new</span> HeroNode(<span class="number">1</span>, <span class="string">&quot;宋江&quot;</span>);</span><br><span class="line">        HeroNode node3 = <span class="keyword">new</span> HeroNode(<span class="number">3</span>, <span class="string">&quot;吴用&quot;</span>);</span><br><span class="line">        HeroNode node6 = <span class="keyword">new</span> HeroNode(<span class="number">6</span>, <span class="string">&quot;卢俊义&quot;</span>);</span><br><span class="line">        HeroNode node8 = <span class="keyword">new</span> HeroNode(<span class="number">8</span>, <span class="string">&quot;林冲&quot;</span>);</span><br><span class="line">        HeroNode node10 = <span class="keyword">new</span> HeroNode(<span class="number">10</span>, <span class="string">&quot;关胜&quot;</span>);</span><br><span class="line">        HeroNode node14 = <span class="keyword">new</span> HeroNode(<span class="number">14</span>, <span class="string">&quot;武松&quot;</span>);</span><br><span class="line"></span><br><span class="line">        node1.setLeft(node3);</span><br><span class="line">        node1.setRight(node6);</span><br><span class="line"></span><br><span class="line">        node3.setLeft(node8);</span><br><span class="line">        node3.setRight(node10);</span><br><span class="line"></span><br><span class="line">        node6.setLeft(node14);</span><br><span class="line"></span><br><span class="line">        TreadedBinaryTree binaryTree = <span class="keyword">new</span> TreadedBinaryTree();</span><br><span class="line">        binaryTree.setRoot(node1);</span><br><span class="line">        binaryTree.treadedNodes();</span><br><span class="line"></span><br><span class="line">        HeroNode node10Left = node14.getLeft();</span><br><span class="line">        System.out.println(<span class="string">&quot;node10 前驱：&quot;</span> + node10Left);</span><br><span class="line"></span><br><span class="line">        HeroNode node10Right = node14.getRight();</span><br><span class="line">        System.out.println(<span class="string">&quot;node10 后驱：&quot;</span> + node10Right);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;使用线索化的遍历遍历线索化二叉树&quot;</span>);</span><br><span class="line">        binaryTree.treadedList();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreadedBinaryTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HeroNode root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了实现线索化，需要创建要给指向当前结点的前驱结点的指针</span></span><br><span class="line">    <span class="comment">//在递归进行线索化时，pre总是保留前一个结点</span></span><br><span class="line">    <span class="keyword">private</span> HeroNode pre = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoot</span><span class="params">(HeroNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.root = root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">treadedNodes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.treadedNodes(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历线索化二叉树的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">treadedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个变量，存储当前遍历的结点，从root开始</span></span><br><span class="line">        HeroNode node = root;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//循环的找到1 eftType==1的结点，第一个找到就是8结点</span></span><br><span class="line">            <span class="comment">//后面随着遍历而变化，因为当1 eftType==1时，说明该结点是按照线索化</span></span><br><span class="line">            <span class="comment">//处理后的有效结点</span></span><br><span class="line">            <span class="keyword">while</span> (node.getLeftType() == <span class="number">0</span>) &#123;</span><br><span class="line">                node = node.getLeft();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//打印当前这个结点</span></span><br><span class="line">            System.out.println(node);</span><br><span class="line">            <span class="comment">//如果当前结点的右指针指向的是后继结点，就一直输出</span></span><br><span class="line">            <span class="keyword">while</span> (node.getRightType() == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//获取到当前结点的后继结点</span></span><br><span class="line">                node = node.getRight();</span><br><span class="line">                System.out.println(node);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//替换这个遍历的结点</span></span><br><span class="line">            node = node.getRight();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * //编写对二叉树进行中序线索化的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 就是当前需要线索化的结点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">treadedNodes</span><span class="params">(HeroNode node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果node==nu1ll,不能线素化</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">///(一)先线素化左子树</span></span><br><span class="line">        treadedNodes(node.getLeft());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//(二)线素化当前结点[有难度]</span></span><br><span class="line">        <span class="comment">//处理当前结点的前驱结点</span></span><br><span class="line">        <span class="keyword">if</span> (node.getLeft() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//让当前结点的左指针指向前驱结点</span></span><br><span class="line">            node.setLeft(pre);</span><br><span class="line">            <span class="comment">//修改当前结点的左指针的类型</span></span><br><span class="line">            node.setLeftType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理后继结点</span></span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="keyword">null</span> &amp;&amp; pre.getRight() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            pre.setRight(node);</span><br><span class="line">            pre.setRightType(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//!!!每处理一个结点后，让当前结点是下一个结点的前驱结点</span></span><br><span class="line">        pre = node;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//(三)在线索化右子树</span></span><br><span class="line">        treadedNodes(node.getRight());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delOrder</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root.delNode(no);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法删除&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root.preOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root.infixOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root.postOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法遍历&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">preOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        HeroNode heroNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            heroNode = <span class="keyword">this</span>.root.preOrderSearch(no);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法查找&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">infixOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        HeroNode heroNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            heroNode = <span class="keyword">this</span>.root.infixOrderSearch(no);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法查找&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">postOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        HeroNode heroNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            heroNode = <span class="keyword">this</span>.root.postOrderSearch(no);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;二叉树为空，无法查找&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heroNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeroNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> HeroNode left;</span><br><span class="line">    <span class="keyword">private</span> HeroNode right;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//说明</span></span><br><span class="line">    <span class="comment">//1。如果1 eftType=0表示指向的是左子树，如果1则表示指向前驱结点</span></span><br><span class="line">    <span class="comment">//2,如果rightType=0表示指向是右子树，如果1表示指向后继结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> leftType;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> rightType;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;HeroNode&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;no=&quot;</span> + no +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HeroNode</span><span class="params">(<span class="keyword">int</span> no, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLeftType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeftType</span><span class="params">(<span class="keyword">int</span> leftType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.leftType = leftType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRightType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRightType</span><span class="params">(<span class="keyword">int</span> rightType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rightType = rightType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNo</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.no = no;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeft</span><span class="params">(HeroNode left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">getRight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRight</span><span class="params">(HeroNode right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归删除结点</span></span><br><span class="line">    <span class="comment">//1,如果删除的节点是叶子节点，则侧删除该节点</span></span><br><span class="line">    <span class="comment">//2,如果删除的节点是非叶子节点，则删除该子树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//思路</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1。因为我们的二叉树是单向的，所以我们是判断当前结点的子结点是否需要删除结点，而不能去判断当前这个结点是不是需要删除结，</span></span><br><span class="line"><span class="comment">        2。如果当前结点的左子结点不为空，并且左子结点就是要删除结点，就将this.1eft=null;并且就返回（结束递归删除）</span></span><br><span class="line"><span class="comment">        3,如果当前结点的右子结点不为空，并且右子结点就是要删除结点，就将this,right=ul1;并且就返回（结束递归删除）</span></span><br><span class="line"><span class="comment">        4。如果第2和第3步没有删除结点，那么我们就需要向左子树进行递归删除</span></span><br><span class="line"><span class="comment">        5。如果第4步也没有删除结点，则应当向右子树进行递归删除，</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">        <span class="comment">//2如果当前结点的左子结点不为空，并且左子结点就是要删除结点，就将this,1eft=nu11;并且就返回（结束递归删除）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.no == no) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3,如果当前结点的右子结点不为空，并且右子结点就是要删除结点，就将this,right=nu11;并且就返回（结束递归删除）</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.no == no) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4,我们就需要向左子树进行递归删除</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.delNode(no);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right.delNode(no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先输出父节点</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//递归向左子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归向右子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归向左子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先输出父节点</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//递归向右子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归向左子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归向右子树前序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right.postOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先输出父节点</span></span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前序查找</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> no 查找条件 编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果返回节点信息 没有找到返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">preOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.no == no) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1,则判断当前结点的左子节点是否为空，如果不为空，则递归前序查找</span></span><br><span class="line">        <span class="comment">//2,如果左递归前序查找，找到结点，则返回</span></span><br><span class="line">        HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resNode = <span class="keyword">this</span>.left.preOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1,左递归前序查找，找到结点，则返回，否继续判断，</span></span><br><span class="line">        <span class="comment">//2,当前的结点的右子节点是否为空，如果不空，则继续向右递归前序查找</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resNode = <span class="keyword">this</span>.right.preOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中序查找</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> no 查找条件 编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果返回节点信息 没有找到返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">infixOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断当前结点的左子节点是否为空，如果不为空，则递归中序查找</span></span><br><span class="line">        HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resNode = <span class="keyword">this</span>.left.infixOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果找到，则返回，如果没有找到，就和当前结点比较，如果是则返回当前结点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.no == no) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resNode = <span class="keyword">this</span>.right.infixOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 中序查找</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> no 查找条件 编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果返回节点信息 没有找到返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HeroNode <span class="title">postOrderSearch</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断当前结点的左子节点是否为空，如果不为空，则递归中序查找</span></span><br><span class="line">        HeroNode resNode = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resNode = <span class="keyword">this</span>.left.postOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resNode = <span class="keyword">this</span>.right.infixOrderSearch(no);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (resNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果找到，则返回，如果没有找到，就和当前结点比较，如果是则返回当前结点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.no == no) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> resNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>堆</tag>
        <tag>数组</tag>
        <tag>指针</tag>
        <tag>变量</tag>
        <tag>Qt</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础15：多路查找树</title>
    <url>/posts/WCK7NZ.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://xuemingde.com/pages/image/2022/10/14/111151zHnpSV.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/14/1115253jWYVn.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/14/111910VciP2D.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/14/112653rxvhay.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/14/112922xl0e0w.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/14/113905mnSEva.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/14/113959xcVz0p.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/14/114033UzZJ5p.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/14/114306sKgvhF.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/14/142942ScKhMF.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/14/14300251T3bZ.png" alt=""></p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础14：树结构的实际应用</title>
    <url>/posts/QAQAP8.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>堆排序基本介绍</p>
<ol>
<li>堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种<strong><code>选择排序</code></strong>，它的最坏，最好，平均时间复杂度均为O(nlogn),它也是不稳定排序。</li>
<li>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值称为大顶堆，注意：没有要求结点的左孩子的值和右孩子的值的大小关系。</li>
<li>每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆</li>
<li>大顶堆举例说明</li>
</ol>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/13/21014357KQhG.png" alt=""></p>
<ol>
<li><p>小顶堆举例说明</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/15/191013E1YBtl.png" alt=""></p>
</li>
<li><p>一般升序采用大顶堆，降序采用小顶堆</p>
</li>
</ol>
<p>堆排序的基本思想</p>
<ol>
<li>将待排序序列构造成一个大顶堆</li>
<li>此时，整个序列的最大值就是堆顶的根节点。</li>
<li>将其与末尾元素进行交换，此时末尾就为最大值。</li>
<li>然后将剩余n-1个元素重新构造成一个堆，这样会得到个元素的次小值。如此反复执行，便能得到一个有序序列了。</li>
</ol>
<blockquote>
<p>可以看到在构建大项堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了.</p>
</blockquote>
<p>要求：给你一个数组{4,6,8,5,9}，要求使用堆排序法，将数组升序排序。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/15/195121K6Ub03.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/15/195229hejqVu.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/15/195447H1ETNN.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/15/195610LSZedh.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/15/195735n8eg43.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/15/195821HLWpRP.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/15/195922XlHoyZ.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/15/200037QQspfd.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/15/200152VAgDUI.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/15/200229xeK5mb.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/15/200317VCv17z.png" alt=""></p>
<p>代码案例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆排序</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：XMD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 15.9.22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//要求将数组进行升序排序</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">9</span>,-<span class="number">1</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        heapSort(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;堆排序&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//完成我们最终代码</span></span><br><span class="line">        <span class="comment">//将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            adjustHeap(arr, i, arr.length);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  2),将堆顶元素与末尾元素交换，将最大元素&quot;沉&quot;到数组末端；</span></span><br><span class="line"><span class="comment">         *  3),重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = arr.length - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">            arr[j] = arr[<span class="number">0</span>];</span><br><span class="line">            arr[<span class="number">0</span>] = temp;</span><br><span class="line">            adjustHeap(arr, <span class="number">0</span>, j);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;数组：&quot;</span> + Arrays.toString(arr));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将一个数组（二叉树），调整成一个大顶堆</span></span><br><span class="line"><span class="comment">     * 举例int arr[]=&#123;4,6,8,5,9&#125;;=&gt;i=1=&gt;adjustHeap=&gt;得到&#123;4,9,8,5,6&#125;</span></span><br><span class="line"><span class="comment">     * 如果我们再次调用adjustHeap传入的是1=0=&gt;得到&#123;4,9,8,5,6&#125;=&gt;&#123;9,6,8,5,4)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr    待整顿的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i      表示叶子结点再办数组中的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lenght 表示对多少个元素继续调整，length是在逐滋的减少</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> lenght)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先取出当前元素的值，保存在临时变量</span></span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        <span class="comment">//开始调整</span></span><br><span class="line">        <span class="comment">//说明</span></span><br><span class="line">        <span class="comment">//1,k=1*2+1k是i结点的左子结点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = i * <span class="number">2</span> + <span class="number">1</span>; k &lt; lenght; k = k * <span class="number">2</span> + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//说明左子结点的值小于右子结点的值</span></span><br><span class="line">            <span class="keyword">if</span> (k+<span class="number">1</span> &lt; lenght &amp;&amp; arr[k] &lt; arr[k + <span class="number">1</span>]) &#123;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果子节点大于父节点</span></span><br><span class="line">            <span class="keyword">if</span> (arr[k] &gt; temp) &#123;</span><br><span class="line">                <span class="comment">//把较大的值赋给当前结点</span></span><br><span class="line">                arr[i] = arr[k];</span><br><span class="line">                <span class="comment">//!!  i指向k,继续循环比较</span></span><br><span class="line">                i = k;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当fo下循环结束后，我们已经将以i为父结点的树的最大值，放在了最顶（局部）</span></span><br><span class="line">        <span class="comment">//将temp值放到调整后的位置</span></span><br><span class="line">        arr[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>有点难度</code></p>
</blockquote>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/15/204434wr7Uug.png" alt=""></p>
<h1 id="哈夫曼-赫夫曼（-huffman）树"><a href="#哈夫曼-赫夫曼（-huffman）树" class="headerlink" title="哈夫曼/赫夫曼（ huffman）树"></a>哈夫曼/赫夫曼（ huffman）树</h1><p>基本介绍</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/22/184636z4Sy6j.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/22/184705PZLSf8.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/22/1849465QS2YM.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/22/185220uUr1mN.png" alt=""></p>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈夫曼树</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：XMD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 22.9.22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">13</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">29</span>, <span class="number">6</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        Node node = createHuffmanTree(arr);</span><br><span class="line">        preOrder(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            root.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建哈夫曼树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">createHuffmanTree</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第一步为了操作方便</span></span><br><span class="line">        <span class="comment">//1.遍历arr数组</span></span><br><span class="line">        <span class="comment">//2,将arr的每个元素构成成一个Node</span></span><br><span class="line">        <span class="comment">//3,将Node放入到ArrayList中</span></span><br><span class="line">        List&lt;Node&gt; nodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value : arr) &#123;</span><br><span class="line">            nodes.add(<span class="keyword">new</span> Node(value));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (nodes.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//排序，从大到小</span></span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line"></span><br><span class="line">            <span class="comment">////取出根节点权值最小的两颗二叉树</span></span><br><span class="line">            <span class="comment">//(1)取出权值最小的结点（二叉树）</span></span><br><span class="line">            Node leftnode = nodes.get(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//(2)取出权值第二小的结点（二叉树）</span></span><br><span class="line">            Node rightnode = nodes.get(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//(3)构建一颗新的二叉树</span></span><br><span class="line">            Node parent = <span class="keyword">new</span> Node(leftnode.value + rightnode.value);</span><br><span class="line">            parent.left = leftnode;</span><br><span class="line">            parent.reght = rightnode;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//(4)从ArrayList删除处理过的二叉树</span></span><br><span class="line">            nodes.remove(leftnode);</span><br><span class="line">            nodes.remove(rightnode);</span><br><span class="line">            <span class="comment">//(5)将parent加入到nodes</span></span><br><span class="line">            nodes.add(parent);</span><br><span class="line"></span><br><span class="line">            Collections.sort(nodes);</span><br><span class="line">            System.out.println(nodes);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nodes.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建节点类</span></span><br><span class="line"><span class="comment">//为了让Node对象持续排序Collections集合排序</span></span><br><span class="line"><span class="comment">//让Node实现Comparable接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node reght;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写一个前序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.reght != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.reght.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从小到大</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value - o.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="哈夫曼-赫夫曼（-huffman）编码"><a href="#哈夫曼-赫夫曼（-huffman）编码" class="headerlink" title="哈夫曼/赫夫曼（ huffman）编码"></a>哈夫曼/赫夫曼（ huffman）编码</h1><p>基本介绍</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/22/1941106ZPJwd.png" alt=""></p>
<p>原理剖析  </p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/22/200003jsppvk.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/22/200036JcnQ32.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/22/200303bbwJoD.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/22/201024xNXv3Q.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/22/201552fimUDg.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/22/201647lK3ztG.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/22/202103GKEXuo.png" alt=""></p>
<p>思路</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/09/22/202954qtoeHU.png" alt=""></p>
<h2 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈夫曼编码</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：XMD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 8.10.22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanCodeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;i like like like java do you like a java&quot;</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = str.getBytes();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(bytes.length);</span></span><br><span class="line"><span class="comment">//        List&lt;Node2&gt; nodes = getNodes(bytes);</span></span><br><span class="line"><span class="comment">//        System.out.println(nodes);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;哈夫曼数&quot;);</span></span><br><span class="line"><span class="comment">//        Node2 hUffmanTree = createHUffmanTree(nodes);</span></span><br><span class="line"><span class="comment">//        System.out.println(hUffmanTree);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;前序遍历&quot;);</span></span><br><span class="line"><span class="comment">//        perOrder(hUffmanTree);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        Map&lt;Byte, String&gt; huffmanCodes = getCodes(hUffmanTree);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;生产的哈夫曼的编码表：&quot; + huffmanCodes);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        byte[] zip = zip(bytes, huffmanCodes);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;huffmanCodeByte=&quot; + Arrays.toString(zip)); //17个字节</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//数据压缩</span></span><br><span class="line">        <span class="keyword">byte</span>[] zip = huffmanZip(bytes);</span><br><span class="line">        System.out.println(<span class="string">&quot;压缩后的：&quot;</span>  + Arrays.toString(zip));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用一个方法，将前面的方法封装起来，便于我们的调用。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用一个方法，将前面的方法封装起来，便于我们的调用。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 原始的字符串对应的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] huffmanZip(<span class="keyword">byte</span>[] bytes) &#123;</span><br><span class="line">        List&lt;Node2&gt; nodes = getNodes(bytes);</span><br><span class="line">        Node2 hUffmanTree = createHUffmanTree(nodes);</span><br><span class="line">        Map&lt;Byte, String&gt; codes = getCodes(hUffmanTree);</span><br><span class="line">        <span class="keyword">return</span> zip(bytes, codes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perOrder</span><span class="params">(Node2 root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            root.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个方法，将字符串对应的byte[]数组，通过生成的赫夫曼编码表，返回一个赫夫曼编码压缩后的byte[]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] zip(<span class="keyword">byte</span>[] bytes, Map&lt;Byte, String&gt; huffmanCodes) &#123;</span><br><span class="line">        <span class="comment">//1,利用huffmanCodes将bytes转成赫夫曼编码对应的字符串</span></span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> aByte : bytes) &#123;</span><br><span class="line">            stringBuilder.append(huffmanCodes.get(aByte));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">if</span> (stringBuilder.length() % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            len = stringBuilder.length() / <span class="number">8</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len = stringBuilder.length() / <span class="number">8</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建存储压缩后的byte数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] huffmanCodeBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stringBuilder.length(); i += <span class="number">8</span>) &#123;</span><br><span class="line">            String strByte;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">8</span> &gt; stringBuilder.length()) &#123;</span><br><span class="line">                strByte = stringBuilder.substring(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                strByte = stringBuilder.substring(i, i + <span class="number">8</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            huffmanCodeBytes[index] = (<span class="keyword">byte</span>) Integer.parseInt(strByte, <span class="number">2</span>);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1,将赫夫曼编码表存放在Map&lt;Byte,String&gt;形式</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Byte, String&gt; huffmanCodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//2,在生成赫夫曼编码表示，需要去拼接路径，定义一个StringBuilder存储某个叶子结点的路径</span></span><br><span class="line">    <span class="keyword">static</span> StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了调用方便，我们重载getCodes</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Byte, String&gt; <span class="title">getCodes</span><span class="params">(Node2 root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        getCodes(root.left, <span class="string">&quot;0&quot;</span>, stringBuilder);</span><br><span class="line">        getCodes(root.right, <span class="string">&quot;1&quot;</span>, stringBuilder);</span><br><span class="line">        <span class="keyword">return</span> huffmanCodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到将传入的node节点的所有的叶子结点的夫曼编码，并且放入到huffmanCodes中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node          传入的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code          左子节点：0，右子节点：1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stringBuilder 用于拼接路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getCodes</span><span class="params">(Node2 node, String code, StringBuilder stringBuilder)</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder1 = <span class="keyword">new</span> StringBuilder(stringBuilder);</span><br><span class="line">        stringBuilder1.append(code);</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.data == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//判断当前node是叶子结点还是非叶子结点</span></span><br><span class="line">                <span class="comment">//递归处理</span></span><br><span class="line">                <span class="comment">//向左递归</span></span><br><span class="line">                getCodes(node.left, <span class="string">&quot;0&quot;</span>, stringBuilder1);</span><br><span class="line">                <span class="comment">//向右递归</span></span><br><span class="line">                getCodes(node.right, <span class="string">&quot;1&quot;</span>, stringBuilder1);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                huffmanCodes.put(node.data, stringBuilder1.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Node2&gt; <span class="title">getNodes</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Node2&gt; node2s = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Map&lt;Byte, Integer&gt; count = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> aByte : bytes) &#123;</span><br><span class="line">            Integer integer = count.get(aByte);</span><br><span class="line">            <span class="keyword">if</span> (integer == <span class="keyword">null</span>) &#123;</span><br><span class="line">                count.put(aByte, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count.put(aByte, integer + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte, Integer&gt; entry : count.entrySet()) &#123;</span><br><span class="line">            node2s.add(<span class="keyword">new</span> Node2(entry.getKey(), entry.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node2s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node2 <span class="title">createHUffmanTree</span><span class="params">(List&lt;Node2&gt; node2s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (node2s.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//排序，从小到大</span></span><br><span class="line">            Collections.sort(node2s);</span><br><span class="line">            <span class="comment">//取出第一个最小的二叉树</span></span><br><span class="line">            Node2 leftNode = node2s.get(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//取出第一个最小的二叉树</span></span><br><span class="line">            Node2 rightNode = node2s.get(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//创建一颗新的二叉树，它的根节点没有datā，只有权值</span></span><br><span class="line">            Node2 parent = <span class="keyword">new</span> Node2(<span class="keyword">null</span>, leftNode.weight + rightNode.weight);</span><br><span class="line">            parent.left = leftNode;</span><br><span class="line">            parent.right = rightNode;</span><br><span class="line">            <span class="comment">//将已经处理的两颗二叉树从nodes删除</span></span><br><span class="line">            node2s.remove(leftNode);</span><br><span class="line">            node2s.remove(rightNode);</span><br><span class="line">            node2s.add(parent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node2s.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Node，带数据和权值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node2</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node2</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//存放数据</span></span><br><span class="line">    Byte data;</span><br><span class="line">    <span class="comment">//权值，表示字符出现的次数</span></span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    Node2 left;</span><br><span class="line">    Node2 right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node2</span><span class="params">(Byte data, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node2 o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.weight - o.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node2&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;data=&quot;</span> + data +</span><br><span class="line">                <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数据解码"><a href="#数据解码" class="headerlink" title="数据解码"></a>数据解码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈夫曼编码</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：XMD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 8.10.22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanCodeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;i like like like java do you like a java&quot;</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = str.getBytes();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(bytes.length);</span></span><br><span class="line"><span class="comment">//        List&lt;Node2&gt; nodes = getNodes(bytes);</span></span><br><span class="line"><span class="comment">//        System.out.println(nodes);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;哈夫曼数&quot;);</span></span><br><span class="line"><span class="comment">//        Node2 hUffmanTree = createHUffmanTree(nodes);</span></span><br><span class="line"><span class="comment">//        System.out.println(hUffmanTree);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;前序遍历&quot;);</span></span><br><span class="line"><span class="comment">//        perOrder(hUffmanTree);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        Map&lt;Byte, String&gt; huffmanCodes = getCodes(hUffmanTree);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;生产的哈夫曼的编码表：&quot; + huffmanCodes);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        byte[] zip = zip(bytes, huffmanCodes);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;huffmanCodeByte=&quot; + Arrays.toString(zip)); //17个字节</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//数据压缩</span></span><br><span class="line">        <span class="keyword">byte</span>[] zip = huffmanZip(bytes);</span><br><span class="line">        System.out.println(<span class="string">&quot;压缩后的：&quot;</span> + Arrays.toString(zip));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解码</span></span><br><span class="line">        <span class="keyword">byte</span>[] decode = decode(huffmanCodes, zip);</span><br><span class="line">        System.out.println(<span class="string">&quot;原来字符串=&quot;</span> + <span class="keyword">new</span> String(decode));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将一个byte转成一个二进制的字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b    传入的byte</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> flag 标志是否需要补高位如果是true,表示需要补高位，如果是false表示不补，如课是最后一个字节，无需补高位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是该b对应的二进制的字符串，（注意是按补码返回）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">byteToBitString</span><span class="params">(<span class="keyword">boolean</span> flag, <span class="keyword">byte</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = b;</span><br><span class="line">        <span class="comment">////如果是正数我们还存在补高位</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp |= <span class="number">256</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String string = Integer.toBinaryString(temp);</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="comment">//返回的是temp对应的二进制的补码</span></span><br><span class="line">            <span class="keyword">return</span> string.substring(string.length() - <span class="number">8</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> string;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个方法，完成对压缩数据的解码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanCodes 哈夫曼编码表map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanBytes 哈夫曼编码得到的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 原来的字符串对应的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decode(Map&lt;Byte, String&gt; huffmanCodes, <span class="keyword">byte</span>[] huffmanBytes) &#123;</span><br><span class="line">        <span class="comment">//1.先得到huffmanBytes对应的二进制的字符串，形式1010100010111.··</span></span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//将byte[] 转成二进制的字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; huffmanBytes.length; i++) &#123;</span><br><span class="line">            <span class="keyword">byte</span> b = huffmanBytes[i];</span><br><span class="line">            <span class="comment">//判断是不是最后一个字节</span></span><br><span class="line">            <span class="keyword">boolean</span> flag = (i == huffmanBytes.length - <span class="number">1</span>);</span><br><span class="line">            String string = byteToBitString(!flag, b);</span><br><span class="line">            stringBuilder.append(string);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把字符串安装指定的赫夫曼编码进行解码</span></span><br><span class="line">        <span class="comment">//把赫夫曼编码表进行调换，因为反向查询a-&gt;100100-&gt;a</span></span><br><span class="line">        Map&lt;String, Byte&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte, String&gt; entry : huffmanCodes.entrySet()) &#123;</span><br><span class="line">            map.put(entry.getValue(), entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Byte&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; stringBuilder.length(); ) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">            Byte b = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                <span class="comment">//s不动，让count移动，指定匹配到一个字符</span></span><br><span class="line">                String key = stringBuilder.substring(s, s + count);</span><br><span class="line">                b = map.get(key);</span><br><span class="line">                <span class="comment">//没有匹配到</span></span><br><span class="line">                <span class="keyword">if</span> (b == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//匹配到了</span></span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(b);</span><br><span class="line">            s += count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当for循环结束后，我们list中就存放了所有的字符串</span></span><br><span class="line">        <span class="comment">//把list中的数据存入到byte[] 中，并返回</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line">            bytes[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用一个方法，将前面的方法封装起来，便于我们的调用。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用一个方法，将前面的方法封装起来，便于我们的调用。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 原始的字符串对应的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] huffmanZip(<span class="keyword">byte</span>[] bytes) &#123;</span><br><span class="line">        List&lt;Node2&gt; nodes = getNodes(bytes);</span><br><span class="line">        Node2 hUffmanTree = createHUffmanTree(nodes);</span><br><span class="line">        Map&lt;Byte, String&gt; codes = getCodes(hUffmanTree);</span><br><span class="line">        <span class="keyword">return</span> zip(bytes, codes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perOrder</span><span class="params">(Node2 root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            root.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个方法，将字符串对应的byte[]数组，通过生成的赫夫曼编码表，返回一个赫夫曼编码压缩后的byte[]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] zip(<span class="keyword">byte</span>[] bytes, Map&lt;Byte, String&gt; huffmanCodes) &#123;</span><br><span class="line">        <span class="comment">//1,利用huffmanCodes将bytes转成赫夫曼编码对应的字符串</span></span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> aByte : bytes) &#123;</span><br><span class="line">            stringBuilder.append(huffmanCodes.get(aByte));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;zip code=&quot;</span> + stringBuilder);</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">if</span> (stringBuilder.length() % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            len = stringBuilder.length() / <span class="number">8</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len = stringBuilder.length() / <span class="number">8</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建存储压缩后的byte数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] huffmanCodeBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stringBuilder.length(); i += <span class="number">8</span>) &#123;</span><br><span class="line">            String strByte;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">8</span> &gt; stringBuilder.length()) &#123;</span><br><span class="line">                strByte = stringBuilder.substring(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                strByte = stringBuilder.substring(i, i + <span class="number">8</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            huffmanCodeBytes[index] = (<span class="keyword">byte</span>) Integer.parseInt(strByte, <span class="number">2</span>);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1,将赫夫曼编码表存放在Map&lt;Byte,String&gt;形式</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Byte, String&gt; huffmanCodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//2,在生成赫夫曼编码表示，需要去拼接路径，定义一个StringBuilder存储某个叶子结点的路径</span></span><br><span class="line">    <span class="keyword">static</span> StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了调用方便，我们重载getCodes</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Byte, String&gt; <span class="title">getCodes</span><span class="params">(Node2 root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        getCodes(root.left, <span class="string">&quot;0&quot;</span>, stringBuilder);</span><br><span class="line">        getCodes(root.right, <span class="string">&quot;1&quot;</span>, stringBuilder);</span><br><span class="line">        <span class="keyword">return</span> huffmanCodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到将传入的node节点的所有的叶子结点的夫曼编码，并且放入到huffmanCodes中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node          传入的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code          左子节点：0，右子节点：1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stringBuilder 用于拼接路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getCodes</span><span class="params">(Node2 node, String code, StringBuilder stringBuilder)</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder1 = <span class="keyword">new</span> StringBuilder(stringBuilder);</span><br><span class="line">        stringBuilder1.append(code);</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.data == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//判断当前node是叶子结点还是非叶子结点</span></span><br><span class="line">                <span class="comment">//递归处理</span></span><br><span class="line">                <span class="comment">//向左递归</span></span><br><span class="line">                getCodes(node.left, <span class="string">&quot;0&quot;</span>, stringBuilder1);</span><br><span class="line">                <span class="comment">//向右递归</span></span><br><span class="line">                getCodes(node.right, <span class="string">&quot;1&quot;</span>, stringBuilder1);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                huffmanCodes.put(node.data, stringBuilder1.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Node2&gt; <span class="title">getNodes</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Node2&gt; node2s = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Map&lt;Byte, Integer&gt; count = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> aByte : bytes) &#123;</span><br><span class="line">            Integer integer = count.get(aByte);</span><br><span class="line">            <span class="keyword">if</span> (integer == <span class="keyword">null</span>) &#123;</span><br><span class="line">                count.put(aByte, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count.put(aByte, integer + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte, Integer&gt; entry : count.entrySet()) &#123;</span><br><span class="line">            node2s.add(<span class="keyword">new</span> Node2(entry.getKey(), entry.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node2s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node2 <span class="title">createHUffmanTree</span><span class="params">(List&lt;Node2&gt; node2s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (node2s.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//排序，从小到大</span></span><br><span class="line">            Collections.sort(node2s);</span><br><span class="line">            <span class="comment">//取出第一个最小的二叉树</span></span><br><span class="line">            Node2 leftNode = node2s.get(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//取出第一个最小的二叉树</span></span><br><span class="line">            Node2 rightNode = node2s.get(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//创建一颗新的二叉树，它的根节点没有datā，只有权值</span></span><br><span class="line">            Node2 parent = <span class="keyword">new</span> Node2(<span class="keyword">null</span>, leftNode.weight + rightNode.weight);</span><br><span class="line">            parent.left = leftNode;</span><br><span class="line">            parent.right = rightNode;</span><br><span class="line">            <span class="comment">//将已经处理的两颗二叉树从nodes删除</span></span><br><span class="line">            node2s.remove(leftNode);</span><br><span class="line">            node2s.remove(rightNode);</span><br><span class="line">            node2s.add(parent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node2s.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Node，带数据和权值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node2</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node2</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//存放数据</span></span><br><span class="line">    Byte data;</span><br><span class="line">    <span class="comment">//权值，表示字符出现的次数</span></span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    Node2 left;</span><br><span class="line">    Node2 right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node2</span><span class="params">(Byte data, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node2 o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.weight - o.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node2&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;data=&quot;</span> + data +</span><br><span class="line">                <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件压缩-解压"><a href="#文件压缩-解压" class="headerlink" title="文件压缩/解压"></a>文件压缩/解压</h2><p><img data-src="https://xuemingde.com/pages/image/2022/10/09/081349rmHMq5.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 哈夫曼编码</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：XMD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 8.10.22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanCodeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        String str = &quot;i like like like java do you like a java&quot;;</span></span><br><span class="line"><span class="comment">//        byte[] bytes = str.getBytes();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(bytes.length);</span></span><br><span class="line"><span class="comment">//        List&lt;Node2&gt; nodes = getNodes(bytes);</span></span><br><span class="line"><span class="comment">//        System.out.println(nodes);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;哈夫曼数&quot;);</span></span><br><span class="line"><span class="comment">//        Node2 hUffmanTree = createHUffmanTree(nodes);</span></span><br><span class="line"><span class="comment">//        System.out.println(hUffmanTree);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;前序遍历&quot;);</span></span><br><span class="line"><span class="comment">//        perOrder(hUffmanTree);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        Map&lt;Byte, String&gt; huffmanCodes = getCodes(hUffmanTree);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;生产的哈夫曼的编码表：&quot; + huffmanCodes);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        byte[] zip = zip(bytes, huffmanCodes);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;huffmanCodeByte=&quot; + Arrays.toString(zip)); //17个字节</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//数据压缩</span></span><br><span class="line"><span class="comment">//        byte[] zip = huffmanZip(bytes);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;压缩后的：&quot; + Arrays.toString(zip));</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        //解码</span></span><br><span class="line"><span class="comment">//        byte[] decode = decode(huffmanCodes, zip);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;原来字符串=&quot; + new String(decode));</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试压缩文件</span></span><br><span class="line">        String srcFile = <span class="string">&quot;/Users/yons/Downloads/HuffmanCodeDemo.java&quot;</span>;</span><br><span class="line">        String dstFile = <span class="string">&quot;/Users/yons/Downloads/临时/HuffmanCodeDemo.zip&quot;</span>;</span><br><span class="line">        String dstFile2 = <span class="string">&quot;/Users/yons/Downloads/临时/HuffmanCodeDemo2.java&quot;</span>;</span><br><span class="line">        zipFile(srcFile, dstFile);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//文件解压</span></span><br><span class="line">        unZipFile(dstFile, dstFile2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解压文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> zipFile</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dstFile</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unZipFile</span><span class="params">(String zipFile, String dstFile)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                FileInputStream is = <span class="keyword">new</span> FileInputStream(zipFile);</span><br><span class="line">                ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(is)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] huffmanBytes = (<span class="keyword">byte</span>[]) ois.readObject();</span><br><span class="line">            Map&lt;Byte, String&gt; huffmanCodes = (Map&lt;Byte, String&gt;) ois.readObject();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] decode = decode(huffmanCodes, huffmanBytes);</span><br><span class="line">            FileOutputStream os = <span class="keyword">new</span> FileOutputStream(dstFile);</span><br><span class="line">            os.write(decode);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * //压缩文件</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> srcFile 你传入的希望压缩的文件的全路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dstFile 我们压缩后将压缩文件放到哪个目录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">zipFile</span><span class="params">(String srcFile, String dstFile)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="comment">//创建文件的输入流</span></span><br><span class="line">                FileInputStream is = <span class="keyword">new</span> FileInputStream(srcFile);</span><br><span class="line">                <span class="comment">//创建文件的输出流，存放压缩文件</span></span><br><span class="line">                FileOutputStream os = <span class="keyword">new</span> FileOutputStream(dstFile);</span><br><span class="line">                <span class="comment">//创建一个和文件输出流关联的ObjectOutputstream</span></span><br><span class="line">                ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(os)</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">            <span class="comment">//读取文件</span></span><br><span class="line">            is.read(b);</span><br><span class="line">            <span class="comment">//直接对源文件压缩</span></span><br><span class="line">            <span class="keyword">byte</span>[] huffmanBytes = huffmanZip(b);</span><br><span class="line">            <span class="comment">//把哈夫曼编码后的字节数组写入压缩文件</span></span><br><span class="line">            oos.writeObject(huffmanBytes);</span><br><span class="line">            <span class="comment">//这里我们以对象流的方式写入赫夫曼编码，是为了以后我们恢复源文件时使用</span></span><br><span class="line">            <span class="comment">//注意一定要把哈夫曼编码写入压缩文件</span></span><br><span class="line">            oos.writeObject(huffmanCodes);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将一个byte转成一个二进制的字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b    传入的byte</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> flag 标志是否需要补高位如果是true,表示需要补高位，如果是false表示不补，如课是最后一个字节，无需补高位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是该b对应的二进制的字符串，（注意是按补码返回）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">byteToBitString</span><span class="params">(<span class="keyword">boolean</span> flag, <span class="keyword">byte</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = b;</span><br><span class="line">        <span class="comment">////如果是正数我们还存在补高位</span></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            temp |= <span class="number">256</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String string = Integer.toBinaryString(temp);</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="comment">//返回的是temp对应的二进制的补码</span></span><br><span class="line">            <span class="keyword">return</span> string.substring(string.length() - <span class="number">8</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> string;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个方法，完成对压缩数据的解码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanCodes 哈夫曼编码表map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> huffmanBytes 哈夫曼编码得到的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 原来的字符串对应的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decode(Map&lt;Byte, String&gt; huffmanCodes, <span class="keyword">byte</span>[] huffmanBytes) &#123;</span><br><span class="line">        <span class="comment">//1.先得到huffmanBytes对应的二进制的字符串，形式1010100010111.··</span></span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//将byte[] 转成二进制的字符串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; huffmanBytes.length; i++) &#123;</span><br><span class="line">            <span class="keyword">byte</span> b = huffmanBytes[i];</span><br><span class="line">            <span class="comment">//判断是不是最后一个字节</span></span><br><span class="line">            <span class="keyword">boolean</span> flag = (i == huffmanBytes.length - <span class="number">1</span>);</span><br><span class="line">            String string = byteToBitString(!flag, b);</span><br><span class="line">            stringBuilder.append(string);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把字符串安装指定的赫夫曼编码进行解码</span></span><br><span class="line">        <span class="comment">//把赫夫曼编码表进行调换，因为反向查询a-&gt;100100-&gt;a</span></span><br><span class="line">        Map&lt;String, Byte&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte, String&gt; entry : huffmanCodes.entrySet()) &#123;</span><br><span class="line">            map.put(entry.getValue(), entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Byte&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; stringBuilder.length(); ) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">            Byte b = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">                <span class="comment">//s不动，让count移动，指定匹配到一个字符</span></span><br><span class="line">                String key = stringBuilder.substring(s, s + count);</span><br><span class="line">                b = map.get(key);</span><br><span class="line">                <span class="comment">//没有匹配到</span></span><br><span class="line">                <span class="keyword">if</span> (b == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//匹配到了</span></span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(b);</span><br><span class="line">            s += count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当for循环结束后，我们list中就存放了所有的字符串</span></span><br><span class="line">        <span class="comment">//把list中的数据存入到byte[] 中，并返回</span></span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line">            bytes[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用一个方法，将前面的方法封装起来，便于我们的调用。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用一个方法，将前面的方法封装起来，便于我们的调用。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 原始的字符串对应的字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] huffmanZip(<span class="keyword">byte</span>[] bytes) &#123;</span><br><span class="line">        List&lt;Node2&gt; nodes = getNodes(bytes);</span><br><span class="line">        Node2 hUffmanTree = createHUffmanTree(nodes);</span><br><span class="line">        Map&lt;Byte, String&gt; codes = getCodes(hUffmanTree);</span><br><span class="line">        <span class="keyword">return</span> zip(bytes, codes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perOrder</span><span class="params">(Node2 root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            root.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写一个方法，将字符串对应的byte[]数组，通过生成的赫夫曼编码表，返回一个赫夫曼编码压缩后的byte[]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] zip(<span class="keyword">byte</span>[] bytes, Map&lt;Byte, String&gt; huffmanCodes) &#123;</span><br><span class="line">        <span class="comment">//1,利用huffmanCodes将bytes转成赫夫曼编码对应的字符串</span></span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> aByte : bytes) &#123;</span><br><span class="line">            stringBuilder.append(huffmanCodes.get(aByte));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(&quot;zip code=&quot; + stringBuilder);</span></span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">if</span> (stringBuilder.length() % <span class="number">8</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            len = stringBuilder.length() / <span class="number">8</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            len = stringBuilder.length() / <span class="number">8</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建存储压缩后的byte数组</span></span><br><span class="line">        <span class="keyword">byte</span>[] huffmanCodeBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stringBuilder.length(); i += <span class="number">8</span>) &#123;</span><br><span class="line">            String strByte;</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">8</span> &gt; stringBuilder.length()) &#123;</span><br><span class="line">                strByte = stringBuilder.substring(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                strByte = stringBuilder.substring(i, i + <span class="number">8</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            huffmanCodeBytes[index] = (<span class="keyword">byte</span>) Integer.parseInt(strByte, <span class="number">2</span>);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> huffmanCodeBytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1,将赫夫曼编码表存放在Map&lt;Byte,String&gt;形式</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Byte, String&gt; huffmanCodes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//2,在生成赫夫曼编码表示，需要去拼接路径，定义一个StringBuilder存储某个叶子结点的路径</span></span><br><span class="line">    <span class="keyword">static</span> StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为了调用方便，我们重载getCodes</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Byte, String&gt; <span class="title">getCodes</span><span class="params">(Node2 root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        getCodes(root.left, <span class="string">&quot;0&quot;</span>, stringBuilder);</span><br><span class="line">        getCodes(root.right, <span class="string">&quot;1&quot;</span>, stringBuilder);</span><br><span class="line">        <span class="keyword">return</span> huffmanCodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到将传入的node节点的所有的叶子结点的夫曼编码，并且放入到huffmanCodes中</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node          传入的节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> code          左子节点：0，右子节点：1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> stringBuilder 用于拼接路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getCodes</span><span class="params">(Node2 node, String code, StringBuilder stringBuilder)</span> </span>&#123;</span><br><span class="line">        StringBuilder stringBuilder1 = <span class="keyword">new</span> StringBuilder(stringBuilder);</span><br><span class="line">        stringBuilder1.append(code);</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.data == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//判断当前node是叶子结点还是非叶子结点</span></span><br><span class="line">                <span class="comment">//递归处理</span></span><br><span class="line">                <span class="comment">//向左递归</span></span><br><span class="line">                getCodes(node.left, <span class="string">&quot;0&quot;</span>, stringBuilder1);</span><br><span class="line">                <span class="comment">//向右递归</span></span><br><span class="line">                getCodes(node.right, <span class="string">&quot;1&quot;</span>, stringBuilder1);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                huffmanCodes.put(node.data, stringBuilder1.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Node2&gt; <span class="title">getNodes</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Node2&gt; node2s = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Map&lt;Byte, Integer&gt; count = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> aByte : bytes) &#123;</span><br><span class="line">            Integer integer = count.get(aByte);</span><br><span class="line">            <span class="keyword">if</span> (integer == <span class="keyword">null</span>) &#123;</span><br><span class="line">                count.put(aByte, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                count.put(aByte, integer + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Byte, Integer&gt; entry : count.entrySet()) &#123;</span><br><span class="line">            node2s.add(<span class="keyword">new</span> Node2(entry.getKey(), entry.getValue()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node2s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Node2 <span class="title">createHUffmanTree</span><span class="params">(List&lt;Node2&gt; node2s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (node2s.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//排序，从小到大</span></span><br><span class="line">            Collections.sort(node2s);</span><br><span class="line">            <span class="comment">//取出第一个最小的二叉树</span></span><br><span class="line">            Node2 leftNode = node2s.get(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//取出第一个最小的二叉树</span></span><br><span class="line">            Node2 rightNode = node2s.get(<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//创建一颗新的二叉树，它的根节点没有datā，只有权值</span></span><br><span class="line">            Node2 parent = <span class="keyword">new</span> Node2(<span class="keyword">null</span>, leftNode.weight + rightNode.weight);</span><br><span class="line">            parent.left = leftNode;</span><br><span class="line">            parent.right = rightNode;</span><br><span class="line">            <span class="comment">//将已经处理的两颗二叉树从nodes删除</span></span><br><span class="line">            node2s.remove(leftNode);</span><br><span class="line">            node2s.remove(rightNode);</span><br><span class="line">            node2s.add(parent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node2s.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Node，带数据和权值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node2</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node2</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//存放数据</span></span><br><span class="line">    Byte data;</span><br><span class="line">    <span class="comment">//权值，表示字符出现的次数</span></span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line">    Node2 left;</span><br><span class="line">    Node2 right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node2</span><span class="params">(Byte data, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node2 o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.weight - o.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node2&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;data=&quot;</span> + data +</span><br><span class="line">                <span class="string">&quot;, weight=&quot;</span> + weight +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right.preOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h1><p><img data-src="https://xuemingde.com/pages/image/2022/10/09/142630H3LZ2E.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/09/142654kJGjBG.png" alt=""></p>
<p>介绍</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/09/1429207qK5IZ.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/09/143249vuRRrN.png" alt=""></p>
<h2 id="二叉排序树的创建和遍历"><a href="#二叉排序树的创建和遍历" class="headerlink" title="二叉排序树的创建和遍历"></a>二叉排序树的创建和遍历</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉排序树</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：XMD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 9.10.22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySortTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BinarySortTree binarySortTree = <span class="keyword">new</span> BinarySortTree();</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">7</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            binarySortTree.add(<span class="keyword">new</span> Node(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//中序遍历</span></span><br><span class="line">        binarySortTree.infixOrder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySortTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            root = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            root.infixOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;空的&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归的形式添加结点，注意需要满足二叉排序树的要求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.value &lt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.left = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.value &gt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.right = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="二叉排序数树的删除"><a href="#二叉排序数树的删除" class="headerlink" title="二叉排序数树的删除"></a>二叉排序数树的删除</h2><p><img data-src="https://xuemingde.com/pages/image/2022/10/09/1713062gF2uw.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/09/171357ueSdYc.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉排序树</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：XMD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 9.10.22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySortTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BinarySortTree binarySortTree = <span class="keyword">new</span> BinarySortTree();</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">7</span>, <span class="number">3</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            binarySortTree.add(<span class="keyword">new</span> Node(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//中序遍历</span></span><br><span class="line">        binarySortTree.infixOrder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//测试删除叶子结点</span></span><br><span class="line">        binarySortTree.delNode(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;删除后的遍历-------&quot;</span>);</span><br><span class="line">        <span class="comment">//中序遍历</span></span><br><span class="line">        binarySortTree.infixOrder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinarySortTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            root = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            root.infixOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;空的&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找要删除的结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root.seachParent(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 传入的结点（当做二叉排序树的根结点）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回的以node为根结点的二叉排序树的最小结点的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delRightTreeMin</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node target = node;</span><br><span class="line">        <span class="keyword">while</span> (target.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            target = target.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除最小的节点</span></span><br><span class="line">        delNode(target.value);</span><br><span class="line">        <span class="keyword">return</span> target.value;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除结点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//1,需求先去找到要则除的结点targetNode</span></span><br><span class="line">            Node targetNode = search(value);</span><br><span class="line">            <span class="comment">//如果没有找到要删除的结点</span></span><br><span class="line">            <span class="keyword">if</span> (targetNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果我们发现当前这颗二叉排序树只有一个结点</span></span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                root = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//去找到targetNode的父结点</span></span><br><span class="line">            Node parent = searchParent(value);</span><br><span class="line">            <span class="keyword">if</span> (targetNode.left == <span class="keyword">null</span> &amp;&amp; targetNode.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//判断targetNode是父结点的左子结点，还是右子结点</span></span><br><span class="line">                <span class="keyword">if</span> (parent.left != <span class="keyword">null</span> &amp;&amp; parent.left.value == value) &#123;</span><br><span class="line">                    <span class="comment">//是左子结点</span></span><br><span class="line">                    parent.left = <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent.right != <span class="keyword">null</span> &amp;&amp; parent.right.value == value) &#123;</span><br><span class="line">                    <span class="comment">//是右子结点</span></span><br><span class="line">                    parent.right = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetNode.left != <span class="keyword">null</span> &amp;&amp; targetNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//删除有两颗子树的节点</span></span><br><span class="line">                <span class="keyword">int</span> treeMin = delRightTreeMin(targetNode.right);</span><br><span class="line">                targetNode.value = treeMin;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//删除只有一个子节点的节点</span></span><br><span class="line">                <span class="comment">//如果要删除的节点有左子节点</span></span><br><span class="line">                <span class="keyword">if</span> (targetNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//如果targetNode是parent的左子结点</span></span><br><span class="line">                        <span class="keyword">if</span> (parent.left.value == value) &#123;</span><br><span class="line">                            parent.left = targetNode.left;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">//targetNode是parent的右子结点</span></span><br><span class="line">                            parent.right = targetNode.left;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        root = targetNode.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果要删除的结点有左子结点</span></span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//如果targetNode是parent的左子结点</span></span><br><span class="line">                        <span class="keyword">if</span> (parent.left.value == value) &#123;</span><br><span class="line">                            parent.left = targetNode.right;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">//如果targetNode是parent的右子结点</span></span><br><span class="line">                            parent.right = targetNode.right;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        root = targetNode.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 希望删除的结点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果找到返回该结点，否则返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">this</span>.value) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line">            <span class="comment">//如果查找的值小于当前结点，向左子树递归查找</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.left.search(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.right.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找要删除的节点的父节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 要找到的结点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回的是要删除的结点的父结点，如果没有就返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">seachParent</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果当前结点就是要刷除的结点的父结点，就返回</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.value == value) ||</span><br><span class="line">                (<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.value == value)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果查找的值小于当前结点的值，并且当前结点的左子结点不为空</span></span><br><span class="line">            <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.left.seachParent(value);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= <span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.right.seachParent(value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归的形式添加结点，注意需要满足二叉排序树的要求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.value &lt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.left = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.value &gt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.right = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h1><p><img data-src="https://xuemingde.com/pages/image/2022/10/10/081630YhZ24j.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/10/081936w2NP7A.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/10/082001fn7rZh.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/10/082227KwW5bm.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/10/082248vCTsqG.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/14/10281076ElkR.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/14/10303621fnYP.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/14/104724CfeOlF.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/14/110512iCcvRY.png" alt=""></p>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 平衡二叉树</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：XMD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 10.10.22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AvlTreeDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        int[] arr = &#123;4, 3, 6, 5, 7, 8&#125;;</span></span><br><span class="line"><span class="comment">//        int[] arr = &#123;10, 12, 8, 9, 7, 6&#125;;</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">10</span>, <span class="number">12</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        AVLTree avlTree = <span class="keyword">new</span> AVLTree();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : arr) &#123;</span><br><span class="line">            avlTree.add(<span class="keyword">new</span> Node(i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;中序遍历&quot;</span>);</span><br><span class="line">        avlTree.infixOrder();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;在平衡之后----&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;树的高度=&quot;</span> + avlTree.getRoot().height());</span><br><span class="line">        System.out.println(<span class="string">&quot;左子树的高度=&quot;</span> + avlTree.getRoot().leftHeight());</span><br><span class="line">        System.out.println(<span class="string">&quot;右子树的高度=&quot;</span> + avlTree.getRoot().rightHeight());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前的根节点=&quot;</span> + avlTree.getRoot());</span><br><span class="line">        System.out.println(<span class="string">&quot;当前的根左节点=&quot;</span> + avlTree.getRoot().left);</span><br><span class="line">        System.out.println(<span class="string">&quot;当前的根右节点=&quot;</span> + avlTree.getRoot().right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AVLTree</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">getRoot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            root = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            root.infixOrder();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;空的&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找要删除的结点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">searchParent</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> root.seachParent(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node 传入的结点（当做二叉排序树的根结点）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回的以node为根结点的二叉排序树的最小结点的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delRightTreeMin</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        Node target = node;</span><br><span class="line">        <span class="keyword">while</span> (target.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            target = target.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除最小的节点</span></span><br><span class="line">        delNode(target.value);</span><br><span class="line">        <span class="keyword">return</span> target.value;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除结点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//1,需求先去找到要则除的结点targetNode</span></span><br><span class="line">            Node targetNode = search(value);</span><br><span class="line">            <span class="comment">//如果没有找到要删除的结点</span></span><br><span class="line">            <span class="keyword">if</span> (targetNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果我们发现当前这颗二叉排序树只有一个结点</span></span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                root = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//去找到targetNode的父结点</span></span><br><span class="line">            Node parent = searchParent(value);</span><br><span class="line">            <span class="keyword">if</span> (targetNode.left == <span class="keyword">null</span> &amp;&amp; targetNode.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//判断targetNode是父结点的左子结点，还是右子结点</span></span><br><span class="line">                <span class="keyword">if</span> (parent.left != <span class="keyword">null</span> &amp;&amp; parent.left.value == value) &#123;</span><br><span class="line">                    <span class="comment">//是左子结点</span></span><br><span class="line">                    parent.left = <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parent.right != <span class="keyword">null</span> &amp;&amp; parent.right.value == value) &#123;</span><br><span class="line">                    <span class="comment">//是右子结点</span></span><br><span class="line">                    parent.right = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetNode.left != <span class="keyword">null</span> &amp;&amp; targetNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//删除有两颗子树的节点</span></span><br><span class="line">                <span class="keyword">int</span> treeMin = delRightTreeMin(targetNode.right);</span><br><span class="line">                targetNode.value = treeMin;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//删除只有一个子节点的节点</span></span><br><span class="line">                <span class="comment">//如果要删除的节点有左子节点</span></span><br><span class="line">                <span class="keyword">if</span> (targetNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//如果targetNode是parent的左子结点</span></span><br><span class="line">                        <span class="keyword">if</span> (parent.left.value == value) &#123;</span><br><span class="line">                            parent.left = targetNode.left;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">//targetNode是parent的右子结点</span></span><br><span class="line">                            parent.right = targetNode.left;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        root = targetNode.left;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果要删除的结点有左子结点</span></span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//如果targetNode是parent的左子结点</span></span><br><span class="line">                        <span class="keyword">if</span> (parent.left.value == value) &#123;</span><br><span class="line">                            parent.left = targetNode.right;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">//如果targetNode是parent的右子结点</span></span><br><span class="line">                            parent.right = targetNode.right;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        root = targetNode.right;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Node&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;value=&quot;</span> + value +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回左子树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leftHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left.height();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回右子树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rightHeight</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right.height();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回当前节点的高度，以该节点为根节点的树的高度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">height</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(left == <span class="keyword">null</span> ? <span class="number">0</span> : left.height(), right == <span class="keyword">null</span> ? <span class="number">0</span> : right.height()) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 希望删除的结点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果找到返回该结点，否则返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">search</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">this</span>.value) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line">            <span class="comment">//如果查找的值小于当前结点，向左子树递归查找</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.left.search(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.right.search(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找要删除的节点的父节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 要找到的结点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回的是要删除的结点的父结点，如果没有就返回null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">seachParent</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果当前结点就是要刷除的结点的父结点，就返回</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">this</span>.left != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.left.value == value) ||</span><br><span class="line">                (<span class="keyword">this</span>.right != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.right.value == value)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果查找的值小于当前结点的值，并且当前结点的左子结点不为空</span></span><br><span class="line">            <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.left.seachParent(value);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt;= <span class="keyword">this</span>.value &amp;&amp; <span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.right.seachParent(value);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归的形式添加结点，注意需要满足二叉排序树的要求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node.value &lt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.left == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.left = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.left.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.value &gt; <span class="keyword">this</span>.value) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.right = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.right.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//当添加完节点后，如果：右子树的高度-左子树的高度 &gt; 1,需要左旋转</span></span><br><span class="line">        <span class="keyword">if</span> (rightHeight() - leftHeight() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//如果它的右子树的左子树的高度大于它的右子树的右子树的高度</span></span><br><span class="line">            <span class="keyword">if</span> (right != <span class="keyword">null</span> &amp;&amp; right.leftHeight() &gt; right.rightHeight())&#123;</span><br><span class="line">                right.rightRotate();</span><br><span class="line">                leftRotate();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//左旋转</span></span><br><span class="line">                leftRotate();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//必须要！！！</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        //当添加完一个结点后，如果（左子树的高度~右子树的高度）&gt;1，右旋转</span></span><br><span class="line">        <span class="keyword">if</span> (leftHeight() - rightHeight() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; left.rightHeight() &gt; left.leftHeight())&#123;</span><br><span class="line">                <span class="comment">//先对当前结点的左结点（左子树）-&gt;左旋转</span></span><br><span class="line">                left.leftRotate();</span><br><span class="line">                <span class="comment">//再对当前结点进行右旋转</span></span><br><span class="line">                rightRotate();</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                rightRotate();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">infixOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.left.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.right.infixOrder();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//左旋转方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">leftRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建新的结点，以当前根结点的值</span></span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line">        <span class="comment">//把新的结点的左子树设置成当前的结点 的左子树</span></span><br><span class="line">        newNode.left = left;</span><br><span class="line">        <span class="comment">//把新的结点的右子树设置成当前结点的右子树的左子树</span></span><br><span class="line">        newNode.right = right.right;</span><br><span class="line">        <span class="comment">//把当前节点的值替换成右子节点的值</span></span><br><span class="line">        value = right.value;</span><br><span class="line">        <span class="comment">//把当前结点的右子树设置成当前结点的右子树的右子树</span></span><br><span class="line">        right = right.right;</span><br><span class="line">        <span class="comment">//把当前结点的左子树设置成新的节点</span></span><br><span class="line">        left = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 右旋转</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rightRotate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node newNode = <span class="keyword">new</span> Node(value);</span><br><span class="line">        newNode.right = right;</span><br><span class="line">        newNode.left = left.right;</span><br><span class="line">        value = left.value;</span><br><span class="line">        left = left.left;</span><br><span class="line">        right = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>集合</tag>
        <tag>堆</tag>
        <tag>数组</tag>
        <tag>局部</tag>
        <tag>变量</tag>
        <tag>Qt</tag>
        <tag>索引</tag>
        <tag>MQ</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础16：图</title>
    <url>/posts/15KJ31K.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="图的基本介绍"><a href="#图的基本介绍" class="headerlink" title="图的基本介绍"></a>图的基本介绍</h1><p><strong>为什么要有图</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/15/1414506sNQMH.png" alt=""></p>
<p><strong>图的举例说明</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/15/141527E8jUYT.png" alt=""></p>
<h1 id="图的常用概念"><a href="#图的常用概念" class="headerlink" title="图的常用概念"></a>图的常用概念</h1><p><img data-src="https://xuemingde.com/pages/image/2022/10/15/141723LQQY8y.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/15/141754tviCu3.png" alt=""></p>
<h1 id="图的表示方式"><a href="#图的表示方式" class="headerlink" title="图的表示方式"></a>图的表示方式</h1><p><img data-src="https://xuemingde.com/pages/image/2022/10/15/141918IYcm2m.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/15/142209DGc0Mc.png" alt=""></p>
<h1 id="图的快速入门案例"><a href="#图的快速入门案例" class="headerlink" title="图的快速入门案例"></a>图的快速入门案例</h1><p><img data-src="https://xuemingde.com/pages/image/2022/10/15/142500Z38tsY.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TODO</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：XMD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 15.10.22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储顶点集合</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertexList;</span><br><span class="line">    <span class="comment">//存储图对应的邻结矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] edges;</span><br><span class="line">    <span class="comment">//表示边的数目</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numOfEdges;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//结点个数</span></span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">        String vertexs[] = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//创建图对象</span></span><br><span class="line">        Graph graph = <span class="keyword">new</span> Graph(n);</span><br><span class="line">        <span class="comment">//添加顶点</span></span><br><span class="line">        <span class="keyword">for</span> (String value : vertexs) &#123;</span><br><span class="line">            graph.insertVertex(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加边  A-B  A-C  B-C  B-D  B-E</span></span><br><span class="line">        graph.insetEdges(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">        graph.insetEdges(<span class="number">0</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">        graph.insetEdges(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">        graph.insetEdges(<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">        graph.insetEdges(<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//显式</span></span><br><span class="line">        graph.showGraph();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        vertexList = <span class="keyword">new</span> ArrayList&lt;&gt;(n);</span><br><span class="line">        numOfEdges = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显式图</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) &#123;</span><br><span class="line">            System.err.println(Arrays.toString(edge));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回结点的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumOfVertex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到边的数目</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumOfEdges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numOfEdges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回结点对应的数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValueByIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.get(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回v1和v2的权值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加结点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vertex</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertVertex</span><span class="params">(String vertex)</span> </span>&#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加边</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1     表示点的下标即使第几个顶点&quot;A&quot;-&quot;B&quot;&quot;A&quot;-&gt;0&quot;B&quot;-&gt;1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2     第二个顶点对应的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insetEdges</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        edges[v1][v2] = weight;</span><br><span class="line">        edges[v2][v1] = weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="图的深度优先遍历"><a href="#图的深度优先遍历" class="headerlink" title="图的深度优先遍历"></a>图的深度优先遍历</h1><p><img data-src="https://xuemingde.com/pages/image/2022/10/15/153916N6Efvo.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/15/155015t6vgIK.png" alt=""></p>
<h1 id="图的广度优先遍历"><a href="#图的广度优先遍历" class="headerlink" title="图的广度优先遍历"></a>图的广度优先遍历</h1><p><img data-src="https://xuemingde.com/pages/image/2022/10/17/090950GajbCf.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/17/091259tagB5U.png" alt=""></p>
<h1 id="广度优先与深度优先遍历的代码实现"><a href="#广度优先与深度优先遍历的代码实现" class="headerlink" title="广度优先与深度优先遍历的代码实现"></a>广度优先与深度优先遍历的代码实现</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TODO</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：XMD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 15.10.22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="comment">//存储顶点集合</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; vertexList;</span><br><span class="line">    <span class="comment">//存储图对应的邻结矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] edges;</span><br><span class="line">    <span class="comment">//表示边的数目</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numOfEdges;</span><br><span class="line">    <span class="comment">//记录某个结点是否被访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] isVisited;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String vertexs[] = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">//创建图对象</span></span><br><span class="line">        Graph graph = <span class="keyword">new</span> Graph(vertexs.length);</span><br><span class="line">        <span class="comment">//添加顶点</span></span><br><span class="line">        <span class="keyword">for</span> (String value : vertexs) &#123;</span><br><span class="line">            graph.insertVertex(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//添加边  A-B  A-C  B-C  B-D  B-E</span></span><br><span class="line">        graph.insetEdges(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insetEdges(<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insetEdges(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insetEdges(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">        graph.insetEdges(<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//显式</span></span><br><span class="line"><span class="comment">//        graph.showGraph();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println(&quot;测试DFS&quot;);</span></span><br><span class="line"><span class="comment">//        graph.dfs();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;测试BFS&quot;</span>);</span><br><span class="line">        graph.bfs();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        vertexList = <span class="keyword">new</span> ArrayList&lt;&gt;(n);</span><br><span class="line">        numOfEdges = <span class="number">0</span>;</span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到第一个邻接结点的下标</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果存在就返回对应的下标，否则返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFirstNeighbor</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexList.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[index][i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据前一个邻接结点的下标来获取下一个邻接结点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNextNeighbor</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = v2 + <span class="number">1</span>; i &lt; vertexList.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (edges[v1][i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 深度优先遍历算法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isVisited</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">boolean</span>[] isVisited, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//首先我们访问该结点，输出</span></span><br><span class="line">        System.out.print(getValueByIndex(i) + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">        <span class="comment">//将结点设置为已经访问</span></span><br><span class="line">        isVisited[i] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//查找结点i的第一个邻接结点w</span></span><br><span class="line">        <span class="keyword">int</span> w = getFirstNeighbor(i);</span><br><span class="line">        <span class="keyword">while</span> (w != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isVisited[w]) &#123;</span><br><span class="line">                <span class="comment">//没有被访问过</span></span><br><span class="line">                dfs(isVisited, w);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果w结点已经被访问过</span></span><br><span class="line">            w = getNextNeighbor(i, w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对dfs进行重载，遍历所有的节点，进行dfs</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[vertexList.size()];</span><br><span class="line">        <span class="comment">//遍历所有的结点进行dfs</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getNumOfVertex(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isVisited[i]) &#123;</span><br><span class="line">                dfs(isVisited, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对一个结点进行广度优先遍历的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isVisited</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">boolean</span>[] isVisited, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> u; <span class="comment">// 表示队列的头节点对应的下标</span></span><br><span class="line">        <span class="keyword">int</span> w; <span class="comment">//邻接结点W</span></span><br><span class="line">        LinkedList&lt;Object&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//访问结点，输出结点的信息</span></span><br><span class="line">        System.out.print(getValueByIndex(i) + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">        isVisited[i] = <span class="keyword">true</span>;</span><br><span class="line">        queue.addLast(i);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//取出队列的头结点下标</span></span><br><span class="line">            u = (Integer) queue.removeFirst();</span><br><span class="line">            <span class="comment">//得到第一个邻接结点的下标W</span></span><br><span class="line">            w = getFirstNeighbor(u);</span><br><span class="line">            <span class="keyword">while</span> (w != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//是否访问过</span></span><br><span class="line">                <span class="keyword">if</span> (!isVisited[w]) &#123;</span><br><span class="line">                    System.out.print(getValueByIndex(w) + <span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">                    isVisited[w] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">//入队列</span></span><br><span class="line">                    queue.addLast(w);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//以u为前驱点，找w后面的下一个邻结点</span></span><br><span class="line">                w = getNextNeighbor(u, w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 遍历所有的结点，都进行广度优先搜索</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isVisited = <span class="keyword">new</span> <span class="keyword">boolean</span>[vertexList.size()];</span><br><span class="line">        <span class="comment">//遍历所有的结点进行bfs</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; getNumOfVertex(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!isVisited[i]) &#123;</span><br><span class="line">                bfs(isVisited, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//显式图</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) &#123;</span><br><span class="line">            System.err.println(Arrays.toString(edge));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回结点的个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumOfVertex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到边的数目</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumOfEdges</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> numOfEdges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回结点对应的数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValueByIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vertexList.get(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回v1和v2的权值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWeight</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> edges[v1][v2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加结点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vertex</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertVertex</span><span class="params">(String vertex)</span> </span>&#123;</span><br><span class="line">        vertexList.add(vertex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加边</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v1     表示点的下标即使第几个顶点&quot;A&quot;-&quot;B&quot;&quot;A&quot;-&gt;0&quot;B&quot;-&gt;1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v2     第二个顶点对应的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insetEdges</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        edges[v1][v2] = weight;</span><br><span class="line">        edges[v2][v1] = weight;</span><br><span class="line">        numOfEdges++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="DFS与BFS-比较"><a href="#DFS与BFS-比较" class="headerlink" title="DFS与BFS 比较"></a>DFS与BFS 比较</h1><p><img data-src="https://xuemingde.com/pages/image/2022/10/17/09380119ieBJ.png" alt=""></p>
]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>集合</tag>
        <tag>GC</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>算法基础17：常用的10种算法</title>
    <url>/posts/21HQZA5.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="二分查找算法"><a href="#二分查找算法" class="headerlink" title="二分查找算法"></a>二分查找算法</h1><ol>
<li>非递归</li>
</ol>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/17/100130p9u6Y8.png" alt=""></p>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchNoRecur</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">67</span>, <span class="number">100</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> index = binarySearch(arr, <span class="number">11</span>);</span><br><span class="line">        System.out.println(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二分查找的非递归实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> arr    待查找的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 需要查找的数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回对应下标，-1表示没有找到</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = arr.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h1><p><img data-src="https://xuemingde.com/pages/image/2022/10/17/102158MjHvsu.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/17/1024475DYcYV.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/17/102621ycFGQW.png" alt=""></p>
<h2 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h2><p><img data-src="https://xuemingde.com/pages/image/2022/10/17/102847AuZjA2.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/17/1448517oUTQZ.png" alt=""></p>
<p>汉诺塔问题代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HanoiTower</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        hanoiTower(<span class="number">5</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hanoiTower</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">char</span> a, <span class="keyword">char</span> b, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果只有一个盘</span></span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;第1个盘从&quot;</span> + a + <span class="string">&quot;-&gt;&quot;</span> + c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果我们有&gt;=2情况，我们总是可以看做是两个盘1.最下边的一个盘2，上面的所有盘</span></span><br><span class="line">            <span class="comment">//1. 先把最上面的所有盘A-&gt; B,移动过程使用到C</span></span><br><span class="line">            hanoiTower(num - <span class="number">1</span>, a, c, b);</span><br><span class="line">            <span class="comment">//2. 把最小面的盘 A-&gt;C</span></span><br><span class="line">            System.out.println(<span class="string">&quot;第&quot;</span> + num + <span class="string">&quot;个盘从&quot;</span> + a + <span class="string">&quot;-&gt;&quot;</span> + c);</span><br><span class="line">            <span class="comment">//3. 把B的所有盘从B——&gt;C 移动成功使用A</span></span><br><span class="line">            hanoiTower(num - <span class="number">1</span>, b, a, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="动态规划算法"><a href="#动态规划算法" class="headerlink" title="动态规划算法"></a>动态规划算法</h1><p><img data-src="https://xuemingde.com/pages/image/2022/10/17/153743pNkckP.png" alt=""></p>
<p><strong>介绍</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/17/154417X7x9zs.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/17/154745MPcmAz.png" alt=""></p>
<h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p><img data-src="https://xuemingde.com/pages/image/2022/10/17/154821X6GdM7.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/17/161940UgivUN.png" alt=""></p>
<p>背包问题代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">knapsackProblem</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//物品重量</span></span><br><span class="line">        <span class="keyword">int</span>[] w = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="comment">//物品价值（物品的价值这里val[i]就是前面讲的v[i]）</span></span><br><span class="line">        <span class="keyword">int</span>[] val = &#123;<span class="number">1500</span>, <span class="number">3000</span>, <span class="number">2000</span>, <span class="number">4000</span>, <span class="number">3500</span>&#125;;</span><br><span class="line">        <span class="comment">//背包容量</span></span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">5</span>;</span><br><span class="line">        <span class="comment">//物品个数</span></span><br><span class="line">        <span class="keyword">int</span> n = val.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//w[1][j]表示在前i个物品中能够装入容量为j的背包中的最大价值</span></span><br><span class="line">        <span class="keyword">int</span>[][] v = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//为了记录放入商品的情况，我们定一个二维数组</span></span><br><span class="line">        <span class="keyword">int</span>[][] path = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//初始化第一行第一列，这里在本程序中可以不去处理，因为默认为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.length; i++) &#123;</span><br><span class="line">            v[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v[<span class="number">0</span>].length; i++) &#123;</span><br><span class="line">            v[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据更是规划处理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; v.length; i++) &#123;<span class="comment">//不处理第一行1是从1开始的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; v[<span class="number">0</span>].length; j++) &#123;<span class="comment">//不处理第一列，j是从1开始的</span></span><br><span class="line">                <span class="keyword">if</span> (w[i - <span class="number">1</span>] &gt; j) &#123;<span class="comment">//因为我们程序i是从1开始的，因此原来公式中的w[i]修改成w[i-1]</span></span><br><span class="line">                    v[i][j] = v[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//因为我们的1从1开始的，因此公式需要调整如下</span></span><br><span class="line"><span class="comment">//                    v[i][j] = Math.max(v[i - 1][j], val[i - 1] + v[i - 1][j - w[i - 1]]);</span></span><br><span class="line">                    <span class="keyword">if</span> (v[i - <span class="number">1</span>][j] &lt; val[i - <span class="number">1</span>] + v[i - <span class="number">1</span>][j - w[i - <span class="number">1</span>]]) &#123;</span><br><span class="line">                        v[i][j] = val[i - <span class="number">1</span>] + v[i - <span class="number">1</span>][j - w[i - <span class="number">1</span>]];</span><br><span class="line">                        path[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        v[i][j] = v[i - <span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v[i].length; j++) &#123;</span><br><span class="line">                System.out.print(v[i][j] + <span class="string">&quot;   &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        for (int i = 0; i &lt; path.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//            for (int j = 0; j &lt; path[i].length; j++) &#123;</span></span><br><span class="line"><span class="comment">//                if (path[i][j] == 1) &#123;</span></span><br><span class="line"><span class="comment">//                    System.out.printf(&quot;第%d个商品放入到背包&quot;, i);</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//                System.out.println();</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = path.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = path[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span> &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (path[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;第%d个商品放入到背包&quot;</span>, i);</span><br><span class="line">                System.out.println();</span><br><span class="line">                j -= w[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h1><p><img data-src="https://xuemingde.com/pages/image/2022/10/17/1703363Hyii3.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/17/170704VB7OVs.png" alt=""></p>
<p>暴力算法 代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViolentMatch</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">&quot;付货款都是垃圾和家里房东还是垃圾和家圾和家里&quot;</span>;</span><br><span class="line">        String str2 = <span class="string">&quot;是垃圾和家圾&quot;</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> match = violentMatch(str1, str2);</span><br><span class="line">        System.out.println(match);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 暴力匹配算法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">violentMatch</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] s1 = str1.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] s2 = str2.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> s1len = s1.length;</span><br><span class="line">        <span class="keyword">int</span> s2len = s2.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; s1len &amp;&amp; j &lt; s2len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1[i] == s2[j]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i = i - (j - <span class="number">1</span>);</span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == s2len) &#123;</span><br><span class="line">            <span class="keyword">return</span> i - j;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>KMP 算法介绍</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/17/1722471omnmW.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/17/184223lIOaqq.png" alt=""></p>
<p>KMP 算法代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * KMP算法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：XMD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 17.10.22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KmpAlgorithm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">&quot;BBC ABCDAB ABCDABCDABDE&quot;</span>;</span><br><span class="line">        String str2 = <span class="string">&quot;ABCDABD&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span>[] ints = kmpNext(str2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> search = kmpSearch(str1, str2, ints);</span><br><span class="line">        System.out.println(search);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * KMP算法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str1 源数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str2 子数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> next 部分匹配表，是子串对应的部分匹配表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果是-1就是没有匹配到，否则返回第一个匹配的位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kmpSearch</span><span class="params">(String str1, String str2, <span class="keyword">int</span>[] next)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; str1.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//需要处理str1,charAt(i)！=str2,charAt(j),去调整j的大小</span></span><br><span class="line">            <span class="comment">// KMP算法核心点</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; str1.charAt(i) != str2.charAt(j)) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (str1.charAt(i) == str2.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == str2.length()) &#123;</span><br><span class="line">                <span class="keyword">return</span> i - j + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取到一个字符串（子串）的部分匹配值表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dest</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] kmpNext(String dest) &#123;</span><br><span class="line">        <span class="comment">//创建一个neXt数组保存部分匹配值</span></span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[dest.length()];</span><br><span class="line">        <span class="comment">///如果字符串是长度为1部分匹配值就是0</span></span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; dest.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//当dest.charAt(i) != dest.charAt(j) 需要从next[j-1] 获取新的j</span></span><br><span class="line">            <span class="comment">//直到有dest.charAt(i) == dest.charAt(j) 成立时退出</span></span><br><span class="line">            <span class="comment">//这是kmp算法的核心点</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; dest.charAt(i) != dest.charAt(j)) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当dest.charAt(i)== dest.charAt(j)满足时，部分匹配值就+1</span></span><br><span class="line">            <span class="keyword">if</span> (dest.charAt(i) == dest.charAt(j)) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="贪婪（贪心）算法"><a href="#贪婪（贪心）算法" class="headerlink" title="贪婪（贪心）算法"></a>贪婪（贪心）算法</h1><p><img data-src="https://xuemingde.com/pages/image/2022/10/17/202750KjtZ8K.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/17/202939Xf24vB.png" alt=""></p>
<p>案例</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/17/203138eNPcju.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/17/203213EG2WSj.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/17/20360026q0VN.png" alt=""></p>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 贪婪算法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：XMD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 17.10.22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AreedyAlgorithm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, HashSet&lt;String&gt;&gt; broadcasts = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        HashSet&lt;String&gt; hashSet1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        hashSet1.add(<span class="string">&quot;北京&quot;</span>);</span><br><span class="line">        hashSet1.add(<span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        hashSet1.add(<span class="string">&quot;天津&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; hashSet2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        hashSet2.add(<span class="string">&quot;广州&quot;</span>);</span><br><span class="line">        hashSet2.add(<span class="string">&quot;北京&quot;</span>);</span><br><span class="line">        hashSet2.add(<span class="string">&quot;深圳&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; hashSet3 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        hashSet3.add(<span class="string">&quot;成都&quot;</span>);</span><br><span class="line">        hashSet3.add(<span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        hashSet3.add(<span class="string">&quot;杭州&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; hashSet4 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        hashSet4.add(<span class="string">&quot;上海&quot;</span>);</span><br><span class="line">        hashSet4.add(<span class="string">&quot;天津&quot;</span>);</span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; hashSet5 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        hashSet5.add(<span class="string">&quot;杭州&quot;</span>);</span><br><span class="line">        hashSet5.add(<span class="string">&quot;大连&quot;</span>);</span><br><span class="line"></span><br><span class="line">        broadcasts.put(<span class="string">&quot;K1&quot;</span>, hashSet1);</span><br><span class="line">        broadcasts.put(<span class="string">&quot;K2&quot;</span>, hashSet2);</span><br><span class="line">        broadcasts.put(<span class="string">&quot;K3&quot;</span>, hashSet3);</span><br><span class="line">        broadcasts.put(<span class="string">&quot;K4&quot;</span>, hashSet4);</span><br><span class="line">        broadcasts.put(<span class="string">&quot;K5&quot;</span>, hashSet5);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//存放所有的地区</span></span><br><span class="line">        HashSet&lt;String&gt; allAdress = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        allAdress.addAll(hashSet1);</span><br><span class="line">        allAdress.addAll(hashSet2);</span><br><span class="line">        allAdress.addAll(hashSet3);</span><br><span class="line">        allAdress.addAll(hashSet4);</span><br><span class="line">        allAdress.addAll(hashSet5);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建list，存放选择的电台集合</span></span><br><span class="line">        List&lt;String&gt; selects = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//定义一个临时的集合，在遍历的过程中，存放遍历过程中的电台覆盖的地区和当前还没有覆盖的地区的交集</span></span><br><span class="line">        HashSet&lt;String&gt; tempSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">//定义给maxKey,保存在一次遍历过程中，能够覆盖最大未覆盖的地区对应的电台的key</span></span><br><span class="line">        String maxKey;</span><br><span class="line">        <span class="comment">// 如果naxKey不为nul1,则会加入到selects</span></span><br><span class="line">        <span class="comment">//如果allAreas不为0，则表示还没有覆盖到所有的地区</span></span><br><span class="line">        <span class="keyword">while</span> (allAdress.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            maxKey = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (String key : broadcasts.keySet()) &#123;</span><br><span class="line">                tempSet.clear();</span><br><span class="line">                HashSet&lt;String&gt; areas = broadcasts.get(key);</span><br><span class="line">                tempSet.addAll(areas);</span><br><span class="line">                <span class="comment">//求出tempSet和allAreas集合的交集，交集会赋给tempSet</span></span><br><span class="line">                tempSet.retainAll(allAdress);</span><br><span class="line">                <span class="comment">//如果当前这个集合包含的未覆盖地区的数量，比maxKey指向的集合地区还多</span></span><br><span class="line">                <span class="comment">//就需要重置maxKey 体现出贪心算法的特点，每次都选择最优的</span></span><br><span class="line">                <span class="comment">//broadcasts.get(maxKey).size()</span></span><br><span class="line">                <span class="keyword">if</span> (tempSet.size() &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        (maxKey == <span class="keyword">null</span> || tempSet.size() &gt; broadcasts.get(maxKey).size())) &#123;</span><br><span class="line">                    maxKey = key;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//maxKey!=null,就应该将maxKey加入selects</span></span><br><span class="line">            <span class="keyword">if</span> (maxKey != <span class="keyword">null</span>) &#123;</span><br><span class="line">                selects.add(maxKey);</span><br><span class="line">                <span class="comment">//将maxKey指向的广播电台覆盖的地区，从allArees去掉</span></span><br><span class="line">                allAdress.removeAll(broadcasts.get(maxKey));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;结果：&quot;</span> + selects);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/17/212025oAu6Pd.png" alt=""></p>
<h1 id="普里姆算法"><a href="#普里姆算法" class="headerlink" title="普里姆算法"></a>普里姆算法</h1><p><img data-src="https://xuemingde.com/pages/image/2022/10/18/0808136xEf5l.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/18/08114811DNBc.png" alt=""></p>
<p><strong>正确的思路，就是尽可能的选择少的路线，并且每条路线最小，保证总里程数最少</strong></p>
<h2 id="普里姆算法介绍"><a href="#普里姆算法介绍" class="headerlink" title="普里姆算法介绍"></a>普里姆算法介绍</h2><ol>
<li><p>普利姆(Prim)算法求最小生成树，也就是在包含n个顶点的连通图中，找出只有(n-1)条边包含所有n个顶点的连通子图，也就是所谓的<strong>极小连通子图</strong></p>
</li>
<li><p>普利姆的算法如下：</p>
<ol>
<li>设G=(N,E)是连通网，T=(U,D)是最小生成树，V,U是顶点集合，E,D是边的集合</li>
<li>若从顶点u开始构造最小生成树，则从集合V中取出顶点u放入集合U中，标记顶点v的visited[u]=1</li>
</ol>
</li>
</ol>
<ol>
<li>若集合U中顶点ui与集合V-U中的顶点v之间存在边，则寻找这些边中权值最小的边，但不能构成回路，将顶点vj加入集合U中，将边(ui,vj)加入集合D中，标记visited[vj]=1</li>
<li>重复步骤②，直到U与V相等，即所有顶点都被标记为访问过，此时D中有n-1条边</li>
<li><strong>提示：单独看步骤很难理解，我们通过代码来讲解，比较好理解</strong>.</li>
</ol>
<p>代码实现（修路问题）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimAlgorithm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] data = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> verxs = data.length;</span><br><span class="line">        <span class="comment">//10000表示两点不连通</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[][] weight = &#123;</span><br><span class="line">                &#123;<span class="number">10000</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">2</span>&#125;,</span><br><span class="line">                &#123;<span class="number">5</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">9</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">3</span>&#125;,</span><br><span class="line">                &#123;<span class="number">7</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">8</span>, <span class="number">10000</span>, <span class="number">10000</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10000</span>, <span class="number">9</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">4</span>, <span class="number">10000</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10000</span>, <span class="number">10000</span>, <span class="number">8</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">5</span>, <span class="number">4</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10000</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">10000</span>, <span class="number">6</span>&#125;,</span><br><span class="line">                &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">10000</span>, <span class="number">10000</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">10000</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        MGraph mGraph = <span class="keyword">new</span> MGraph(verxs);</span><br><span class="line">        MinTree minTree = <span class="keyword">new</span> MinTree();</span><br><span class="line">        minTree.createGraph(mGraph, verxs, data, weight);</span><br><span class="line">        minTree.showGraph(mGraph);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        minTree.prim(mGraph, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建最小生成树-&gt;村庄的图</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinTree</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建图的邻接矩阵</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph  图对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> verxs  图对应的顶点个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> data   图的各个顶点的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> weight 图的邻接矩阵</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createGraph</span><span class="params">(MGraph graph, <span class="keyword">int</span> verxs, <span class="keyword">char</span>[] data, <span class="keyword">int</span>[][] weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; verxs; i++) &#123;</span><br><span class="line">            graph.data[i] = data[i];</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; verxs; j++) &#123;</span><br><span class="line">                graph.weight[i][j] = weight[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 显式图的邻接矩阵</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGraph</span><span class="params">(MGraph graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] link : graph.weight) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(link));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编写prim算法，得到最小生成树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> graph</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v     表示从图的第几个顶点开始生成&#x27;A&#x27;-&gt;0&#x27;B&#x27;-&gt;1,··</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prim</span><span class="params">(MGraph graph, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[graph.verxs];</span><br><span class="line">        <span class="comment">//把当前这个结点标记为已访问</span></span><br><span class="line">        visited[v] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//h1和h2记录两个顶点的下标</span></span><br><span class="line">        <span class="keyword">int</span> h1 = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> h2 = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//将minWeight初始成一个大数，后面在遍历过程中，会被替换</span></span><br><span class="line">        <span class="keyword">int</span> minWeight = <span class="number">10000</span>;</span><br><span class="line">        <span class="comment">//因为有graph,verxs顶点，普利姆算法结束后，有graph.verxs-l边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; graph.verxs; k++) &#123;</span><br><span class="line">            <span class="comment">//确定每一次生成的子图和哪个节点的距离最近</span></span><br><span class="line">            <span class="comment">//节点表示被访问的结点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; graph.verxs; i++) &#123;</span><br><span class="line">                <span class="comment">//j表示还没有被访问过的节点</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graph.verxs; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (visited[i] == <span class="number">1</span> &amp;&amp; visited[j] == <span class="number">0</span> &amp;&amp; graph.weight[i][j] &lt; minWeight) &#123;</span><br><span class="line">                        <span class="comment">//寻找已经访问过的结点和未访问过的结点间的权值最小的边</span></span><br><span class="line">                        minWeight = graph.weight[i][j];</span><br><span class="line">                        h1 = i;</span><br><span class="line">                        h2 = j;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到一条最小的边</span></span><br><span class="line">            System.out.println(<span class="string">&quot;边&quot;</span> + graph.data[h1] + <span class="string">&quot;,&quot;</span> + graph.data[h2] + <span class="string">&quot;权值：&quot;</span> + minWeight);</span><br><span class="line">            <span class="comment">//将当前这个结点标记为已经访问</span></span><br><span class="line">            visited[h2] = <span class="number">1</span>;</span><br><span class="line">            minWeight = <span class="number">10000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MGraph</span> </span>&#123;</span><br><span class="line">    <span class="comment">//表示图的节点个数</span></span><br><span class="line">    <span class="keyword">int</span> verxs;</span><br><span class="line">    <span class="comment">//存放结点数据</span></span><br><span class="line">    <span class="keyword">char</span>[] data;</span><br><span class="line">    <span class="comment">//存放边，就是我们的邻接矩阵</span></span><br><span class="line">    <span class="keyword">int</span>[][] weight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MGraph</span><span class="params">(<span class="keyword">int</span> verxs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.verxs = verxs;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="keyword">char</span>[verxs];</span><br><span class="line">        weight = <span class="keyword">new</span> <span class="keyword">int</span>[verxs][verxs];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="克鲁斯卡尔算法"><a href="#克鲁斯卡尔算法" class="headerlink" title="克鲁斯卡尔算法"></a>克鲁斯卡尔算法</h1><p><img data-src="https://xuemingde.com/pages/image/2022/10/18/094127Iirgn2.png" alt=""></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><ol>
<li>克鲁斯卡尔(Kruskal)算法，是用来求加权连通图的最小生成树的算法。</li>
<li>基本思想：按照权值从小到大的顺序选择n-1条边，并保证这n-1条边不构成回路</li>
<li>具体做法：首先构造一个只含个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森林中不产生回路，直至森林变成一棵树为止</li>
</ol>
<h2 id="图解说明"><a href="#图解说明" class="headerlink" title="图解说明"></a>图解说明</h2><p>以城市公交站问题来图解说明克鲁斯卡尔算法的原理和步骤：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/18/094852hUKmPI.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/18/09504874EhXk.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/18/095119JtyENw.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/18/095349c4XJmq.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/18/095459i4mlEr.png" alt=""></p>
<p><strong>克鲁斯卡尔算法分析</strong><br>根据前面介绍的克鲁斯卡尔算法的基本思想和做法，我们能够了解到，克鲁斯卡尔算法重点需要解决的以下两个问题：<br>问题一对图的所有边按照权值大小进行排序。<br>问题二将边添加到最小生成树中时，怎么样判断是否形成了回路。</p>
<p>问题一很好解决，采用排序算法进行排序即可。<br>问题二，处理方式是：记录顶点在”最小生成树”中的终点，顶点的终点是”在最小生成树中与它连通的最大顶点”。然后每次需要将一条边添加到最小生存树时，判断该边的两个顶点的终点是否重合，重合的话则会构成回路。</p>
<p><strong>如何判断是否构成回路</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/18/100821xxjnzI.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/18/100933pV86Lw.png" alt=""></p>
<p>公交站问题代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 克鲁斯卡尔算法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：XMD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18.10.22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KruskalCase</span> </span>&#123;</span><br><span class="line">    <span class="comment">//两个顶点不能连通</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INF = Integer.MAX_VALUE;</span><br><span class="line">    <span class="comment">//顶点数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span>[] vertexs;</span><br><span class="line">    <span class="comment">//邻接矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[][] matrix;</span><br><span class="line">    <span class="comment">//边的个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> edgeNum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">KruskalCase</span><span class="params">(<span class="keyword">char</span>[] vertexs, <span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> vlen = vertexs.length;</span><br><span class="line">        <span class="comment">//初始化顶点</span></span><br><span class="line">        <span class="keyword">this</span>.vertexs = <span class="keyword">new</span> <span class="keyword">char</span>[vlen];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.vertexs[i] = vertexs[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化边</span></span><br><span class="line">        <span class="keyword">this</span>.matrix = <span class="keyword">new</span> <span class="keyword">int</span>[vlen][vlen];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vlen; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vlen; j++) &#123;</span><br><span class="line">                <span class="keyword">this</span>.matrix[i][j] = matrix[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//统计边</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vlen; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; vlen; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.matrix[i][j] != INF) &#123;</span><br><span class="line">                    edgeNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] vertexs = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123;</span><br><span class="line">                &#123;<span class="number">0</span>, <span class="number">12</span>, INF, INF, INF, <span class="number">16</span>, <span class="number">14</span>&#125;,</span><br><span class="line">                &#123;<span class="number">12</span>, <span class="number">0</span>, <span class="number">10</span>, INF, INF, <span class="number">7</span>, INF&#125;,</span><br><span class="line">                &#123;INF, <span class="number">10</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, INF&#125;,</span><br><span class="line">                &#123;INF, INF, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, INF, INF&#125;,</span><br><span class="line">                &#123;INF, INF, <span class="number">5</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">8</span>&#125;,</span><br><span class="line">                &#123;<span class="number">16</span>, <span class="number">7</span>, <span class="number">6</span>, INF, <span class="number">2</span>, <span class="number">0</span>, <span class="number">9</span>&#125;,</span><br><span class="line">                &#123;<span class="number">14</span>, INF, INF, INF, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">        KruskalCase kruskalCase = <span class="keyword">new</span> KruskalCase(vertexs, matrix);</span><br><span class="line"><span class="comment">//        kruskalCase.print();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        final EData[] edges = kruskalCase.getEdges();</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;排序前&quot; + Arrays.toString(edges));</span></span><br><span class="line"><span class="comment">//        kruskalCase.sortEdges(edges);</span></span><br><span class="line"><span class="comment">//        System.out.println(&quot;排序后&quot; + Arrays.toString(edges));</span></span><br><span class="line"></span><br><span class="line">        kruskalCase.print();</span><br><span class="line">        kruskalCase.kruskal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//表示最后结果数组的索引</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//用于保存已有最小生成树中的每个顶点在最小生成树中的终点</span></span><br><span class="line">        <span class="keyword">int</span>[] ends = <span class="keyword">new</span> <span class="keyword">int</span>[edgeNum];</span><br><span class="line">        <span class="comment">//创建结果数组，保存最后的最小生成树</span></span><br><span class="line">        EData[] rets = <span class="keyword">new</span> EData[edgeNum];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取图中所有边的几个</span></span><br><span class="line">        EData[] edges = getEdges();</span><br><span class="line">        System.out.println(<span class="string">&quot;图的边的集合：&quot;</span> + Arrays.toString(edges));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//按照边的权值排序</span></span><br><span class="line">        sortEdges(edges);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历 将边添加到最小生成树中时，判断是准备加入的边否形成了回路，如果没有，就加入rts,否则不能加入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edgeNum; i++) &#123;</span><br><span class="line">            <span class="comment">//获取到第i条边的第一个顶点（起点）</span></span><br><span class="line">            <span class="keyword">int</span> p1 = getPosition(edges[i].start);</span><br><span class="line">            <span class="comment">//获取到第i条边的第2个顶点</span></span><br><span class="line">            <span class="keyword">int</span> p2 = getPosition(edges[i].end);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取p1这个顶点在已有最小生成树中的终点</span></span><br><span class="line">            <span class="keyword">int</span> m = getEnd(ends, p1);</span><br><span class="line">            <span class="comment">//获取2这个顶点在已有最小生成树中的终点</span></span><br><span class="line">            <span class="keyword">int</span> n = getEnd(ends, p2);</span><br><span class="line">            <span class="comment">//是否构成回路</span></span><br><span class="line">            <span class="keyword">if</span> (m != n) &#123;</span><br><span class="line">                ends[m] = n;</span><br><span class="line">                rets[index++] = edges[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//统计并打印最小生成树</span></span><br><span class="line">        System.out.println(<span class="string">&quot;最小生成树：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++) &#123;</span><br><span class="line">            System.out.println(rets[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;邻接矩阵：\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vertexs.length; j++) &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;%12d\t&quot;</span>, matrix[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对边进行排序处理，冒泡排序</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> edges</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sortEdges</span><span class="params">(EData[] edges)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edges.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; edges.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (edges[j].weight &gt; edges[j + <span class="number">1</span>].weight) &#123;</span><br><span class="line">                    EData temp = edges[j];</span><br><span class="line">                    edges[j] = edges[j + <span class="number">1</span>];</span><br><span class="line">                    edges[j + <span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ch</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回ch顶点对应的下标，如果找不到，返回-1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getPosition</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vertexs[i] == ch) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能：获取图中边，放到EData[]数组中，后面我们需要遍历该数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> EData[] getEdges() &#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        EData[] edges = <span class="keyword">new</span> EData[edgeNum];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vertexs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; vertexs.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] != INF) &#123;</span><br><span class="line">                    edges[index++] = <span class="keyword">new</span> EData(vertexs[i], vertexs[j], matrix[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> edges;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能：获取下标为的顶点的终点,用于后面判断两个顶点的终点是否相同</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ends 数组就是记录了各个顶点对应的终点是哪个,ends 数组是在遍历过程中，逐步形成</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i    表示传入的顶点对应的下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回的就是下标为的这个顶点对应的终点的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getEnd</span><span class="params">(<span class="keyword">int</span>[] ends, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (ends[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            i = ends[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EData</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> start;</span><br><span class="line">    <span class="keyword">char</span> end;</span><br><span class="line">    <span class="keyword">int</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EData</span><span class="params">(<span class="keyword">char</span> start, <span class="keyword">char</span> end, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;[&quot;</span> + start + <span class="string">&quot;-&quot;</span> + end + <span class="string">&quot;]:&quot;</span> + weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="迪杰斯特拉算法"><a href="#迪杰斯特拉算法" class="headerlink" title="迪杰斯特拉算法"></a>迪杰斯特拉算法</h1><p><strong>应用场景：最短路径问题</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/18/133053GnI5hw.png" alt=""></p>
<ol>
<li><p>战争时期，胜利乡有7个村庄(A,B,C,D,E,FG),现在有六个邮差，从G点出发，需要分别把邮件分别送到A,B,C,D,E,F六个村庄</p>
</li>
<li><p>各个村庄的距离用边线表示（权），比如A-B距离5公里</p>
</li>
<li><p>问：如何计算出G村庄到其它各个村庄的最短距离？</p>
</li>
<li><p>如果从其它点出发到各个点的最短距离又是多少？</p>
<p>​</p>
</li>
</ol>
<p><strong>迪杰斯特拉(Dijkstra)算法介绍</strong></p>
<p>迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个结点到其他结点的最短路径。它的主要特点是以起始点为中心向外层层扩展（广度优先搜索思想），直到扩展到终点为止。</p>
<p><strong>迪杰斯特拉(Dijkstra)算法过程</strong></p>
<p>设置出发顶点为v,顶点集合V{v1,v2,vi.},v到V中各顶点的距离构成距离集合Dis,Dis{d1,d2,di,…}，Dis集合记录着v到图中各顶点的距离（到自身可以看作0，v到vi距离心应为di)</p>
<ol>
<li>从Dis中选择值最小的di并移出Dis集合，同时移出V集合中对应的顶点vi,此时的v到vi即为最短路径</li>
<li>更新Dis集合，更新规则为：比较v到V集合中顶点的距离值，与v通过vi到V集合中顶点的距离值，保留值较小的一个（同时也应该更新顶点的前驱节点为ⅵ，表明是通过ⅵ到达的)</li>
<li>重复执行两步骤，直到最短路径顶点为目标顶点即可结束</li>
</ol>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 迪杰斯特拉算法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：XMD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 18.10.22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DijkstraAlgorithm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] vertex = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[vertex.length][vertex.length];</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">65535</span>;</span><br><span class="line">        matrix[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N, <span class="number">5</span>, <span class="number">7</span>, N, N, N, <span class="number">2</span>&#125;;</span><br><span class="line">        matrix[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>, N, N, <span class="number">9</span>, N, N, <span class="number">3</span>&#125;;</span><br><span class="line">        matrix[<span class="number">2</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">7</span>, N, N, N, <span class="number">8</span>, N, N&#125;;</span><br><span class="line">        matrix[<span class="number">3</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N, <span class="number">9</span>, N, N, N, <span class="number">4</span>, N&#125;;</span><br><span class="line">        matrix[<span class="number">4</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N, N, <span class="number">8</span>, N, N, <span class="number">5</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        matrix[<span class="number">5</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N, N, N, <span class="number">4</span>, <span class="number">5</span>, N, <span class="number">6</span>&#125;;</span><br><span class="line">        matrix[<span class="number">6</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, N, N, <span class="number">4</span>, <span class="number">6</span>, N&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建图</span></span><br><span class="line">        Graph graph = <span class="keyword">new</span> Graph(vertex, matrix);</span><br><span class="line">        graph.showGraph();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//0表示从A到各个顶点的最短距离</span></span><br><span class="line">        <span class="comment">//打印的结果 A(0) | B(5) | C(7) | D(12) | E(6) | F(8) | G(2) |  表示 A-A最短距离为0  A-B的最短距离为5  。。。。。</span></span><br><span class="line">        graph.dsj(<span class="number">0</span>);</span><br><span class="line">        graph.showDjs();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="comment">//顶点数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] vertex;</span><br><span class="line">    <span class="comment">//邻接矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] matrix;</span><br><span class="line">    <span class="comment">//已经访问的顶点的集合</span></span><br><span class="line">    <span class="keyword">private</span> VisitedVertex vv;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">char</span>[] vertex, <span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vertex = vertex;</span><br><span class="line">        <span class="keyword">this</span>.matrix = matrix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : matrix) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(ints));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showDjs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vv.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 迪杰斯特拉算法实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 表示出发顶点对应的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dsj</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        vv = <span class="keyword">new</span> VisitedVertex(vertex.length, index);</span><br><span class="line">        <span class="comment">////更新index顶点到周围顶点的距离和前驱顶点</span></span><br><span class="line">        update(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; vertex.length; j++) &#123;</span><br><span class="line">            <span class="comment">//选择并返回新的访问顶点</span></span><br><span class="line">            index = vv.updateArr();</span><br><span class="line">            <span class="comment">//更新index顶点到周围顶点的距离和前驱顶点</span></span><br><span class="line">            update(index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * //更新index下标顶点到周围顶点的距离和周围顶点的前驱顶点，</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">///根据遍历我们的邻接矩阵的matrix[index]行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix[index].length; i++) &#123;</span><br><span class="line">            <span class="comment">//len含义是：出发顶点到index顶点的距离+从index顶点到j顶点的距离的和</span></span><br><span class="line">            len = vv.getDis(index) + matrix[index][i];</span><br><span class="line">            <span class="comment">//如果j顶点没有被访问过，并且len小于出发顶点到j顶点的距离，就需要更新</span></span><br><span class="line">            <span class="keyword">if</span> (!vv.in(i) &amp;&amp; len &lt; vv.getDis(i)) &#123;</span><br><span class="line">                <span class="comment">//更新j顶点的前驱为index顶点</span></span><br><span class="line">                vv.updatePre(i, index);</span><br><span class="line">                <span class="comment">//更新出发顶点到顶点的距离</span></span><br><span class="line">                vv.updateDis(i, len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * //已访问顶点集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VisitedVertex</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录各个顶点是否访问过1表示访问过，0未访问，会动态更新</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] already_arr;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每个下标对应的值为前一个顶点下标，会动态更新</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] pre_visited;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录出发顶点到其他所有顶点的距离，比如G为出发顶点，就会记录G到其它顶点的距离，会动态更新，求的最短距离就会存放到d1s</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dis;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lenght 表示顶点的个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index  出发顶点对应的下标，比如G顶点，下标就是6</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VisitedVertex</span><span class="params">(<span class="keyword">int</span> lenght, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.already_arr = <span class="keyword">new</span> <span class="keyword">int</span>[lenght];</span><br><span class="line">        <span class="keyword">this</span>.pre_visited = <span class="keyword">new</span> <span class="keyword">int</span>[lenght];</span><br><span class="line">        <span class="keyword">this</span>.dis = <span class="keyword">new</span> <span class="keyword">int</span>[lenght];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化dis数组</span></span><br><span class="line">        Arrays.fill(dis, <span class="number">65535</span>);</span><br><span class="line">        <span class="comment">//设置出发顶点被访问过</span></span><br><span class="line">        <span class="keyword">this</span>.already_arr[index] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//设置出发顶点的访问距离为0</span></span><br><span class="line">        <span class="keyword">this</span>.dis[index] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能：判断index顶点是否被访问过</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果访问过，就返回true,否则访问false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">in</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> already_arr[index] == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能：更新出发顶点到index顶点的距离</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> len</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateDis</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        dis[index] = len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能：更新pre这个顶点的前驱顶点为index顶点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pre</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updatePre</span><span class="params">(<span class="keyword">int</span> pre, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        pre_visited[pre] = index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能：返回出发顶点到index顶点的距离</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDis</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dis[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * //继续选择并返回新的访问顶点，比如这里的G完后，就是A点作为新的访问顶点（注意不是出发顶点）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateArr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">65535</span>, index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; already_arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (already_arr[i] == <span class="number">0</span> &amp;&amp; dis[i] &lt; min) &#123;</span><br><span class="line">                min = dis[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        already_arr[index] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * //即将三个数组的情况输出</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===========&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : already_arr) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot;&gt;&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;===========&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : pre_visited) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot;&gt;&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;===========&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> di : dis) &#123;</span><br><span class="line">            System.out.print(di + <span class="string">&quot;&gt;&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;===========&quot;</span>);</span><br><span class="line">        <span class="keyword">char</span>[] vertex = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : dis) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">65535</span>) &#123;</span><br><span class="line">                System.out.print(vertex[count] + <span class="string">&quot;(&quot;</span> + i + <span class="string">&quot;) | &quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;N  &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="弗洛伊德算法"><a href="#弗洛伊德算法" class="headerlink" title="弗洛伊德算法"></a>弗洛伊德算法</h1><p><strong>弗洛伊德(Floyd)算法介绍</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/19/081846RtwGEZ.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/19/082330cs24UW.png" alt=""></p>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 弗洛伊德算法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：XMD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 19.10.22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FloydAlgorithm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] vertex = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] matrix = <span class="keyword">new</span> <span class="keyword">int</span>[vertex.length][vertex.length];</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">65535</span>;</span><br><span class="line">        matrix[<span class="number">0</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">5</span>, <span class="number">7</span>, N, N, N, <span class="number">2</span>&#125;;</span><br><span class="line">        matrix[<span class="number">1</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>, <span class="number">0</span>, N, <span class="number">9</span>, N, N, <span class="number">3</span>&#125;;</span><br><span class="line">        matrix[<span class="number">2</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">7</span>, N, <span class="number">0</span>, N, <span class="number">8</span>, N, N&#125;;</span><br><span class="line">        matrix[<span class="number">3</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N, <span class="number">9</span>, N, <span class="number">0</span>, N, <span class="number">4</span>, N&#125;;</span><br><span class="line">        matrix[<span class="number">4</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N, N, <span class="number">8</span>, N, <span class="number">0</span>, <span class="number">5</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        matrix[<span class="number">5</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;N, N, N, <span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        matrix[<span class="number">6</span>] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>, <span class="number">3</span>, N, N, <span class="number">4</span>, <span class="number">6</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Graph 对象</span></span><br><span class="line">        Graph graph = <span class="keyword">new</span> Graph(vertex.length, matrix, vertex);</span><br><span class="line">        graph.floyd();</span><br><span class="line">        graph.show();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">    <span class="comment">//顶点数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] vertex;</span><br><span class="line">    <span class="comment">//保存，从各个顶点出发到其它顶点的距离，最后的结果，也是保留在该数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] dis;</span><br><span class="line">    <span class="comment">//保存到达目标顶点的前驱顶点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[][] pre;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lenght 大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> matrix 邻接矩阵</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> vertex 顶点数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> lenght, <span class="keyword">int</span>[][] matrix, <span class="keyword">char</span>[] vertex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vertex = vertex;</span><br><span class="line">        <span class="keyword">this</span>.dis = matrix;</span><br><span class="line">        <span class="keyword">this</span>.pre = <span class="keyword">new</span> <span class="keyword">int</span>[lenght][lenght];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lenght; i++) &#123;</span><br><span class="line">            Arrays.fill(pre[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//显式pre数组和dis数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; dis.length; k++) &#123;</span><br><span class="line">            <span class="comment">//先将pre数组输出的一行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dis.length; i++) &#123;</span><br><span class="line">                System.out.print(pre[k][i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            <span class="comment">//dis数组输出的一行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dis.length; i++) &#123;</span><br><span class="line">                System.out.print(vertex[k] + <span class="string">&quot;到&quot;</span> + vertex[i] + <span class="string">&quot;最短路径：&quot;</span> + dis[k][i] + <span class="string">&quot; / &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//保存距离</span></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//对中间顶点遍历，k就是中间顶点的下标[A,B,C,D,E,F,G]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; dis.length; k++) &#123;</span><br><span class="line">            <span class="comment">//从i顶点开始出发[A,B,C,D,E,F,G]</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dis.length; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; dis.length; j++) &#123;</span><br><span class="line">                    <span class="comment">//求出从i顶点出发，经过k中间顶点，到达j顶点距离</span></span><br><span class="line">                    len = dis[i][k] + dis[k][j];</span><br><span class="line">                    <span class="keyword">if</span> (len &lt; dis[k][j]) &#123;</span><br><span class="line">                        dis[i][j] = len;</span><br><span class="line">                        <span class="comment">//更新前驱顶点</span></span><br><span class="line">                        pre[i][j] = pre[k][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="马踏棋盘算法"><a href="#马踏棋盘算法" class="headerlink" title="马踏棋盘算法"></a>马踏棋盘算法</h1><blockquote>
<p>骑士周游问题</p>
</blockquote>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/19/1003432O5iZV.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/10/19/101918gkmeQw.png" alt=""></p>
<p>代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.algorithm.horse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.awt.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 马踏棋盘</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>：XMD</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 19.10.22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HorseCheckerboard</span> </span>&#123;</span><br><span class="line">    <span class="comment">//棋盘列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> X;</span><br><span class="line">    <span class="comment">//棋盘行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> Y;</span><br><span class="line">    <span class="comment">//标记棋盘的各个位置是否被访问过</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> visited[];</span><br><span class="line">    <span class="comment">//标记是否棋盘的所有位置都被访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> finished;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        X = <span class="number">8</span>;</span><br><span class="line">        Y = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> column = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] chessborad = <span class="keyword">new</span> <span class="keyword">int</span>[X][Y];</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[X * Y];</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        traversalChessborad(chessborad, row - <span class="number">1</span>, column - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;耗时：&quot;</span> + (end - start));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : chessborad) &#123;</span><br><span class="line">            System.out.println(Arrays.toString(ints));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 完成骑士周游问题的算法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chessborad 棋盘</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> row        当前位置行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> column     当前位置列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> step       第几步</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traversalChessborad</span><span class="params">(<span class="keyword">int</span>[][] chessborad, <span class="keyword">int</span> row, <span class="keyword">int</span> column, <span class="keyword">int</span> step)</span> </span>&#123;</span><br><span class="line">        chessborad[row][column] = step;</span><br><span class="line">        visited[row * X + column] = <span class="keyword">true</span>;</span><br><span class="line">        List&lt;Point&gt; ps = next(<span class="keyword">new</span> Point(column, row));</span><br><span class="line">        <span class="comment">//对ps进行排序，排序的规则就是对ps的所有的Poit对象的下一步的位置的数目，进行非递减排序</span></span><br><span class="line">        sort(ps);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!ps.isEmpty()) &#123;</span><br><span class="line">            Point p = ps.remove(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (!visited[p.y * X + p.x]) &#123;</span><br><span class="line">                traversalChessborad(chessborad, p.y, p.x, step + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断马儿是否完成了任务，使用stp和应该走的步数比较，</span></span><br><span class="line">        <span class="comment">//如果没有达到数量，则表示没有完成任务，将整个棋盘置0</span></span><br><span class="line">        <span class="comment">//1,棋盘到目前位置，仍然没有走完</span></span><br><span class="line">        <span class="comment">//2。棋盘处于一个回溯过程</span></span><br><span class="line">        <span class="keyword">if</span> (step &lt; X * Y &amp;&amp; !finished) &#123;</span><br><span class="line">            chessborad[row][column] = <span class="number">0</span>;</span><br><span class="line">            visited[row * X + column] = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            finished = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 功能：根据当前位置(Point.对象)，计算马儿还能走哪些位置(Point),并放入到一个集合中(ArrayList),最多有8个位置</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> curPoint</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Point&gt; <span class="title">next</span><span class="params">(Point curPoint)</span> </span>&#123;</span><br><span class="line">        List&lt;Point&gt; ps = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Point p1 = <span class="keyword">new</span> Point();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((p1.x = curPoint.x - <span class="number">2</span>) &gt;= <span class="number">0</span> &amp;&amp; (p1.y = curPoint.y - <span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            ps.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((p1.x = curPoint.x - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp; (p1.y = curPoint.y - <span class="number">2</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            ps.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((p1.x = curPoint.x + <span class="number">1</span>) &lt; X &amp;&amp; (p1.y = curPoint.y - <span class="number">2</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            ps.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((p1.x = curPoint.x + <span class="number">2</span>) &lt; X &amp;&amp; (p1.y = curPoint.y - <span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            ps.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((p1.x = curPoint.x + <span class="number">2</span>) &lt; X &amp;&amp; (p1.y = curPoint.y + <span class="number">1</span>) &lt; Y) &#123;</span><br><span class="line">            ps.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((p1.x = curPoint.x + <span class="number">1</span>) &lt; X &amp;&amp; (p1.y = curPoint.y + <span class="number">2</span>) &lt; Y) &#123;</span><br><span class="line">            ps.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((p1.x = curPoint.x - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp; (p1.y = curPoint.y + <span class="number">2</span>) &lt; Y) &#123;</span><br><span class="line">            ps.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((p1.x = curPoint.x - <span class="number">2</span>) &gt;= <span class="number">0</span> &amp;&amp; (p1.y = curPoint.y + <span class="number">1</span>) &lt; Y) &#123;</span><br><span class="line">            ps.add(<span class="keyword">new</span> Point(p1));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据当前这个一步的所有的下一步的选择位置，进行非递减排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;Point&gt; ps)</span> </span>&#123;</span><br><span class="line">        ps.sort((o1, o2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> count1 = next(o1).size();</span><br><span class="line">            <span class="keyword">int</span> count2 = next(o2).size();</span><br><span class="line">            <span class="keyword">if</span> (count1 &lt; count2) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count1 == count2) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法和数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>集合</tag>
        <tag>数组</tag>
        <tag>索引</tag>
        <tag>MQ</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>搞懂 Nginx 高性能网络工作原理</title>
    <url>/posts/1F4BTHB.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在单进程的网络编程模型中。所有的网络相关的动作都是在一个进程里完成的，如监听 socket 的创建， bind、listen。再比如 epoll 的创建、要监听事件的添加，以及 epoll_wait 等待时间发生。这些统统都是在一个进程里搞定。</p>
<p>一个客户端和使用了 epoll 的服务端的交互过程如下图所示。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/13/1053-dlCnp7.png" alt="图片"></p>
<p>以下是其大概的代码示例（没耐心看的同学可以先）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="comment">//监听</span></span><br><span class="line"> lfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line"> bind(lfd, ...)</span><br><span class="line"> listen(lfd, ...);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//创建epoll对象，并把 listen socket的事件管理起来</span></span><br><span class="line"> efd = epoll_create(...);</span><br><span class="line"> epoll_ctl(efd, EPOLL_CTL_ADD, lfd, ...);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//事件循环</span></span><br><span class="line"> <span class="keyword">for</span> (;;)</span><br><span class="line"> &#123;</span><br><span class="line">  size_t nready = epoll_wait(efd, ep, ...);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nready; ++i)&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(ep[i].data.fd == lfd)&#123;</span><br><span class="line">    <span class="comment">//lfd上发生事件表示都连接到达，accept接收它</span></span><br><span class="line">    fd = accept(listenfd, ...);</span><br><span class="line">    epoll_ctl(efd, EPOLL_CTL_ADD, fd, ...);</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//其它socket发生的事件都是读写请求、或者关闭连接</span></span><br><span class="line">    ...</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在单进程模型中，不管有多少的连接，是几万还是几十万，服务器都是通过 epoll 来监控这些连接 socket 上的可读和可写事件。当某个 socket 上有数据发生的时候，再以非阻塞的方式对 socket 进行读写操作。</p>
<p>事实上，Redis 5.0 及以前的版本中，它的网络部分去掉对 handler 的封装，去掉时间事件以后，代码基本和上述 demo 非常接近。而且因为 Redis 的业务特点只需要内存 IO，且 CPU 计算少，所以可以达到数万的 QPS。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/13/1053-CALz1l.png" alt="图片"></p>
<p>但是单进程的问题也是显而易见的，没有办法充分发挥多核的优势。所以目前业界绝大部分的后端服务还都是需要基于多进程的方式来进行开发的。到了多进程的时候，更复杂的问题多进程之间的配合和协作问题就产生了。比如</p>
<ul>
<li>哪个进程执行监听 listen ，以及 accept 接收新连接？</li>
<li>哪个进程负责发现用户连接上的读写事件？</li>
<li>当有用户请求到达的时候，如何均匀地将请求分散到不同的进程中？</li>
<li>需不需要单独搞一部分进程执行计算工作</li>
<li>…</li>
</ul>
<p>事实上，以上这些问题并没有标准答案。各大应用或者网络框架都有自己不同的实现方式。为此业界还专门总结出了两类网络设计模式 - Reactor 和 Proactor。不过今天我不想讨论这种抽象模式，而是想带大家看一个具体的 Case - Nginx  是如何在多进程下使用 epoll 的。</p>
<h1 id="Nginx-Master-进程初始化"><a href="#Nginx-Master-进程初始化" class="headerlink" title="Nginx Master 进程初始化"></a>Nginx Master 进程初始化</h1><p>在 Nginx 中，将进程分成了两类。一类是 Master 进程，一类是 Worker 进程。</p>
<p>在 Master 进程中，主要的任务是负责启动整个程序、读取配置文件、监听和处理各种信号，并对 Worker 进程进行统筹管理。</p>
<p>不过今天我们要查看的重点问题是看网络。在 Master 进程中，和网络相关的操作非常简单就是创建了 socket 并对其进行 bind 和 监听。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/13/1054-9Pe9UT.png" alt="图片"></p>
<p>具体细节我们来看 Main 函数。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: src/core/nginx.c</span></span><br><span class="line"><span class="built_in">int</span> ngx_cdecl main(<span class="built_in">int</span> argc, <span class="built_in">char</span> *const *argv)</span><br><span class="line">&#123;</span><br><span class="line"> ngx_cycle_t      *cycle, init_cycle;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//1.1 ngx_init_cycle 中开启监听</span></span><br><span class="line"> cycle = ngx<span class="constructor">_init_cycle(&amp;<span class="params">init_cycle</span>)</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//1.2 启动主进程循环</span></span><br><span class="line"> ngx<span class="constructor">_master_process_cycle(<span class="params">cycle</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Nginx 中，ngx_cycle_t 是非常核心的一个结构体。这个结构体存储了很多东西，也贯穿了好多的函数。其中对端口的 bind 和 listen 就是在它执行时完成的。</p>
<p>ngx_master_process_cycle 是 Master 进程的主事件循环。它先是根据配置启动指定数量的 Worker 进程，然后就开始关注和处理重启、退出等信号。接下来我们分两个小节来更详细地看。</p>
<h2 id="Nginx-的服务端口监听"><a href="#Nginx-的服务端口监听" class="headerlink" title="Nginx 的服务端口监听"></a>Nginx 的服务端口监听</h2><p>我们看下 ngx_init_cycle 中是如何执行 bind 和 listen 的。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: src/core/ngx_cycle.c</span></span><br><span class="line">ngx_cycle_t *ngx<span class="constructor">_init_cycle(<span class="params">ngx_cycle_t</span> <span class="operator">*</span><span class="params">old_cycle</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> ......</span><br><span class="line"> <span class="keyword">if</span> (ngx<span class="constructor">_open_listening_sockets(<span class="params">cycle</span>)</span> != NGX_OK) &#123;</span><br><span class="line">  goto failed;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>真正的监听还是在 ngx_open_listening_sockets 函数中，继续看它的源码。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: src/core/ngx_connection.c</span></span><br><span class="line">ngx_int_t ngx<span class="constructor">_open_listening_sockets(<span class="params">ngx_cycle_t</span> <span class="operator">*</span><span class="params">cycle</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> ......</span><br><span class="line"></span><br><span class="line"> <span class="comment">//要监听的 socket 对象</span></span><br><span class="line"> ls = cycle-&gt;listening.elts;</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cycle-&gt;listening.nelts; i++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取第i个socket</span></span><br><span class="line">  s = ngx<span class="constructor">_socket(<span class="params">ls</span>[<span class="params">i</span>].<span class="params">sockaddr</span>-&gt;<span class="params">sa_family</span>, <span class="params">ls</span>[<span class="params">i</span>].<span class="params">type</span>, 0)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//绑定</span></span><br><span class="line">  bind(s, ls<span class="literal">[<span class="identifier">i</span>]</span>.sockaddr, ls<span class="literal">[<span class="identifier">i</span>]</span>.socklen)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//监听</span></span><br><span class="line">  listen(s, ls<span class="literal">[<span class="identifier">i</span>]</span>.backlog)</span><br><span class="line">  ls<span class="literal">[<span class="identifier">i</span>]</span>.listen = <span class="number">1</span>;</span><br><span class="line">  ls<span class="literal">[<span class="identifier">i</span>]</span>.fd = s;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个函数中，遍历要监听的 socket。如果是启用了 REUSEPORT 配置，那先把 socket 设置上 SO_REUSEPORT 选项。然后接下来就是大家都熟悉的 bind 和 listen。<code>所以，bind 和 listen 是在 Master 进程中完成的。</code></p>
<h2 id="Master-进程的主循环"><a href="#Master-进程的主循环" class="headerlink" title="Master 进程的主循环"></a>Master 进程的主循环</h2><p>在 ngx_master_process_cycle 中主要完成两件事。</p>
<ul>
<li>启动 Worker 进程</li>
<li>将 Master 进程推入事件循环</li>
</ul>
<p>在创建 Worker 进程的时候，是通过 fork 系统调用让 Worker 进程完全复制自己的资源，包括 listen 状态的 socket 句柄。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/13/1055-fjVRZT.png" alt="图片"></p>
<p>我们接下来看详细的代码。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>file: src<span class="regexp">/os/u</span>nix/ngx_process_cycle.c</span><br><span class="line">void ngx_master_process_cycle(ngx_cycle_t *cycle)</span><br><span class="line">&#123;</span><br><span class="line"> ......</span><br><span class="line"> ngx_start_worker_processes(cycle, ccf-&gt;worker_processes,</span><br><span class="line">          NGX_PROCESS_RESPAWN);</span><br><span class="line"> <span class="regexp">//</span>进入主循环,等待接收各种信号</span><br><span class="line"> <span class="keyword">for</span> ( ;; ) &#123;</span><br><span class="line">  <span class="regexp">//</span>ngx_quit</span><br><span class="line">  <span class="regexp">//</span>ngx_reconfigure</span><br><span class="line">  <span class="regexp">//</span>ngx_restart</span><br><span class="line">  ...</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主进程在配置中读取到了 Worker 进程的数量 <code>ccf-&gt;worker_processes</code>。通过 ngx_start_worker_processes 来启动指定数量的 Worker。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file:src/os/unix/ngx_process_cycle.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">void</span> ngx_start_worker_processes(...)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  ngx_spawn_process(cycle, ngx_worker_process_cycle,</span><br><span class="line">        (<span class="built_in">void</span> *) (intptr_t) i, <span class="string">&quot;worker process&quot;</span>, <span class="keyword">type</span>);</span><br><span class="line">  ...</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中值得注意的是，在调用 ngx_spawn_process 时的几个参数</p>
<ul>
<li>cycle：nginx 的核心数据结构</li>
<li>ngx_worker_process_cycle：worker 进程的入口函数</li>
<li>i: 当前 worker 的序号</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: src/os/unix/ngx_process.c</span></span><br><span class="line"><span class="function"><span class="keyword">ngx_pid_t</span> <span class="title">ngx_spawn_process</span><span class="params">(<span class="keyword">ngx_cycle_t</span> *cycle, ngx_spawn_proc_pt proc,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> pid = fork();</span><br><span class="line"> <span class="keyword">switch</span> (pid) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">-1</span>: <span class="comment">//出错了</span></span><br><span class="line">   ... </span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//子进程创建成功</span></span><br><span class="line">   ngx_parent = ngx_pid;</span><br><span class="line">   ngx_pid = ngx_getpid();</span><br><span class="line">   proc(cycle, data);</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 ngx_spawn_process 中调用 fork 来创建进程，创建成功后 Worker 进程就将进入 ngx_worker_process_cycle 来进行处理了。</p>
<p><strong>总结：</strong> 在网络上，master 进程其实只是 listen 了一下。listen 过后的 socket 存到 cycle-&gt;listening 这里了。剩下的网络操作都是在 Worker 中完成的。</p>
<h1 id="Worker-进程处理"><a href="#Worker-进程处理" class="headerlink" title="Worker 进程处理"></a>Worker 进程处理</h1><p>在上面小节中看到，Master 进程关于网络其实做的事情不多，只是 bind 和 listen 了一下。epoll 相关的函数调用一个也没见着，更别说 accept  接收连接，以及 read 、 write 函数处理了。那这些细节一定都是在 Worker 进程中完成的。</p>
<p>事实的确如此，epoll_create、epoll_ctl、epoll_wait 都是在 Worker 进程中执行的。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/13/1056-4w6vng.png" alt="图片"></p>
<p>在 Worker 进程中，创建了一个 epoll 内核对象，通过 epoll_ctl 将其想监听的事件注册上去，然后调用 epoll_wait 进入事件循环。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: src/os/unix/ngx_process_cycle.c</span></span><br><span class="line">static void ngx<span class="constructor">_worker_process_cycle(<span class="params">ngx_cycle_t</span> <span class="operator">*</span><span class="params">cycle</span>, <span class="params">void</span> <span class="operator">*</span><span class="params">data</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">//2.2 Worker进程初始化编译进来的各个模块</span></span><br><span class="line"> ngx<span class="constructor">_worker_process_init(<span class="params">cycle</span>, <span class="params">worker</span>)</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//进入事件循环</span></span><br><span class="line"> <span class="keyword">for</span> ( ;; ) &#123;</span><br><span class="line">  <span class="comment">//2.3 进入 epollwait</span></span><br><span class="line">  ngx<span class="constructor">_process_events_and_timers(<span class="params">cycle</span>)</span>;</span><br><span class="line">  ......</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们分别来细看。</p>
<h2 id="Nginx-的-网络相关-module"><a href="#Nginx-的-网络相关-module" class="headerlink" title="Nginx 的 网络相关 module"></a>Nginx 的 网络相关 module</h2><p>撇开 Worker 的工作流程不提，咱们先来了解一个背景知识 - Nginx module。</p>
<p>Nginx 采用的是一种模块化的架构，它的模块包括核心模块、标准HTTP模块、可选HTTP模块、邮件服务模块和第三方模块等几大类。每一个模块都以一个  module 的形式存在，都对应一个 ngx_module_s 结构体。通过这种方式来实现软件可拔插，是一种非常优秀的软件架构。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/13/1057-yQvFVi.png" alt="图片"></p>
<p>每个 module 根据自己的需求来实现各种 init_xxx, exit_xxx 方法来供 Nginx 在合适的时机调用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: src/core/ngx_module.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_module_s</span> &#123;</span></span><br><span class="line"> ......</span><br><span class="line"></span><br><span class="line"> <span class="keyword">ngx_uint_t</span>            version;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">void</span>                 *ctx;</span><br><span class="line"> <span class="keyword">ngx_command_t</span>        *commands;</span><br><span class="line"> <span class="keyword">ngx_uint_t</span>            type;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">ngx_int_t</span>           (*init_master)(<span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>);</span><br><span class="line"> <span class="keyword">ngx_int_t</span>           (*init_module)(<span class="keyword">ngx_cycle_t</span> *cycle);</span><br><span class="line"> <span class="keyword">ngx_int_t</span>           (*init_process)(<span class="keyword">ngx_cycle_t</span> *cycle);</span><br><span class="line"> <span class="keyword">ngx_int_t</span>           (*init_thread)(<span class="keyword">ngx_cycle_t</span> *cycle);</span><br><span class="line"> <span class="keyword">void</span>                (*exit_thread)(<span class="keyword">ngx_cycle_t</span> *cycle);</span><br><span class="line"> <span class="keyword">void</span>                (*exit_process)(<span class="keyword">ngx_cycle_t</span> *cycle);</span><br><span class="line"> <span class="keyword">void</span>                (*exit_master)(<span class="keyword">ngx_cycle_t</span> *cycle);</span><br><span class="line"></span><br><span class="line"> ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中和网络相关的 module 有 ngx_events_module 、ngx_event_core_module 和具体的网络底层模块 ngx_epoll_module、ngx_kqueue_module等。</p>
<p>对于 ngx_epoll_module 来说，它在其上下文 ngx_epoll_module_ctx 中定义了各种 actions 方法（添加事件、删除事件、添加连接等）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file:src/event/ngx_event.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> <span class="keyword">ngx_str_t</span>              *name;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">void</span>                 *(*create_conf)(<span class="keyword">ngx_cycle_t</span> *cycle);</span><br><span class="line"> <span class="keyword">char</span>                 *(*init_conf)(<span class="keyword">ngx_cycle_t</span> *cycle, <span class="keyword">void</span> *conf);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">ngx_event_actions_t</span>     actions;</span><br><span class="line">&#125; <span class="keyword">ngx_event_module_t</span>;</span><br><span class="line"><span class="comment">//file:src/event/modules/ngx_epoll_module.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">ngx_event_module_t</span>  ngx_epoll_module_ctx = &#123;</span><br><span class="line"> &amp;epoll_name,</span><br><span class="line"> ngx_epoll_create_conf,               <span class="comment">/* create configuration */</span></span><br><span class="line"> ngx_epoll_init_conf,                 <span class="comment">/* init configuration */</span></span><br><span class="line"></span><br><span class="line"> &#123;</span><br><span class="line">  ngx_epoll_add_event,             <span class="comment">/* add an event */</span></span><br><span class="line">  ngx_epoll_del_event,             <span class="comment">/* delete an event */</span></span><br><span class="line">  ngx_epoll_add_event,             <span class="comment">/* enable an event */</span></span><br><span class="line">  ngx_epoll_del_event,             <span class="comment">/* disable an event */</span></span><br><span class="line">  ngx_epoll_add_connection,        <span class="comment">/* add an connection */</span></span><br><span class="line">  ngx_epoll_del_connection,        <span class="comment">/* delete an connection */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (NGX_HAVE_EVENTFD)</span></span><br><span class="line">  ngx_epoll_notify,                <span class="comment">/* trigger a notify */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="literal">NULL</span>,                            <span class="comment">/* trigger a notify */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  ngx_epoll_process_events,        <span class="comment">/* process the events */</span></span><br><span class="line">  ngx_epoll_init,                  <span class="comment">/* init the events */</span></span><br><span class="line">  ngx_epoll_done,                  <span class="comment">/* done the events */</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中有一个 init 方法是 ngx_epoll_init，在这个 init 中会进行 epoll 对象的创建，以及 ngx_event_actions 方法的设置。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file:src/event/modules/ngx_epoll_module.c</span></span><br><span class="line">static ngx_int_t</span><br><span class="line">ngx<span class="constructor">_epoll_init(<span class="params">ngx_cycle_t</span> <span class="operator">*</span><span class="params">cycle</span>, <span class="params">ngx_msec_t</span> <span class="params">timer</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">//创建一个 epoll 句柄</span></span><br><span class="line"> ep = epoll<span class="constructor">_create(<span class="params">cycle</span>-&gt;<span class="params">connection_n</span> <span class="operator">/</span> 2)</span>;</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> ngx_event_actions = ngx_epoll_module_ctx.actions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Worker-进程初始化各个模块"><a href="#Worker-进程初始化各个模块" class="headerlink" title="Worker 进程初始化各个模块"></a>Worker 进程初始化各个模块</h2><p>Worker 进程初始化的时候，在 ngx_worker_process_init 中读取配置信息进行一些设置，然后调用所有模块的 init_process 方法。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/13/1057-ip58U0.png" alt="图片"></p>
<p>来看详细代码。</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: src/os/unix/ngx_process_cycle.c</span></span><br><span class="line">static void</span><br><span class="line">ngx_worker_process_init(ngx_cycle_t *cycle, ngx_int_t worker)</span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> <span class="comment">//获取配置</span></span><br><span class="line"> <span class="function"><span class="title">ccf</span> = (ngx_core_conf_t *) ngx_get_conf(cycle-&gt;</span>conf_ctx, ngx_core_module);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//设置优先级</span></span><br><span class="line"> <span class="function"><span class="title">setpriority</span>(PRIO_PROCESS, 0, ccf-&gt;</span>priority)</span><br><span class="line"></span><br><span class="line"> <span class="comment">//设置文件描述符限制</span></span><br><span class="line"> setrlimit(RLIMIT_NOFILE, &amp;rlmt)</span><br><span class="line"> setrlimit(RLIMIT_CORE, &amp;rlmt)</span><br><span class="line"></span><br><span class="line"> <span class="comment">//group 和 uid 设置</span></span><br><span class="line"> <span class="function"><span class="title">initgroups</span>(ccf-&gt;</span><span class="function"><span class="title">username</span>, ccf-&gt;</span>group)</span><br><span class="line"> <span class="function"><span class="title">setuid</span>(ccf-&gt;</span>user)</span><br><span class="line"></span><br><span class="line"> <span class="comment">//CPU亲和性</span></span><br><span class="line"> cpu_affinity = ngx_get_cpu_affinity(worker)</span><br><span class="line"> <span class="keyword">if</span> (cpu_affinity) &#123;</span><br><span class="line">  <span class="function"><span class="title">ngx_setaffinity</span>(cpu_affinity, cycle-&gt;</span><span class="built_in">log</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> ......</span><br><span class="line"></span><br><span class="line"> <span class="comment">//调用各个模块的init_process进行模块初始化</span></span><br><span class="line"> <span class="function"><span class="title">for</span> (i = 0; cycle-&gt;</span>modules[i]; i++) &#123;</span><br><span class="line">  <span class="function"><span class="title">if</span> (cycle-&gt;</span><span class="function"><span class="title">modules</span>[i]-&gt;</span>init_process) &#123;</span><br><span class="line">   <span class="function"><span class="title">if</span> (cycle-&gt;</span><span class="function"><span class="title">modules</span>[i]-&gt;</span>init_process(cycle) == NGX_ERROR) &#123;</span><br><span class="line">    <span class="comment">/* fatal */</span></span><br><span class="line">    exit(<span class="number">2</span>);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面我们说过 ngx_event_core_module ，它的 init_process 方法是 ngx_event_process_init。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>file: src<span class="regexp">/event/</span>ngx_event.c</span><br><span class="line">ngx_module_t  ngx_event_core_module = &#123;</span><br><span class="line"> ...</span><br><span class="line"> ngx_event_process_init,                <span class="regexp">/* init process */</span></span><br><span class="line"> ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 ngx_event_core_module 的 ngx_event_process_init 中，我们将看到 <code>Worker 进程使用 epoll_create 来创建 epoll 对象，使用epoll_ctl 来监听 listen socket 上的连接请求</code>。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/13/1057-xlLVNH.png" alt="图片"></p>
<p>来详细看 ngx_event_process_init 的代码。</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: src/event/ngx_event.c</span></span><br><span class="line">static ngx_int_t ngx_event_process_init(ngx_cycle_t *cycle)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">//调用模块的init，创建 epoll 对象</span></span><br><span class="line"> <span class="function"><span class="title">for</span> (m = 0; cycle-&gt;</span>modules[m]; m++) &#123;</span><br><span class="line">  <span class="function"><span class="title">if</span> (cycle-&gt;</span><span class="function"><span class="title">modules</span>[m]-&gt;</span>type != NGX_EVENT_MODULE) &#123;</span><br><span class="line">   continue;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="title">module</span>-&gt;</span>actions.init(cycle, ngx_timer_resolution)</span><br><span class="line">  break;</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> <span class="comment">//获取自己监听的sokcet，将它们都添加到 epoll 中</span></span><br><span class="line"> ngx_event_t         *rev</span><br><span class="line"> <span class="function"><span class="title">ls</span> = cycle-&gt;</span>listening.elts;</span><br><span class="line"> <span class="function"><span class="title">for</span> (i = 0; i &lt; cycle-&gt;</span>listening.nelts; i++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取一个 ngx_connection_t</span></span><br><span class="line">  <span class="function"><span class="title">c</span> = ngx_get_connection(ls[i].fd, cycle-&gt;</span><span class="built_in">log</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//设置回调函数为 ngx_event_accept</span></span><br><span class="line">  <span class="function"><span class="title">rev</span>-&gt;</span>handler = ngx_event_accept </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ngx_add_event(rev, NGX_READ_EVENT, <span class="number">0</span>) == NGX_ERROR) &#123;</span><br><span class="line">   return NGX_ERROR;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 ngx_add_event 注册的 READ 事件的处理函数。ngx_add_event 就是一个抽象，对于 epoll 来说就是对 epoll_ctl 的封装而已。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span>file: src<span class="regexp">/event/</span>ngx_event.h</span><br><span class="line"><span class="comment">#define ngx_add_event        ngx_event_actions.add</span></span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span>file: src<span class="regexp">/event/m</span>odules/ngx_epoll_module.c</span><br><span class="line">static ngx_int_t ngx_epoll_add_event(...)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span> (epoll_ctl(ep, op, c-&gt;fd, &amp;ee) == -<span class="number">1</span>) &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>TODO</code>: epoll_create 还没解决呢。</p>
<h2 id="进入-epollwait"><a href="#进入-epollwait" class="headerlink" title="进入 epollwait"></a>进入 epollwait</h2><p>在 ngx_worker_process_init 中， epoll_create 和 epoll_ctl 都已经完成了。接下来就是进入事件循环，执行 epoll_wait 来处理。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/13/1058-q96euT.png" alt="图片"></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: src/event/ngx_event.c</span></span><br><span class="line">void</span><br><span class="line">ngx<span class="constructor">_process_events_and_timers(<span class="params">ngx_cycle_t</span> <span class="operator">*</span><span class="params">cycle</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line"> <span class="comment">// 防accept惊群锁</span></span><br><span class="line"> <span class="keyword">if</span> (ngx_use_accept_mutex) &#123;</span><br><span class="line">  <span class="comment">//尝试获取锁，获取失败直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (ngx<span class="constructor">_trylock_accept_mutex(<span class="params">cycle</span>)</span><span class="operator"> == </span>NGX_ERROR) &#123;</span><br><span class="line">   return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取锁成功，则设置 NGX_POST_EVENTS 标记。</span></span><br><span class="line">  <span class="keyword">if</span> (ngx_accept_mutex_held) &#123;</span><br><span class="line">   flags <span class="pattern-match">|= <span class="constructor">NGX_POST_EVENTS</span>;</span></span><br><span class="line"><span class="pattern-match">  &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="pattern-match">   <span class="operator">...</span></span></span><br><span class="line"><span class="pattern-match">  &#125;</span></span><br><span class="line"><span class="pattern-match"> &#125;</span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match"> <span class="operator">/</span><span class="operator">/</span>处理各种事件</span></span><br><span class="line"><span class="pattern-match"> (void) ngx<span class="constructor">_process_events(<span class="params">cycle</span>, <span class="params">timer</span>, <span class="params">flags</span>)</span>;</span></span><br><span class="line"><span class="pattern-match">&#125;</span></span><br></pre></td></tr></table></figure>
<p>在 ngx_process_events_and_timers 开头处，判断是否使用 accpet_mutext  锁。这是一个防止惊群的解决办法。如果使用的话，先调用 ngx_trylock_accept_mutex  获取锁，获取失败则直接返回，过段时间再来尝试。获取成功是则设置 NGX_POST_EVENTS 的标志位。</p>
<p>接下来调用 ngx_process_events 来处理各种网络和 timer 事件。对于 epoll 来说，这个函数就是对 epoll_wait 的封装。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: src/event/ngx_event.h</span></span><br><span class="line">#define ngx_process_events   ngx_event_actions.process_events</span><br><span class="line"><span class="comment">//file: src/event/modules/ngx_epoll_module.c</span></span><br><span class="line">static ngx_int_t ngx<span class="constructor">_epoll_process_events(<span class="params">ngx_cycle_t</span> <span class="operator">*</span><span class="params">cycle</span>, <span class="operator">...</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> events = epoll<span class="constructor">_wait(<span class="params">ep</span>, <span class="params">event_list</span>, (<span class="params">int</span>)</span> nevents, timer);</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; events; i++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (flags &amp; NGX_POST_EVENTS) &#123;</span><br><span class="line">   ...</span><br><span class="line">   ngx<span class="constructor">_post_event(<span class="params">rev</span>, <span class="params">queue</span>)</span>;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   <span class="comment">//调用回调函数</span></span><br><span class="line">   rev-&gt;handler(rev);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，在 ngx_epoll_process_events 是调用 epoll_wait 等待各种事件的发生。如果没有 NGX_POST_EVENTS  标志，则直接回调 rev-&gt;handler 进行处理。使用了 accept_mutex 锁的话，先把这个事件保存起来，等后面合适的时机再去 accpet。</p>
<p>简单对本节内容汇总一下。在 Master 进程中只是做了 socket 的 bind 和 listen。 而在 Worker 进程中所做的事情比较多，创建了  epoll，使用 epoll_ctl 将 listen 状态的 socket 的事件监控起来。最后调用 epoll_wait  进入了事件循环，开始处理各种网络和 timer 事件。 本节流程总结如图。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/13/1058-ZcmK2t.png" alt="图片"></p>
<h1 id="用户连接来啦"><a href="#用户连接来啦" class="headerlink" title="用户连接来啦"></a>用户连接来啦</h1><p>现在假设用户的连接请求已经到了，这时候 epoll_wait 返回后会执行其对应的 handler 函数 ngx_add_event。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/13/1059-8ka7r8.png" alt="图片"></p>
<p>在该回调函数中被执行到的时候，表示 listen 状态的 socket 上面有连接到了。所以这个函数主要做了三件事。</p>
<ul>
<li>1.调用 accept 获取用户连接</li>
<li>2.获取 connection 对象，其回调函数为 ngx_http_init_connection</li>
<li>3.将新连接 socket 通过 epoll_ctl 添加到 epoll 中进行管理</li>
</ul>
<p>我们来看 ngx_event_accept 详细代码。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: src/event/ngx_event_accept.c</span></span><br><span class="line">void ngx<span class="constructor">_event_accept(<span class="params">ngx_event_t</span> <span class="operator">*</span><span class="params">ev</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="comment">//接收建立好的连接</span></span><br><span class="line">  s = accept(lc-&gt;fd, &amp;sa.sockaddr, &amp;socklen);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> s &#123;</span><br><span class="line">   <span class="comment">//3.1 获取 connection</span></span><br><span class="line">   c = ngx<span class="constructor">_get_connection(<span class="params">s</span>, <span class="params">ev</span>-&gt;<span class="params">log</span>)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3.2 添加新连接</span></span><br><span class="line">   <span class="keyword">if</span> (ngx<span class="constructor">_add_conn(<span class="params">c</span>)</span><span class="operator"> == </span>NGX_ERROR) &#123;</span><br><span class="line">    ngx<span class="constructor">_close_accepted_connection(<span class="params">c</span>)</span>;</span><br><span class="line">    return;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125; </span><br><span class="line"> &#125; <span class="keyword">while</span> (ev-&gt;available);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>listen socket 上的读事件发生的时候，就意味着有用户连接就绪了。所以可以直接通过 accept 将其取出来。取出连接以后，再获取一个空闲的 connection对象，通过 ngx_add_conn 将其添加到 epoll 中进行管理。</p>
<h2 id="获取-connection"><a href="#获取-connection" class="headerlink" title="获取 connection"></a>获取 connection</h2><p>我们说一下 ngx_get_connection，这个函数本身倒是没有啥可说的。就是从 ngx_cycle 的 free_connections 中获取一个 connection 出来。</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: src/core/ngx_connection.c</span></span><br><span class="line">ngx_connection_t *ngx_get_connection(ngx_socket_t s, ngx_log_t *<span class="built_in">log</span>)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="function"><span class="title">c</span> = ngx_cycle-&gt;</span>free_connections;</span><br><span class="line"> <span class="function"><span class="title">c</span>-&gt;</span>read = rev;</span><br><span class="line"> <span class="function"><span class="title">c</span>-&gt;</span>write = wev;</span><br><span class="line"> <span class="function"><span class="title">c</span>-&gt;</span>fd = s;</span><br><span class="line"> <span class="function"><span class="title">c</span>-&gt;</span><span class="built_in">log</span> = <span class="built_in">log</span>;</span><br><span class="line"> return c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得说的是 free_connections 中的连接，对于 HTTP 服务来说，会经过 ngx_http_init_connection  的初始化处理。它会设置该连接读写事件的回调函数 c-&gt;read-&gt;handler 和  c-&gt;write-&gt;handler。</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: src/http/ngx_http_request.c</span></span><br><span class="line">void ngx_http_init_connection(ngx_connection_t *c)</span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line"> <span class="function"><span class="title">rev</span> = c-&gt;</span>read;</span><br><span class="line"> <span class="function"><span class="title">rev</span>-&gt;</span>handler = ngx_http_wait_request_handler;</span><br><span class="line"> <span class="function"><span class="title">c</span>-&gt;</span><span class="function"><span class="title">write</span>-&gt;</span>handler = ngx_http_empty_handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="添加新连接"><a href="#添加新连接" class="headerlink" title="添加新连接"></a>添加新连接</h2><p>我们再来看 ngx_add_conn，对于 epoll module 来说，它就是 ngx_epoll_add_connection 这个函数。</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="comment">//file: src/event/ngx_event.h</span></span><br><span class="line">#define ngx_add_conn         ngx_event_actions.add_conn</span><br><span class="line"></span><br><span class="line"><span class="comment">//file: src/event/modules/ngx_epoll_module.c</span></span><br><span class="line">static ngx_int_t</span><br><span class="line">ngx_epoll_add_connection(ngx_connection_t *c)</span><br><span class="line">&#123;</span><br><span class="line"> struct epoll_event  ee;</span><br><span class="line"> ee.events = EPOLLIN|EPOLLOUT|EPOLLET|EPOLLRDHUP;</span><br><span class="line"> <span class="function"><span class="title">ee</span>.<span class="keyword">data</span>.ptr = (void *) ((uintptr_t) c | c-&gt;</span><span class="function"><span class="title">read</span>-&gt;</span>instance);</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="title">epoll_ctl</span>(ep, EPOLL_CTL_ADD, c-&gt;</span>fd, &amp;ee)</span><br><span class="line"> <span class="function"><span class="title">c</span>-&gt;</span><span class="function"><span class="title">read</span>-&gt;</span>active = <span class="number">1</span>;</span><br><span class="line"> <span class="function"><span class="title">c</span>-&gt;</span><span class="function"><span class="title">write</span>-&gt;</span>active = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"> return NGX_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见这只是 epoll_ctl 的一个封装而已。这里再补充说一下，如果这个客户端连接 socket 上有数据到达的时候，就会进入到上面 3.1 节中注册的 ngx_http_wait_request_handler 函数进行处理。后面就是 HTTP 的处理逻辑了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Nginx 的 Master 中做的网络相关动作不多，仅仅只是创建了 socket、然后 bind 并 listen 了一下。接着就是用自己 fork  出来多个 Worker 进程来。由于每个进程都一样，所以每个 Worker 都有 Master 创建出来的 listen 状态的 socket  句柄。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/13/1100-taQ3DS.png" alt="图片"></p>
<p>Worker 进程处理的网络相关工作就比较多了。epoll_create、epoll_ctl、epoll_wait 都是在 Worker 进程中执行的，也包括用户连接上的数据 read、处理 和 write。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/13/1100-le5RfF.png" alt="图片"></p>
<ul>
<li>1.先是使用 epoll_create 创建一个 epoll 对象出来</li>
<li>2.设置回调为 ngx_event_accept</li>
<li>3.通过 epoll_ctl 将所有 listen 状态的 socket 的事件都管理起来</li>
<li>4.执行 epoll_wait 等待 listen socket 上的连接到来</li>
<li>5.新连接到来是 epoll_wait 返回，进入 ngx_event_accept 回调</li>
<li>6.ngx_event_accept 回调中将新连接也添加到 epoll 中进行管理（其回调为ngx_http_init_connection）</li>
<li>7.继续进入 epoll_wait 等待事件</li>
<li>8.用户数据请求到达时进入 http 回调函数进行处理</li>
</ul>
<p>讲到这里，你可以觉得咱们已经讨论完了。实际上有一个点我们还没有考虑到。我们上面讨论的流程是一个 Worker 在工作的情况。那么在多 Worker 的情况下，Nginx 的全貌咱们还没展开说过。通过上文我们可以看到以下几个细节：</p>
<ul>
<li>1.每个 Worker 都会有一个属于自己的 epoll 对象</li>
<li>2.每个 Worker 会关注所有的 listen 状态上的新连接事件</li>
<li>3.对于用户连接，只有一个 Worker 会处理，其它 Worker 不会持有该用户连接的 socket。</li>
</ul>
<p>根据这三条结论，我们再画一个 Nginx 的全貌图。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/13/1100-ZuryGp.png" alt="图片"></p>
<p>好了，今天关于 Nginx 网络原理的分享就到此结束。希望通过这个优秀的软件能给你的工作带去一些启发和思考，助力你的工作提升。能阅读到这里的同学们都是好样的，晚餐回去都给自己加个鸡腿！</p>
<p>最后学学极客时间，留一道思考题。</p>
<p><strong>思考题：</strong>“上面这个图中每个 Worker 里的 epoll 对象会监听同一批 listen 状态的 socket，那么当有用户连接到来的时候，Nginx 和 Linux  是如何保证没有惊群问题的呢（只有一个 Worker 来响应该请求）？欢迎你把你的思考留在评论区。”</p>
<hr>
<blockquote>
<p>原文： <span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvQVg2RnZhbDhSd2tnenB0ZGpsVTVrZw==">万字多图，搞懂 Nginx 高性能网络工作原理！<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
]]></content>
      <categories>
        <category>网络通信</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>内存</tag>
        <tag>GC</tag>
        <tag>const</tag>
        <tag>函数</tag>
        <tag>linux</tag>
        <tag>CPU</tag>
        <tag>锁</tag>
        <tag>Redis</tag>
        <tag>Nginx</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>四种WebSocket 使用方式</title>
    <url>/posts/12A6AMS.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MDk1OTQwMDgyMTg3NjMyNjc3">一文搞懂四种 WebSocket 使用方式，建议收藏！ - 掘金<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>在上家公司做IM消息系统的时候，一直是使用 WebSocket 作为收发消息的基础组件，今天就和大家聊聊在 Java 中，使用 WebSocket 所常见的四种姿势，如果大家以后或者现在碰到有要使用 WebSoocket 的情况可以做个参考。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/11/0752-Sf6CD4.awebp" alt="img"></p>
<p>上面的思维导图已经给大家列出了三种使用 WebSocket 的方式，下文会对它们的特点进行一一解读，不同的方式具有不同的特点，我们先按下不表。</p>
<p>在这里，我想让大家思考一下我在思维导图中列举的第四种做 WebScoket 支持的方案可能是什么？不知道大家能不能猜对，后文将会给出答案。</p>
<h2 id="WS简介"><a href="#WS简介" class="headerlink" title="WS简介"></a>WS简介</h2><p>在正式开始之前，我觉得有必要简单介绍一下 WebSocket 协议，引入任何一个东西之前都有必要知道我们为什么需要它？</p>
<p>在 Web 开发领域，我们最常用的协议是 HTTP，HTTP 协议和 WS 协议都是基于 TCP 所做的封装，但是 HTTP 协议从一开始便被设计成请求 -&gt; 响应的模式，所以在很长一段时间内 HTTP 都是只能从客户端发向服务端，并不具备从服务端主动推送消息的功能，这也导致在浏览器端想要做到服务器主动推送的效果只能用一些轮询和长轮询的方案来做，但因为它们并不是真正的全双工，所以在消耗资源多的同时，实时性也没理想中那么好。</p>
<p>既然市场有需求，那肯定也会有对应的新技术出现，WebSocket 就是这样的背景下被开发与制定出来的，并且它作为 HTML5 规范的一部分，得到了所有主流浏览器的支持，同时它还兼容了 HTTP 协议，默认使用 HTTP 的80端口和443端口，同时使用 HTTP header 进行协议升级。</p>
<p>和 HTTP 相比，WS 至少有以下几个优点：</p>
<ol>
<li>使用的资源更少：因为它的头更小。</li>
<li>实时性更强：服务端可以通过连接主动向客户端推送消息。</li>
<li>有状态：开启链接之后可以不用每次都携带状态信息。</li>
</ol>
<p>除了这几个优点以外，我觉得对于 WS 我们开发人员起码还要了解它的握手过程和协议帧的意义，这就像学习 TCP 的时候需要了解 TCP 头每个字节帧对应的意义一样。</p>
<p>像握手过程我就不说了，因为它复用了 HTTP 头只需要在<span class="exturl" data-url="aHR0cHM6Ly9saW5rLmp1ZWppbi5jbj90YXJnZXQ9aHR0cHMlM0ElMkYlMkZ6aC53aWtpcGVkaWEub3JnJTJGd2lraSUyRldlYlNvY2tldA==">维基百科<i class="fa fa-external-link-alt"></i></span>（阮一峰的文章讲的也很明白）上面看一下就明白了，像协议帧的话无非就是：标识符、操作符、数据、数据长度这些协议通用帧，基本都没有深入了解的必要，我认为一般只需要关心 WS 的操作符就可以了。</p>
<p>WS 的操作符代表了 WS 的消息类型，它的消息类型主要有如下六种：</p>
<ol>
<li><strong>文本消息</strong></li>
<li><strong>二进制消息</strong></li>
<li><strong>分片消息</strong>（分片消息代表此消息是一个某个消息中的一部分，想想大文件分片）</li>
<li><strong>连接关闭消息</strong></li>
<li><strong>PING 消息</strong></li>
<li><strong>PONG 消息</strong>（PING的回复就是PONG）</li>
</ol>
<p>那我们既然知道了 WS 主要有以上六种操作，那么一个正常的 WS 框架应当可以很轻松的处理以上这几种消息，所以接下来就是本文的中心内容，看看以下这几种 WS 框架能不能很方便的处理这几种 WS 消息。</p>
<h2 id="J2EE-方式"><a href="#J2EE-方式" class="headerlink" title="J2EE 方式"></a>J2EE 方式</h2><p>先来 J2EE，一般我把 javax 包里面对 JavaWeb 的扩展都叫做 J2EE，这个定义是否完全正确我觉得没必要深究，只是一种个人习惯，而本章节所介绍的 J2EE 方式则是指 Tomcat 为 WS 所做的支持，这套代码的包名前缀叫做：<code>javax.websocket</code>。</p>
<p>这套代码中定义了一套适用于 WS 开发的注解和相关支持，我们可以利用它和 Tomcat 进行WS 开发，由于现在更多的都是使用 SpringBoot 的内嵌容器了，所以这次我们就来按照 SpringBoot 内嵌容器的方式来演示。</p>
<p>首先是引入 <code>SpringBoot - Web</code> 的依赖，因为这个依赖中引入了内嵌式容器 Tomcat：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>接着就是将一个类定义为 WS 服务器，这一步也很简单，只需要为这个类加上<code>@ServerEndpoint</code>注解就可以了，在这个注解中比较常用的有三个参数：WS路径、序列化处理类、反序列化处理类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ServerEndpoint &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    String[] subprotocols() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Decoder&gt;[] decoders() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Encoder&gt;[] encoders() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Configurator&gt; configurator() <span class="keyword">default</span> Configurator.class;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接下来我们来看具体的一个 WS 服务器类示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ServerEndpoint(&quot;/j2ee-ws/&#123;msg&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立连接成功调用</span></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(Session session, <span class="meta">@PathParam(value = &quot;msg&quot;)</span> String msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WebSocketServer 收到连接: &quot;</span> + session.getId() + <span class="string">&quot;, 当前消息：&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//收到客户端信息</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Session session, String message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        message = <span class="string">&quot;WebSocketServer 收到连接：&quot;</span> + session.getId() +  <span class="string">&quot;，已收到消息：&quot;</span> + message;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">        session.getBasicRemote().sendText(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接关闭</span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onclose</span><span class="params">(Session session)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在以上代码中，我们着重关心 WS 相关的注解，主要有以下四个：</p>
<ol>
<li><code>@ServerEndpoint</code> ： 这里就像 RequestMapping 一样，放入一个 WS 服务器监听的 URL。</li>
<li><code>@OnOpen</code> ：这个注解修饰的方法会在 WS 连接开始时执行。</li>
<li><code>@OnClose</code> ：这个注解修饰的方法则会在 WS 关闭时执行。</li>
<li><code>@OnMessage</code> ：这个注解则是修饰消息接受的方法，并且由于消息有文本和二进制两种方式，所以此方法参数上可以使用 String 或者二进制数组的方式，就像下面这样：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@OnMessage</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Session session, String message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@OnMessage</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Session session, <span class="keyword">byte</span>[] message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>除了以上这几个以外，常用的功能方面还差一个分片消息、Ping 消息 和 Pong 消息，对于这三个功能我并没有查到相关用法，只在源码的接口列表中看到了一个 PongMessage 接口，有知道的读者朋友们有知道的可以在评论区指出。</p>
<p>细心的小伙伴们可能发现了，示例中的 WebSocketServer 类还有一个 <code>@Component 注解</code>，这是由于我们使用的是内嵌容器，而内嵌容器需要被 Spring 管理并初始化，所以需要给 WebSocketServer 类加上这么一个注解，所以代码中还需要有这么一个配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServerEndpointExporter <span class="title">serverEndpointExporter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServerEndpointExporter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>Tips</strong>：在不使用内嵌容器的时候可以不做以上步骤。</p>
<p>最后上个简陋的 WS 效果示例图，前端方面直接使用 HTML5 的 WebScoket 标准库，具体可以查看我的仓库代码：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/22/1005-A2Or0g.jpg" alt="img"></p>
<h2 id="Spring-方式"><a href="#Spring-方式" class="headerlink" title="Spring 方式"></a>Spring 方式</h2><p>第二部分来说 Spring 方式，Spring 作为 Java 开发界的老大哥，几乎封装了一切可以封装的，对于 WS 开发呢 Spring 也提供了一套相关支持，而且从使用方面我觉得要比 J2EE 的更易用。</p>
<p>使用它的第一步我们先引入 <code>SpringBoot - WS</code> 依赖，这个依赖包也会隐式依赖 SpringBoot - Web 包：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>第二步就是准备一个用来处理 WS 请求的 Handle了，Spring 为此提供了一个接口—— WebSocketHandler，我们可以通过实现此接口重写其接口方法的方式自定义逻辑，我们来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringSocketHandle</span> <span class="keyword">implements</span> <span class="title">WebSocketHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterConnectionEstablished</span><span class="params">(WebSocketSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SpringSocketHandle, 收到新的连接: &quot;</span> + session.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(WebSocketSession session, WebSocketMessage&lt;?&gt; message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String msg = <span class="string">&quot;SpringSocketHandle, 连接：&quot;</span> + session.getId() +  <span class="string">&quot;，已收到消息。&quot;</span>;</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">        session.sendMessage(<span class="keyword">new</span> TextMessage(msg));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleTransportError</span><span class="params">(WebSocketSession session, Throwable exception)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WS 连接发生错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterConnectionClosed</span><span class="params">(WebSocketSession session, CloseStatus closeStatus)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WS 关闭连接&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 支持分片消息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsPartialMessages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>上面这个例子很好的展示了 WebSocketHandler 接口中的五个函数，通过名字我们就应该知道它具有什么功能了：</p>
<ol>
<li><strong>afterConnectionEstablished</strong>：连接成功后调用。</li>
<li><strong>handleMessage</strong>：处理发送来的消息。</li>
<li><strong>handleTransportError：</strong> WS 连接出错时调用。</li>
<li><strong>afterConnectionClosed</strong>：连接关闭后调用。</li>
<li><strong>supportsPartialMessages</strong>：是否支持分片消息。</li>
</ol>
<p>以上这几个方法重点可以来看一下 handleMessage 方法，handleMessage 方法中有一个 <code>WebSocketMessage</code> 参数，这也是一个接口，我们一般不直接使用这个接口而是使用它的实现类，它有以下几个实现类：</p>
<ol>
<li><strong>BinaryMessage</strong>：二进制消息体</li>
<li><strong>TextMessage</strong>：文本消息体</li>
<li><strong>PingMessage：</strong> Ping <em>**</em>消息体</li>
<li><strong>PongMessage：</strong> Pong <em>**</em>消息体</li>
</ol>
<p>但是由于 <code>handleMessage</code> 这个方法参数是<code>WebSocketMessage</code>，所以我们实际使用中可能需要判断一下当前来的消息具体是它的哪个子类，比如这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(WebSocketSession session, WebSocketMessage&lt;?&gt; message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (message <span class="keyword">instanceof</span> TextMessage) &#123;</span><br><span class="line">            <span class="keyword">this</span>.handleTextMessage(session, (TextMessage)message);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message <span class="keyword">instanceof</span> BinaryMessage) &#123;</span><br><span class="line">            <span class="keyword">this</span>.handleBinaryMessage(session, (BinaryMessage)message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>但是总这样写也不是个事，为了避免这些重复性代码，Spring 给我们定义了一个 <code>AbstractWebSocketHandler</code>，它已经封装了这些重复劳动，我们可以直接继承这个类然后重写我们想要处理的消息类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handleTextMessage</span><span class="params">(WebSocketSession session, TextMessage message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handleBinaryMessage</span><span class="params">(WebSocketSession session, BinaryMessage message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handlePongMessage</span><span class="params">(WebSocketSession session, PongMessage message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>上面这部分都是对于 Handle 的操作，有了 Handle 之后我们还需要将它绑定在某个 URL 上，或者说监听某个 URL，那么必不可少的需要以下配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocket</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringSocketConfig</span> <span class="keyword">implements</span> <span class="title">WebSocketConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SpringSocketHandle springSocketHandle;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerWebSocketHandlers</span><span class="params">(WebSocketHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addHandler(springSocketHandle, <span class="string">&quot;/spring-ws&quot;</span>).setAllowedOrigins(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>这里我把我的自定义 Handle 注册到 <code>&quot;/spring-ws&quot;</code> 上面并设置了一下跨域，在整个配置类上还要打上<code>@EnableWebSocket</code> 注解，用于开启 WS 监听。</p>
<p>Spring 的方式也就以上这些内容了，不知道大家是否感觉 Spring 所提供的 WS 封装要比 J2EE 的更方便也更全面一些，起码我只要看 <strong>WebSocketHandler</strong> 接口就能知道所有常用功能的用法，所以对于 WS 开发来说我是比较推荐 Spring 方式的。</p>
<p>最后上个简陋的 WS 效果示例图，前端方面直接使用 HTML5 的 WebScoket 标准库，具体可以查看我的仓库代码：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/11/0800-wDUc79.awebp" alt="img"></p>
<h2 id="SocketIO-方式"><a href="#SocketIO-方式" class="headerlink" title="SocketIO 方式"></a>SocketIO 方式</h2><p>SocketIO 方式和上面两种有点不太一样，因为 SocketIO 诞生初就是为了兼容性作为考量的，前端的读者们应该对它更熟悉，因为它是一个 JS 库，我们先来看一下维基百科对它的定义：</p>
<p>Socket.IO 是一个面向实时 web 应用的 JavaScript 库。它使得服务器和客户端之间实时双向的通信成为可能。他有两个部分：在浏览器中运行的客户端库，和一个面向Node.js的服务端库，两者有着几乎一样的API。</p>
<p>Socket.IO 主要使用WebSocket协议。但是如果需要的话，Socket.io可以回退到几种其它方法，例如Adobe Flash Sockets，JSONP拉取，或是传统的AJAX拉取，并且在同时提供完全相同的接口。</p>
<p>所以我觉得使用它更多是因为兼容性，因为 HTML5 之后原生的 WS 应该也够用了，然而它是一个前端库，所以 Java 语言这块并没有官方支持，好在民间大神已经以 Netty 为基础开发了能与它对接的 Java 库： <code>netty-socketio</code>。</p>
<p>不过我要先给大家提个醒，不再建议使用它了，不是因为它很久没更新了，而是因为它支持的 Socket-Client 版本太老了，截止到 2022-04-29 日，SocketIO 已经更新到 4.X 了，但是 NettySocketIO 还只支持 2.X 的 Socket-Client 版本。</p>
<p>说了这么多，该教大家如何使用它了，第一步还是引入最新的依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.corundumstudio.socketio<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-socketio<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>第二步就是配置一个 WS 服务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketIoConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SocketIOServer <span class="title">socketIOServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        com.corundumstudio.socketio.Configuration config = <span class="keyword">new</span> com.corundumstudio.socketio.Configuration();</span><br><span class="line"></span><br><span class="line">        config.setHostname(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        config.setPort(<span class="number">8001</span>);</span><br><span class="line">        config.setContext(<span class="string">&quot;/socketio-ws&quot;</span>);</span><br><span class="line">        SocketIOServer server = <span class="keyword">new</span> SocketIOServer(config);</span><br><span class="line">        server.start();</span><br><span class="line">        <span class="keyword">return</span> server;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SpringAnnotationScanner <span class="title">springAnnotationScanner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SpringAnnotationScanner(socketIOServer());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>大家在上文的配置中，可以看到设置了一些 Web 服务器参数，比如：端口号和监听的 path，并将这个服务启动起来，服务启动之后日志上会打印这样一句日志：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[ntLoopGroup-<span class="number">2</span>-<span class="number">1</span>] c.c.socketio.SocketIOServer : SocketIO server started at port: <span class="number">8001</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>这就代表启动成功了，接下来就是要对 WS 消息做一些处理了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketIoHandle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 客户端连上socket服务器时执行此事件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> client</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnConnect</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConnect</span><span class="params">(SocketIOClient client)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SocketIoHandle 收到连接：&quot;</span> + client.getSessionId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 客户端断开socket服务器时执行此事件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> client</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnDisconnect</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDisconnect</span><span class="params">(SocketIOClient client)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前链接关闭：&quot;</span> + client.getSessionId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnEvent( value = &quot;onMsg&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(SocketIOClient client, AckRequest request, Object data)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SocketIoHandle 收到消息：&quot;</span> + data);</span><br><span class="line">        request.isAckRequested();</span><br><span class="line">        client.sendEvent(<span class="string">&quot;chatMsg&quot;</span>, <span class="string">&quot;我是 NettySocketIO 后端服务，已收到连接：&quot;</span> + client.getSessionId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>我相信对于以上代码，前两个方法是很好懂的，但是对于第三个方法如果大家没有接触过 SocketIO 就比较难理解了，为什么<code>@OnEvent( value = &quot;onMsg&quot;)</code>里面这个值是自定义的，这就涉及到 SocketIO 里面发消息的机制了，通过 SocketIO 发消息是要发给某个事件的，所以这里的第三个方法就是监听 发给<code>onMsg</code>事件的所有消息，监听到之后我又给客户端发了一条消息，这次发给的事件是：<code>chatMsg</code>，客户端也需要监听此事件才能接收到这条消息。</p>
<p>最后再上一个简陋的效果图：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/11/0801-vF70Qs.awebp" alt="img"></p>
<p>由于前端代码不再是标准的 HTML5 的连接方式，所以我这里简要贴一下相关代码，具体更多内容可以看我的代码仓库：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function">function <span class="title">changeSocketStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        let element = document.getElementById(<span class="string">&quot;socketStatus&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (socketStatus) &#123;</span><br><span class="line">            element.textContent = <span class="string">&quot;关闭WebSocket&quot;</span>;</span><br><span class="line">            <span class="keyword">const</span> socketUrl=<span class="string">&quot;ws://127.0.0.1:8001&quot;</span>;</span><br><span class="line">            socket = io.connect(socketUrl, &#123;</span><br><span class="line">                transports: [<span class="string">&#x27;websocket&#x27;</span>],</span><br><span class="line">                path: <span class="string">&quot;/socketio-ws&quot;</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//打开事件</span></span><br><span class="line">            socket.on(<span class="string">&#x27;connect&#x27;</span>, () =&gt; &#123;</span><br><span class="line">                console.log(<span class="string">&quot;websocket已打开&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//获得消息事件</span></span><br><span class="line">            socket.on(<span class="string">&#x27;chatMsg&#x27;</span>, (msg) =&gt; &#123;</span><br><span class="line">                <span class="keyword">const</span> serverMsg = <span class="string">&quot;收到服务端信息：&quot;</span> + msg;</span><br><span class="line">                pushContent(serverMsg, <span class="number">2</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//关闭事件</span></span><br><span class="line">            socket.on(<span class="string">&#x27;disconnect&#x27;</span>, () =&gt; &#123;</span><br><span class="line">                console.log(<span class="string">&quot;websocket已关闭&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//发生了错误事件</span></span><br><span class="line">            socket.on(<span class="string">&#x27;connect_error&#x27;</span>, () =&gt; &#123;</span><br><span class="line">                console.log(<span class="string">&quot;websocket发生了错误&quot;</span>);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h2 id="第四种方式？"><a href="#第四种方式？" class="headerlink" title="第四种方式？"></a>第四种方式？</h2><p>第四种方式其实就是 Netty 了，Netty 作为 Java 界大名鼎鼎的开发组件，对于常见协议也全部进行了封装，所以我们可以直接在 Netty 中去很方便的使用 WebSocket，接下来我们可以看看 Netty 怎么作为 WS 的服务器进行开发。</p>
<p>注意：以下内容如果没有 Netty 基础可能一脸蒙的进，一脸蒙的出，不过还是建议大家看看，Netty 其实很简单。</p>
<p>第一步需要先引入一个 Netty 开发包，我这里为了方便一般都是 All In：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.75.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>第二步的话就需要启动一个 Netty 容器了，配置很多，但是比较关键的也就那几个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketNettServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        NioEventLoopGroup boss = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        NioEventLoopGroup work = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            bootstrap</span><br><span class="line">                    .group(boss, work)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">//设置保持活动连接状态</span></span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                    .localAddress(<span class="number">8080</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG))</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ch.pipeline()</span><br><span class="line">                                    <span class="comment">// HTTP 请求解码和响应编码</span></span><br><span class="line">                                    .addLast(<span class="keyword">new</span> HttpServerCodec())</span><br><span class="line">                                    <span class="comment">// HTTP 压缩支持</span></span><br><span class="line">                                    .addLast(<span class="keyword">new</span> HttpContentCompressor())</span><br><span class="line">                                    <span class="comment">// HTTP 对象聚合完整对象</span></span><br><span class="line">                                    .addLast(<span class="keyword">new</span> HttpObjectAggregator(<span class="number">65536</span>))</span><br><span class="line">                                    <span class="comment">// WebSocket支持</span></span><br><span class="line">                                    .addLast(<span class="keyword">new</span> WebSocketServerProtocolHandler(<span class="string">&quot;/ws&quot;</span>))</span><br><span class="line">                                    .addLast(WsTextInBoundHandle.INSTANCE);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//绑定端口号，启动服务端</span></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.bind().sync();</span><br><span class="line">            System.out.println(<span class="string">&quot;WebSocketNettServer启动成功&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//对关闭通道进行监听</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            boss.shutdownGracefully().syncUninterruptibly();</span><br><span class="line">            work.shutdownGracefully().syncUninterruptibly();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>以上代码我们主要关心端口号和重写的 <code>ChannelInitializer</code> 就行了，里面我们定义了五个过滤器（Netty 使用责任链模式），前面三个都是 HTTP 请求的常用过滤器（毕竟 WS 握手是使用 HTTP 头的所以也要配置 HTTP 支持），第四个则是 WS 的支持，它会拦截 <code>/ws</code> 路径，最关键的就是第五个了过滤器它是我们具体的业务逻辑处理类，效果基本和 Spring 那部门中的 Handle 差不多，我们来看看代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WsTextInBoundHandle</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">TextWebSocketFrame</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">WsTextInBoundHandle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化 WsTextInBoundHandle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WsTextInBoundHandle 收到了连接&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        String str = <span class="string">&quot;WsTextInBoundHandle 收到了一条消息, 内容为：&quot;</span> + msg.text();</span><br><span class="line"></span><br><span class="line">        System.out.println(str);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------WsTextInBoundHandle 处理业务逻辑-----------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String responseStr = <span class="string">&quot;&#123;&quot;</span>status<span class="string">&quot;:200, &quot;</span>content<span class="string">&quot;:&quot;</span>收到<span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        ctx.channel().writeAndFlush(<span class="keyword">new</span> TextWebSocketFrame(responseStr));</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------WsTextInBoundHandle 数据回复完毕-----------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;WsTextInBoundHandle 消息收到完毕&quot;</span>);</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WsTextInBoundHandle 连接逻辑中发生了异常&quot;</span>);</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>这里面的方法我都不说了，看名字就差不多知道了，主要是看一下这个类的泛型：<strong>TextWebSocketFrame</strong>，很明显这是一个 WS 文本消息的类，我们顺着它的定义去看发现它继承了 <strong>WebSocketFrame</strong>，接着我们去看它的子类：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/11/0801-THU9Ds.awebp" alt="img"></p>
<p>一图胜千言，我想不用多说大家也都知道具体的类是处理什么消息了把，在上文的示例中我们是一定了一个文本 WS 消息的处理类，如果你想处理其他数据类型的消息，可以将泛型中的 <strong>TextWebSocketFrame</strong> 换成其他 <strong>WebSocketFrame</strong> 类就可以了 <strong>。</strong></p>
<p>至于为什么没有连接成功后的处理，这个是和 Netty 的相关机制有关，可以在 <strong>channelActive</strong> 方法中处理，大家有兴趣的可以了解一下 Netty。</p>
<p>最后上个简陋的 WS 效果示例图，前端方面直接使用 HTML5 的 WebScoket 标准库，具体可以查看我的仓库代码：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/11/0803-UL861t.awebp" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>洋洋洒洒五千字，有了收获别忘赞。</strong></p>
<p>在上文中，我总共介绍了四种在 Java 中使用 WS 的方式，从我个人使用意向来说我感觉应该是这样的：<code>Spring 方式 &gt; Netty 方式 &gt; J2EE 方式 &gt; SocketIO 方式</code>，当然了，如果你的业务存在浏览器兼容性问题，其实只有一种选择：SocketIO。</p>
<p>最后，我估计某些读者会去具体拉代码看代码，所以我简单说一下代码结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">├─java</span><br><span class="line">│  └─com</span><br><span class="line">│      └─example</span><br><span class="line">│          └─springwebsocket</span><br><span class="line">│              │  SpringWebsocketApplication.java</span><br><span class="line">│              │  TestController.java</span><br><span class="line">│              │</span><br><span class="line">│              ├─j2ee</span><br><span class="line">│              │      WebSocketConfig.java</span><br><span class="line">│              │      WebSocketServer.java</span><br><span class="line">│              │</span><br><span class="line">│              ├─socketio</span><br><span class="line">│              │      SocketIoConfig.java</span><br><span class="line">│              │      SocketIoHandle.java</span><br><span class="line">│              │</span><br><span class="line">│              └─spring</span><br><span class="line">│                      SpringSocketConfig.java</span><br><span class="line">│                      SpringSocketHandle.java</span><br><span class="line">│</span><br><span class="line">└─resources</span><br><span class="line">    └─templates</span><br><span class="line">            J2eeIndex.html</span><br><span class="line">            SocketIoIndex.html</span><br><span class="line">            SpringIndex.html</span><br></pre></td></tr></table></figure>
<p>代码结构如上所示，应用代码分成了三个文件夹，分别放着三种方式的具体示例代码，在资源文件夹下的 <strong>templates</strong> 文件夹也有三个 HTML 文件，就是对应三种示例的 HTML 页面，里面的链接地址和端口我都预设好了，拉下来直接单独编译此模块运行即可。</p>
<p>我没有往里面放 Netty 的代码，是因为感觉 Netty 部分内容很少，文章示例中的代码直接复制就能用，后面如果写 Netty 的话会再开一个 Netty 模块用来放 Netty 相关的代码。</p>
]]></content>
      <categories>
        <category>网络通信</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>Spring</tag>
        <tag>SpringBoot</tag>
        <tag>bug</tag>
        <tag>const</tag>
        <tag>函数</tag>
        <tag>数组</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot整合SpringSocket</title>
    <url>/posts/343MDA1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://xuemingde.com/pages/image/2022/07/16/14231657954463.png" alt="14231657954463"></p>
<blockquote>
<p>纯代码分享，粘贴复制可运行</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-freemarker<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.server.ServerHttpRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.server.ServerHttpResponse;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.WebSocketHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.server.HandshakeInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现【握手拦截器】</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Slf</span>4j       注解使用解析 https://www.cnblogs.com/sxdcgaq8080/p/11288213.html</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Component</span>   注解是将本拦截器注入为Bean给Spring容器管理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sxd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/2 13:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandshakeInterceptor</span> <span class="keyword">implements</span> <span class="title">HandshakeInterceptor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写方法 在握手之前做的事情</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serverHttpRequest</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serverHttpResponse</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> webSocketHandler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">beforeHandshake</span><span class="params">(ServerHttpRequest serverHttpRequest, ServerHttpResponse serverHttpResponse, WebSocketHandler webSocketHandler, Map&lt;String, Object&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写方法 在握手之后做的事情</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serverHttpRequest</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serverHttpResponse</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> webSocketHandler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterHandshake</span><span class="params">(ServerHttpRequest serverHttpRequest, ServerHttpResponse serverHttpResponse, WebSocketHandler webSocketHandler, Exception e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现WebSocketHandler接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sxd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/2 14:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySocketHander</span> <span class="keyword">implements</span> <span class="title">WebSocketHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为了保存在线用户信息，在方法中新建一个list存储一下【实际项目依据复杂度，可以存储到数据库或者缓存】</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> List&lt;WebSocketSession&gt; SESSIONS = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterConnectionEstablished</span><span class="params">(WebSocketSession webSocketSession)</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;链接成功......&quot;</span>);</span><br><span class="line">        SESSIONS.add(webSocketSession);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(WebSocketSession webSocketSession, WebSocketMessage&lt;?&gt; webSocketMessage)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;处理要发送的消息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleTransportError</span><span class="params">(WebSocketSession webSocketSession, Throwable throwable)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (webSocketSession.isOpen()) &#123;</span><br><span class="line">            webSocketSession.close();</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;链接出错，关闭链接......&quot;</span>);</span><br><span class="line">        SESSIONS.remove(webSocketSession);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterConnectionClosed</span><span class="params">(WebSocketSession webSocketSession, CloseStatus closeStatus)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;链接关闭......&quot;</span> + closeStatus.toString());</span><br><span class="line">        SESSIONS.remove(webSocketSession);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsPartialMessages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给所有在线用户发送消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendMessageToUsers</span><span class="params">(TextMessage message)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;给所有在线用户发送消息&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (WebSocketSession user : SESSIONS) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (user.isOpen()) &#123;</span><br><span class="line">                    user.sendMessage(message);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.EnableWebSocket;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.WebSocketConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sxd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/2 14:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocket</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebSocketConfig</span>  <span class="keyword">implements</span> <span class="title">WebSocketConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MyHandshakeInterceptor handshakeInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MySocketHander socketHander;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现 WebSocketConfigurer 接口</span></span><br><span class="line"><span class="comment">     * 重写 registerWebSocketHandlers 方法，这是一个核心实现方法，配置 websocket 入口，允许访问的域、注册 Handler、SockJs 支持和拦截器。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * registry.addHandler()注册和路由的功能</span></span><br><span class="line"><span class="comment">     *      当客户端发起 websocket 连接，把 /path 交给对应的 handler 处理，而不实现具体的业务逻辑，可以理解为收集和任务分发中心。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * addInterceptors() 顾名思义就是为 handler 添加拦截器</span></span><br><span class="line"><span class="comment">     *      可以在调用 handler 前后加入我们自己的逻辑代码。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * setAllowedOrigins(String[] domains),允许指定的域名或 IP (含端口号)建立长连接</span></span><br><span class="line"><span class="comment">     *      如果只允许自家域名访问，这里轻松设置。如果不限时使用 * 号，如果指定了域名，则必须要以 http 或 https 开头。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerWebSocketHandlers</span><span class="params">(WebSocketHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//部分 支持websocket 的访问链接,允许跨域</span></span><br><span class="line">        registry.addHandler(socketHander, <span class="string">&quot;/ws&quot;</span>).addInterceptors(handshakeInterceptor).setAllowedOrigins(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">//部分 不支持websocket的访问链接,允许跨域</span></span><br><span class="line">        registry.addHandler(socketHander, <span class="string">&quot;/sockjs/ws&quot;</span>).addInterceptors(handshakeInterceptor).setAllowedOrigins(<span class="string">&quot;*&quot;</span>).withSockJS();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//定时任务测试发送消息</span></span><br><span class="line">    <span class="meta">@Scheduled(fixedRate = 3000)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduledTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;任务执行时间：&quot;</span> + LocalDateTime.now());</span><br><span class="line">        JSONObject obj = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        obj.put(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;34r35436554766787dfds&quot;</span>);</span><br><span class="line">        MySocketHander.sendMessageToUsers(<span class="keyword">new</span> TextMessage(obj.toJSONString()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>网络通信</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>Spring</tag>
        <tag>数据库</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring方式实现Socket通讯</title>
    <url>/posts/2QRJVBZ.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>参考文章<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc3hkY2dhcTgwODAvcC8xMDY5MDY0NC5odG1s">【springboot】【socket】spring boot整合socket,实现服务器端两种消息推送 - Angel挤一挤 - 博客园<i class="fa fa-external-link-alt"></i></span> </p>
</blockquote>
<p>在SpringBoot中的代码实现</p>
<h2 id="pom文件完整示例"><a href="#pom文件完整示例" class="headerlink" title="pom文件完整示例"></a>pom文件完整示例</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-freemarker<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="新建握手拦截器"><a href="#新建握手拦截器" class="headerlink" title="新建握手拦截器"></a>新建握手拦截器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> socket.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.server.ServerHttpRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.server.ServerHttpResponse;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.WebSocketHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.server.HandshakeInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现【握手拦截器】</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Slf</span>4j       注解使用解析 https://www.cnblogs.com/sxdcgaq8080/p/11288213.html</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Component</span>   注解是将本拦截器注入为Bean给Spring容器管理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sxd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/2 13:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandshakeInterceptor</span> <span class="keyword">implements</span> <span class="title">HandshakeInterceptor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写方法 在握手之前做的事情</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serverHttpRequest</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serverHttpResponse</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> webSocketHandler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">beforeHandshake</span><span class="params">(ServerHttpRequest serverHttpRequest, ServerHttpResponse serverHttpResponse, WebSocketHandler webSocketHandler, Map&lt;String, Object&gt; map)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写方法 在握手之后做的事情</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serverHttpRequest</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serverHttpResponse</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> webSocketHandler</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterHandshake</span><span class="params">(ServerHttpRequest serverHttpRequest, ServerHttpResponse serverHttpResponse, WebSocketHandler webSocketHandler, Exception e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="新建webSocket的handler处理器"><a href="#新建webSocket的handler处理器" class="headerlink" title="新建webSocket的handler处理器"></a>新建webSocket的handler处理器</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> socket.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现WebSocketHandler接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sxd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/2 14:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySocketHander</span> <span class="keyword">implements</span> <span class="title">WebSocketHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为了保存在线用户信息，在方法中新建一个list存储一下【实际项目依据复杂度，可以存储到数据库或者缓存】</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> List&lt;WebSocketSession&gt; SESSIONS = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterConnectionEstablished</span><span class="params">(WebSocketSession webSocketSession)</span></span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;链接成功......&quot;</span>);</span><br><span class="line">        SESSIONS.add(webSocketSession);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(WebSocketSession webSocketSession, WebSocketMessage&lt;?&gt; webSocketMessage)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;处理要发送的消息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleTransportError</span><span class="params">(WebSocketSession webSocketSession, Throwable throwable)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (webSocketSession.isOpen()) &#123;</span><br><span class="line">            webSocketSession.close();</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">&quot;链接出错，关闭链接......&quot;</span>);</span><br><span class="line">        SESSIONS.remove(webSocketSession);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterConnectionClosed</span><span class="params">(WebSocketSession webSocketSession, CloseStatus closeStatus)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;链接关闭......&quot;</span> + closeStatus.toString());</span><br><span class="line">        SESSIONS.remove(webSocketSession);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsPartialMessages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给所有在线用户发送消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendMessageToUsers</span><span class="params">(TextMessage message)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;给所有在线用户发送消息&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (WebSocketSession user : SESSIONS) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (user.isOpen()) &#123;</span><br><span class="line">                    user.sendMessage(message);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="新建webSocket的config配置"><a href="#新建webSocket的config配置" class="headerlink" title="新建webSocket的config配置"></a>新建webSocket的config配置</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> socket.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.EnableWebSocket;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.WebSocketConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> sxd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/8/2 14:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocket</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebSocketConfig</span>  <span class="keyword">implements</span> <span class="title">WebSocketConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MyHandshakeInterceptor handshakeInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MySocketHander socketHander;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现 WebSocketConfigurer 接口</span></span><br><span class="line"><span class="comment">     * 重写 registerWebSocketHandlers 方法，这是一个核心实现方法，配置 websocket 入口，允许访问的域、注册 Handler、SockJs 支持和拦截器。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * registry.addHandler()注册和路由的功能</span></span><br><span class="line"><span class="comment">     *      当客户端发起 websocket 连接，把 /path 交给对应的 handler 处理，而不实现具体的业务逻辑，可以理解为收集和任务分发中心。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * addInterceptors() 顾名思义就是为 handler 添加拦截器</span></span><br><span class="line"><span class="comment">     *      可以在调用 handler 前后加入我们自己的逻辑代码。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * setAllowedOrigins(String[] domains),允许指定的域名或 IP (含端口号)建立长连接</span></span><br><span class="line"><span class="comment">     *      如果只允许自家域名访问，这里轻松设置。如果不限时使用 * 号，如果指定了域名，则必须要以 http 或 https 开头。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerWebSocketHandlers</span><span class="params">(WebSocketHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//部分 支持websocket 的访问链接,允许跨域</span></span><br><span class="line">        registry.addHandler(socketHander, <span class="string">&quot;/ws&quot;</span>).addInterceptors(handshakeInterceptor).setAllowedOrigins(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">//部分 不支持websocket的访问链接,允许跨域</span></span><br><span class="line">        registry.addHandler(socketHander, <span class="string">&quot;/sockjs/ws&quot;</span>).addInterceptors(handshakeInterceptor).setAllowedOrigins(<span class="string">&quot;*&quot;</span>).withSockJS();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建chat1-html"><a href="#创建chat1-html" class="headerlink" title="创建chat1.html"></a>创建chat1.html</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>测试websocket<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge,chrome=1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.2/css/bootstrap.min.css&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery-toast-plugin/1.3.2/jquery.toast.min.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;input-group mb-3&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;input-group-prepend&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">class</span>=<span class="string">&quot;input-group-text&quot;</span> <span class="attr">for</span>=<span class="string">&quot;inputGroupSelect01&quot;</span>&gt;</span>用户<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">class</span>=<span class="string">&quot;custom-select&quot;</span> <span class="attr">id</span>=<span class="string">&quot;inputGroupSelect01&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span> <span class="attr">selected</span>&gt;</span>选择一个...<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;input-group mb-3&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;input-group-append&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;input-group-text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn1&quot;</span>&gt;</span>发送给所有人<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;input-group mb-3&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;input-group-append&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;input-group-text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn2&quot;</span>&gt;</span>发送给单人<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.min.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.2/js/bootstrap.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery-toast-plugin/1.3.2/jquery.toast.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">language</span>=<span class="string">javascript</span>&gt;</span></span><br><span class="line"><span class="javascript">    $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> websocket;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (<span class="string">&#x27;WebSocket&#x27;</span> <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&quot;WebSocket--&gt;&quot;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="comment">//new WebSocket()在IDEA打开的任何项目中都可以 直接调用</span></span></span><br><span class="line"><span class="javascript">            websocket = <span class="keyword">new</span> WebSocket(<span class="string">&quot;ws://localhost:8020/ws&quot;</span>);</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&#x27;MozWebSocket&#x27;</span> <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&quot;MozWebSocket--&gt;&quot;</span>);</span></span><br><span class="line"><span class="javascript">            websocket = <span class="keyword">new</span> MozWebSocket(<span class="string">&quot;ws://ws&quot;</span>);</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&quot;SockJS--&gt;&quot;</span>);</span></span><br><span class="line"><span class="javascript">            websocket = <span class="keyword">new</span> SockJS(<span class="string">&quot;http://127.0.0.1:8020/sockjs/ws&quot;</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="javascript">        websocket.onopen = <span class="function"><span class="keyword">function</span> (<span class="params">evnt</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&quot;链接服务器成功!&quot;</span>, evnt.data);</span></span><br><span class="line">        &#125;;</span><br><span class="line"><span class="javascript">        websocket.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">evnt</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;收到消息:&#x27;</span>, evnt.data);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> json = <span class="built_in">JSON</span>.parse(evnt.data);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (json.hasOwnProperty(<span class="string">&#x27;users&#x27;</span>)) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> users = json.users;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; users.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">                    $(<span class="string">&quot;#inputGroupSelect01&quot;</span>).append(<span class="string">&#x27;&lt;option value=&quot;&#x27;</span> + users[i] + <span class="string">&#x27;&quot;&gt;&#x27;</span> + users[i] + <span class="string">&#x27;&lt;/option&gt;&#x27;</span>);</span></span><br><span class="line">                &#125;</span><br><span class="line"><span class="javascript">            &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">//打印消息</span></span></span><br><span class="line"><span class="javascript">                toast(json.msg, <span class="string">&#x27;info&#x27;</span>)</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"><span class="javascript">        websocket.onerror = <span class="function"><span class="keyword">function</span> (<span class="params">evnt</span>) </span>&#123;</span></span><br><span class="line">        &#125;;</span><br><span class="line"><span class="javascript">        websocket.onclose = <span class="function"><span class="keyword">function</span> (<span class="params">evnt</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&quot;与服务器断开了链接!&quot;</span>)</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        $(<span class="string">&#x27;#btn2&#x27;</span>).bind(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (websocket != <span class="literal">null</span>) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">//根据勾选的人数确定是群聊还是单聊</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> value = $(<span class="built_in">this</span>).parent().parent().find(<span class="string">&#x27;input&#x27;</span>).val();</span></span><br><span class="line"><span class="javascript">                <span class="comment">//得到选择的用户</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> name = $(<span class="string">&quot;#inputGroupSelect01&quot;</span>).find(<span class="string">&quot;option:selected&quot;</span>).val();</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&#x27;选中的用户&#x27;</span>, name);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">if</span> (name === <span class="string">&#x27;选择一个...&#x27;</span>) &#123;</span></span><br><span class="line"><span class="javascript">                    toast(<span class="string">&#x27;请选择一个用户&#x27;</span>, <span class="string">&#x27;warning&#x27;</span>)</span></span><br><span class="line"><span class="javascript">                &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> object = &#123;</span></span><br><span class="line">                        to: name,</span><br><span class="line">                        msg: value,</span><br><span class="line">                        type: 2</span><br><span class="line">                    &#125;;</span><br><span class="line"><span class="javascript">                    <span class="comment">//将object转成json字符串发送给服务端</span></span></span><br><span class="line"><span class="javascript">                    <span class="keyword">var</span> json = <span class="built_in">JSON</span>.stringify(object);</span></span><br><span class="line">                    websocket.send(json);</span><br><span class="line">                &#125;</span><br><span class="line"><span class="javascript">            &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&#x27;未与服务器链接.&#x27;</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="javascript">        $(<span class="string">&#x27;#btn1&#x27;</span>).bind(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (websocket != <span class="literal">null</span>) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="comment">//根据勾选的人数确定是群聊还是单聊</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> value = $(<span class="built_in">this</span>).parent().parent().find(<span class="string">&#x27;input&#x27;</span>).val();</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> object = &#123;</span></span><br><span class="line">                    msg: value,</span><br><span class="line">                    type: 1</span><br><span class="line">                &#125;;</span><br><span class="line"><span class="javascript">                <span class="comment">//将object转成json字符串发送给服务端</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> json = <span class="built_in">JSON</span>.stringify(object);</span></span><br><span class="line">                websocket.send(json);</span><br><span class="line"><span class="javascript">            &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">&#x27;未与服务器链接.&#x27;</span>);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">toast</span>(<span class="params">text, icon</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        $.toast(&#123;</span></span><br><span class="line">            text: text,</span><br><span class="line"><span class="javascript">            heading: <span class="string">&#x27;新消息&#x27;</span>,</span></span><br><span class="line">            icon: icon,</span><br><span class="line"><span class="javascript">            showHideTransition: <span class="string">&#x27;slide&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            allowToastClose: <span class="literal">true</span>,</span></span><br><span class="line">            hideAfter: 3000,</span><br><span class="line">            stack: 5,</span><br><span class="line"><span class="javascript">            position: <span class="string">&#x27;top-right&#x27;</span>,</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">            bgColor: <span class="string">&#x27;#444444&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            textColor: <span class="string">&#x27;#eeeeee&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            textAlign: <span class="string">&#x27;left&#x27;</span>,</span></span><br><span class="line"><span class="javascript">            loader: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">            loaderBg: <span class="string">&#x27;#006eff&#x27;</span></span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="创建一个定时任务发送消息"><a href="#创建一个定时任务发送消息" class="headerlink" title="创建一个定时任务发送消息"></a>创建一个定时任务发送消息</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> socket.task;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Scheduled;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.TextMessage;</span><br><span class="line"><span class="keyword">import</span> socket.config.MySocketHander;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled(fixedRate = 3000)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduledTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;任务执行时间：&quot;</span> + LocalDateTime.now());</span><br><span class="line">        JSONObject obj = <span class="keyword">new</span> JSONObject();</span><br><span class="line">        obj.put(<span class="string">&quot;msg&quot;</span>, <span class="string">&quot;34r35436554766787dfds&quot;</span>);</span><br><span class="line">        MySocketHander.sendMessageToUsers(<span class="keyword">new</span> TextMessage(obj.toJSONString()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在启动类上添加：<code>@EnableScheduling</code></p>
</blockquote>
<p><img data-src="https://xuemingde.com/pages/image/2022/07/07/16131657181713.png" alt=""></p>
]]></content>
      <categories>
        <category>网络通信</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>Spring</tag>
        <tag>SpringBoot</tag>
        <tag>GC</tag>
        <tag>数据库</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/posts/3RP071Y.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><div style="text-align: center;"></div><br><span id="more"></span></p>
<p>设计模式：单例模式</p>
<p>有8种写法，比较完美的有两种</p>
<p>第一种写法 饿汉式 （推荐使用）</p>
<p>  <img data-src="https://xuemingde.com/pages/image/others/20210303095809.png" alt="image-20210303095807254"></p>
<p>第二种写法 （与第一个没多大区别）</p>
<p>  <img data-src="https://xuemingde.com/pages/image/others/20210303100334.png" alt="image-20210303100333399"></p>
<p>第三种  懒汉式</p>
<p>  <img data-src="https://xuemingde.com/pages/image/others/20210303100646.png" alt="image-20210303100645328"></p>
<blockquote>
<p>在多线程的情况下，会出现混乱的问题。</p>
</blockquote>
<p>第四种写法 也称为懒汉式 ，为了解决3的问题，加锁，但是效率会降低</p>
<p>  <img data-src="https://xuemingde.com/pages/image/others/20210303101652.png" alt="image-20210303101650114"></p>
<p>  <img data-src="https://xuemingde.com/pages/image/others/20210303101828.png" alt="image-20210303101827498"></p>
<p>第五种写法 也称为懒汉式 但还是不能彻底混乱的问题</p>
<p> <img data-src="https://xuemingde.com/pages/image/others/20210303104008.png" alt="image-20210303103235098"></p>
<p>第六种写法 也称为懒汉式  双重检查</p>
<p>  <img data-src="https://xuemingde.com/pages/image/others/20210303104005.png" alt="image-20210303104003250"></p>
<p>第七种写法   比较完美的写法之一 ，静态内部类 ，比第一个完美一些 ，JVM保证了线程安全<br><img data-src="https://xuemingde.com/pages/image/others/20210303104251.png" alt="image-20210303104248470"></p>
<p>第八种写法 完美之二的写法  但实际应用很少</p>
<p> <img data-src="https://xuemingde.com/pages/image/others/20210303104859.png" alt="image-20210303104858499"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>C</tag>
        <tag>锁</tag>
        <tag>多线程</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/posts/1SE7DKH.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><div style="text-align: center;"></div><br><span id="more"></span></p>
<p>设计模式：策略模式</p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210303142704.png" alt="20210303142542"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/posts/1A7H3VK.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><div style="text-align: center;"></div><br><span id="more"></span></p>
<p>设计模式：工厂模式</p>
<p>定义：</p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210303165428.png" alt="image-20210303165427631"></p>
<h5 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h5><p><img data-src="https://xuemingde.com/pages/image/others/20210303175832.png" alt="image-20210303175831580"></p>
<p>示例：</p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210303180006.png" alt="20210303175920"></p>
<p>示例2：</p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210303181728.png" alt="20210303181719"></p>
<h5 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h5><p><img data-src="https://xuemingde.com/pages/image/others/20210303180146.png" alt="image-20210303180145554"></p>
<p>简单示例：</p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210303180257.png" alt="20210303180236"></p>
<p>示例2 （<strong>多个工厂方法模式</strong>）：</p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210303182328.png" alt="image-20210303182326999"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210303182512.png" alt="image-20210303182511513"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210303182536.png" alt="image-20210303182535497"></p>
<p>示例三：（<strong>静态工厂方法模式</strong>）</p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210303182834.png" alt="image-20210303182833553"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210303182911.png" alt="image-20210303182910733"></p>
<h5 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h5><p><img data-src="https://xuemingde.com/pages/image/others/20210303180358.png" alt="image-20210303180357927"></p>
<p>简单示例：</p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210303180654.png" alt="20210303180632"></p>
<p>示例2：</p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210303183022.png" alt="20210303183012"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210303183306.png" alt="image-20210303183304996"></p>
<h4 id="（扩展：工厂模式-策略模式-示例）"><a href="#（扩展：工厂模式-策略模式-示例）" class="headerlink" title="（扩展：工厂模式 + 策略模式   示例）"></a>（扩展：工厂模式 + 策略模式   示例）</h4><p>步骤一：创建一个接口</p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210303170119.png" alt="image-20210303170118294"></p>
<p>步骤二：创建实现接口的实体类。</p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210303170236.png" alt="image-20210303170234895"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210303170256.png" alt="image-20210303170255248"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210303170320.png" alt="image-20210303170319633"></p>
<p>步骤三：创建工厂</p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210303170407.png" alt="image-20210303170406566"></p>
<p>步骤四：具体调用</p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210303170512.png" alt="image-20210303170511413"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>调停者模式</title>
    <url>/posts/1XH0CQD.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><div style="text-align: center;"></div><br><span id="more"></span></p>
<p>设计模式：调停者模式 （对内）</p>
<p>部门内部打交道。每个类之间都不要互相打交道了，都通过一个调停者来交互。</p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210304103804.png" alt="image-20210304103801698"></p>
<p><strong>在实际应用中最多的就是消息中间件 — MQ</strong>。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>MQ</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>门面模式</title>
    <url>/posts/3WTTEPN.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><div style="text-align: center;"></div><br><span id="more"></span></p>
<p>设计模式：门面模式 （对外）</p>
<p>要和系统中的多个类打交道，还必须理解这多个类之前的关系，太麻烦了，可以直接把这些错综复杂关系的类用一个Facade门面封装起来，就是对外的一个门面，调用者只需要和这个门面打交道即可。</p>
<p>图解：</p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210304103936.png" alt="image-20210304103935715"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210304104708.png" alt="image-20210304104706445"></p>
<p>代码示例：</p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210304104804.png" alt="20210304104745"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰器模式</title>
    <url>/posts/2DXJCR6.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><div style="text-align: center;"></div><br><span id="more"></span></p>
<p>设计模式：装饰器模式</p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210304105514.png" alt="image-20210304105512902"></p>
<p>代码示例：</p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210304112222.png" alt="20210304111428"></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>责任链模式</title>
    <url>/posts/1H0GRKY.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><div style="text-align: center;"></div><br><span id="more"></span></p>
<p>设计模式：责任链模式</p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210304114341.png" alt="image-20210304114339970"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210304114713.png" alt="image-20210304114712508"></p>
<p>代码示例：</p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210304115041.png" alt="20210304115025"></p>
<blockquote>
<p>相关文章：<span class="exturl" data-url="aHR0cHM6Ly9yZWZhY3RvcmluZ2d1cnUuY24vZGVzaWduLXBhdHRlcm5zL2NoYWluLW9mLXJlc3BvbnNpYmlsaXR5">https://refactoringguru.cn/design-patterns/chain-of-responsibility<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<h4 id=""><a href="#" class="headerlink" title=" "></a> </h4>]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>命令模式</title>
    <url>/posts/1W16KG7.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><div style="text-align: center;"></div><br><span id="more"></span></p>
<p>设计模式：命令模式</p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210304140012.png" alt="image-20210304140011639"></p>
<blockquote>
<p>相关文章：<span class="exturl" data-url="aHR0cHM6Ly9yZWZhY3RvcmluZ2d1cnUuY24vZGVzaWduLXBhdHRlcm5zL2NvbW1hbmQ=">https://refactoringguru.cn/design-patterns/command<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>原型模式</title>
    <url>/posts/28TV773.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><div style="text-align: center;"></div><br><span id="more"></span></p>
<p>设计模式：原型模式</p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210308114626.png" alt="image-20210308114624316"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210308114701.png" alt="image-20210308114700698"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210308114722.png" alt="image-20210308114721158"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210308114920.png" alt="image-20210308114918947"></p>
<blockquote>
<p>关于设计模式，推荐一个网址： <span class="exturl" data-url="aHR0cHM6Ly9yZWZhY3RvcmluZ2d1cnUuY24vZGVzaWduLXBhdHRlcm5z">https://refactoringguru.cn/design-patterns<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式二三事</title>
    <url>/posts/2FRFVT7.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><div style="text-align: center;"></div><br><span id="more"></span></p>
<p>在线查看: <span class="exturl" data-url="aHR0cHM6Ly93d3cuYWxpeXVuZHJpdmUuY29tL3MvWFh2NzJIcWZkWmc=">阿里云盘<i class="fa fa-external-link-alt"></i></span></p>
<hr>
<p>原文：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TWpNNU5qUTVNVEk1T0E9PSZhbXA7bWlkPTI2NTE3NjY4NTUmYW1wO2lkeD0xJmFtcDtzbj1lNDI5MTU0ZTVkNGVmMGVkYjMxNWIzNzY4OGY3Zjk2ZSZhbXA7Y2hrc209YmQxMjE5MGE4YTY1OTAxY2FmMWMyMThhZDE4MjI1MGE2ODFmOGRjMzkzMGZkYWE3OTQ0ZjViNzk4ZWYwZWMxZmU1MjZiMDUxNWZmOCZhbXA7c2NlbmU9MTc4JmFtcDtjdXJfYWxidW1faWQ9MjMwMzI1NDkwNjUxNjE5MzI4MiNyZA==">设计模式二三事<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Hutool返回树结构工具类TreeUtil</title>
    <url>/posts/3DM6SJ9.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>考虑到菜单等需求的普遍性，有用户提交了一个扩展性极好的树状结构实现。这种树状结构可以根据配置文件灵活的定义节点之间的关系，也能很好的兼容关系数据库中数据</p>
<p>数据的实体类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MenuInfo</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">8839460886585312600L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(columnDefinition = &quot;varchar(50)  comment &#x27;菜单名称&#x27;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String menuName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(columnDefinition = &quot;varchar(50)  comment &#x27;允许操作编码&#x27;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String permission;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(columnDefinition = &quot;varchar(50)  comment &#x27;菜单地址&#x27;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(columnDefinition = &quot;int(1)  comment &#x27;父级ID&#x27;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer parentId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(columnDefinition = &quot;varchar(50)  comment &#x27;菜单图标&#x27;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String icon;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(columnDefinition = &quot;int(1)  comment &#x27;排序&#x27;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer sort;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(columnDefinition = &quot;int(1)  comment &#x27;路由缓冲&#x27;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer keepAlive;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(columnDefinition = &quot;int(1)  comment &#x27;菜单类型,0:菜单 1:按钮&#x27;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Integer type;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据库数据如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/29/1021-c2LkKr.png" alt=""></p>
<p>查询出来的数据源：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;MenuInfo&gt; menuInfos = <span class="keyword">this</span>.menuService.list();</span><br></pre></td></tr></table></figure>
<p>将<code>List&lt;MenuInfo&gt;</code>转化为树结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Tree&lt;Integer&gt;&gt; menuTreeConvert(List&lt;MenuInfo&gt; menuInfos,Integer parentId)&#123;</span><br><span class="line">    List&lt;TreeNode&lt;Integer&gt;&gt; nodeList = menuInfos.stream().map(menuInfo -&gt; &#123;</span><br><span class="line">        </span><br><span class="line">       <span class="comment">//扩展字段</span></span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;type&quot;</span>, menuInfo.getType());</span><br><span class="line">        map.put(<span class="string">&quot;keepAlive&quot;</span>, menuInfo.getKeepAlive());</span><br><span class="line">        map.put(<span class="string">&quot;icon&quot;</span>, menuInfo.getIcon());</span><br><span class="line">        map.put(<span class="string">&quot;path&quot;</span>, menuInfo.getPath());</span><br><span class="line">        map.put(<span class="string">&quot;sort&quot;</span>, menuInfo.getSort());</span><br><span class="line">        map.put(<span class="string">&quot;permission&quot;</span>, menuInfo.getPermission());</span><br><span class="line">      </span><br><span class="line">        TreeNode&lt;Integer&gt; treeNode = <span class="keyword">new</span> TreeNode&lt;Integer&gt;()</span><br><span class="line">                 <span class="comment">//ID</span></span><br><span class="line">                .setId(menuInfo.getId())</span><br><span class="line">                .setName(menuInfo.getMenuName())</span><br><span class="line">                .setParentId(menuInfo.getParentId())</span><br><span class="line">                .setWeight(menuInfo.getSort())</span><br><span class="line">                .setExtra(map);</span><br><span class="line">        <span class="keyword">return</span> treeNode;</span><br><span class="line">    &#125;).collect(Collectors.toList());</span><br><span class="line">    <span class="comment">//配置</span></span><br><span class="line">    TreeNodeConfig treeNodeConfig = <span class="keyword">new</span> TreeNodeConfig();</span><br><span class="line">    treeNodeConfig.setChildrenKey(<span class="string">&quot;children&quot;</span>);</span><br><span class="line">    treeNodeConfig.setParentIdKey(<span class="string">&quot;parentId&quot;</span>);</span><br><span class="line">    treeNodeConfig.setNameKey(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    treeNodeConfig.setWeightKey(<span class="string">&quot;sort&quot;</span>);</span><br><span class="line">    <span class="comment">// 最大递归深度</span></span><br><span class="line">    treeNodeConfig.setDeep(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">//转换器</span></span><br><span class="line">   <span class="keyword">return</span> TreeUtil.build(nodeList,parentId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回实例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="attr">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">           <span class="attr">&quot;parentId&quot;</span>: <span class="number">0</span>,</span><br><span class="line">           <span class="attr">&quot;weight&quot;</span>: <span class="number">1</span>,</span><br><span class="line">           <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;容器管理&quot;</span>,</span><br><span class="line">           <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;/container&quot;</span>,</span><br><span class="line">           <span class="attr">&quot;keepAlive&quot;</span>: <span class="number">0</span>,</span><br><span class="line">           <span class="attr">&quot;icon&quot;</span>: <span class="string">&quot;icon-mokuai&quot;</span>,</span><br><span class="line">           <span class="attr">&quot;permission&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">           <span class="attr">&quot;sort&quot;</span>: <span class="number">1</span>,</span><br><span class="line">           <span class="attr">&quot;type&quot;</span>: <span class="number">0</span></span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="attr">&quot;id&quot;</span>: <span class="number">2</span>,</span><br><span class="line">           <span class="attr">&quot;parentId&quot;</span>: <span class="number">0</span>,</span><br><span class="line">           <span class="attr">&quot;weight&quot;</span>: <span class="number">2</span>,</span><br><span class="line">           <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;样本源管理&quot;</span>,</span><br><span class="line">           <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;/sample_source&quot;</span>,</span><br><span class="line">           <span class="attr">&quot;keepAlive&quot;</span>: <span class="number">0</span>,</span><br><span class="line">           <span class="attr">&quot;icon&quot;</span>: <span class="string">&quot;icon-zaixianyonghu&quot;</span>,</span><br><span class="line">           <span class="attr">&quot;permission&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">           <span class="attr">&quot;sort&quot;</span>: <span class="number">2</span>,</span><br><span class="line">           <span class="attr">&quot;type&quot;</span>: <span class="number">0</span></span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="attr">&quot;id&quot;</span>: <span class="number">3</span>,</span><br><span class="line">           <span class="attr">&quot;parentId&quot;</span>: <span class="number">0</span>,</span><br><span class="line">           <span class="attr">&quot;weight&quot;</span>: <span class="number">3</span>,</span><br><span class="line">           <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;样本管理&quot;</span>,</span><br><span class="line">           <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;/sample_manage&quot;</span>,</span><br><span class="line">           <span class="attr">&quot;keepAlive&quot;</span>: <span class="number">0</span>,</span><br><span class="line">           <span class="attr">&quot;icon&quot;</span>: <span class="string">&quot;icon-yangbenzu&quot;</span>,</span><br><span class="line">           <span class="attr">&quot;permission&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">           <span class="attr">&quot;sort&quot;</span>: <span class="number">3</span>,</span><br><span class="line">           <span class="attr">&quot;type&quot;</span>: <span class="number">0</span></span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="attr">&quot;id&quot;</span>: <span class="number">4</span>,</span><br><span class="line">           <span class="attr">&quot;parentId&quot;</span>: <span class="number">0</span>,</span><br><span class="line">           <span class="attr">&quot;weight&quot;</span>: <span class="number">4</span>,</span><br><span class="line">           <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;随访管理&quot;</span>,</span><br><span class="line">           <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;/followup&quot;</span>,</span><br><span class="line">           <span class="attr">&quot;keepAlive&quot;</span>: <span class="number">0</span>,</span><br><span class="line">           <span class="attr">&quot;icon&quot;</span>: <span class="string">&quot;icon-gongyingshang2&quot;</span>,</span><br><span class="line">           <span class="attr">&quot;permission&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">           <span class="attr">&quot;sort&quot;</span>: <span class="number">4</span>,</span><br><span class="line">           <span class="attr">&quot;type&quot;</span>: <span class="number">0</span></span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="attr">&quot;id&quot;</span>: <span class="number">5</span>,</span><br><span class="line">           <span class="attr">&quot;parentId&quot;</span>: <span class="number">0</span>,</span><br><span class="line">           <span class="attr">&quot;weight&quot;</span>: <span class="number">5</span>,</span><br><span class="line">           <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;数据采集&quot;</span>,</span><br><span class="line">           <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;/plc&quot;</span>,</span><br><span class="line">           <span class="attr">&quot;keepAlive&quot;</span>: <span class="number">0</span>,</span><br><span class="line">           <span class="attr">&quot;icon&quot;</span>: <span class="string">&quot;icon-wodeyingyong&quot;</span>,</span><br><span class="line">           <span class="attr">&quot;permission&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">           <span class="attr">&quot;sort&quot;</span>: <span class="number">5</span>,</span><br><span class="line">           <span class="attr">&quot;type&quot;</span>: <span class="number">0</span></span><br><span class="line">       &#125;,</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="attr">&quot;id&quot;</span>: <span class="number">6</span>,</span><br><span class="line">           <span class="attr">&quot;parentId&quot;</span>: <span class="number">0</span>,</span><br><span class="line">           <span class="attr">&quot;weight&quot;</span>: <span class="number">6</span>,</span><br><span class="line">           <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;权限管理&quot;</span>,</span><br><span class="line">           <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;/user&quot;</span>,</span><br><span class="line">           <span class="attr">&quot;keepAlive&quot;</span>: <span class="number">0</span>,</span><br><span class="line">           <span class="attr">&quot;icon&quot;</span>: <span class="string">&quot;icon-renwu&quot;</span>,</span><br><span class="line">           <span class="attr">&quot;permission&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">           <span class="attr">&quot;sort&quot;</span>: <span class="number">6</span>,</span><br><span class="line">           <span class="attr">&quot;type&quot;</span>: <span class="number">0</span>,</span><br><span class="line">           <span class="attr">&quot;children&quot;</span>: [</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="attr">&quot;id&quot;</span>: <span class="number">7</span>,</span><br><span class="line">                   <span class="attr">&quot;parentId&quot;</span>: <span class="number">6</span>,</span><br><span class="line">                   <span class="attr">&quot;weight&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                   <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;菜单管理&quot;</span>,</span><br><span class="line">                   <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;/admin/menu/index&quot;</span>,</span><br><span class="line">                   <span class="attr">&quot;keepAlive&quot;</span>: <span class="number">0</span>,</span><br><span class="line">                   <span class="attr">&quot;icon&quot;</span>: <span class="string">&quot;icon-caidan&quot;</span>,</span><br><span class="line">                   <span class="attr">&quot;permission&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                   <span class="attr">&quot;sort&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                   <span class="attr">&quot;type&quot;</span>: <span class="number">0</span>,</span><br><span class="line">                   <span class="attr">&quot;children&quot;</span>: [</span><br><span class="line">                       &#123;</span><br><span class="line">                           <span class="attr">&quot;id&quot;</span>: <span class="number">8</span>,</span><br><span class="line">                           <span class="attr">&quot;parentId&quot;</span>: <span class="number">7</span>,</span><br><span class="line">                           <span class="attr">&quot;weight&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                           <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;菜单查阅&quot;</span>,</span><br><span class="line">                           <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                           <span class="attr">&quot;keepAlive&quot;</span>: <span class="number">0</span>,</span><br><span class="line">                           <span class="attr">&quot;icon&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                           <span class="attr">&quot;permission&quot;</span>: <span class="string">&quot;sys_menu_view&quot;</span>,</span><br><span class="line">                           <span class="attr">&quot;sort&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                           <span class="attr">&quot;type&quot;</span>: <span class="number">1</span></span><br><span class="line">                       &#125;,</span><br><span class="line">                       &#123;</span><br><span class="line">                           <span class="attr">&quot;id&quot;</span>: <span class="number">9</span>,</span><br><span class="line">                           <span class="attr">&quot;parentId&quot;</span>: <span class="number">7</span>,</span><br><span class="line">                           <span class="attr">&quot;weight&quot;</span>: <span class="number">2</span>,</span><br><span class="line">                           <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;菜单新增&quot;</span>,</span><br><span class="line">                           <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                           <span class="attr">&quot;keepAlive&quot;</span>: <span class="number">0</span>,</span><br><span class="line">                           <span class="attr">&quot;icon&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                           <span class="attr">&quot;permission&quot;</span>: <span class="string">&quot;sys_menu_add&quot;</span>,</span><br><span class="line">                           <span class="attr">&quot;sort&quot;</span>: <span class="number">2</span>,</span><br><span class="line">                           <span class="attr">&quot;type&quot;</span>: <span class="number">1</span></span><br><span class="line">                       &#125;,</span><br><span class="line">                       &#123;</span><br><span class="line">                           <span class="attr">&quot;id&quot;</span>: <span class="number">10</span>,</span><br><span class="line">                           <span class="attr">&quot;parentId&quot;</span>: <span class="number">7</span>,</span><br><span class="line">                           <span class="attr">&quot;weight&quot;</span>: <span class="number">3</span>,</span><br><span class="line">                           <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;菜单修改&quot;</span>,</span><br><span class="line">                           <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                           <span class="attr">&quot;keepAlive&quot;</span>: <span class="number">0</span>,</span><br><span class="line">                           <span class="attr">&quot;icon&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                           <span class="attr">&quot;permission&quot;</span>: <span class="string">&quot;sys_menu_edit&quot;</span>,</span><br><span class="line">                           <span class="attr">&quot;sort&quot;</span>: <span class="number">3</span>,</span><br><span class="line">                           <span class="attr">&quot;type&quot;</span>: <span class="number">1</span></span><br><span class="line">                       &#125;,</span><br><span class="line">                       &#123;</span><br><span class="line">                           <span class="attr">&quot;id&quot;</span>: <span class="number">11</span>,</span><br><span class="line">                           <span class="attr">&quot;parentId&quot;</span>: <span class="number">7</span>,</span><br><span class="line">                           <span class="attr">&quot;weight&quot;</span>: <span class="number">4</span>,</span><br><span class="line">                           <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;菜单删除&quot;</span>,</span><br><span class="line">                           <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                           <span class="attr">&quot;keepAlive&quot;</span>: <span class="number">0</span>,</span><br><span class="line">                           <span class="attr">&quot;icon&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                           <span class="attr">&quot;permission&quot;</span>: <span class="string">&quot;sys_menu_del&quot;</span>,</span><br><span class="line">                           <span class="attr">&quot;sort&quot;</span>: <span class="number">4</span>,</span><br><span class="line">                           <span class="attr">&quot;type&quot;</span>: <span class="number">1</span></span><br><span class="line">                       &#125;</span><br><span class="line">                   ]</span><br><span class="line">               &#125;,</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="attr">&quot;id&quot;</span>: <span class="number">12</span>,</span><br><span class="line">                   <span class="attr">&quot;parentId&quot;</span>: <span class="number">6</span>,</span><br><span class="line">                   <span class="attr">&quot;weight&quot;</span>: <span class="number">2</span>,</span><br><span class="line">                   <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;用户管理&quot;</span>,</span><br><span class="line">                   <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;/admin/user/index&quot;</span>,</span><br><span class="line">                   <span class="attr">&quot;keepAlive&quot;</span>: <span class="number">0</span>,</span><br><span class="line">                   <span class="attr">&quot;icon&quot;</span>: <span class="string">&quot;icon-wodezhanghu&quot;</span>,</span><br><span class="line">                   <span class="attr">&quot;permission&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">                   <span class="attr">&quot;sort&quot;</span>: <span class="number">2</span>,</span><br><span class="line">                   <span class="attr">&quot;type&quot;</span>: <span class="number">0</span></span><br><span class="line">               &#125;</span><br><span class="line">           ]</span><br><span class="line">       &#125;</span><br><span class="line">   ]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>造轮子</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>数据库</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap集合详解</title>
    <url>/posts/ZNDDGW.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误！！" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="710b365472dc2023a2c987209ad1bd4db76c04e1352a82da079ae017b05dbddb">74cb8564a1a5011174dce9c9daf289e93a020a72391f81b774e768619642850d883bcc818f2e0b8872194105df27fcc16b8925374397b16c7d49dd3757c723011849756f571da355fb76273375f81b53a15530149a7fc31f97e8905dff5049874e8012184eb9d3d0ecc9216bedfee6bb585e28521d48dc72420408117a23ca29f767fc11a7de4d0c18159d35edab2654fbfa6eb8595bbf572dd2459084a800838efec2597c4a15f193e56c965208ff1228a5c2f4f9c73c56b91cbd2ebe7a58316cb2cbd605b71be100e81e350f245733533401f69c8953e21048cef8405e18fa8f2f4749f2ca8d181e76b47f1e932257b5a69a1f0a02d5f2f54de75586c03b449f2cbb94b6cfedbd5d27bcdf790c4fdcf61a28446ed83aa74ca0d94f79d13071bb263df9c41ce02950777013b9e9430f4aae69e83c5ad4563fa87f1330b03893ce3de39b1a631b110abd3fcb48536728e0d6dd704adec07fecbee3978eef351d826e4774640d85db4029396d01b27ef134605cd4b8acd64792f029cd59d9421b5d05be3ca62fbb4e3ed9ba7c3bfb2ea6c3f97b1fbe336711e8e4eed95e406394be04d9c02f8174a022838239c39ebb335bb1c05da516822ebc8a36737cc89f44b6aceb9b14abebb7c1422b10c0e723f06bc772af8bcfad6c96519c9c28d8569393c3fc3509ea34012897ceb56f29618a266780f855885b75282fa7be75020c747fa022eb8e522c67ccadc078bd512eb187bdc4545a5b14e79a8e764d94727664db72c28ec474045e12dbde577f6694267ca06fa808b05dedfb94d0db1aff1b4fb7506aa2a99962900522cbad9c5917fe014c7a9be3845bee41e9f27cd1a12a125e447af1cde88223dd84be8015d764194be5e4e0ab74847630c5fbe2783c4f0a3003fcefd3831370a16f438b667d1e5565789786a7465bf59e2ac8035a860e08e47ed4a171fd48fb5eeb9c74e71f965b2820e345a1a5693576bc9d2daeb2fcf529387a98c74eac15e330735b45655093b3a7eb5c279fcfee8726fdf53509dc6d8539826e7f77a12841f3eb7ffc2b779435e0c3d40a3bcc5f2df9f9d4fbb05c63759b56581acaaf3d231c39e6c176a00a074349272b0f012ac5d726a8efaded26e8e096303d2729b4feaf8286f53e823536c62f44ddac4b866bf759eefb9e16af5834a9b3d40764b704eb8a7ca18c70e4bf6f18d33015ff65835976baeaee330e1a55f5e935b94901c6ec5ea1d7b1be0068293db8794f94018bd147a530a6a8ee37ac8bee8ff5ac4d1706591d9d3262da32e24b3b2173a5b346f7dc92d28713a53739b8a3c864f938401ff725a6f9afa5c8561d26cd207b663bd5ee83ceb2cf9ec37b5b7c835caf4b085c58d3c335597134e456af3d01485e0586be6f6c4fbd54e4abe22ff9dd61d9c98e0b2240f2061a8f65e1bd3a3ff2e15ab9af784bb3179ee5bc027f1ac128e299e53fe2044f73a6e8ad67c252d1bd67f0e5b73ce588165d5158d744193e259fd81061c612deb73439e4e3b615da860b8113a18ac81f7cc10ff05fa38dd9ab7c37933ff7d5a0e40c12c7997d73a9acfc45cd4800a38c09fa41e39ac1c84fe00e558873083b814fe9dbe94a228e2199d421f3c163f487eb001b6ff1926d916112c5191de722562cb3c7ba51ccdb65d1b7b3c42f017c7a7c42d8e3fc8705eb44cd71b5badb626b805564d6e47ed1dfccc70e8f0ea69728bdfeb1e92c78aeb7646d425c716565d9cd0eba1683d8e970338e072668089177625aa77770655cd3f947ebaec482ca5357c5a2c2dc346cf53edf18b849051127c27c7a1fa113e26bf31fe4ee65b0ea31769be33200735d9c03a8eb38c286115fd223e1408bc36ecbadcdbd26152aa99f8d78f2a5c126bf2f78b5c60944763b866eb37de0d14ea790d930d5760dfa823598ecc58a0d01ad5593b73c63a40b1549a8b3b33078c00af3689ea379410ca8e606ae58302ca944b32cfc49a873ebef8b547f40040ca3a1fddcfc652ee317dd317f556dcaf0fd9120e3c44c30fe04f7caa6c493fcf4b8702cff02dbfa070bdeff750da962986206d849468704090c1c8d9742e132448d2488bf878d479f62c26113270f18ebf10f0b753fe02389fa1f2b04c824f741cf86a6bcb73fc189c9741648f9f383b23897e40fb680717f1d7fdbff82ff9717e327d0d890f1c4b87309ba60def5f33a864f760a5a10cb6a8cfe7d577d10d7590d5e5b1fd6b64419e7d833d7265fee9524791cf3bb168fa0af8d4b72209e8f8b648da8684e54ef19d966548d69215da1f53fc56e9c22ff645a378e6e337282faea62d7b00ca206ddd416a95f52f3e02028ad93afee0c4171f78d4b35b93d386ffdfb203948f8813b033bade40b9cdc376519a424fe3b9c6a559b8e4f0ed8f7f078f8e733cbe3fc6d9414d5f3c882969b39c2e2d1c6f41d260d761a3c90bbc94fcef15d7d89a819a3271af12080a84a593712fa399f6d51c51efbe6cd5f589746978e37ef3bef5653b776c5c728965e3ec0a87d6fc37d6bad3c5353a57bb1d47c8076b86e21b69d02385ce2439ddbbc3c8cd00b8748ef094e939035e980bd5fee0fafd8ec182e9cd291bd60b8196138d7d0a657d6e93601666cb0ec7be708280eb5e387d534ccc19805c25e6a16d9b7dac59cb79e7050578b7cd0a9534e308edcf5b9bfbfc8bb6831751cd06b9f059c20f56c769939cce321fdac4b0adb25b93ec72bf4f13cf0acb411a0ab9a69306d6f92212e3ad7d15c0903a3e34186667591b447c30828318d870cbc0a493d9224ff15f548c4925a429b9f83e8f9707ca51058e63ff2f69a1696b26a60ec26c63ef489297ce2eae63f0438ffb56fcdddb04b01b1c45a06975109e2b4ac74c9730d71bdaaaf3a703c51bb37214ef9611df6f91d4f25225c2326dae07ba611946d1cf10f24763b404fb5049b01959792c0d88e8827c98712bf867f2aaf849a61e6139c568c3eaa5a7029d02765e203991c9ccd8e74a9b8f1fd217accdee8f37183b11112da1990250f84f635a8f94dff737538d8ff292fdc837a28c9565acc3f89df1e320827cff218024f07d424ff7853cbc3ab59652213ca1f01bdfe4e9d1b791e667095de2adcabc7e0c9a1270dc1a8247f104b7aa310109dcbbedf1d2204647d1caed11e41716f1c06a324c9d652c135723980a2b4f6ae1a25c800484cb58a4be9be8822dd212cce599344c29b08b27db1940aa44c65d1f9d63c58e37d402b1821e170506b037602a32bbac1a49d91e964b77f10994bc2a10537b33caaa4ad46151cfb54379d2fe3d3a90ee40c7808b180adec29bc447adfdc9a4c5b2a2326d0fc7b91816093f9cc2e24ca2501cef0f7d0af396321b91db5d3015b6191a531df24d60de068cc6d63451517acff1c4b29a6972aa0ac7c843fc153f1776e1c25300af76a77c7fb902c85d0376f7bdf2c01b62b804be3b1c6d1f8727ce8ba2d849422a35494106e07c6b45dd19af4b7d86fae61c4e2a77eac80dcad329a89876d17776ace2ef1a46abe5689e861ca47d74a8fac6562652ecb9a72007361c17ed38d0c5dab0e295922d99db1dee510fae0844123f40fecf80630aefdcd7945a40437bedf34d7e44646f2870d1be6cc327c39d3673bf04a3d2ac5136b8f72d5f94d94702fa5442ff17fe68e47da7754086725f5cce5051891efb7e611fe19ab8f13a41bd53773a344d8e1bf9babb99d4ff6b551c89c4f7a751f41892e03ceae15b200452835c9ea411e36f445bc21a33dff4443991421dd920a1742a10db3cd216659b9ddfb3c6c7e8c6e496ffa011be10941a820fed712cfddb29e36569091d6646bc83d3433fc127ec5c5154792a18d3f69ab45e2b4bfc5208f2198c4b798898b7a54e2d0b936359d30cad7e4d33d766627860f069cba60e70d3b8cb5f4629bd1ae885f751c653aa160ff1f68149da6b001145a42139f535ccfe4333a5d9ad4bc757d908f939b2a0e88dfa268c315d80acc2f166ba1aa369b757a3c32ea347adf79a6f470d739736740efdb3a2266940bdd0e56700e072e477bacd73b36ba49fb43b29016e8ee869687d3962f88ee71d625dc52a005241cc84909d7b4dad9f82a9fc75450d1d944f78da231ef7659b09e713814b3afba40c11b4ab30aa2a33998a44fed8308e6983aa628cd60059134aad5e06dfe3cc7f2fdf0b2c0baf1d0f0371b04cd1e4e4e18a0266bb65a45b9f16108691d0cc8f3c77259c6cec4d2ca1a8ce50b972cdabf3b784bf241eedbdb02e201dfd42ed84a724f1fbd972c521171c548ca03634ad2422fd318ad1aecb84eb2b4fd90cff57d90b70ae34395f0a6f2c2741ec9890cae50a68761301fa81895bd6622b65fd4c77ace0628720353db73c4d233064d2352ce41285e1ec45d8efb621b48b6f63e6f22b042b13009ab8feee78ca2941ad9bf7ddab87f70d384ea93e3e81228b2c1ef81f70260fcc39da1e4d8c7ddb4eff297ecb5021a53bd32af018363e63a939d62bb8d16ad105328f0f520e80787a8412eb06fa6250e451bb20e6836df17a592a92a82be1ca454cab5f7a14a2979e80f2841461512f181e0a162c57133b4d4fb8248d5c0dbc7daebb32953960fc7b3e877cf985f51f3112835bb82cc2a7f4ea8b788704d4e21558e3f2332420abe2150feb0f57986aa5e7f309b5ed0af7b6d33cfd9c1d7ca242aad59c8ee639a4d963b29ca73f03864a6ed8068a44070d3574e1ce142ac268360f9cbc0c52b33ff6b8b65c18ad56e8274080efa5d133b0cfcc1096e932c78ff08d45fc6c2c2e7afe26631d684f2180f0a7fc2236a5fa4e0a6254157ff4f9766b22a790ec6253f2b0571be4b2236dd201b7ca998b8a2d2f8b11bdd2437ff1c7cd30951172bd1490a2e8587d1363db3d7161484732dd204ac9cb43a07fd919638ba9d15ee27ee24e8bef2ca1d3bada9b98f9c2cf99414970fd501f0e22d18577cb67e61fcad61f6a2739c016df597416cc3f7b97fa6b5901decad998ff1bf1df617b87da96ae754e03decacc53e8e431bfc6258c9dd5f03831c9e17fa19b2079ddd5c1a3829ddabb2d1d86c9cf3024efd3ffd80aad8407609a0f79086cd52406001c9834858e21b9dabcc9ae06f54da2ce1668d93b8ed30d381056e8efd6f9d34aad3b1fcefa9d2c068c302e1de3ca0b1d3576cbce9e5c9cbb3d20f84d91dfa61babc97430f3ef912a90876d85095154327629851af1c01ecf25a76b139e2403e753a082f7a0c6e4245ccf5c1efc6418d7db381150b0ac7ba0b9e1890d4298ae4c14fdc098aeefaa56c8bd728dabc81644818cea4dd6b96a7bf23aa27df512a77bd19ee2991766b6e479dfcbc9d473ba92fb4b5a6f338cb7c44c5bf734a60955bb1912ea6fec040049c54f97178cf96487b08d6d6bdde978823b21cfd2369a386f344d0ad4b78ab90a1c3a9db2761aa929be996dde105bfbb657cd2c4cbb3727ddceb0edc47391c7c19fa37784196845b1997b84ba281c6399c4cd57ed5e202cdea562d4eba9c45d10a7b2e97d4e1f442a1e98bf7a2573ac321f39dea87bcf77782c56990c333ea55ec4d77af36dfd29c63720807b71c924d69bb20649d5552c10979d983fc790866b9a72633859d2372bd8ea0c7acdee8d25e8cb72e8cdc55622584b217b9618bd410b2ca3c54d7040b94fad481f970a2b7cd1d114a0668cf1045e5efc679ae85bf720790731779cc15375c8241ec902c683f930ffa56f3bf9759040075a02b426d227c3af5cbac4026a8d0ef51498bd2ce8aaa301e5cf065abc730dfb4c5a1e007f4b137407e5489587b994b0fe8240bf35ca7c2682478ce898faf0ca2e0ea8cb5899efcaa3be93ba047acfe833ec8fbdba6e8168d2784ee549851f774e7dc774e7db13455efc9341cbd31ad0bd03eabb79fea97da45dc879cf55e11c7a33dab7e15d50e1f71f2b6fbeadc3882487caca0ddab7fa215521596f7daf7449ef465c572bd8d9cbd6e4f6bc5a9d4ee7c9a2b6f791df298acf5b174d1c1777c87290c8c68f6a862d794459f334082208e353406365204dd331492c7d6a3a0e4c9f2be5ba2b8bcf02559522dc745cfe9670836d46c61ba0e0d3bd76e19b97156be34f2a44807828f0b3bf46a8aeb50009f13e77ccfa4a8385f1670b03b61d179031b44338ee03f978dce9bdb6dab68b21ce69b107d6f3171497e367770677b963d196414563306d2621627b5f845db34f46c3bebede6b1b370b94cb426c3e6777d18291f649bacb9e247b5984e1ad05e378311723f7cd522961d451ff32e9a5f238880f32a21a83426256f65d3d11d7baf9e61f5ce6706961697e9a54623ecbeaac0d19c63a316bb0583cb555d1c075b142628969eb8e426082a046d75602b64d6a5725bdea87d7db91e038a7399a94bfdd7d3ae59a2a8fe553918924ed64d445d70f5c5ca06a36040c4e36afcbbcbeddfa893e913e0947d6efd7e2e466f44a714c0f4aa01dcfa05c0f410e1eded5cac95e5a55ac0481d5846e2740f0ffa505e635a20055b8fa4692eab0739e08780a5dc4e01342d8e7869b51a1a7bcfbb1d0cb9424c7d9748a8950d62138a0581d5b11a2819f1ce195f76aca8eacd644cf6b1e84202391d837dadf40dec1600ce0cbde7cb3d404419bddfec475d4c33935a733692ed38a5e73be649171bc289ae607da9911d48a536d738a7823fdf3f5c94bb7056fade5925b32db9d1cb2f300950e70ac51b0d2729d44e3ac355257baa95b7374adab1ee2cd1dfdbda3e8f9a2ff63007e174c2f077dfe69ebf075a09fd8848f41c33b608a83078e2481a463ba7c32b3436fa489a1f2a73d013c057dda3daafcd2eb4b904dd7f04ab0a375ff05b5547fa6e9234fbbd63250eced1f6aa1b0c45666a5a8dda9cf6c7db979d5454c7ee019c3b4012f82a1a72390107ba94946b37ad602ab3241e571fd51bb124abf9ac76931a141e09dbab5a3bb30d6b57703926711a51fbd6b14488360a470888aa908f3b14a983e7dd47fe455ed5f7b18ec09549b8437914c3cef52579d3f34cb67c05a4fb18b6efc94a5c08b7ede2c79bffb5d50a65b4a5068453e79e9a70841872f19e95096854021f4b2f025f4e67bca09e079041623f85a2e9e05fc6489b2a62a25fea180de2445d9e8e79ab77069ae9d27c7de725aa7cdce149d86f1d110d5d3b9cb0636c11794e8cb588ae6cb47ff2cb3fe210355da96135b057d1a57dbe6e2d5798e5d4bfb14a45e47a780e674ed0f5d2c622567aef8d9ba7bfb1c5849792fcd1ef05e5f66baf0185a57d1c9deebd823ad541269171821ee83804d8aa347f595a208291d8cffcd2eed75f65e8b178ae987e7cfc7ce950b27bff9a4faf89c47ce3ccf2efbf6b37443f54d1a3f647b2628b448bdc5699e65cc952259e658a5765b0927d70c52669b7f1d94c67509231bbd72c52ae23f4c2fe0cf131340c7e0389eb243c97e24f86735f195ea5f928178bac45fda15da6536127f60f8856ff9c015228222d72a41e005c9d3cf3f0967fc097d376139c63f6cc8235e7341dfe4a6a669891ffde40e4688bcf3481403cb2c0f2f87d57449b10a4707dbb95f8b4bbde265073775da8a4c6d80abdcee2c72c4c4f2920c9f321b8ae0467dc18dc68cc1a992deeb6c50435ae346fbcad6e52f5c01269e97edbe7bc64648b0497669e22200140ec1a504de31fe3dc6994bcac988f40f4262c6ae236009a4db34a012d1a7d1cd298931149334331da964996f706e8f97c351b57cde39b3aba6fbec8d3e0dfbb38eedaf351b1f2c2725cc40cc6b06ecb6bd29b8510f55101536055b0d3630ae8112fd3f08705f3838136789a068dfa5d625470015389628a55965bc42bcce9436ac8e1ecae08363b2a0c88fb30b1628103429e9e5fd20f9dc60bcfb48c108bb366d7d70c2bb2788995b6b1516a721544061ad48a875967f771296ac4105f0f666a0e0b0635f34420df352d78f08d5f3f5b5c2cb4851c75d8380e3a8c4f6cc02fdd2f258d8af0aaca9926cd0c195c9b30184166014bd5d93cb652f50f45125418b2a91de1a5e9eaf71dcf5dc76bab3244aaa1e246ef57322495104a1f78193558dc2e05f46915c9476f117f80bb6a99fdf1367cdb9f42bc4873df957b6ac95e4ac028522020419d29e47da95f006a0dbad9fb58bf63418934b2864810d4520b3b418fddf8935289c5bc77a370d6418d15f8dca1c42685deaacd7567150774517b700a3bd164d0e02051706c402eb8e11b6faf3617edba7d3fde0035f81aff46ea4cb9e22b8973b79289329bf9cfb9a31f842fbb43a96f3fd8c043efdc11f792363ad4d914850b8af4adff01c8a8bb06439f1f0cc99b423a80f9106fcd38e6498379ad59c344114658a7453208cfa391f28d8f9dc1afcf7454fea129893357b7d6f5744dddcd31476c1c9e5a7035088782af95b20dd6e8b330ce091546c51cea3cc5f46079a54b80674ece3e16b889bec15d4cbe68c63908862830e2306e85f2cf334b99a3dd9a557b9ff038a09a51da953eb85d7cb1c75060a9304d467a12ddf19adcbc514db2c125a026ab3893ddb8889e8f2ec731d2f6abe0a98305a1277fb31d036a4d854d957f676343f2fc7294d8fc9c26f11432f95d89eedac1b3ac642314591a506c6ee79f3dfd2b319be13104c0bf365ac4c37af4a192a8ca28b879cd2d730eb307c1ead7f49050e9c228baac0212118f4466665435e22ce5ccc756bf352795bf9e3f37e7645912f8b46e7ea5116770d3be2f466ade173f178aaeaff893a2cd8675edd5faeead868f0d5c43564e0023b13db4502e84989984c728982caa82594a2e2cca72977951f1d61012c6c3d8d4aa6e7e888b499dc81d72c96161c9dbfa17baefda97b21d9852ddfaf2bff42a9540497867cec1f86e8e2dd01a69d08ecd737bd2f2cf7a0d3560c14315665f703460ef9329fca1bb3eda4a92ba6f5003e44994c5cd4ca136a093d4bc0d6bc50f5ebb156413c17cd9395b999884ccc6ddadbf9bcd6ca3dced12937946ae89143b7b4eda9b9ae25fa128786363c0dcbd5d31a5300daa771b23dc8256cd1e03fe48271339a34cc47bd0178110cf392c8977b7534122112b8242d9ae0d11344545b52e72472c10990fa74c1eb5ed8ce3656431fe5553f7a22658011acf22a65ef559073ed55325f5a7ef95b2101c93fa4ad904f1ff201d04ca93f23471f444d774cd6f4133b56c2bc546665e66da95ff1d48639ade802398570b2e05fb72c287fd0aa1ea3ddd6623f540585cd89c3d7b4606a650ff0820e5d3b9d17ec52b78741ef3fb4b0a809b20a14d78071cbbcc5ddd5003ee90b1488c4e4408e2c58703f80719e5edba5032f45d3bfb8dd7e8ef73a509c5ba5b6fae63ad2292707fc87f44596b8ca57761d91981506efdbc40e4eb9332bfed18f148c43e2ce359ed8fbabfbb61d64daba8499d2a1630f8e7311e08611bba6e6ad74d03d06c42651e70d017b9ca914e213c42e8443b13e8322241e1154ddafc730ff68b4360f278fb6c4c9e9f9556f219fff25543c8b2cb58c73c07e7e1d05ddc17a7ad970c0e923d6a3a1f3b6d4966e9d80c6da65f91c16876fce51f55d94adddd331f1fc898800b81d002b280d9aae0df45c32f54fbaefd71cbbcb709e005b65664fe8e8b0cf39df40995f7b5ee312d39e8e63028a1a717e5ebebbab554c7612c4fb68411c6b4f8311b8bae10225a9e624ce76ea149e422e8de33c41ccc0fdf66d47b1191d2fa9680b734e0a5cab05a2f83941886a65b3a1a423405c31e52cc5e83dac0ac12d9ecf0faf8ab2777efe3f50decff3b5351d5ff5c8347a1373bb36637a87b0659f9d2c14f8fa14775b339a37a5ba1716c1025eaa7fd84a038d87be736b1930ea3667733d218c1c490ef5551c5a7d1246f80a1479d35fe222ad05bb6573d15e888c378574020c420732698c6f0d2716da6c3a85f091baf520509681ffd1a0d9389ac3f2dfa30e741395a56498cce18a65f5c00ba6d2ea00b895d4678338c44335f24a90be2a1f7a174b107ee8d417e9385cac294b570bf59f6329efaacd74087bf0ea483d57d08184a29aca34de2fba29c7acb6ee8c7f30ed3687f08b7489b3ddc8d76cf18c576d473ac46454230ea32ad0a682bc042d62c4d4809941d46f5981d824d0e9cecdb4d85ed8df1c4c26f420a6b61d047f36b05404f6e4fe95f94192e34c9cced1b4d297350eca1daaab01105929c2ddd418806fcf5c2e6fe19a92d92a3e896c270403473f3a74f02f01534224d82367bb71fc5370fe97d69197c7d46d3843d72aa0b7c2df7c51dee4e63394310a38ce11e0a06ad5602eec18e1904edb4880c6786aa622e1b9661bf57901c3cf9eff5b88b06c555212b6ebe44c50038def6df0e7ef031bf006b195a9352bfed2ec6056223c2a5cb3e7b847be28d2a0ea737b303403fde8979d28af8c2802d2fa30664fc59d63485193b04c0708d3826dfb403b64a54c74e889a6e310b8e8cc1e924e044a499fe29245567bbd1afbfd5c3aabad6e1fcd791c4e5c90a8e3f36cd4c6e801255340ebe0b347340cd9da784c5bcaad05c90e048845dfb1fbe2203a3f77dce99ad5558b3e78644a161f265d8728daea06a0a0e0c18de4dece7ea126267bde31df8a9eabfa3ea7dd45a1f9906f9cc257ab38ec5b01c2d83f62be19f1d2ed3562492586e17c422a5235978113919a8016251d64487097e6bae694c649e04c54e5debf1f7fb165713a687dab5045171159ec3d5c1125674f4bf70310209ed960db773703beb6c4e9b4226abea346428aa9427c863ee354154d0cea4acd920c74427ed4b94fe2f68138b9f7e576c63521f8aff069533031869fd70b6e4831a1195a890d8958a4334ff1e9d02a4b1b7ebf62637dd4204d19808916b70a351e7c398925f66e6a3cd2f5e792bd93d32a6a96ef728b43de3689e1fbad012fb52db924ac7fed6479db88593df9468353b6bab564142e74d0dc6711613651015a2a1f04d2819d9204a8a86d707ff50cd40cb71599f0cc2ba75dbe1c9cc5d061b6c76c3ca36e19b8d53105e02ddaafcb41d3f0c46999699a14582c7e632e3c27a9926c0105cfc08f2f530ac79c9377ed19ab17fe8e6ef4ca85c9ba4f9791b4fece62905be3b20624e567f7e9445bca633d5a61cdd42d64618698cd6eb0f470647550aa01f6aa5e1ee6e7cb673766035d217d44885d7aab3f992101dc4ec9f40178b5626aca371036c8cc6fdabc8db1aaaf746f4901781942361b298f5b4022ac16f8e06bd4ec709f1b4ed56433b38e01ad62e5bbd49d2a772e2478949bedc268d184d123e7de1206c661f606f70b6aaed27c465162fb236c2325fd824ea6f8044587240f4a3d6fdf2083b24774a632397690aa8acf910f43aa6d2c1a92549eb40503919c383bfa5eadc8f3449b50de3ccf76bdcb4501e6f530d51de1c2527839a139cd0b06d2069a8e7c41c2dcc8af718253b8b0ce008a88ece0440c211068bcb69044c6de661e547dd2cba154e0a4f2895d4e3d2dc2535134bc69c9ff4b765ced03e3dc583b1d9a58a7020757bcc483d9a773cde967e90b1454f3235aa360800bc54c06b5e35a3f5770a25b6cad8eec8ec6db27d39d5224abc40225096b86a6de5baffd3337596d7b948ac3e4128ec60724c53dbf73fda7fc3594bd631505d16c2f9e7fd3f47a462b460832c4ecebb9e1de012b424741663f8ece5c5889560c8c0da5f10bb57f478994e96111849b42413252e4de74853cc4c283d316b0b0ca6c9dcd3ba865454bed885df01fa59d09b53fa7538d556d529c0f85fc79df71135f143d26dc9ea2fdef1a6e577910ddd3e5e70c6a1b34f330f99483eb1426caf8f489f89ceeb7ba96da9fafbeb23e9b48c2f8b4a38a142b2a1e1550ec8413c47ac0e16c92e6720c480009996a8d85c429fc6b2633e72615d4e22803cc0b0dab19e7dc0c9135c5bb92b20d32e2d00301ca3ecf2bf73152747b0c58f315bc75b719b77ddd622d9ae9286fa35300f142b4d858f0e97b6bd9dc23b42a21ee5aed7b011bbcbf1ad0549bd129830a9761daca716679a361449590195827703957dcc51a1f58eaab686f17c11e1dde8ae3284910aba1df0f6000532a0116bd30a8453b7f0401725ff520ada9b0af49805a8261642a60be48fb9c457e5f267d3289552c6d7563fa991d753e495f55cc5e8b5043d0c56b2cecc705f5157afd38722b44c68bb8d1ee571d47f4b1ad2e75728b501cf7edcc88162236b057d61faf07cf1dbee316e9420484da1b3a269e16f609313ae05b5f3972fbe47e332239d7ae4fdc9ff5c3edc44951bf12b09383f13a43c1c5aa24d06f97a9a9b655f51327e26fc47fb68cdcdb022abcc6b8c9f7506f9a63aaae4744403dc50796ca2b8305d6be842fd516797ca0bef2463ebd795cc446a744fc1aa34b48a75216ecc05040ea48166da217e4b77563e76986e30821addbb7b2458d4a6df547f0acb6298ed8e902fffcf7c8c6aac2911fc194537da26d43e39411541286a96f356893aef5fafbc44812e8e754251f00c13c6310125adc5e722984448aa17b950c7d29d68621dee77977d5d24ca6e30f2987f3c4ef5fefe5cd163db3416007b2d5ad263abf3456c3d55d6cf04afd6bff1e461397885e2c37ae9ccc6ea95ddd33cdeeb570b1e00b72759525debbabc6cb79a4bd857842a0b78957447aa4b6daa67373d2ca220c7a42fd56eaea88a4e0ea80e81f9bd84333819e317d2eb74a657e91ef6710341e1313b377ca5a0c38301f7ffe325e060056f9047d8433b0e8d4dc0c8de5c2241334aa42a0408c19d46003f1ecc45e0eb2249e4efdb8878c8bb7de52080428670fef8e896010db3937b9c53153671e8c34e9a2a5f88c9f9b47c5dedee9faa0dab074c63807b04f42220cb2aac95ed3704746ae89a0cc5259a2bbae9383bda8721a227a562d22db55cc01b9dca333586d899f6fa168889ce9e6e685e4a9f42837d3a4fb376f04dbc497246e24b2841e92dbcf65d42c17e760d7268e43b3759939b7b58aa1911c9f83b535c9b8114c8bcc5b9cc07fd5d0935c6a444e6413e6e257e6b8e73970a63100d2328a2e03a40cf9410cf95c8dd73ecf6704f016f07686b5a68c30b4bb23dc2e2f245ffb968d7015cc1698807ae87fb3ff3f6e582b9dc0aecc1041adfbe59b6fde5ee790eae1049e95af1e84de7f3d9108c384377df462e278bd226b49c55ca839c4f88b0aee3fb6221bed0f8f12130d1ef2896ce026e2b6ea5416cf27bffb81a043e2dbeddd55b7a2f8e2ccfae000b7ae512ae54d20addd85c8650835f6bc61a476e3ff25f66d21c620ffdd55157286ce479ff96fb7d661bf0ffb884871cd5bb5d935cce5be9c2325f143c0d0a298a1336f9133de1b3be45da24a7a4afbd1d0547f6ff521092615de1d7917e91d46a156ed78f3f28dbaaef80c54be9079e8b427cc492dc10384628cfcb9f456c13000b93e2069d69e3cf085fc17666b05d28d4a9691adbde407b57cf24549ff6260a5b35095bcc4b02193a7c93b9a52264f52e2f714de6c46b7ed570e8ee7e06cc7835c77f5b5c6aa4eb268a18daf5dffa3d3bca4fe512fa0729bfc77b66c151aa81a4b1b0f48fa741a9e30e7badc315a439cfe5be589fb2f7bf323cab7c9e753ead5d963178086805905a1f291910897301d3982138ef1948c68e6f82273cf68c898f4a49dabc508614ad1822578c572c40da805b52211cae41da37750279eef68131f8b2535ce9cdbbd4570e2bfb82a3b5c26a8f2d3a148ef5b822479902df1ac38e66d1ee20b9a286667803f1cb23f1c39508cfc33ca4b023784f030411916552ccd469b60bbc989e41fd0ea4be3c0955b433262b1c1753f2462d2e5fa0c7e2292ab4db940ee283aaae23b981c7d5af14340a2f0b6012e97d45da787995bd4ac832971c5af9253c97dccd3e6a7d9017dded529990900d6d91c0f8b03c880b6cfbe11382898f2e7c6e9599cc754bbc49c8acb9214343987aef9f148812f1cc3a9d34f2c252d09502c6dd32a829ce5c23dafdbdaa6161203510b57592a165106be38f3b7e0ed6e3f2186aab1e6779bb5e3da89a4cd17e5db72802cfbb75b58df698b839b259cee99468da54070353ca518cdeedb5da6253d3142ff163ec3176086cd0dd02ecc208bf1ab91734e9b19271e2b90d66edf06150a0bc103223a106b0da5472925c33bcc5a014a05e91f11cf6c3a634fb595875cb18894b9d9b71740cb3926b017590d0344faf339294ef1447f0700adb91ac9cca9bbea87b9d6c515936e56747676bf7ea5b576ef430d5522ecfaab067b367f4d27597d95a574792b9d3ff6f44fb3b5966339e874a00795dc0f866ec5869bcc6787b6c3978a4875b8eb29fa629a39d1f09da39418b43ae7235399eafe00e033ccbc16c637fbbfdb0fc48909b7b886534da75a02a9859d043182690a45398effcec03de1079306d1e920ae822eba314d6b9c4157ee18824f9e9f7311ef9a4ac102ae11827e9313c7b8e38961568b990a52dac3c47dd1fe5ddb6f2f14effbe6cbad420d6b4e4602ccb25354a1f6a3f8d8ba92e669582e89a9451dd67b9d375fd0d405c2c4bc0cede0e009af167edde0b1e703d924cc1ffff65f6ee32c96b148a6cd599b5ef4be9a549ae5c9e913a9e728ae456ad3d1666ffc0d96f8aa15fb16ebc692467ee8ffd7fe31fdff6b99b35fdebe9edcb705d9696c4ecc29a63182d6448330d2c2d937f23426a194a68a1dc26796c0d1996c41aa3e0c0530d7bdb36f1e7a7c6a61aad4006aea4aaa8f2a1e3cd110a566444ed7df373715d3df1a1142db2254ab10b126d8dad7b3ccc1252a5d7982119e572cf1208df3a766199c4a72fb8c505407e03dcd564856236feef666e252b43bf902b2e0dc93b581a3ab46176ab471aec2de33e73dcb630a3d315314e0b395257068dd38d051ffdfcb65b799ce51fd08054510ff21bf7e90afb329170e6379c9b8d0c042e03cc514ddca02e5348ee45fc6628978245b587e1735e86555b99fcb4c6ebdc8fa9429d4f7a568b1afad0fc5b2fa0e2e61f7d15bbd780b27c9ff71660e93e41d5ebc73159171aa9db4d2e74e513581980b4012cf9f4efe8dd47647dbf5c95d7c23772784370a5a232d53d830eeb14b9c52ff5fc6b37ba7023a4b04a5cc5999a97d3b9c04a6da93a000884a147ff194ee82082df8896eec7285867125556ef1c3d156148c45d2f52be2702fe8f56ea9a4c1c54eaa1a7a4e03956952dde253f176809a92a1be750494c8dac8eb085478f53bf60914ce284915e482f5b4f26ca5c87431517942653c97d3c9da296195a4f0395295db7f527c42ae86b005c19dd698d125705b92aece39923b47f1b3d7ebab1d623cd9711510db3e7e22d185e1a4db39db871b0c41f0724ecc2c3e5ee91a65e372551a4de5c284f10514b81aff271ceed69ca9873fa0baf1dfd0d296f4d0c3fc48656e7f39982fdf94bdc3b0048d235e4dfefac58b1db5b010cac53c43ed3327cc3bd5838d64c9d1d2533039ae3dd9c27db6605a6b981e26a2c10f10be16057fa67882b8f2398ea6609d957c02a73ca042f50146577173c7a0519da561d29ec29b6405ebd1ee448ff161afc12d9fb4f571c552c10ee543a53ebd7ea50be89106fdc9d98711b9c271ae79ac97887db5a9f8f6ce429f4502eec317a285337f990f9f6aaf75ab4b6867225f912f227242fece5a6374b2fa4548b952eb9cfc94fc9050755416c4ed6d310aeac4b799904dc94d31c26c02286e1bd0baa381cfa4a396f95dda076bcb83f882076b72d98fee536fdf8c1c3dfd7a1995d3d47c55e4f1a292a81e89ae05dd390932606902d660fbd37de83901b6ccb24ab2326f5cba26526174805f83ab9df3f586a876881d631292c966cc1fde7c8b3b807011315a6db946455d030800aa6d160fa15c71ed81cc4a8f6421584e765010f6fde40eb9c934fab4f23b4108a92ec9a5864db03a6d70b7bcb2cc650a70adedd773ed9dc419d0a8f9d3876bf5394fcd3014f224ccaf37197f5dee12a3125e1fa25117cd9d616634d7f817bd32e95d35594c2854fd72fbb161939aa48270264e9156bb36ee5c1777469bd00ec051a27855d15f4df77c7359b98f3c6e54fd5710e76192f3269514aef738bbe0219ab53e749eca1f18ce59e3780f57c30b394b5e1e70de16b2267963eda6b6400e45a5a5e20fde431fefe47d21e267655ad01eabd67979682fc5ba204cf75e2a2f1522009a9657767bf633d6cddc5212b67146ae01e0b7627ecf3dbe822f58005e03f2449e31999d2c7ed803e85f7f055252fc3db92d0f13993051009581f7f034cef1ab9168a22fce60b837a386a19ac7e37d8e011ca2f14b3fbe0e1eb107a5bb64ffb7085c9356e0bac2e3b0c81f33350ef12d19a7f47e9e8357d72c9686c2527aca0a9f293c0217131d36e73a6caaffc03fb145c4b3bd7c5a996e78f56947a18a0e1c5b70fddd0fca8e40f94633a5fa760aacf4d769f50c8c0ec5b8834fb5d309f661d3bc3a1d6a6ed6e5623175d0cba9518fcdcfa9ec55b356382f635d23c949ce32a87242cbc2e2349735f3c11ab4e42357b60637516bc41cbb99157a2965a9e68e674d7f49f432eeef654acc9225e2099ae1ef37d2f513fc2ae817e3393396dd2f01fa3ce48514fdc52df0732daa8481eb5b055d9a32cac39821abb7b36cac4f9f965056f4824d8315a6b9bad1dd80260ec249b7f6a70db719e1d76e897e9e24f2204d7e6de4c6d0ba26829a3275b67191b836c773f33a9b4ace5f9cc092205e7b302f83a664082c597f84a1dbac983299f0a597f43f947ffa2a4e27365acd79a9887ca74fbb28c0d477cb395d442bb878f160e79315ca8898bc6be476c79ee6cb59787c7dfc087b6007b8c02acfa19928ec359e42dd9069939a3bd178f9f7dac61d54af3d63279020ca5907961e387e071f357c8628b346709b803dec8a7dd9c1e07aa55bb797bec803b5f64ad1e3c7f65f45bdb16c36beb6666053819eee45e83f78523104413c5783d0eae78afd174d2719562fdad02784a504e525ebbd92fcc7ae424b1c1415d7aea0a08a015a058433d9d35123c2eb2a576f1e0be90af82f6b50f7bb208afc3c8d44171c8d068f1ba5f674ccfa728712a33eb29a9f30ea323265037328f142552de4bd6a8f6e855f72c47b743f2781b26afcb05aba8e97f70cf3c0a3b8d6169eb80e1981cc2686f11d1483e0e1fd662a9a94c866390c119457a6d11a0c84ac5cabd660097a4026115ba782ed6674c67f4756af04817dfd962b34e160ac0c98a9502e7ddd36c18af7bfd06b12d119122fcd0f169c7823028ed4d3b9cc306b9df959be58245f12661d722e04c346e94748cd281b7ccb69cd1335ca029d37e7f45c8c9794614f6c9f02bbe4ec64378bc1b6e0b14e988216f251f017b2424737d1412f199594e16403057b5be0b2be2ab9aa74d4a2507c2952422a96a21d2bb80482090ea33599f9687e3ef79c82d369f61aef4a632469c5427a1d7fc40959a13d49034c10ce40c88429d0c38367dd1a68a55d2bea64b22fbc35083b4ff0cf8addb2b467f540191c0999bfbee53c78b9ab595f5e8b057478949b718b6f653b904ea74b4e1473c87c44bc8f257478ebeea8d169affcea40347a09cf90178f2e34dbc2b40db77d9a24ef91e2722f00a5fec3e6a5be8577287dc08a08a148b4c064378c29dee0ad07edc8e4a9b25a88cb75a29ec310f027b64caa55808e6423b3a79b2e363e38337ef59667ea0d9e8b3d9db8a303d6f9393b2a37942b5802c17a028d866d52058f67c26cf915a7e5488cb780abb928f961d8a62cb34f9a40696c4c1591460edad6a9f37b4de972253934c6764da2988c1cccbe58a0b38fb0c4f04ed311becd6442361ca0ecb4602324c9210cb1910c414a8ee480945a600c78eb45db6bba1360fab451b2bf02e3075b10c0fc53ef3514a68ee34cf0794f3e12f3d77d4c13159f1b42891df130725078e405374b87f04825289716711adbfe49895b9f277f508fe8b2fe0e0d3562f7dccb3b6f1f814442e2cc60a7021be73697d35a8ed55dbeff15c1e84b3a97705ad47b8f915a5a55fca211ba22a0d057e299653ae7e253512df4a6bd971227cf3d375f46165cf33c062581620d65a7ab4e69df5d0d709f9b62410bd23b490583caa186b85b4012029a3644409275660d62732d2eccac89fddb9efa9a9b6cdefb2f0c2b50ca3a1a999a059e816cd525f3ea513076f3b4a6ffe0047aa3ba14c1f5953a09cb24a4ea25d9decc3f86b0091407792302f65d0df898572a733135f99b46f46105aecc7397e190fe9d8c68b76238a261ecfe9d70954ec0ed32ac029e9d9c2ff76babdb9b25d2394158e7edecc164daee5b99848b5cf7d88256bb1b1475490a2c1bfb1e0bec3234e81fa6bfb6d51b680903822a610e83a87fa8ec7880eb41f309874c6842f7ef4c2b03f3b22abd59c5e33c94d372135147a0c8d15f8510a517a8c1dd7fda4ff3c9c4fdc9cf899fd496d249c1496c266bf1d99fee900414e0e5c23b20933e59d12c562be535e1d5c7a699a811d6af7928d8f803635aa57916f4a43a6fb0fb47f4f814366d4a8650c021b3ec811802d3428f0be0129e8adf38206fa952eda4f6496014d1a3635477fe8930a23e447349e177fc715b539a8e1b15feccd796fc234da2ffebc5562b34e008be3f4e5c42ae45a83b89a2325c38e449a77f1076cadb4b9ae66c426a0e5933e73f045dca78b45ec674a61cfafcb2175117c6592f50802d6702c2b62574b26c830a04a51115d623075124464c8a6e2d3ea1e5a0d82213f3e471abcd74989da4c9948caae37a16b39759087ec7e0d4ddd427ff4ccc3e783a0ef72726dd7560e879cd796eed53e962b416d453a63cd15eb4429afe732ec3046cbe4f7708b5965775bacc5e6154f80e0c0f202b7b4b6f51bc42e3328fdbc8360897775bf0adebdf361dfdc286d4276e1a91921085846bd659b8d353d5bfadb52aae9ea34ef2fab47e8fbb2535d0e6b5c13ce1cca5ab925e730c457dea011a0af7216454d61ca37dad2c855b19f5ec66b95f12ac7b6a77359191acfc8fb2e13213f84800b59b4bcc1be854ec202e567a9c2890816b94dd1b14a1833bccabafdc689732a6755f22c98461892ab28d9d03d4e3f62c1bbc103616666d1f84fbe082ace0ebafa011595a1181814d5261cad7dc6619ebb974acbac8b47fbca01870477bfce1c70584c54d42d60575ce679fea55493a68ce1d3b44d8f7e6ec6208098b66149e286d8e6daf5017d39a45a90a781d7d02d8f2136d8c5d9684225fdbee07def71fb0b05fb83ac15d392f07c94522d0619f8c75b5524410196d950021067ee5c524d63271a8b8315bcf4ff41bce947f869947064d81bf7e9e69c857cef64c879d4f74916266e43584d754fcc5876a650245b415982a09f0422b1200ecb5a875c024d08da4269995e5309d9c5a038205a5b58702ec6e5cb12305131ebeb0f72693e2d9ab300b4b5d5a5fbb7b679ee26d367ef5e63b8500fd8f3fb62a53dacc6aae77c6d1a8139b82998ecd950e15c140f89aa3bb639590fbabe7cdb38533850d8b370514e498f85090a0a9c8f1a88f1181b0fc6e963f08b20467e15f80a127e8d47ec140dae4fd20c0bee45b515da48393d399f12717a4831a5f0449e2081f9f2c43353d45bf8315ec1d977ba5f329465803000ad09f4caed0cd4c4c1b8afaac5b49cf830c0ebe435a0bdfed9455b51b4779e21090df14419bca7ad5a8293a6360e03057543309148823a003c03dbf1c3204ef6943081f29083b81fc904ae2512920440c79489887c2a429a4773fc568dab4e6a232716838045ec9b693291503c70078eb6125f277d9cb2ae79243fb9d8618b98c5d2bf81ebfda9ea3b2b815f6c0e3e71783796cfb97d78e4923a80808045e7b0d975120973d38908a77ae78d500fee6214ba03d2c02a4cd4e88b1a59adb576e6347af08f824b9ae6ee47d77ce85966087b489937a2d681781c8ee7cb3d988eba1bf49f040890ca18fbde61be1eec53e52093a584d59dc5b69f2462f713cc08cbdc1b755aff86ef9fa1f12cc9d3e726b1ae483d8b22744b08105cd01e40b21580a5fede9f7bdb4befa79f74fed564df97e65fb691d0c74bff5eca875d0039dca0d61cd6f7af827b08d521baffbe94207ef18cbe92e606d4e84a55d65336ef1611956f73d9e204bb54ed126d97e50eeff0070320ffde13ca36fcaee3269c2d0c491d6f3a093d4578d83075eeccbb8e4071399b35fec3b942956b044718b6945118c92d0b9573a32a30e432eb06baeb7c8b48c6f01d396393cbd59d1648b81baa9588a82467f0581213117e925f1ecc29d240746f48dff52853ea5a06eb7d58f3c8b8a31cfe966a22583447e6f5de979bf91844e69f2c511b11a38c919278ee54dcc230fd94316cd01fc8d9d9686ac79f1711ddec0eb3e2119cf9023f9e01ea7624bd1a6a2fabf24f03d8b9ffa6c099d116d6844b1e6d3a70d8c112cf3ff63188040f1531c200cd11530b5cd6d311a9d837ae2f89f505f2e3b0069049372c207d6242b6da1ea8df7418027ebf1e47cb2029b977d485354a660184902c98601b16994c145992c409932255c59ce02e26a4853d0005ec357367a90884989b6869e4bec6594e848b3c9b9dc3f21689c908b43622958322bf45648708c7ac24e0b8776267697cdaaab5c443e9d5549f83b5c3f54658195831620e9d288f73df182b507086890908979937bef00282812503ea936d210cd36b756f665d4d830e63109c04943aecd83314daf1d56a7fddeab4fe781c1f328e7a9db6dfa28dd368015e5164cc5f29f1d069c9bef70ce8d4b5a929586f46a7949126207c4cda49fc8fa60bbcef76c55c91c0ae7e69414f9c20ba014a0f7df67b5979bb5c7500d396fd5e1de650256d403c822cc61f8253183f761b930cadb4a209d30f689f3fd256ac3065d82e90e41e5be2f6915ad7e156345a50aa26efcbfbda1747b08cacad5bd768cb58ac65c66a07dc80c81f98133a1f036ea7a39ef37c054b88d06ed0374ca2499805ca8e70a32856db5b2b7dfb50a11ada529f75ca08f879723ff1f4929979d9a1b7aa427280f4ed779a767318c0faedf5d9cffed1e9b18f1140c699f465e24ae04243974ee09f3b757f117559e090ac64ab3211359cab4e74a6ac8fcddba080c0cf6a4d51eb9afd950a01c15a14d2b3955e0d22befb2443773bb07368670c0b7e5b4a5f7a0d10573daa9323356051fc43a8b70210fa0e0fa47c8838a6cfa1ec6ed3b453fae89211a117da7519983cf61caff262e67bf95b08d02f4d4ee62ad7f154b1c17f1cbf0b84340b4dc2ba739a2e6c23e8664566383d773d899896312b7273c374b6dd0c5a2192c9826a2f042fc086ffcc31e03fdb95b4ccdec8cf15e1e3c5638c7096b644157e39bada0e8ca911705085513028b9e0594ffe29a2ae0d5a89572f23dbe3b2431e03d3ad2bcfaeb8c0b84ffe85e335a7c2693d9e29ee6d5651aad1e4a861b34c6e38763e35bb1eabd7471cc1c56ffbf43a197c2525f7a7298ad5703a8b8d70603cff202b12b83f7eeaf36cdca12929ef8daf11b0678d4485ca3119b06d933d0a4557f451ad04be4806f42d47f1f4cbaad5100e694799cea74fb19c67ee2eea764259104b22aa841fa38a3ab97dd64034e065f079bd50f7648ed222364a8772c0d53073cb537c338516a23adb237f08b1f4eaedf2512192b2e4739976ede3581d6affa34a5986fd9cae57010662db46dbb78b206333bbfc8576c241700df8b4c7c65ef18bb3832d05e5e6cd4d93b9cce37d1550b59f8df3aab113026859629caa8dc04a92b1d47861afcb4c78d1fcb7449709b7fd1f8ca264e65f5e882c1ef4f1f41f06dc9e43aef093fe5e44a22688fbdeec8c26f74dce6214878a11b4e0ae31e848504f144f0335a377e65d63d13a745643e6095d51c0d434aac1f0e2f3189e7c434a579eae7c813e93d27dcead25d337d9dd55750745c4bceacb4e3a59d5c7efd4debf024aff5dc490c3873b03d34caca7272cbc161298a482bd71b64426dd6867e5b417be30907f785eda47a10d13d9c3d00d628d9fa764d20b9b30fe399c6b786a1e75b105f4190cd192cb8816abbb9ca00bddf843d488d9a662e70148dddaeb180e7d2e34386754eff46e63c45f73fe9b1b79a2975abc9e7444b989a9831d763790002203102b72a2a45415254cd4a81ec6394f53145e93e04789c830de8c0c61258c0aab8da2db7f7b976c05f76421e73cea06c0f3b49f5caf7d8948980336edf33ad650ded7603a1d6bb51ef3f238f066163c15fd8b070ff924cd98d03f6ef84ac67c9ed781403571b9aec2a378e1bae1e2a666d87921bb5fc2edfc366c22bcfa0f43b63c91b8d833688ffd87aaeeb4cf84531660c61ccbb60b16199971044641a2ef78dadc5fe203e0f3be228e69e911c23df5e30f060cf114aa1ca5d1e95657a69437aaf4e078ec3ae5f11ea611d4804cd8252ad95066c2ce88884fba75a82a7eab0df98e9ea4fff646c92086e72867b8b384f601ee045628ffa320b9042d8f8098d4df9a74813287f2a51a51fbb83f0c743dc50204249d051c541924ebd2ca92b25d65d3fd44f76ca66a5177ea1bc36b9f2299a9c58e4cc7b7a000de322d5cb7f510f6df49ac7a78a1383c24ab4caf03fd965d15c3a943c33b0cc29c500ec8d9d89b710aa60193a873eddf5b914d4a3513fd19ff2e1aa56ed07f3dce9393a0f0b606565da59e3d9f83723bf821cab1995df8b917036c971dbbfd56bf148570a674f68004254a358a29f1de89bb2c2578d4707c479f6ba296010ffcdbc54791a2fcf2dcfb93ee91fb7fb964229eefbbdab36f641d885548f35d46a55ede4e4424f70b92a0d4b4a3ba2a921df647be0168a5c2eaab053a639e2fdeb6ef0815187a70f40c0bb85295e70b075e2cc6c791bc0c23af9d825c431b491cc218187a9c844d8f7c1718bf538c0a3e071ffa68a9453a2f49995c82f5e767f79dd365c09b4515cf669041923d74e3cb012c091bf67196820a7a3b0c598fb67a0e29103949e10c0a6f20cecf5717facdb7f506029ccba806100d54463e29017543253949b645b531d00dd8f0026affe61bc9b6a762c3a77e6cae7846de85fd8780d81439ca0de54b2dfffd19422e38bff73ed9483ebce010d4ca93eb658aade3aaea60df9ec414a6ac21daabd4ef6070c0648aa3ec9d997c8e5beae02c9b0de9b6823ae685b6cb76584dedc8a82380d5797e7b5352e4099a373c5e820162052c0b59499c75d1d7febb02199787cdb76b0228dbeb3896526ac637efdf50d33873d5fdbb3734a289aa5b0f1bed4905e314d1ce16df915c13dfad8f6c9f8ead64ecc92a7a8f2c5a16353a66e592dca956ffc3e9c8e361dc06afc774f70e0d79a92e904bc7d5774b8695545d028526c900e10bc63489c5fa280d027631c80134acc0b46c956004da6d9376bd1befd524b1a468dcc4f3cd771203cc126185d8ec9a997c08099654d074548a223f7e153da7c5ff4929bbd476841dba985b1d0f6c7f5c00cdebc265145fdeedbe8dacde9bd63b1320a22363b5d722e0a798d95064c050535833bf2f6aebe659f9fb6e21ba70c669e057d45e1846ed8bbf59cb15d99d0098a41617ec575cbeb7d576fbbba23df9f023b6857e4acd16d28f75d1fbf00347f6dedb12704aadf800c8271462c36ab99c4b386b581c1ae86b75a6ba648c130e7750fa32b1189d8fcf87a35f93db521edd4b1e9e8299d3493a889e38f9b84004e7912773bc17e175f28cf2d2a8d1eb81da0643c1a6b5531342610d82d7f720a8fd3512371b724f8bdf9e48a08368cc28b72c4b93f9a4db46c4b47287696ecb26ec15f2110bdc61cffe136e70dc30764313cdca88e6458a4b5b2f991fb019cd6314c25aee3e48bf67649365c41742ed6e8d8f9c23e74643858afc6a53e934bfb1547676202fe51a0e572f5aa5c361f9bdd9ddb6cb0c500d5771da4026732e39050ad9731538d2870c57db5126a21842183bf6b65edd50398fca93b0aef44e66809f5d18bf01b5c74c3abdb69279a7da9cdee2a023432b2b6482a1898d8f8f14226d8036ea2a5143a151631a56a96b7b1b3ee7b7b2cfd87f9c1c1baa8db37201822dea917c4118fee0125595ecd3485c28d60f8e2760a42fefb153e4fc8e58f2f05caecaab398b2c84d64b294043bf3ba6c31f8cd05daf03c0f6cdc597f8bcd064263aee7c172684dc622d82b9cae402f661191b94a8e0007213e537dfed67b465b2f6b8e882f755c4eb8cd5866ec3f54fcd2bc355e57ac30706d47c0a82ecc0b499ba1e518f5b775a1736a36e27cf6739ec49f38f4c2c3a3b96be189a191c7972dc6d3630e0d9e6ddb5f87544fee0644f78cc38c8c7295e90e6af43f9fa5724829d994e5474fa7af608bf232a288c3317f3818764cf0e8257652907b6189e86bd3589562e1d56ccb2f87c708999426edc302081f1d962ecf328d7cb927badafbca392722ac2b0974016a2715d2ca33171ffe8c084db70596977b6b055fb2d796fd9fd8068778b654462fd657e9b8a9010a925a715485d769baf229973bda5abbcfbe5d8464643c3bacb66bd0910264ef7259c7370baa8f2de2a0430c305cd922a822f90ef4debb0f75ff08ab363d2d3b6376a9a69d8780bdc2a384f978da6faa639113b1e65c273f1f4429434dbdf175ab37b4a270eaba99100aee9c12aa573c92a71ca65a85e917542125c7a807770189dbe57bfe1f042fc8a3a7634c608ba853f81334678ae6ec6aedf2b1126fef61ff1f324113fab7104ad66ce108b418a2c6a411782bdab4eafbc8243d9c2896a20348b96453853ef96ff2b519493949b397b8955bc6337655c1252336080f614987a27a7b9fb3f8da9f1bf10a3c49a09196d4174c30e90f2f149731e06147ff716793aefa761e652ac643a1e8eb07fb35e2adf3f41ef5277ba5a4938dd0e3e37a41489b0648dd859ad0fa58158dc72cda611ecb1457213211f8cb4e2c2b2290f1ff01b997909ce5c8f072493e62da32c58e72bc208d292e516db600f22f83a5d2e5dada24b28bb4e4607d8f9cc22cd4b6a6c26a68dd734b0cc6c5313fe5e4ee1d56e55d0b7ef4fe6f8ec894e555629b050bce482f7d4d123e2224b14de62612021a97e15b9325fd454123d3326d4f0b6dc0b72029589d0b05f9ab0576f9a38570b5119ad9ad1b1cad14cc19f6734cf0f85cfac941046791e5621cdaa2ce06ce3eb14cbf175ba0dfef15db7544b6fcc0b1d3ace9105ab8eb2b8d6dab79da38631164f20e4c0baa80f9582f9c85bdafa78527bc83aef79f0880031269778f83be41ab0ab8e41e5e7dc2c2c62e674aabead4111ae7f054d2e18837daf6da5de344e3717537777ff397569be174b9b4446f6663f668bbededbbb64bc0a9f4e4ce9d55bffd1911f318b575cbc4d87da7fd0bfbfa4e5012abe3eab55e561a0ab0601a433c9778765ad1d253392726da3377679a511ca12a19e362d4624188372c8a2ced162551c7dee91c52c778369e699bca32982f881f11583a3e8ce97d57114c13083cf0fbb1a9cb39f22a478db73b954884509cf70b7291902e83085c54ec88e005b3dc084151da9dec8401293b84f533c042066b2e5953aff5366f5f8b3b8bd0cd803201b016d5b78d70101d107aa0e521fe198b4a6c9885fa88f8992bdf558a009b4a7f93613f5ad4b0725528debf2f9a96a9400375b8f84108ceeeb5f67dc61cdfd82b5b87eed8addf82f9918f4b94823323c054800d46e013c78ccac580edf54a28617cb2d13b86ce0c62ae6f003e273a0a0fcc135cea158c793cc3fdcd9ac93b25265f2ea028e4b1be684831ce62092488ebbbbd5db27334c8ec35409ace6883c0d6fe3ac3f02a2af261d78daaee3e2c17cb29211dcad1edaa67b248e703c171aefbe35dded9801a16fa7d66d1f9e5293ba3dbf853ae6c8996438173588b09638e8a8e44687cdd7a252d85476a3353cfb51101736f785e970297fcaae8aa8f44ecee1f50979d092149e0833ef3cc497426e2af7aeff800b8e2341d51c91f1a24f05d4045f968057ca5794653d69e5b5629e037c6c713559b7787702f4e65b8cc3bb4eb14069bf9a343dff05b0de919c4174d7f39e58382fd24a0db1501fc06213ec6b3b591ead7b3b25c513b37a7ad8cbb324f951cdcbb36e821cedbf25b5311b4a4c77409aaddbfd8529ec663883cbd97fb413dca59922e3e7ed23feff94c41ac0d9575510c6775891e3cb3f77a377a94cbe41938523fee4e67e4f398814149e58a3e3811c2794b20109e632a6878a2556cdbc69b07239d8792e7571e546427e5ea2b9298c0a19645341c76072b1cacc0d1db0ef64f30f4815919550c0ecfcba6a43f04812ecb423b9e26e689292aa6dab24e77ff1e60d3fcd565ae7a75b9ad87fc85b677f2cde9b312f3504dce1d417b571c10e99f259ff5c617f9f91f4d49abd374fe40e4f17395f565ce7257df44d4483cb27e4efe79404c7d29a4f491cd9a7c714637e4864ddeec5a62b6d6b82d67b278eaa1f5b67e72d25d0815fcd7cf3de75d137082daabf70af32bf59b1fec6ebb9ea9d736b5218091107bc3fe27879b4aa748cd7e2ba132fc6390bb72a6a90bcb77c662eb564e1253ec1cb3b955e8b14382f1eb853b1fc14e7beb2966365c18623ec8f85b24948f3bc62493716b4e09cc21282c1639e916e4d15ab791a320f8bbee063b3e01896cc75181f78c7b92c70bdcf5862a2ddfdb4b2091956f8f21b0b2a4d400b033f1744ed5027fe75a5c58a1b7574fa76e320d911f39ce7c918275f7c5e9f9c0a0d88df3f290ebea1b1edb54ee48fccc6aa6505dc8d15313a062b2dca2a329e28fd36b6704a99d8a5de1e2c52c614f0d06687e29b70704296c23cbfb24a622d960d42c188cac30a9ce34ae4ae38a2ea2b78f8f3577860f36e4bde1173aee2a9332405f7beced7bee5a08f987f8ab3157974cde8686e9ddea00139706de24dfda97562a1e67573191ee5fdff080b17db923eb843b1fec8f8cc38bf2577443e0b4768b7aa4afefb5593eec859c10cd0d88fc06ad4d817d1d312a74fba213d736ff83bf6929d591a492a69857cd5ac1a311b6132aba80fad8c43ea76e43a959457c244a529376aa33e502a0f9058265f446f670026ea0cbb03d3fac763f063e1276a2cae521a4db6c3d5693504e2d6f8c9104b5d4a8af809ed50e1a505e2fc56f7f7a2063f7e5c11866b215b48616e66ec4a09ae470654d97175b0b62c4064da9c39902c356986683a9289203425fdfa62d77a0aaf4602809aa71d0e73b0e25283d561610e02114b390f3e1f13cae60ed4e5c9f1c1989c5e60093b55b851effae83bf66a1309d1c46f31eb2b3d6d244dab80a97de8a2e5a7c044d11c8a7b19a0748386f9ebad8a11b63c50ec4572eee80a56dc7275c93b3c689a36cb571a731cef6c12f9e4fe3294718d248991c88ff8db36e5a6a913a25a0a87381884c23cabf1ac76b3e1f12d594c90c41b3e1ff5499ffdae8e53a061a281439bd4b69e5c27ce3227a23623de2feb2cc154d8267d7062a74c13e29f2b898c75a5e86bb5d3bc363f07ddb75563567fca1ee7effab6a95da9e75db6fb7b02ef31b454f4426a40f0096a410dc000e0da434fd32e4b45289dc13c6b0ecd16c78071071074bb8708feaa28646ed9e92c682b02f13f441fbe82e757603d8540ef4a9443103072e4719e8db6f7b3f68452e1db8608d9b2cbbe051fe48513fa2e3eb5f2f1b98319d66275bd1e7c4a60d0b4e13589666ae4927ed41be120c9a505a4ab854690e78cdecb677980ccf40c3c77189e5720c6e0a8bdf4932593e5a3c6ca774f582f80d02d91ed2d9ec4dc68c53fcb6c42ef73114e2f266845b6a880658f2b12c9c5ae1405feac04ae6dd83cf6371e6f87d8689a61e5fab513d8a5cc7a6b4814de2711549ce735605f89e900eaa82b76454636f840b6c79169f9e2f2796955368cc9afac847a5b439ce484f380a6464c84f11ede557132b361ceaf5fe926c22bbbcdb43bcd0fd9c48bbef449b8fdaf98388f08930bd78424c06d095878ddf5390e78e5eeaa782dea4f6291002ebf6258fd9713f8ca8496262dfd673830958628f07d4bc0f7e056d15a75af81109b9e508742400a5967c5e7b14952bd383d72c1346e6e9c5c89751f25db1c333e23e5604b91f84a24bda3d5fdb931f34fdadf16908db7330ac6c031448180806971d96f803f280e24c938e4d7a2d525748d8b6638b624359c64fc47579d63e9b5389c8e464b027ef4092888fd334c4492c96ba595c7672d56088b0bf0e53dce0211bbd837d1ba54f588f0481e731c21928848b7b347f50e715a7f3ff50887def7a553aebd32ff7d7f4a87721a8c7f7720e49991ca2d85a1c30ff69b3a2337b5e2e5bf453d47723f9d2cc664326ca2e22153e842f9fa2063f10f727bfa35edbed1193ac158ec35cab34350627944e091fa4acaca624ff52518c30b19c71df6845138e89d9f12dd57b4373b5941bbebbc75462ec2bda9e78210c792dd32b6204eabc8373d837ec667e4e5bd46d8098b8b1b303a25d0f82c35d51f27532937f48a46146bccd3ba3db2ee1ca7b37d67868495b86255d5d8efdbd1c710d663fe362dd7c9f047a242a264da365022bc6b8520fce39baab1861d14c3433d844eba269ec0ce5f50b94782b5ac6fb69805e0a7a34903baff9323cc3e202d5a23ce88add8dd5c364d921db71f768c9bdd3e94a532d031ac84e8f75bae24a981be6703609b9021c38310e2dc5096b96fb0c5ab970e53ba2c18ad98cf3e7e1cc27cc340ca8d6b3f8818f16ad8e2c4cd12ca7f5ff3cc217a14d9a3a3572d8770764cc0e08ff53967ec1f47d35e9cc343b469f82830dd6fa397158caa01a459d2b1564c4674bc5c47a9b9c01806c3f1c1514b76c3f1d6a19dd82e4a2a33b4950979a904bdb29c6adfa7016c7cda102b66fcd3c1e96056bb7796c0261c22b200fb7694414eebf8da5a2deb69a1e1e48d348bed150e2d46d01b0330df00a2c59e66d372a9e0d671c55eda39264f183fecb0280b180d443564ee55310f5c20b469a9ff18b56293464a15c6b3c6ee98f34bcacb310be46561b87d6742a94b68b049128fdaaf5aa57c2a2d403eadebf7d65e0d6cd5a52bb6be6ee8b8e264fdc2304d90ce2979ba38c2ad00c1fc31fdd8011edf57e84b7413059b24c5a26f84ebf36f2be6b66e9d7a930fe0ee30ddc89b51f196cb9d3bd62ba5e3b13cf9c434318a93ad2701f92d6b7b2628f40fafff0302491a0b78e767f26c794960ba8e37e55759d89c45490f8d2c60eff4ea1872cc28677cf48fcbdb9004f83ee43b261f0711a11e164a8379d53932d034928f5527cf84e7a4169818648ea0cb4aabfc867868108eb019bcfcd92a4588ae53a8d9e0913856c1fa21fbda6a50d3f871107834fbd096b2002b9b90c96dd3c153f93936a104550525b9c628e3b735814f5c4aa63486247bebcc42f3f54ed4df21a36288ff789cf05e106c0547a315e91219abfa760f2a238dc0436d87153656f90602d22cd70fd1ec2383275aecb39376eafcb41a501c35b571eda70ca4fca2e9d79f7f9513521c568dd94be265c1b1b89c2a9ff29bba75ebfc296c3c94ca5a4edc741682670c56941ea74d01f6e106c1acc609778e89d8ae71ccd5b447ecef4fcf8ed43e0254f8e4c61e762a97ea947b5c9369840ec88b775d06b9341ecf19917f06560afb3d620d0e26075fcce326a4bb74ca654da58106bf3ca03f64f8efc25c9f53da69f5c7f8ae781e02d58aa8e7acbee792e55d8f27772a1a4fa409f2c4cbf0af3d8e5ab6f3d4bc81e93df6ba3a1269764afc75cca49d938940514fb6995e6907f70d11469773511ecd8d6c2068514d95962d6aee044e0e57427156bebbb801b8885275dbc99af076a2dedc5a1c16e01ce57eac8c4f980ec3af3a19be198e9ce43cec085ddb976952a3067cbff42ad947451c2ad6981d1cf937a7e3cf6865257eeb58f97f1950690fe20f2ca44242641edfc5e1a24c6db3f77f4461880415567566d34421e1c5f1e094c0812596450ee3df74b3fbd0d47bfadbeab8eed11c5c8b1535463f88c0d268c82fe084c2055d6dce592bd92d4a8660c7b66a681e5629601bcddaf3aa660a79679601232c7c4d16b75a594fa19af24f1886a18d518be2cebc9c40f5d44be8fe2e7ad9dff95ff255ba7fd3f570ce97ec05af956dc497ff403873803d63b481efea65ed16ee358f00cf45369aa8f43c59039ea63db3af20c4c49b475474493f23920c161fbae6e604aeb44dd54cc957fcee18be82d0ba2141f0c3ccd6d2e6c135a41a6a5feb10485062ed4669cd80f3a8403e345da8f9727dd7e25768a67727c29adeb4a3b4be0782c03246e3177176e843ad86b59b380a9179e6d9c17a96372afc0001b966273ec8b69ab6ef83b646119b60161c6c215364fa7458f6b3b617eed45a83aed756e0f2d580ced0b3a24e686d3e9217de7736df4831d34f1b19a5ea6ccf974a78acfc0ae317efb57e6c20eee68a65ada09e86de089d79bf1ddb45a654cde72297dfe372173faed72fb07e7250c7d98fba9e1491ee22f7c3112ad405f715127b8874cfa6c37617e656b9edd761528477ee0f4bbfe46ed172244e561faf72ec3e2d09e7b4af4c0e180cf2050e0533ec5c655cec250a0abda5151bdd16eac590e9d0834f93e3a8b0bed2de92edff045f9a3fc0b11cbe8984cea23910e1e5002f92aa0a5213b11094e1c55deb2dffb316fd57762d426c5f018be35b7cc186c098c3e668a519309fa60f197232d79da229bf5e4f67338d5f1316a7e0410eaacdf697dc997567d4bea9198d01acd87893fbcc10ede0927f12f935b5cbd37182e15873e2b98dfbaba3efcf5f9c6d30a8f11a31c3c7e1fc8c6052baa24b04eef53a87f953ececed28042611b76c96573552fdfd29adf1d8f6d8cfdbc393534e19c294962f69ec48412e183380252f24f622091744a2a41475a0c718f6479f4a69ae455945abd83afe6110c640d82adb3dc782c8e5f2714c1dbd1252ac8e1a3c6bf2f7025dd47cb3c5dab9740a2bf84e167d78775015479f8dd0e6a7b30c0be7b65cb72f8d22f7aaa654d8a7e0e7aad95ef299592f4ae668e75f0ac2e28d0641441005fd9b8f393c52674531b713db2d5d3862fa9aca0b02fc9fc7f3cd61d4faa6c3b8426f53d0d165c01de84195e727422154a3e2f0230b0b3f25018b7a655be07e2135666a66dc1c220b4482f2da2e5e95aaf0720af689d1b74a9f5ab1f9e247503d7ae6aa1102ab48ba5d5f6fe9b93569a1fc49156a1f568144116e87ace6fdda44f74e7875212b33236d1edb52924e8063f58224fa4b37192e7d13e0bb5c12a9887c41eedba372992bc9d1d5459915f766ac07d3d597e079b18be42c378405af9ee3d45b547a5cf9cfeee45184c1678b4f4d2804d7c7d570c394938bfd34f1abc1c4c88abb37849de383a18f159088ab92ed38a85846833309e9e4dd4a9951da7e60a03384bc4962e86404a557cf094c2d206831ec3f2763abaf190ac449e09c054f27e444f83f7d5ba1992ec55520c8fbdd4e2b13f89ea3ce0fcf75490cb56b1ac990f44f91587fff5c7365c9de99d4bb004185a0ec26425692dd9162820b9206121a0f9775c827bfd61af033076a5cd02c2ef0dbd9e818679ff6d8875c2257549a8565e878fd9ba02fe970498cbce05bcad8f44d368f8dfd4e06d9062f4ca41228b46d985b754a02796c9e7142c0fecac0b131039c07db85f85a0014aa7b17455a02bc3a3a379db89e88830c960bd1733a7a7b50800e2d4df2fac7545948b604b93e6c5783ef7ae2503fbe732af05d6ce87b598eb6e28c29e095b516afb865a204b4382b366740d39838053a7532ec4a0ee281beacd4b409100333930c3d7ddb2fa14f86221f32743eb4fe039e3056bded5212dd2ab2f7db4068c71928e470081a702eda5148dd15ba14c68fcf0e6667978745481e317704bc797be702ac0c6f6d71b1759e5d99d518366c24c286f0a9c440b11f30e263b3da5b379a92b6e8e31787e21d780d1d42171ae93e3a7334fd9c3d2d8aad7cd3950ed06a3383b141c63e7684230e90ef86cd45409cb65416d3952d9786360531825b814e3ff10064e3d26a067a306fb9311a5c49d4d9cdd54b9e7d29c373a2da6eedf7154d15d6f868bd23adc36f4ee474e15a5badcfabc24ae3481b7ae74e016f10ed991720deca955d4460e74a28f007becb127986e79c03d75895ee08248f9f65f4e847b4c90d50e42e9fb71874ad1376896a636d732f27b824ca7952f4af79f74b3b4ff33fa69ed8933f0dd79fa70bd23dac94e87abc597864ef9339cf890fe4fe36f41de0c8fa915c23a243736544d8bcd498a571635895552034d7fb2b870e5f6cb30139300ee0099c509651bfb12b63f8b6ed6d32e73603fc60d116934a1849e7e1c189adab9bc9f4f840d5c8ce01f499187bb6c24dd4e588ddbe5035eb463c7bf1c408cec47e8ed026c395ec004368236466dbd8606b31eb67a268b4d5686756a15605a55256bf8e82745484cca39984e57b1c25ad46f600257ae2bfb3e1cf1f8647d3daaad7b5c1c90bfcb9674668a04548ff857b00bd1b30b083054256adce40c378c3c3d85f88bf8c9d1a2340938e53caf52cd3a263f304f66643405aae7f8fc9e65b4f5f374186a5d0e87749d53d799343310370d59fcc15a526ff48ae3350039bed9298b5f5254dd47c16fbfec9ab478d88e7eeae8113e5d16e8e8fb11ae71b18ea0798754556a6041013974419d8495aeb2deae55fac05856d2f1deff8951afc4fbc2107b72c6090b3bdaebeb76fe3b49fd53558b185e9ef6a9b786124a49bef134ae1679f6003075a35b2bef6ec67b797b2a2d1984b63c3a0210cd5705dcdc6c8cf045dc615f357880e668f3d45c08b1559d5bd5e226963f7bcb56fb98f5b29823d1166a4d2b08e91478d2bc5cea2f9c819a4a719ceddd7eae87d4050c8dddd1217a3184e57b609c2294edea5252c8bbaf87d435f429999ebe750fff1388c95fdc443e26afbf97568484c02a58892052a65b0fd4c15c9170272fabb7b2b0e9b9744fb38f13e8aa70a997e09797d32946b8205ec2fbbfc9921d52c3b120334c64f3b24725e79af5df7ccc77a256ac770853531dfb8f7a6188496e3e672306a30e659673b30cd1405eb1917a5c9</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">点击编辑可查看</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>集合数组</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>内存</tag>
        <tag>集合</tag>
        <tag>函数</tag>
        <tag>数组</tag>
        <tag>CPU</tag>
        <tag>变量</tag>
        <tag>锁</tag>
        <tag>索引</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>理解ThreadLocal</title>
    <url>/posts/3AX6RYY.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><div style="text-align: center;"></div><br><span id="more"></span></p>
<h4 id="ThreadLocal是什么"><a href="#ThreadLocal是什么" class="headerlink" title="ThreadLocal是什么"></a>ThreadLocal是什么</h4><p>官方解释：</p>
<p><img data-src="https://xuemingde.com/pages/image/others/1616815633283-c9b7df4f-4278-4d34-b855-337a20803e62.png" alt="image.png"></p>
<ul>
<li>ThreadLocal是一个关于创建线程局部变量的类，主要作用是存储线程的局部变量，做到数据隔离。保存在ThreadLocal中的数据只属于当前线程，对其他线程是不可见的。在多线程环境下，可以防止自己的变量被其他线程修改而导致数据不一致性。</li>
<li>ThreadLocal设计的目的就是为了能够使得当前线程拥有属于自己的变量，并不是为了解决并发或者共享变量的问题</li>
<li>底层使用ThreadLocalMap实现，每个线程都拥有自己的ThreadLocalMap，内部是继承了WeakReference的Entry数组，包含的Key为ThreadLocal，值为Object。 </li>
</ul>
<h4 id="原理浅析"><a href="#原理浅析" class="headerlink" title="原理浅析"></a>原理浅析</h4><p><img data-src="https://xuemingde.com/pages/image/others/1616815997129-aad7490b-f671-40d6-8879-bca2658e5aef.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1616826908408-53d45106-cf00-4626-9c81-4e8ad36b281b.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1616826928515-5ade4c61-6adf-4537-95dd-064749ec857b.png" alt="image.png"></p>
<h4 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h4><p><img data-src="https://xuemingde.com/pages/image/others/1616826982637-30659013-3102-4326-b0d8-070f401cedf3.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1616827030318-d21e91df-a93e-4776-95de-44ce3a9063db.png" alt="image.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">//获取 hash 值，用于数组中的下标</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果数组该位置有对象则进入</span></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//k 相等则覆盖旧值</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//此时说明此处 Entry 的 k 中的对象实例已经被回收了，需要替换掉这个位置的 key 和 value</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 Entry 对象</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取 Entry</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ThreadLocalMap的内存泄露问题"><a href="#ThreadLocalMap的内存泄露问题" class="headerlink" title="ThreadLocalMap的内存泄露问题"></a>ThreadLocalMap的内存泄露问题</h4><p>我们知道ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal没有外部强引用时，在GC的时候，这个ThreadLocal必然会被回收，但是对应的value不会被回收掉直到线程结束才会被回收。如果当前线程一直处于运行中，那么这些Entry对象中的value就可能一直无法回收，就会发生内存泄露。实际开发中，会使用线程池维护线程的创建和复用，线程为了复用是不会主动结束的，那么ThreadLocal设置的value值就一直被引用，就会发生内存泄露。</p>
<h4 id="如何避免内存泄露"><a href="#如何避免内存泄露" class="headerlink" title="如何避免内存泄露"></a>如何避免内存泄露</h4><ol>
<li>线程执行完毕调用remove方法</li>
<li>使用ThreadLocal，建议用static修饰 static ThreadLocal<HttpHeader> headerLocal = new ThreadLocal();</li>
<li><p>可以在使用ThreadLocal的类上实现AutoCloseable接口，把需要释放的资源（remove）写在close方法里面，把此类写在try后的()里</p>
<p>代码示例：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppContext</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;User&gt; USER = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AppContext</span><span class="params">(user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(user != <span class="keyword">null</span>)&#123;</span><br><span class="line">            USER.set(user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        USER.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">getUserId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> USER.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行完线程自动释放资源</span></span><br><span class="line"> <span class="keyword">try</span> (AppContext appContext = <span class="keyword">new</span> AppContext(user)) &#123;</span><br><span class="line">          filterChain.doFilter(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="AutoCloseable是什么"><a href="#AutoCloseable是什么" class="headerlink" title="AutoCloseable是什么"></a>AutoCloseable是什么</h4><p>此接口是在jdk1.7之后引入的，可实现自动关闭资源。</p>
<p>值得注意的是，在使用AutoCloseable的时候，必须配合try使用才能自动释放资源，因为利用try(AppContext appContext = AppContext(user)))才能自动调用close()方法。</p>
<blockquote>
<p>相关文章： <span class="exturl" data-url="aHR0cHM6Ly93d3cuanVzdGRvamF2YS5jb20vMjAxOS8wNS8xMi9qYXZhLXRocmVhZGxvY2FsLw==">文章1<i class="fa fa-external-link-alt"></i></span>  </p>
</blockquote>
]]></content>
      <categories>
        <category>集合数组</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>内存</tag>
        <tag>GC</tag>
        <tag>数组</tag>
        <tag>局部</tag>
        <tag>变量</tag>
        <tag>线程池</tag>
        <tag>并发</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>ConcurrentHashMap的理解</title>
    <url>/posts/12EB4HK.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><div style="text-align: center;"></div><br><span id="more"></span></p>
<h2 id="JDK-1-7"><a href="#JDK-1-7" class="headerlink" title="JDK 1.7"></a>JDK 1.7</h2><p>数据结构：是由 Segment 数组、HashEntry 组成，和 HashMap 一样，仍然是数组加链表。</p>
<blockquote>
<p>Segment 是 ConcurrentHashMap 的一个内部类。</p>
</blockquote>
<p>  如何保证线程安全：Segment的分段锁。   </p>
<h2 id="JDK-1-8"><a href="#JDK-1-8" class="headerlink" title="JDK 1.8"></a>JDK 1.8</h2><p>数据结构：整体结构与HashMap别无二致，都是使用哈希表+红黑树结构<br>如何保证线程安全：采用了 CAS + synchronized  </p>
<hr>
<p> 可参考文章</p>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxNzM3NzE2L2FydGljbGUvZGV0YWlscy85MDU0OTg0Nw==">https://blog.csdn.net/qq_41737716/article/details/90549847<i class="fa fa-external-link-alt"></i></span><br><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMTYxNDMwOA==">https://zhuanlan.zhihu.com/p/31614308<i class="fa fa-external-link-alt"></i></span> （JDK1.7）</p>
</blockquote>
]]></content>
      <categories>
        <category>集合数组</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>数组</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8 Stream玩转集合的筛选、归约、分组、聚合</title>
    <url>/posts/1HVJ8ZX.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><div style="text-align: center;"></div><br><span id="more"></span></p>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b175706d834a4a6b8162c330d9fafbae~tplv-k3u1fbpfcp-zoom-in-crop-mark:1956:0:0:0.image" alt="MarkerHub">Java8 Stream</p>
<p>先贴上几个案例，水平高超的同学可以挑战一下：</p>
<ol>
<li>从员工集合中筛选出salary大于8000的员工，并放置到新的集合里。</li>
<li>统计员工的最高薪资、平均薪资、薪资之和。</li>
<li>将员工按薪资从高到低排序，同样薪资者年龄小者在前。</li>
<li>将员工按性别分类，将员工按性别和地区分类，将员工按薪资是否高于8000分为两部分。</li>
</ol>
<p>用传统的迭代处理也不是很难，但代码就显得冗余了，跟Stream相比高下立判。</p>
<h1 id="Stream概述"><a href="#Stream概述" class="headerlink" title="Stream概述"></a>Stream概述</h1><p>Java 8 是一个非常成功的版本，这个版本新增的<code>Stream</code>，配合同版本出现的 <code>Lambda</code> ，给我们操作集合（Collection）提供了极大的便利。</p>
<p>那么什么是<code>Stream</code>？</p>
<blockquote>
<p>❝</p>
<p><code>Stream</code>将要处理的元素集合看作一种流，在流的过程中，借助<code>Stream API</code>对流中的元素进行操作，比如：筛选、排序、聚合等。</p>
<p>❞</p>
</blockquote>
<p><code>Stream</code>可以由数组或集合创建，对流的操作分为两种：</p>
<ol>
<li>中间操作，每次返回一个新的流，可以有多个。</li>
<li>终端操作，每个流只能进行一次终端操作，终端操作结束后流无法再次使用。终端操作会产生一个新的集合或值。</li>
</ol>
<p>另外，<code>Stream</code>有几个特性：</p>
<ol>
<li>stream不存储数据，而是按照特定的规则对数据进行计算，一般会输出结果。</li>
<li>stream不会改变数据源，通常情况下会产生一个新的集合或一个值。</li>
<li>stream具有延迟执行特性，只有调用终端操作时，中间操作才会执行。</li>
</ol>
<h1 id="Stream的创建"><a href="#Stream的创建" class="headerlink" title="Stream的创建"></a>Stream的创建</h1><p><code>Stream</code>可以通过集合数组创建。</p>
<p>1、通过 <code>java.util.Collection.stream()</code> 方法用集合创建流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line"><span class="comment">// 创建一个顺序流</span></span><br><span class="line">Stream&lt;String&gt; stream = list.stream();</span><br><span class="line"><span class="comment">// 创建一个并行流</span></span><br><span class="line">Stream&lt;String&gt; parallelStream = list.parallelStream();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2、使用<code>java.util.Arrays.stream(T[] array)</code>方法用数组创建流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] array=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line">IntStream stream = Arrays.stream(array);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>3、使用<code>Stream</code>的静态方法：<code>of()、iterate()、generate()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">Stream&lt;Integer&gt; stream2 = Stream.iterate(<span class="number">0</span>, (x) -&gt; x + <span class="number">3</span>).limit(<span class="number">4</span>);</span><br><span class="line">stream2.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">Stream&lt;Double&gt; stream3 = Stream.generate(Math::random).limit(<span class="number">3</span>);</span><br><span class="line">stream3.forEach(System.out::println);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>❝</p>
<p>0 3 6 9<br>0.6796156909271994<br>0.1914314208854283<br>0.8116932592396652</p>
<p>❞</p>
</blockquote>
<p><strong>「<code>stream</code>和<code>parallelStream</code>的简单区分：」</strong> <code>stream</code>是顺序流，由主线程按顺序对流执行操作，而<code>parallelStream</code>是并行流，内部以多线程并行执行的方式对流进行操作，但前提是流中的数据处理没有顺序要求。例如筛选集合中的奇数，两者的处理不同之处：</p>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b95747bffc745699900d4b3c3c39a0a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1956:0:0:0.image" alt="MarkerHub">并行流Stream与顺序流Stream</p>
<p>如果流中的数据量足够大，并行流可以加快处速度。</p>
<p>除了直接创建并行流，还可以通过<code>parallel()</code>把顺序流转换成并行流：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;Integer&gt; findFirst = list.stream().parallel().filter(x-&gt;x&gt;<span class="number">6</span>).findFirst();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="Stream的使用"><a href="#Stream的使用" class="headerlink" title="Stream的使用"></a>Stream的使用</h1><p>在使用stream之前，先理解一个概念：<code>Optional</code> 。</p>
<blockquote>
<p>❝</p>
<p><code>Optional</code>类是一个可以为<code>null</code>的容器对象。如果值存在则<code>isPresent()</code>方法会返回<code>true</code>，调用<code>get()</code>方法会返回该对象。</p>
<p>❞</p>
</blockquote>
<p><strong>「接下来，大批代码向你袭来！我将用20个案例将Stream的使用整得明明白白，只要跟着敲一遍代码，就能很好地掌握。」</strong></p>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f92cfa931754ffc8ae7276487b7b2ab~tplv-k3u1fbpfcp-zoom-in-crop-mark:1956:0:0:0.image" alt="MarkerHub">代码有毒</p>
<p>案例使用的员工类</p>
<hr>
<p>这是后面案例中使用的员工类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line">personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>, <span class="number">8900</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jack&quot;</span>, <span class="number">7000</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line">personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Lily&quot;</span>, <span class="number">7800</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line">personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Anni&quot;</span>, <span class="number">8200</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Owen&quot;</span>, <span class="number">9500</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Alisa&quot;</span>, <span class="number">7900</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> String name;  <span class="comment">// 姓名</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> salary; <span class="comment">// 薪资</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> age; <span class="comment">// 年龄</span></span><br><span class="line"> <span class="keyword">private</span> String sex; <span class="comment">//性别</span></span><br><span class="line"> <span class="keyword">private</span> String area;  <span class="comment">// 地区</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 构造方法</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> salary, <span class="keyword">int</span> age,String sex,String area)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.salary = salary;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.sex = sex;</span><br><span class="line">  <span class="keyword">this</span>.area = area;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 省略了get和set，请自行添加</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="遍历-匹配（foreach-find-match）"><a href="#遍历-匹配（foreach-find-match）" class="headerlink" title="遍历/匹配（foreach/find/match）"></a>遍历/匹配（foreach/find/match）</h2><p><code>Stream</code>也是支持类似集合的遍历和匹配元素的，只是<code>Stream</code>中的元素是以<code>Optional</code>类型存在的。<code>Stream</code>的遍历、匹配非常简单。</p>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/716247acfd3047abb3d7a53b6b9ff84e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1956:0:0:0.image" alt="MarkerHub">Stream遍历/匹配</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// import已省略，请自行添加，后面代码亦是</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历输出符合条件的元素</span></span><br><span class="line">        list.stream().filter(x -&gt; x &gt; <span class="number">6</span>).forEach(System.out::println);</span><br><span class="line">        <span class="comment">// 匹配第一个</span></span><br><span class="line">        Optional&lt;Integer&gt; findFirst = list.stream().filter(x -&gt; x &gt; <span class="number">6</span>).findFirst();</span><br><span class="line">        <span class="comment">// 匹配任意（适用于并行流）</span></span><br><span class="line">        Optional&lt;Integer&gt; findAny = list.parallelStream().filter(x -&gt; x &gt; <span class="number">6</span>).findAny();</span><br><span class="line">        <span class="comment">// 是否包含符合特定条件的元素</span></span><br><span class="line">        <span class="keyword">boolean</span> anyMatch = list.stream().anyMatch(x -&gt; x &gt; <span class="number">6</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;匹配第一个值：&quot;</span> + findFirst.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;匹配任意一个值：&quot;</span> + findAny.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;是否存在大于6的值：&quot;</span> + anyMatch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="筛选（filter）"><a href="#筛选（filter）" class="headerlink" title="筛选（filter）"></a>筛选（filter）</h2><p>筛选，是按照一定的规则校验流中的元素，将符合条件的元素提取到新的流中的操作。</p>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f626caea6354b63981b10933036f6f7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1956:0:0:0.image" alt="MarkerHub">Stream筛选filter</p>
<p><strong>「案例一：筛选出<code>Integer</code>集合中大于7的元素，并打印出来」</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  List&lt;Integer&gt; list = Arrays.asList(<span class="number">6</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">9</span>);</span><br><span class="line">  Stream&lt;Integer&gt; stream = list.stream();</span><br><span class="line">  stream.filter(x -&gt; x &gt; <span class="number">7</span>).forEach(System.out::println);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>预期结果：</p>
<blockquote>
<p>❝</p>
<p>8 9</p>
<p>❞</p>
</blockquote>
<p><strong>「案例二：筛选员工中工资高于8000的人，并形成新的集合。」</strong> 形成新集合依赖<code>collect</code>（收集），后文有详细介绍。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  List&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>, <span class="number">8900</span>, <span class="number">23</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jack&quot;</span>, <span class="number">7000</span>, <span class="number">25</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Lily&quot;</span>, <span class="number">7800</span>, <span class="number">21</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Anni&quot;</span>, <span class="number">8200</span>, <span class="number">24</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Owen&quot;</span>, <span class="number">9500</span>, <span class="number">25</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Alisa&quot;</span>, <span class="number">7900</span>, <span class="number">26</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line"></span><br><span class="line">  List&lt;String&gt; fiterList = personList.stream().filter(x -&gt; x.getSalary() &gt; <span class="number">8000</span>).map(Person::getName)</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line">  System.out.print(<span class="string">&quot;高于8000的员工姓名：&quot;</span> + fiterList);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<blockquote>
<p>❝</p>
<p>高于8000的员工姓名：[Tom, Anni, Owen]</p>
<p>❞</p>
</blockquote>
<h2 id="聚合（max-min-count"><a href="#聚合（max-min-count" class="headerlink" title="聚合（max/min/count)"></a>聚合（max/min/count)</h2><p><code>max</code>、<code>min</code>、<code>count</code>这些字眼你一定不陌生，没错，在mysql中我们常用它们进行数据统计。Java stream中也引入了这些概念和用法，极大地方便了我们对集合、数组的数据统计工作。</p>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/81bd7bbffa4a47d489e6efd4e79f3db2~tplv-k3u1fbpfcp-zoom-in-crop-mark:1956:0:0:0.image" alt="MarkerHub">Stream聚合max/min/count</p>
<p><strong>「案例一：获取<code>String</code>集合中最长的元素。」</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;adnm&quot;</span>, <span class="string">&quot;admmt&quot;</span>, <span class="string">&quot;pot&quot;</span>, <span class="string">&quot;xbangd&quot;</span>, <span class="string">&quot;weoujgsd&quot;</span>);</span><br><span class="line"></span><br><span class="line">  Optional&lt;String&gt; max = list.stream().max(Comparator.comparing(String::length));</span><br><span class="line">  System.out.println(<span class="string">&quot;最长的字符串：&quot;</span> + max.get());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>❝</p>
<p>最长的字符串：weoujgsd</p>
<p>❞</p>
</blockquote>
<p><strong>「案例二：获取<code>Integer</code>集合中的最大值。」</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  List&lt;Integer&gt; list = Arrays.asList(<span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 自然排序</span></span><br><span class="line">  Optional&lt;Integer&gt; max = list.stream().max(Integer::compareTo);</span><br><span class="line">  <span class="comment">// 自定义排序</span></span><br><span class="line">  Optional&lt;Integer&gt; max2 = list.stream().max(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  System.out.println(<span class="string">&quot;自然排序的最大值：&quot;</span> + max.get());</span><br><span class="line">  System.out.println(<span class="string">&quot;自定义排序的最大值：&quot;</span> + max2.get());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>❝</p>
<p>自然排序的最大值：11<br>自定义排序的最大值：11</p>
<p>❞</p>
</blockquote>
<p><strong>「案例三：获取员工工资最高的人。」</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  List&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>, <span class="number">8900</span>, <span class="number">23</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jack&quot;</span>, <span class="number">7000</span>, <span class="number">25</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Lily&quot;</span>, <span class="number">7800</span>, <span class="number">21</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Anni&quot;</span>, <span class="number">8200</span>, <span class="number">24</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Owen&quot;</span>, <span class="number">9500</span>, <span class="number">25</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Alisa&quot;</span>, <span class="number">7900</span>, <span class="number">26</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line"></span><br><span class="line">  Optional&lt;Person&gt; max = personList.stream().max(Comparator.comparingInt(Person::getSalary));</span><br><span class="line">  System.out.println(<span class="string">&quot;员工工资最大值：&quot;</span> + max.get().getSalary());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>❝</p>
<p>员工工资最大值：9500</p>
<p>❞</p>
</blockquote>
<p><strong>「案例四：计算<code>Integer</code>集合中大于6的元素的个数。」</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  List&lt;Integer&gt; list = Arrays.asList(<span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">11</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> count = list.stream().filter(x -&gt; x &gt; <span class="number">6</span>).count();</span><br><span class="line">  System.out.println(<span class="string">&quot;list中大于6的元素个数：&quot;</span> + count);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>❝</p>
<p>list中大于6的元素个数：4</p>
<p>❞</p>
</blockquote>
<h2 id="映射-map-flatMap"><a href="#映射-map-flatMap" class="headerlink" title="映射(map/flatMap)"></a>映射(map/flatMap)</h2><p>映射，可以将一个流的元素按照一定的映射规则映射到另一个流中。分为<code>map</code>和<code>flatMap</code>：</p>
<ul>
<li><code>map</code>：接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</li>
<li><code>flatMap</code>：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。</li>
</ul>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9ed32f31a11d43ee969cf66e7dc3b43e~tplv-k3u1fbpfcp-zoom-in-crop-mark:1956:0:0:0.image" alt="MarkerHub">Stream 映射map/flatMap<img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e231c508a1714fbab7b19999400826a7~tplv-k3u1fbpfcp-zoom-in-crop-mark:1956:0:0:0.image" alt="MarkerHub">Stream 映射map/flatMap</p>
<p><strong>「案例一：英文字符串数组的元素全部改为大写。整数数组每个元素+3。」</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  String[] strArr = &#123; <span class="string">&quot;abcd&quot;</span>, <span class="string">&quot;bcdd&quot;</span>, <span class="string">&quot;defde&quot;</span>, <span class="string">&quot;fTr&quot;</span> &#125;;</span><br><span class="line">  List&lt;String&gt; strList = Arrays.stream(strArr).map(String::toUpperCase).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">  List&lt;Integer&gt; intList = Arrays.asList(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">11</span>);</span><br><span class="line">  List&lt;Integer&gt; intListNew = intList.stream().map(x -&gt; x + <span class="number">3</span>).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">&quot;每个元素大写：&quot;</span> + strList);</span><br><span class="line">  System.out.println(<span class="string">&quot;每个元素+3：&quot;</span> + intListNew);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>❝</p>
<p>每个元素大写：[ABCD, BCDD, DEFDE, FTR]<br>每个元素+3：[4, 6, 8, 10, 12, 14]</p>
<p>❞</p>
</blockquote>
<p><strong>「案例二：将员工的薪资全部增加1000。」</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  List&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>, <span class="number">8900</span>, <span class="number">23</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jack&quot;</span>, <span class="number">7000</span>, <span class="number">25</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Lily&quot;</span>, <span class="number">7800</span>, <span class="number">21</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Anni&quot;</span>, <span class="number">8200</span>, <span class="number">24</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Owen&quot;</span>, <span class="number">9500</span>, <span class="number">25</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Alisa&quot;</span>, <span class="number">7900</span>, <span class="number">26</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不改变原来员工集合的方式</span></span><br><span class="line">  List&lt;Person&gt; personListNew = personList.stream().map(person -&gt; &#123;</span><br><span class="line">   Person personNew = <span class="keyword">new</span> Person(person.getName(), <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">   personNew.setSalary(person.getSalary() + <span class="number">10000</span>);</span><br><span class="line">   <span class="keyword">return</span> personNew;</span><br><span class="line">  &#125;).collect(Collectors.toList());</span><br><span class="line">  System.out.println(<span class="string">&quot;一次改动前：&quot;</span> + personList.get(<span class="number">0</span>).getName() + <span class="string">&quot;--&gt;&quot;</span> + personList.get(<span class="number">0</span>).getSalary());</span><br><span class="line">  System.out.println(<span class="string">&quot;一次改动后：&quot;</span> + personListNew.get(<span class="number">0</span>).getName() + <span class="string">&quot;--&gt;&quot;</span> + personListNew.get(<span class="number">0</span>).getSalary());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 改变原来员工集合的方式</span></span><br><span class="line">  List&lt;Person&gt; personListNew2 = personList.stream().map(person -&gt; &#123;</span><br><span class="line">   person.setSalary(person.getSalary() + <span class="number">10000</span>);</span><br><span class="line">   <span class="keyword">return</span> person;</span><br><span class="line">  &#125;).collect(Collectors.toList());</span><br><span class="line">  System.out.println(<span class="string">&quot;二次改动前：&quot;</span> + personList.get(<span class="number">0</span>).getName() + <span class="string">&quot;--&gt;&quot;</span> + personListNew.get(<span class="number">0</span>).getSalary());</span><br><span class="line">  System.out.println(<span class="string">&quot;二次改动后：&quot;</span> + personListNew2.get(<span class="number">0</span>).getName() + <span class="string">&quot;--&gt;&quot;</span> + personListNew.get(<span class="number">0</span>).getSalary());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>❝</p>
<p>一次改动前：Tom–&gt;8900<br>一次改动后：Tom–&gt;18900<br>二次改动前：Tom–&gt;18900<br>二次改动后：Tom–&gt;18900</p>
<p>❞</p>
</blockquote>
<p><strong>「案例三：将两个字符数组合并成一个新的字符数组。」</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;m,k,l,a&quot;</span>, <span class="string">&quot;1,3,5,7&quot;</span>);</span><br><span class="line">  List&lt;String&gt; listNew = list.stream().flatMap(s -&gt; &#123;</span><br><span class="line">   <span class="comment">// 将每个元素转换成一个stream</span></span><br><span class="line">   String[] split = s.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">   Stream&lt;String&gt; s2 = Arrays.stream(split);</span><br><span class="line">   <span class="keyword">return</span> s2;</span><br><span class="line">  &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">&quot;处理前的集合：&quot;</span> + list);</span><br><span class="line">  System.out.println(<span class="string">&quot;处理后的集合：&quot;</span> + listNew);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>❝</p>
<p>处理前的集合：[m-k-l-a, 1-3-5]<br>处理后的集合：[m, k, l, a, 1, 3, 5]</p>
<p>❞</p>
</blockquote>
<h2 id="归约-reduce"><a href="#归约-reduce" class="headerlink" title="归约(reduce)"></a>归约(reduce)</h2><p>归约，也称缩减，顾名思义，是把一个流缩减成一个值，能实现对集合求和、求乘积和求最值操作。</p>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30256107970e45319eebe681edd73184~tplv-k3u1fbpfcp-zoom-in-crop-mark:1956:0:0:0.image" alt="MarkerHub">Stream归约reduce</p>
<p><strong>「案例一：求<code>Integer</code>集合的元素之和、乘积和最大值。」</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">4</span>);</span><br><span class="line">  <span class="comment">// 求和方式1</span></span><br><span class="line">  Optional&lt;Integer&gt; sum = list.stream().reduce((x, y) -&gt; x + y);</span><br><span class="line">  <span class="comment">// 求和方式2</span></span><br><span class="line">  Optional&lt;Integer&gt; sum2 = list.stream().reduce(Integer::sum);</span><br><span class="line">  <span class="comment">// 求和方式3</span></span><br><span class="line">  Integer sum3 = list.stream().reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 求乘积</span></span><br><span class="line">  Optional&lt;Integer&gt; product = list.stream().reduce((x, y) -&gt; x * y);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 求最大值方式1</span></span><br><span class="line">  Optional&lt;Integer&gt; max = list.stream().reduce((x, y) -&gt; x &gt; y ? x : y);</span><br><span class="line">  <span class="comment">// 求最大值写法2</span></span><br><span class="line">  Integer max2 = list.stream().reduce(<span class="number">1</span>, Integer::max);</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">&quot;list求和：&quot;</span> + sum.get() + <span class="string">&quot;,&quot;</span> + sum2.get() + <span class="string">&quot;,&quot;</span> + sum3);</span><br><span class="line">  System.out.println(<span class="string">&quot;list求积：&quot;</span> + product.get());</span><br><span class="line">  System.out.println(<span class="string">&quot;list求和：&quot;</span> + max.get() + <span class="string">&quot;,&quot;</span> + max2);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>❝</p>
<p>list求和：29,29,29<br>list求积：2112<br>list求和：11,11</p>
<p>❞</p>
</blockquote>
<p><strong>「案例二：求所有员工的工资之和和最高工资。」</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  List&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>, <span class="number">8900</span>, <span class="number">23</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jack&quot;</span>, <span class="number">7000</span>, <span class="number">25</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Lily&quot;</span>, <span class="number">7800</span>, <span class="number">21</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Anni&quot;</span>, <span class="number">8200</span>, <span class="number">24</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Owen&quot;</span>, <span class="number">9500</span>, <span class="number">25</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Alisa&quot;</span>, <span class="number">7900</span>, <span class="number">26</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 求工资之和方式1：</span></span><br><span class="line">  Optional&lt;Integer&gt; sumSalary = personList.stream().map(Person::getSalary).reduce(Integer::sum);</span><br><span class="line">  <span class="comment">// 求工资之和方式2：</span></span><br><span class="line">  Integer sumSalary2 = personList.stream().reduce(<span class="number">0</span>, (sum, p) -&gt; sum += p.getSalary(),</span><br><span class="line">    (sum1, sum2) -&gt; sum1 + sum2);</span><br><span class="line">  <span class="comment">// 求工资之和方式3：</span></span><br><span class="line">  Integer sumSalary3 = personList.stream().reduce(<span class="number">0</span>, (sum, p) -&gt; sum += p.getSalary(), Integer::sum);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 求最高工资方式1：</span></span><br><span class="line">  Integer maxSalary = personList.stream().reduce(<span class="number">0</span>, (max, p) -&gt; max &gt; p.getSalary() ? max : p.getSalary(),</span><br><span class="line">    Integer::max);</span><br><span class="line">  <span class="comment">// 求最高工资方式2：</span></span><br><span class="line">  Integer maxSalary2 = personList.stream().reduce(<span class="number">0</span>, (max, p) -&gt; max &gt; p.getSalary() ? max : p.getSalary(),</span><br><span class="line">    (max1, max2) -&gt; max1 &gt; max2 ? max1 : max2);</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">&quot;工资之和：&quot;</span> + sumSalary.get() + <span class="string">&quot;,&quot;</span> + sumSalary2 + <span class="string">&quot;,&quot;</span> + sumSalary3);</span><br><span class="line">  System.out.println(<span class="string">&quot;最高工资：&quot;</span> + maxSalary + <span class="string">&quot;,&quot;</span> + maxSalary2);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<blockquote>
<p>❝</p>
<p>工资之和：49300,49300,49300<br>最高工资：9500,9500</p>
<p>❞</p>
</blockquote>
<h2 id="收集-collect"><a href="#收集-collect" class="headerlink" title="收集(collect)"></a>收集(collect)</h2><p><code>collect</code>，收集，可以说是内容最繁多、功能最丰富的部分了。从字面上去理解，就是把一个流收集起来，最终可以是收集成一个值也可以收集成一个新的集合。</p>
<blockquote>
<p>❝</p>
<p><code>collect</code>主要依赖<code>java.util.stream.Collectors</code>类内置的静态方法。</p>
<p>❞</p>
</blockquote>
<h3 id="归集-toList-toSet-toMap"><a href="#归集-toList-toSet-toMap" class="headerlink" title="归集(toList/toSet/toMap)"></a>归集(toList/toSet/toMap)</h3><p>因为流不存储数据，那么在流中的数据完成处理后，需要将流中的数据重新归集到新的集合里。<code>toList</code>、<code>toSet</code>和<code>toMap</code>比较常用，另外还有<code>toCollection</code>、<code>toConcurrentMap</code>等复杂一些的用法。</p>
<p>下面用一个案例演示<code>toList</code>、<code>toSet</code>和<code>toMap</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">6</span>, <span class="number">20</span>);</span><br><span class="line">  List&lt;Integer&gt; listNew = list.stream().filter(x -&gt; x % <span class="number">2</span> == <span class="number">0</span>).collect(Collectors.toList());</span><br><span class="line">  Set&lt;Integer&gt; set = list.stream().filter(x -&gt; x % <span class="number">2</span> == <span class="number">0</span>).collect(Collectors.toSet());</span><br><span class="line"></span><br><span class="line">  List&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>, <span class="number">8900</span>, <span class="number">23</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jack&quot;</span>, <span class="number">7000</span>, <span class="number">25</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Lily&quot;</span>, <span class="number">7800</span>, <span class="number">21</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Anni&quot;</span>, <span class="number">8200</span>, <span class="number">24</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">  </span><br><span class="line">  Map&lt;?, Person&gt; map = personList.stream().filter(p -&gt; p.getSalary() &gt; <span class="number">8000</span>)</span><br><span class="line">    .collect(Collectors.toMap(Person::getName, p -&gt; p));</span><br><span class="line">  System.out.println(<span class="string">&quot;toList:&quot;</span> + listNew);</span><br><span class="line">  System.out.println(<span class="string">&quot;toSet:&quot;</span> + set);</span><br><span class="line">  System.out.println(<span class="string">&quot;toMap:&quot;</span> + map);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<blockquote>
<p>❝</p>
<p>toList：[6, 4, 6, 6, 20]<br>toSet：[4, 20, 6]<br>toMap：{Tom=mutest.Person@5fd0d5ae, Anni=mutest.Person@2d98a335}</p>
<p>❞</p>
</blockquote>
<h3 id="统计-count-averaging"><a href="#统计-count-averaging" class="headerlink" title="统计(count/averaging)"></a>统计(count/averaging)</h3><p><code>Collectors</code>提供了一系列用于数据统计的静态方法：</p>
<ul>
<li>计数： <code>count</code></li>
<li>平均值： <code>averagingInt</code>、 <code>averagingLong</code>、 <code>averagingDouble</code></li>
<li>最值： <code>maxBy</code>、 <code>minBy</code></li>
<li>求和： <code>summingInt</code>、 <code>summingLong</code>、 <code>summingDouble</code></li>
<li>统计以上所有： <code>summarizingInt</code>、 <code>summarizingLong</code>、 <code>summarizingDouble</code></li>
</ul>
<p><strong>「案例：统计员工人数、平均工资、工资总额、最高工资。」</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  List&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>, <span class="number">8900</span>, <span class="number">23</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jack&quot;</span>, <span class="number">7000</span>, <span class="number">25</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Lily&quot;</span>, <span class="number">7800</span>, <span class="number">21</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 求总数</span></span><br><span class="line">  Long count = personList.stream().collect(Collectors.counting());</span><br><span class="line">  <span class="comment">// 求平均工资</span></span><br><span class="line">  Double average = personList.stream().collect(Collectors.averagingDouble(Person::getSalary));</span><br><span class="line">  <span class="comment">// 求最高工资</span></span><br><span class="line">  Optional&lt;Integer&gt; max = personList.stream().map(Person::getSalary).collect(Collectors.maxBy(Integer::compare));</span><br><span class="line">  <span class="comment">// 求工资之和</span></span><br><span class="line">  Integer sum = personList.stream().collect(Collectors.summingInt(Person::getSalary));</span><br><span class="line">  <span class="comment">// 一次性统计所有信息</span></span><br><span class="line">  DoubleSummaryStatistics collect = personList.stream().collect(Collectors.summarizingDouble(Person::getSalary));</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">&quot;员工总数：&quot;</span> + count);</span><br><span class="line">  System.out.println(<span class="string">&quot;员工平均工资：&quot;</span> + average);</span><br><span class="line">  System.out.println(<span class="string">&quot;员工工资总和：&quot;</span> + sum);</span><br><span class="line">  System.out.println(<span class="string">&quot;员工工资所有统计：&quot;</span> + collect);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<blockquote>
<p>❝</p>
<p>员工总数：3<br>员工平均工资：7900.0<br>员工工资总和：23700<br>员工工资所有统计：DoubleSummaryStatistics{count=3, sum=23700.000000,min=7000.000000, average=7900.000000, max=8900.000000}</p>
<p>❞</p>
</blockquote>
<h3 id="分组-partitioningBy-groupingBy"><a href="#分组-partitioningBy-groupingBy" class="headerlink" title="分组(partitioningBy/groupingBy)"></a>分组(partitioningBy/groupingBy)</h3><ul>
<li>分区：将 <code>stream</code>按条件分为两个 <code>Map</code>，比如员工按薪资是否高于8000分为两部分。</li>
<li>分组：将集合分为多个Map，比如员工按性别分组。有单级分组和多级分组。</li>
</ul>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b701a8a5de0e45abbd8a135ca074eff3~tplv-k3u1fbpfcp-zoom-in-crop-mark:1956:0:0:0.image" alt="MarkerHub">Stream分组partitioningBy/groupingBy</p>
<p><strong>「案例：将员工按薪资是否高于8000分为两部分；将员工按性别和地区分组」</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  List&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>, <span class="number">8900</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jack&quot;</span>, <span class="number">7000</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Lily&quot;</span>, <span class="number">7800</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Anni&quot;</span>, <span class="number">8200</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Owen&quot;</span>, <span class="number">9500</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Alisa&quot;</span>, <span class="number">7900</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将员工按薪资是否高于8000分组</span></span><br><span class="line">        Map&lt;Boolean, List&lt;Person&gt;&gt; part = personList.stream().collect(Collectors.partitioningBy(x -&gt; x.getSalary() &gt; <span class="number">8000</span>));</span><br><span class="line">        <span class="comment">// 将员工按性别分组</span></span><br><span class="line">        Map&lt;String, List&lt;Person&gt;&gt; group = personList.stream().collect(Collectors.groupingBy(Person::getSex));</span><br><span class="line">        <span class="comment">// 将员工先按性别分组，再按地区分组</span></span><br><span class="line">        Map&lt;String, Map&lt;String, List&lt;Person&gt;&gt;&gt; group2 = personList.stream().collect(Collectors.groupingBy(Person::getSex, Collectors.groupingBy(Person::getArea)));</span><br><span class="line">        System.out.println(<span class="string">&quot;员工按薪资是否大于8000分组情况：&quot;</span> + part);</span><br><span class="line">        System.out.println(<span class="string">&quot;员工按性别分组情况：&quot;</span> + group);</span><br><span class="line">        System.out.println(<span class="string">&quot;员工按性别、地区：&quot;</span> + group2);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">员工按薪资是否大于<span class="number">8000</span>分组情况：&#123;<span class="keyword">false</span><span class="operator">=</span>[mutest.Person<span class="title">@2</span>d<span class="number">98</span>a<span class="number">335</span><span class="punctuation">,</span> mutest.Person<span class="title">@16</span>b<span class="number">98e56</span><span class="punctuation">,</span> mutest.Person<span class="title">@7</span>ef<span class="number">20235</span>]<span class="punctuation">,</span> <span class="keyword">true</span><span class="operator">=</span>[mutest.Person<span class="title">@27</span>d<span class="number">6</span><span class="keyword">c</span><span class="number">5e0</span><span class="punctuation">,</span> mutest.Person<span class="title">@4</span>f<span class="number">3</span>f<span class="number">5</span>b<span class="number">24</span><span class="punctuation">,</span> mutest.Person<span class="title">@15</span>aeb<span class="number">7</span>ab]&#125;</span><br><span class="line">员工按性别分组情况：&#123;female<span class="operator">=</span>[mutest.Person<span class="title">@16</span>b<span class="number">98e56</span><span class="punctuation">,</span> mutest.Person<span class="title">@4</span>f<span class="number">3</span>f<span class="number">5</span>b<span class="number">24</span><span class="punctuation">,</span> mutest.Person<span class="title">@7</span>ef<span class="number">20235</span>]<span class="punctuation">,</span> male<span class="operator">=</span>[mutest.Person<span class="title">@27</span>d<span class="number">6</span><span class="keyword">c</span><span class="number">5e0</span><span class="punctuation">,</span> mutest.Person<span class="title">@2</span>d<span class="number">98</span>a<span class="number">335</span><span class="punctuation">,</span> mutest.Person<span class="title">@15</span>aeb<span class="number">7</span>ab]&#125;</span><br><span class="line">员工按性别、地区：&#123;female<span class="operator">=</span>&#123;New York<span class="operator">=</span>[mutest.Person<span class="title">@4</span>f<span class="number">3</span>f<span class="number">5</span>b<span class="number">24</span><span class="punctuation">,</span> mutest.Person<span class="title">@7</span>ef<span class="number">20235</span>]<span class="punctuation">,</span> Washington<span class="operator">=</span>[mutest.Person<span class="title">@16</span>b<span class="number">98e56</span>]&#125;<span class="punctuation">,</span> male<span class="operator">=</span>&#123;New York<span class="operator">=</span>[mutest.Person<span class="title">@27</span>d<span class="number">6</span><span class="keyword">c</span><span class="number">5e0</span><span class="punctuation">,</span> mutest.Person<span class="title">@15</span>aeb<span class="number">7</span>ab]<span class="punctuation">,</span> Washington<span class="operator">=</span>[mutest.Person<span class="title">@2</span>d<span class="number">98</span>a<span class="number">335</span>]&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="接合-joining"><a href="#接合-joining" class="headerlink" title="接合(joining)"></a>接合(joining)</h3><p><code>joining</code>可以将stream中的元素用特定的连接符（没有的话，则直接连接）连接成一个字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  List&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>, <span class="number">8900</span>, <span class="number">23</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jack&quot;</span>, <span class="number">7000</span>, <span class="number">25</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Lily&quot;</span>, <span class="number">7800</span>, <span class="number">21</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line"></span><br><span class="line">  String names = personList.stream().map(p -&gt; p.getName()).collect(Collectors.joining(<span class="string">&quot;,&quot;</span>));</span><br><span class="line">  System.out.println(<span class="string">&quot;所有员工的姓名：&quot;</span> + names);</span><br><span class="line">  List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">  String string = list.stream().collect(Collectors.joining(<span class="string">&quot;-&quot;</span>));</span><br><span class="line">  System.out.println(<span class="string">&quot;拼接后的字符串：&quot;</span> + string);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<blockquote>
<p>❝</p>
<p>所有员工的姓名：Tom,Jack,Lily<br>拼接后的字符串：A-B-C</p>
<p>❞</p>
</blockquote>
<h3 id="归约-reducing"><a href="#归约-reducing" class="headerlink" title="归约(reducing)"></a>归约(reducing)</h3><p><code>Collectors</code>类提供的<code>reducing</code>方法，相比于<code>stream</code>本身的<code>reduce</code>方法，增加了对自定义归约的支持。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  List&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>, <span class="number">8900</span>, <span class="number">23</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jack&quot;</span>, <span class="number">7000</span>, <span class="number">25</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Lily&quot;</span>, <span class="number">7800</span>, <span class="number">21</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每个员工减去起征点后的薪资之和（这个例子并不严谨，但一时没想到好的例子）</span></span><br><span class="line">  Integer sum = personList.stream().collect(Collectors.reducing(<span class="number">0</span>, Person::getSalary, (i, j) -&gt; (i + j - <span class="number">5000</span>)));</span><br><span class="line">  System.out.println(<span class="string">&quot;员工扣税薪资总和：&quot;</span> + sum);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// stream的reduce</span></span><br><span class="line">  Optional&lt;Integer&gt; sum2 = personList.stream().map(Person::getSalary).reduce(Integer::sum);</span><br><span class="line">  System.out.println(<span class="string">&quot;员工薪资总和：&quot;</span> + sum2.get());</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<blockquote>
<p>❝</p>
<p>员工扣税薪资总和：8700<br>员工薪资总和：23700</p>
<p>❞</p>
</blockquote>
<h2 id="排序-sorted"><a href="#排序-sorted" class="headerlink" title="排序(sorted)"></a>排序(sorted)</h2><p>sorted，中间操作。有两种排序：</p>
<ul>
<li>sorted()：自然排序，流中元素需实现Comparable接口</li>
<li>sorted(Comparator com)：Comparator排序器自定义排序</li>
</ul>
<p><strong>「案例：将员工按工资由高到低（工资一样则按年龄由大到小）排序」</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  List&lt;Person&gt; personList = <span class="keyword">new</span> ArrayList&lt;Person&gt;();</span><br><span class="line"></span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Sherry&quot;</span>, <span class="number">9000</span>, <span class="number">24</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>, <span class="number">8900</span>, <span class="number">22</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jack&quot;</span>, <span class="number">9000</span>, <span class="number">25</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;Washington&quot;</span>));</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Lily&quot;</span>, <span class="number">8800</span>, <span class="number">26</span>, <span class="string">&quot;male&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line">  personList.add(<span class="keyword">new</span> Person(<span class="string">&quot;Alisa&quot;</span>, <span class="number">9000</span>, <span class="number">26</span>, <span class="string">&quot;female&quot;</span>, <span class="string">&quot;New York&quot;</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 按工资升序排序（自然排序）</span></span><br><span class="line">  List&lt;String&gt; newList = personList.stream().sorted(Comparator.comparing(Person::getSalary)).map(Person::getName)</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line">  <span class="comment">// 按工资倒序排序</span></span><br><span class="line">  List&lt;String&gt; newList2 = personList.stream().sorted(Comparator.comparing(Person::getSalary).reversed())</span><br><span class="line">    .map(Person::getName).collect(Collectors.toList());</span><br><span class="line">  <span class="comment">// 先按工资再按年龄升序排序</span></span><br><span class="line">  List&lt;String&gt; newList3 = personList.stream()</span><br><span class="line">    .sorted(Comparator.comparing(Person::getSalary).thenComparing(Person::getAge)).map(Person::getName)</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line">  <span class="comment">// 先按工资再按年龄自定义排序（降序）</span></span><br><span class="line">  List&lt;String&gt; newList4 = personList.stream().sorted((p1, p2) -&gt; &#123;</span><br><span class="line">   <span class="keyword">if</span> (p1.getSalary() == p2.getSalary()) &#123;</span><br><span class="line">    <span class="keyword">return</span> p2.getAge() - p1.getAge();</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p2.getSalary() - p1.getSalary();</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;).map(Person::getName).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">&quot;按工资升序排序：&quot;</span> + newList);</span><br><span class="line">  System.out.println(<span class="string">&quot;按工资降序排序：&quot;</span> + newList2);</span><br><span class="line">  System.out.println(<span class="string">&quot;先按工资再按年龄升序排序：&quot;</span> + newList3);</span><br><span class="line">  System.out.println(<span class="string">&quot;先按工资再按年龄自定义降序排序：&quot;</span> + newList4);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<blockquote>
<p>❝</p>
<p>按工资升序排序：[Lily, Tom, Sherry, Jack, Alisa]<br>按工资降序排序：[Sherry, Jack, Alisa, Tom, Lily]<br>先按工资再按年龄升序排序：[Lily, Tom, Sherry, Jack, Alisa]<br>先按工资再按年龄自定义降序排序：[Alisa, Jack, Sherry, Tom, Lily]</p>
<p>❞</p>
</blockquote>
<h2 id="提取-组合"><a href="#提取-组合" class="headerlink" title="提取/组合"></a>提取/组合</h2><p>流也可以进行合并、去重、限制、跳过等操作。</p>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/feac68af6fd2437ca8b2d279668440f6~tplv-k3u1fbpfcp-zoom-in-crop-mark:1956:0:0:0.image" alt="MarkerHub">Stream提取/组合<img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1cb30e7ac2e44747b3f58917c06fee16~tplv-k3u1fbpfcp-zoom-in-crop-mark:1956:0:0:0.image" alt="MarkerHub">Stream提取/组合<img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e621d1cded84c75874a5753bb7500ef~tplv-k3u1fbpfcp-zoom-in-crop-mark:1956:0:0:0.image" alt="MarkerHub">Stream提取/组合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamTest</span> </span>&#123;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  String[] arr1 = &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span> &#125;;</span><br><span class="line">  String[] arr2 = &#123; <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>, <span class="string">&quot;f&quot;</span>, <span class="string">&quot;g&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">  Stream&lt;String&gt; stream1 = Stream.of(arr1);</span><br><span class="line">  Stream&lt;String&gt; stream2 = Stream.of(arr2);</span><br><span class="line">  <span class="comment">// concat:合并两个流 distinct：去重</span></span><br><span class="line">  List&lt;String&gt; newList = Stream.concat(stream1, stream2).distinct().collect(Collectors.toList());</span><br><span class="line">  <span class="comment">// limit：限制从流中获得前n个数据</span></span><br><span class="line">  List&lt;Integer&gt; collect = Stream.iterate(<span class="number">1</span>, x -&gt; x + <span class="number">2</span>).limit(<span class="number">10</span>).collect(Collectors.toList());</span><br><span class="line">  <span class="comment">// skip：跳过前n个数据</span></span><br><span class="line">  List&lt;Integer&gt; collect2 = Stream.iterate(<span class="number">1</span>, x -&gt; x + <span class="number">2</span>).skip(<span class="number">1</span>).limit(<span class="number">5</span>).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">  System.out.println(<span class="string">&quot;流合并：&quot;</span> + newList);</span><br><span class="line">  System.out.println(<span class="string">&quot;limit：&quot;</span> + collect);</span><br><span class="line">  System.out.println(<span class="string">&quot;skip：&quot;</span> + collect2);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<blockquote>
<p>❝</p>
<p>流合并：[a, b, c, d, e, f, g]<br>limit：[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]<br>skip：[3, 5, 7, 9, 11]</p>
<p>❞</p>
<p>blog.csdn.net/mu_wind/article/details/109516995</p>
</blockquote>
<p>本文转自 <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MDc1MTM3Mjg3MzI3MDU1OTAz">https://juejin.cn/post/7075137287327055903<i class="fa fa-external-link-alt"></i></span>，如有侵权，请联系删除。</p>
]]></content>
      <categories>
        <category>集合数组</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>sql</tag>
        <tag>集合</tag>
        <tag>函数</tag>
        <tag>数组</tag>
        <tag>Mysql</tag>
        <tag>容器</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap与HashTable的区别</title>
    <url>/posts/MVEJAK.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><div style="text-align: center;"></div><br><span id="more"></span></p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li>HashTable 线程同步（线程安全），HashMap非线程同步（线程不安全）。</li>
<li>HashTable 不允许键和值有空值，HashMap允许键和值有空值。</li>
<li>HashTable使用Enumeration,HashMap使用iterator。</li>
<li>HashTable的默认大小是11，扩容方式是old * 2 +1，HashMap的默认大小是16，扩容方式是2的指数倍。</li>
<li>HashTable继承于Dictionary类，HashMap继承于AbstractMap类。</li>
</ul>
<h2 id="HashMap有哪些线程安全的方式"><a href="#HashMap有哪些线程安全的方式" class="headerlink" title="HashMap有哪些线程安全的方式"></a>HashMap有哪些线程安全的方式</h2><h3 id="Conllections-synchronizedMap"><a href="#Conllections-synchronizedMap" class="headerlink" title="Conllections.synchronizedMap"></a>Conllections.synchronizedMap</h3><p>此方法返回一个新的Map，这个新的Map就是线程安全的。<br>特点：<br>通过Conllections.synchronizedMap来封装所有不安全的HashMap方法，就连toString，hashCode都进行了封装，封装的关键点有：</p>
<ul>
<li>使用了synchronized来进行互斥</li>
<li>使用代理模式new一个新的类，这个类同样实现了Map接口。</li>
</ul>
<p>在HashMap上面，synchronized锁住的是对象，所以第一个申请的得到锁，其他线程将进入阻塞，等到唤醒。</p>
<p>优点：<br>代码实现简单。</p>
<p>缺点：<br>从锁的角度来看，上来就加锁，基本上锁住了尽可能大的代码块，性能比较差。</p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>特点<br>重新写了HashMap，比较大的改变有以下几点：</p>
<ul>
<li>使用了新的锁机制，把Hashmap进行了拆分，拆分成了多个独立的块，这样在高并发的情况下减少了锁冲突的可能。</li>
<li>使用的是NonfairSync，这个特性调用的是CAS指令来确保原子性与互斥性，当如果多个线程恰好操作到同一个segment上面，那么只会有一个线程能够运行。</li>
</ul>
<p>优点：<br>需要互斥的代码段比较少，性能也好，ConcurrentHashMap 把整个Map切分成多个块，发生锁碰撞的几率大大降低了，性能会比较好。</p>
<p>缺点：<br>代码繁琐。</p>
]]></content>
      <categories>
        <category>集合数组</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>锁</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8中的Stream轻松遍历树形结构</title>
    <url>/posts/357C6XC.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>原文：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE5MjQ0OTI3L2FydGljbGUvZGV0YWlscy8xMDY0ODE3Nzc=">Java 8 中的 Stream 轻松遍历树形结构，是真的牛逼！<i class="fa fa-external-link-alt"></i></span> </p>
</blockquote>
<p>可能平常会遇到一些需求，比如构建菜单，构建树形结构，数据库一般就使用父id来表示，为了降低数据库的查询压力，我们可以使用Java8中的Stream流一次性把数据查出来，然后通过流式处理，我们一起来看看，代码实现为了实现简单，就模拟查看数据库所有数据到List里面。<br>实体类：Menu.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Menu</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> lcry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Menu</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Integer id;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 父id ，根节点为0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Integer parentId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子节点信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Menu&gt; childList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Menu</span><span class="params">(Integer id, String name, Integer parentId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.parentId = parentId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Menu</span><span class="params">(Integer id, String name, Integer parentId, List&lt;Menu&gt; childList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.parentId = parentId;</span><br><span class="line">        <span class="keyword">this</span>.childList = childList;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>递归组装树形结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testtree</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//模拟从数据库查询出来，公众号Java精选，有惊喜！</span></span><br><span class="line">    List&lt;Menu&gt; menus = Arrays.asList(</span><br><span class="line">            <span class="keyword">new</span> Menu(<span class="number">1</span>,<span class="string">&quot;根节点&quot;</span>,<span class="number">0</span>),</span><br><span class="line">            <span class="keyword">new</span> Menu(<span class="number">2</span>,<span class="string">&quot;子节点1&quot;</span>,<span class="number">1</span>),</span><br><span class="line">            <span class="keyword">new</span> Menu(<span class="number">3</span>,<span class="string">&quot;子节点1.1&quot;</span>,<span class="number">2</span>),</span><br><span class="line">            <span class="keyword">new</span> Menu(<span class="number">4</span>,<span class="string">&quot;子节点1.2&quot;</span>,<span class="number">2</span>),</span><br><span class="line">            <span class="keyword">new</span> Menu(<span class="number">5</span>,<span class="string">&quot;根节点1.3&quot;</span>,<span class="number">2</span>),</span><br><span class="line">            <span class="keyword">new</span> Menu(<span class="number">6</span>,<span class="string">&quot;根节点2&quot;</span>,<span class="number">1</span>),</span><br><span class="line">            <span class="keyword">new</span> Menu(<span class="number">7</span>,<span class="string">&quot;根节点2.1&quot;</span>,<span class="number">6</span>),</span><br><span class="line">            <span class="keyword">new</span> Menu(<span class="number">8</span>,<span class="string">&quot;根节点2.2&quot;</span>,<span class="number">6</span>),</span><br><span class="line">            <span class="keyword">new</span> Menu(<span class="number">9</span>,<span class="string">&quot;根节点2.2.1&quot;</span>,<span class="number">7</span>),</span><br><span class="line">            <span class="keyword">new</span> Menu(<span class="number">10</span>,<span class="string">&quot;根节点2.2.2&quot;</span>,<span class="number">7</span>),</span><br><span class="line">            <span class="keyword">new</span> Menu(<span class="number">11</span>,<span class="string">&quot;根节点3&quot;</span>,<span class="number">1</span>),</span><br><span class="line">            <span class="keyword">new</span> Menu(<span class="number">12</span>,<span class="string">&quot;根节点3.1&quot;</span>,<span class="number">11</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取父节点</span></span><br><span class="line">    List&lt;Menu&gt; collect = menus.stream().filter(m -&gt; m.getParentId() == <span class="number">0</span>).map(</span><br><span class="line">            (m) -&gt; &#123;</span><br><span class="line">                m.setChildList(getChildrens(m, menus));</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">    ).collect(Collectors.toList());</span><br><span class="line">    System.out.println(<span class="string">&quot;-------转json输出结果-------&quot;</span>);</span><br><span class="line">    System.out.println(JSON.toJSON(collect));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归查询子节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> root  根节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> all   所有节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 根节点信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Menu&gt; <span class="title">getChildrens</span><span class="params">(Menu root, List&lt;Menu&gt; all)</span> </span>&#123;</span><br><span class="line">    List&lt;Menu&gt; children = all.stream().filter(m -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.equals(m.getParentId(), root.getId());</span><br><span class="line">    &#125;).map(</span><br><span class="line">            (m) -&gt; &#123;</span><br><span class="line">                m.setChildList(getChildrens(m, all));</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">    ).collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> children;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>格式化打印结果:  </p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/13/1045-YbMIJ3.jpg" alt="1045-YbMIJ3"></p>
<hr>
]]></content>
      <categories>
        <category>集合数组</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>聊聊ConcurrentHashMap</title>
    <url>/posts/3WWPT6W.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>原文：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvcFctbWhkZlBtODJKeEtwUkY5anJOZw==">聊聊ConcurrentHashMap<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>本文汇总了常考的 ConcurrentHashMap 面试题，面试 ConcurrentHashMap，看这一篇就够了！为帮助大家高效复习，专门用”★ “表示面试中出现的频率，”★ “越多，代表越高频！</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/10318bUq3E.png" alt=""></p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><blockquote>
<p>ConcurrentHashMap 的实现原理是什么？★★★★★</p>
</blockquote>
<p>ConcurrentHashMap  在 JDK1.7 和 JDK1.8  的实现方式是不同的。</p>
<p><strong>先来看下JDK1.7</strong></p>
<p>JDK1.7 中的 ConcurrentHashMap 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成，即 ConcurrentHashMap 把哈希桶数组切分成小数组（Segment ），每个小数组有 n 个 HashEntry 组成。</p>
<p>如下图所示，首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一段数据时，其他段的数据也能被其他线程访问，实现了真正的并发访问。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/1032qwe0jW.png" alt=""></p>
<p>Segment 是 ConcurrentHashMap 的一个内部类，主要的组成如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/1034TwAp6g.png" alt=""></p>
<p>Segment 继承了 ReentrantLock，所以 Segment 是一种可重入锁，扮演锁的角色。Segment 默认为 16，也就是并发度为 16。</p>
<p>存放元素的 HashEntry，也是一个静态内部类，主要的组成如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/1034mlVtdv.png" alt=""></p>
<p>其中，用 volatile 修饰了 HashEntry 的数据 value 和 下一个节点 next，保证了多线程环境下数据获取时的<strong>可见性</strong>！</p>
<p><strong>再来看下JDK1.8</strong></p>
<p>在数据结构上， JDK1.8  中的ConcurrentHashMap  选择了与 HashMap 相同的<strong>Node数组+链表+红黑树</strong>结构；在锁的实现上，抛弃了原有的 Segment 分段锁，采用<code>CAS + synchronized</code>实现更加细粒度的锁。</p>
<p>将锁的级别控制在了更细粒度的哈希桶数组元素级别，也就是说只需要锁住这个链表头节点（红黑树的根节点），就不会影响其他的哈希桶数组元素的读写，大大提高了并发度。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/1035IaVcP4.png" alt=""></p>
<blockquote>
<p>JDK1.8  中为什么使用内置锁 synchronized替换 可重入锁 ReentrantLock？★★★★★</p>
</blockquote>
<ul>
<li>在 JDK1.6 中，对 synchronized 锁的实现引入了大量的优化，并且 synchronized 有多种锁状态，会从无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁一步步转换。</li>
<li>减少内存开销 。假设使用可重入锁来获得同步支持，那么每个节点都需要通过继承 AQS 来获得同步支持。但并不是每个节点都需要获得同步支持的，只有链表的头节点（红黑树的根节点）需要同步，这无疑带来了巨大内存浪费。</li>
</ul>
<h2 id="存取"><a href="#存取" class="headerlink" title="存取"></a>存取</h2><blockquote>
<p>ConcurrentHashMap  的 put 方法执行逻辑是什么？★★★★</p>
</blockquote>
<p><strong>先来看JDK1.7</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/1036mwo1VB.png" alt=""></p>
<p>先定位到相应的 Segment ，然后再进行 put 操作。</p>
<p>源代码如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/1037MkDJZI.png" alt=""></p>
<p>首先会尝试获取锁，如果获取失败肯定就有其他线程存在竞争，则利用 <code>scanAndLockForPut()</code> 自旋获取锁。</p>
<ol>
<li>尝试自旋获取锁。</li>
<li>如果重试的次数达到了 <code>MAX_SCAN_RETRIES</code> 则改为阻塞锁获取，保证能获取成功。</li>
</ol>
<p><strong>再来看JDK1.8</strong></p>
<p>大致可以分为以下步骤：</p>
<ol>
<li><p>根据 key 计算出 hash 值；</p>
</li>
<li><p>判断是否需要进行初始化；</p>
</li>
<li><p>定位到 Node，拿到首节点 f，判断首节点 f：</p>
</li>
<li><ul>
<li>如果为  null  ，则通过 CAS 的方式尝试添加；</li>
<li>如果为 <code>f.hash = MOVED = -1</code> ，说明其他线程在扩容，参与一起扩容；</li>
<li>如果都不满足 ，synchronized 锁住 f 节点，判断是链表还是红黑树，遍历插入；</li>
</ul>
</li>
<li><p>当在链表长度达到 8 的时候，数组扩容或者将链表转换为红黑树。</p>
</li>
</ol>
<p>源代码如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/1038xjZFOh.png" alt=""></p>
<blockquote>
<p>ConcurrentHashMap  的 get 方法执行逻辑是什么？★★★★</p>
</blockquote>
<p>同样，<strong>先来看JDK1.7</strong></p>
<p>首先，根据 key 计算出 hash 值定位到具体的 Segment ，再根据 hash 值获取定位 HashEntry 对象，并对 HashEntry 对象进行链表遍历，找到对应元素。</p>
<p>由于 HashEntry 涉及到的共享变量都使用 volatile 修饰，volatile 可以保证内存可见性，所以每次获取时都是最新值。</p>
<p>源代码如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/1038nmFxF6.png" alt=""></p>
<p><strong>再来看JDK1.8</strong></p>
<p>大致可以分为以下步骤：</p>
<ol>
<li>根据 key 计算出 hash 值，判断数组是否为空；</li>
<li>如果是首节点，就直接返回；</li>
<li>如果是红黑树结构，就从红黑树里面查询；</li>
<li>如果是链表结构，循环遍历判断。</li>
</ol>
<p>源代码如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/1039VisPxv.png" alt=""></p>
<blockquote>
<p>ConcurrentHashMap 的 get 方法是否要加锁，为什么？★★★</p>
</blockquote>
<p>get 方法不需要加锁。因为 Node 的元素 value 和指针 next 是用 volatile 修饰的，在多线程环境下线程A修改节点的 value 或者新增节点的时候是对线程B可见的。</p>
<p>这也是它比其他并发集合比如 Hashtable、用 Collections.synchronizedMap()包装的 HashMap 效率高的原因之一。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/1039dvKas4.png" alt=""></p>
<blockquote>
<p>get 方法不需要加锁与 volatile 修饰的哈希桶数组有关吗？★★★</p>
</blockquote>
<p>没有关系。哈希桶数组<code>table</code>用 volatile 修饰主要是保证在数组扩容的时候保证可见性。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/1040RIFKvY.png" alt="图片"></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><blockquote>
<p>ConcurrentHashMap  不支持 key 或者 value 为  null  的原因？★★★</p>
</blockquote>
<p>我们先来说value 为什么不能为 null。因为 ConcurrentHashMap 是用于多线程的 ，如果<code>ConcurrentHashMap.get(key)</code>得到了 null ，这就无法判断，是映射的value是 null ，还是没有找到对应的key而为 null ，就有了二义性。</p>
<p>而用于单线程状态的 HashMap 却可以用<code>containsKey(key)</code> 去判断到底是否包含了这个 null 。</p>
<p>我们用<strong>反证法</strong>来推理：</p>
<p>假设 ConcurrentHashMap 允许存放值为 null 的 value，这时有A、B两个线程，线程A调用<code>ConcurrentHashMap.get(key)</code>方法，返回为 null ，我们不知道这个 null 是没有映射的 null ，还是存的值就是 null 。</p>
<p>假设此时，返回为 null 的真实情况是没有找到对应的 key。那么，我们可以用 <code>ConcurrentHashMap.containsKey(key)</code>来验证我们的假设是否成立，我们期望的结果是返回 false 。</p>
<p>但是在我们调用 <code>ConcurrentHashMap.get(key)</code>方法之后，<code>containsKey</code>方法之前，线程B执行了<code>ConcurrentHashMap.put(key, null)</code>的操作。那么我们调用<code>containsKey</code>方法返回的就是 true 了，这就与我们的假设的真实情况不符合了，这就有了二义性。</p>
<p>至于 ConcurrentHashMap 中的 key 为什么也不能为 null  的问题，源码就是这样写的，哈哈。如果面试官不满意，就回答因为作者Doug不喜欢 null ，所以在设计之初就不允许了 null 的 key  存在。想要深入了解的小伙伴，可以看这篇文章<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpJeE5UUTRNekUxTkE9PSZhbXA7bWlkPTIyNDc0ODQzNTQmYW1wO2lkeD0xJmFtcDtzbj04MGM5Mjg4MWI0N2E1ODZlYmE5YzYzM2ViNzhkMzZmNiZhbXA7Y2hrc209OTc5NmQ1YmZhMGUxNWNhOTcxM2ZmOWRjNmUxMDA1OTNlMGVmMDZlZDdlYTJmNjBjYjk4NGU0OTJjNGVkNDM4ZDI0MDVmYmIyYzRmZiZhbXA7c2NlbmU9MjEjd2VjaGF0X3JlZGlyZWN0">这道面试题我真不知道面试官想要的回答是什么<i class="fa fa-external-link-alt"></i></span></p>
<blockquote>
<p>ConcurrentHashMap 的并发度是什么？★★</p>
</blockquote>
<p>并发度可以理解为程序运行时能够同时更新 ConccurentHashMap且不产生锁竞争的最大线程数。在JDK1.7中，实际上就是ConcurrentHashMap中的分段锁个数，即Segment[]的数组长度，默认是16，这个值可以在构造函数中设置。</p>
<p>如果自己设置了并发度，ConcurrentHashMap 会使用大于等于该值的最小的2的幂指数作为实际并发度，也就是比如你设置的值是17，那么实际并发度是32。</p>
<p>如果并发度设置的过小，会带来严重的锁竞争问题；如果并发度设置的过大，原本位于同一个Segment内的访问会扩散到不同的Segment中，CPU cache命中率会下降，从而引起程序性能下降。</p>
<p>在JDK1.8中，已经摒弃了Segment的概念，选择了Node数组+链表+红黑树结构，并发度大小依赖于数组的大小。</p>
<blockquote>
<p>ConcurrentHashMap 迭代器是强一致性还是弱一致性？★★</p>
</blockquote>
<p>与 HashMap 迭代器是强一致性不同，ConcurrentHashMap 迭代器是弱一致性。</p>
<p>ConcurrentHashMap 的迭代器创建后，就会按照哈希表结构遍历每个元素，但在遍历过程中，内部元素可能会发生变化，如果变化发生在已遍历过的部分，迭代器就不会反映出来，而如果变化发生在未遍历过的部分，迭代器就会发现并反映出来，这就是弱一致性。</p>
<p>这样迭代器线程可以使用原来老的数据，而写线程也可以并发的完成改变，更重要的，这保证了多个线程并发执行的连续性和扩展性，是性能提升的关键。想要深入了解的小伙伴，可以看这篇文章：<span class="exturl" data-url="aHR0cDovL2lmZXZlLmNvbS9Db25jdXJyZW50SGFzaE1hcC13ZWFrbHktY29uc2lzdGVudC8=">http://ifeve.com/ConcurrentHashMap-weakly-consistent/<i class="fa fa-external-link-alt"></i></span></p>
<blockquote>
<h4 id="JDK1-7-与-JDK1-8-中ConcurrentHashMap-的区别？★★★★★"><a href="#JDK1-7-与-JDK1-8-中ConcurrentHashMap-的区别？★★★★★" class="headerlink" title="JDK1.7 与 JDK1.8 中ConcurrentHashMap 的区别？★★★★★"></a>JDK1.7 与 JDK1.8 中ConcurrentHashMap 的区别？★★★★★</h4></blockquote>
<ul>
<li>数据结构：取消了 Segment 分段锁的数据结构，取而代之的是数组+链表+红黑树的结构。</li>
<li>保证线程安全机制：JDK1.7 采用 Segment 的分段锁机制实现线程安全，其中 Segment 继承自 ReentrantLock 。JDK1.8 采用<code>CAS+synchronized</code>保证线程安全。</li>
<li>锁的粒度：JDK1.7 是对需要进行数据操作的 Segment 加锁，JDK1.8 调整为对每个数组元素加锁（Node）。</li>
<li>链表转化为红黑树：定位节点的 hash 算法简化会带来弊端，hash 冲突加剧，因此在链表节点数量大于 8（且数据总量大于等于 64）时，会将链表转化为红黑树进行存储。</li>
<li>查询时间复杂度：从 JDK1.7的遍历链表O(n)， JDK1.8 变成遍历红黑树O(logN)。</li>
</ul>
<blockquote>
<p>ConcurrentHashMap 和 Hashtable 的效率哪个更高？为什么？★★★★★</p>
</blockquote>
<p>ConcurrentHashMap 的效率要高于 Hashtable，因为 Hashtable  给整个哈希表加了一把大锁从而实现线程安全。而ConcurrentHashMap 的锁粒度更低，在 JDK1.7 中采用分段锁实现线程安全，在  JDK1.8 中采用<code>CAS+synchronized</code>实现线程安全。</p>
<blockquote>
<p>具体说一下Hashtable的锁机制 ★★★★★</p>
</blockquote>
<p>Hashtable 是使用 synchronized来实现线程安全的，给整个哈希表加了一把大锁，多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞等待需要的锁被释放，在竞争激烈的多线程场景中性能就会非常差！</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/1042BHfuE2.png" alt=""></p>
<blockquote>
<p>多线程下安全的操作 map还有其他方法吗？★★★</p>
</blockquote>
<p>还可以使用<code>Collections.synchronizedMap</code>方法，对方法进行加同步锁。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/1043OUgPJd.png" alt=""></p>
<p>如果传入的是 HashMap 对象，其实也是对 HashMap 做的方法做了一层包装，里面使用对象锁来保证多线程场景下，线程安全，本质也是对 HashMap 进行全表锁。<strong>在竞争激烈的多线程环境下性能依然也非常差，不推荐使用！</strong></p>
]]></content>
      <categories>
        <category>集合数组</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>内存</tag>
        <tag>集合</tag>
        <tag>函数</tag>
        <tag>数组</tag>
        <tag>CPU</tag>
        <tag>指针</tag>
        <tag>变量</tag>
        <tag>面试</tag>
        <tag>锁</tag>
        <tag>并发</tag>
        <tag>算法</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题集合一</title>
    <url>/posts/38V3ZT.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div style="text-align: center;"></div>



<h4 id="CMS-—-浮动垃圾"><a href="#CMS-—-浮动垃圾" class="headerlink" title="CMS  — 浮动垃圾"></a>CMS  — 浮动垃圾</h4><p>在垃圾回收过程中标记过程中产生的垃圾，被理解为浮动垃圾，这种垃圾没必要去在乎，影响不大，在下一次垃圾回收的时候会被垃圾回收器回收。</p>
<h4 id="CMS-—-错标"><a href="#CMS-—-错标" class="headerlink" title="CMS — 错标"></a>CMS — 错标</h4><p>一个资源在被标记为垃圾的时候，突然另一个资源与之相连，成为了有用的资源，如果资源被清除，会带了问题。</p>
<h4 id="CMS-—-重新标记"><a href="#CMS-—-重新标记" class="headerlink" title="CMS — 重新标记"></a>CMS — 重新标记</h4><p>在标记过程中，可能有些资源被错误标记，所以需要重新标记。这个过程属于STW。</p>
<p>重新标记完成，下一步就是并发处理，把标记为垃圾的资源清楚，这个过程也有可能会产生浮动垃圾，但没有关系，下次标记清除的时候会被处理。</p>
<h4 id="CMS-从线程角度"><a href="#CMS-从线程角度" class="headerlink" title="CMS 从线程角度"></a>CMS 从线程角度</h4><p><img data-src="https://xuemingde.com/pages/image/others/20210302095208.png" alt="image-20210302095206722"></p>
<p>过程简述：</p>
<p> 先经过初始标记，找到根对象，可能会产生浮动垃圾，但没影响，等待下次标记</p>
<p>再经过并发标记，在标记过程中可能会产生错标</p>
<p>重新标记会对错标进行修正</p>
<p>修正好以后，进行并发处理，这时也有可能会产生浮动垃圾，但没影响，等待下次标记</p>
<h4 id="什么情况下才选择使用CMS收集器呢"><a href="#什么情况下才选择使用CMS收集器呢" class="headerlink" title="什么情况下才选择使用CMS收集器呢"></a>什么情况下才选择使用CMS收集器呢</h4><p><img data-src="https://xuemingde.com/pages/image/others/20210302144948.png" alt="image-20210302144947618"></p>
<h4 id="CMS的调优"><a href="#CMS的调优" class="headerlink" title="CMS的调优"></a><strong>CMS的调优</strong></h4><p><img data-src="https://xuemingde.com/pages/image/others/20210302145158.png" alt="image-20210302145157004"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210302145245.png" alt="image-20210302145243983"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210302145257.png" alt="image-20210302145256194"></p>
<h4 id="JDK8默认垃圾回收器"><a href="#JDK8默认垃圾回收器" class="headerlink" title="JDK8默认垃圾回收器"></a>JDK8默认垃圾回收器</h4><p>jdk8环境下，默认使用 Parallel Scavenge（新生代）+ Serial Old（老年代）</p>
]]></content>
      <categories>
        <category>面试资料</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题集合二</title>
    <url>/posts/YGV8AK.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div style="text-align: center;"></div>



<h4 id="堆内存逻辑分区-不适用不分代垃圾收集器"><a href="#堆内存逻辑分区-不适用不分代垃圾收集器" class="headerlink" title="堆内存逻辑分区(不适用不分代垃圾收集器)"></a>堆内存逻辑分区(不适用不分代垃圾收集器)</h4><p><img data-src="https://xuemingde.com/pages/image/others/20210301144548.png" alt=""></p>
<h4 id="jvm-内存空间"><a href="#jvm-内存空间" class="headerlink" title="jvm 内存空间"></a>jvm 内存空间</h4><p><img data-src="https://xuemingde.com/pages/image/others/20210301145713.png" alt=""></p>
<p> 注意：</p>
<p><strong>一个进程都有一套方法区和堆</strong><br><strong>一个线程都有一套Java虚拟机栈和程序计数器</strong></p>
<h4 id="各空间详解"><a href="#各空间详解" class="headerlink" title="各空间详解"></a>各空间详解</h4><p><img data-src="https://xuemingde.com/pages/image/others/20210301150550.png" alt="image-20210301150548679"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210301150843.png" alt="image-20210301150841856"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210301150951.webp" alt="img"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210301151013.png" alt="image-20210301151012040"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210301150727.png" alt="image-20210301150713776"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210301151201.png" alt="image-20210301151159632"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210301151627.png" alt="image-20210301151625877"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210301151826.png" alt="image-20210301151821164"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210301152826.png" alt="image-20210301152825611"></p>
<h4 id="指针碰撞"><a href="#指针碰撞" class="headerlink" title="指针碰撞"></a>指针碰撞</h4><p><img data-src="https://xuemingde.com/pages/image/others/20210301154851.png" alt="image-20210301154850520"></p>
<p>title: java锁、JVM等  </p>
<h4 id="TLAB-（指针碰撞的解决思路）"><a href="#TLAB-（指针碰撞的解决思路）" class="headerlink" title="TLAB   （指针碰撞的解决思路）"></a>TLAB   （指针碰撞的解决思路）</h4><p>TLAB的全称是Thread Local Allocation Buffe，线程本地分配缓存区。</p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210301155427.png" alt="image-20210301155425935"></p>
<h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a><strong>逃逸分析</strong></h4><p><img data-src="https://xuemingde.com/pages/image/others/20210301160619.png" alt="image-20210301160618259"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210301160710.png" alt="image-20210301160709230"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210301160801.png" alt="img"></p>
<h4 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h4><p><img data-src="https://xuemingde.com/pages/image/others/20210301163759.png" alt=""></p>
<h4 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h4><p><img data-src="https://xuemingde.com/pages/image/others/20210301165936.png" alt="image-20210301165930817"></p>
<h4 id="同步消除"><a href="#同步消除" class="headerlink" title="同步消除"></a>同步消除</h4><p><img data-src="https://xuemingde.com/pages/image/others/20210301170028.png" alt="image-20210301170027420"></p>
<h4 id="对象创建过程，在jvm层面的内存分配；流程图"><a href="#对象创建过程，在jvm层面的内存分配；流程图" class="headerlink" title="对象创建过程，在jvm层面的内存分配；流程图"></a>对象创建过程，在jvm层面的内存分配；流程图</h4><p><img data-src="https://xuemingde.com/pages/image/others/20210301170547.png" alt="image-20210301170545945"></p>
<h4 id="只要是分代模型，一定是成对出现，常见的组合有3种"><a href="#只要是分代模型，一定是成对出现，常见的组合有3种" class="headerlink" title="只要是分代模型，一定是成对出现，常见的组合有3种"></a>只要是分代模型，一定是成对出现，常见的组合有3种</h4><p><img data-src="https://xuemingde.com/pages/image/others/20210301172948.png" alt=""></p>
<h4 id="jdk1-8可用分代模型，也可不用分代模型"><a href="#jdk1-8可用分代模型，也可不用分代模型" class="headerlink" title="jdk1.8可用分代模型，也可不用分代模型"></a>jdk1.8可用分代模型，也可不用分代模型</h4><p><img data-src="https://xuemingde.com/pages/image/others/20210301173045.png" alt="image-20210301171243283"></p>
<h4 id="Serial-（-SWT）"><a href="#Serial-（-SWT）" class="headerlink" title="Serial     （ SWT）"></a>Serial     （ SWT）</h4><p>属于单线程回收</p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210301173053.png" alt="image-20210301171615192"></p>
<p>会造成卡顿的现象，是因为业务线程被暂停，垃圾回收线程在工作。JVM调优应该极力避免的现象。</p>
<h4 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h4><p>单线程回收不够的情况下，可以使用Parallel Scavenge，属于多线程回收</p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210301173058.png" alt="image-20210301172618386"></p>
<h4 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h4><p>为了配合CMS的使用，对Parallel Scavenge做了一些改进，就是ParNew</p>
<p>使用多个GC线程的复制收集器来自“ Parallel Scavenge”，因为它具有增强功能，可用于例如，“ ParNew”执行所需的同步，以便它可以在CMS的并发阶段运行。</p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210301175352.png" alt="image-20210301175351245"></p>
<h4 id="CMS-（concurrent-mark-sweep-并发标记清除）"><a href="#CMS-（concurrent-mark-sweep-并发标记清除）" class="headerlink" title="CMS （concurrent mark sweep  并发标记清除）"></a>CMS （concurrent mark sweep  并发标记清除）</h4><p><img data-src="https://xuemingde.com/pages/image/others/20210301175844.png" alt="image-20210301175842829"></p>
<p>工作线程与回收线程同时进行</p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210301180541.png" alt="image-20210301180538636"></p>
]]></content>
      <categories>
        <category>面试资料</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>C</tag>
        <tag>内存</tag>
        <tag>GC</tag>
        <tag>堆</tag>
        <tag>栈</tag>
        <tag>指针</tag>
        <tag>锁</tag>
        <tag>并发</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题集合三</title>
    <url>/posts/1ZN2DTY.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div style="text-align: center;"></div>


<h4 id="单例，双重检查锁"><a href="#单例，双重检查锁" class="headerlink" title="单例，双重检查锁"></a>单例，双重检查锁</h4><p><img data-src="https://xuemingde.com/pages/image/others/20210226094709.png" alt=""></p>
<h4 id="new-一个对象氛围三步"><a href="#new-一个对象氛围三步" class="headerlink" title="new 一个对象氛围三步"></a>new 一个对象氛围三步</h4><ol>
<li>申请内存，设默认值 0 </li>
<li>设置初始值 </li>
<li>建立关联</li>
</ol>
<h4 id="new-对象的时候会有一个问题，就是指令重排序"><a href="#new-对象的时候会有一个问题，就是指令重排序" class="headerlink" title="new 对象的时候会有一个问题，就是指令重排序"></a>new 对象的时候会有一个问题，就是指令重排序</h4><p><img data-src="https://xuemingde.com/pages/image/others/20210226095658.png" alt=""></p>
<p>可以加volatile，volatile的一个作用就是禁止指令重排序，因为有内存屏障</p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210226100612.png" alt=""></p>
<h4 id="volatile-是JVM的关键字"><a href="#volatile-是JVM的关键字" class="headerlink" title="volatile 是JVM的关键字"></a>volatile 是JVM的关键字</h4><p>有两个作用，一个是禁止指令重排序，一个是线程可见性。</p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210226101428.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210226102705.png" alt="image-20210226102702495"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210226102800.png" alt="image-20210226102757830"></p>
<h4 id="一些面试问题"><a href="#一些面试问题" class="headerlink" title="一些面试问题"></a>一些面试问题</h4><p><img data-src="https://xuemingde.com/pages/image/others/20210226103831.png" alt="image-20210226103830233"></p>
<h4 id="线程的原子性"><a href="#线程的原子性" class="headerlink" title="线程的原子性"></a>线程的原子性</h4><p><img data-src="https://xuemingde.com/pages/image/others/20210226111409.png" alt="image-20210226111407167"></p>
<p>为了保证线程的原子性，需要加锁，一个线程执行完，才允许下一个线程的操作</p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210226111719.png" alt="image-20210226111718278"></p>
<h4 id="java对象的内存布局"><a href="#java对象的内存布局" class="headerlink" title="java对象的内存布局"></a>java对象的内存布局</h4><p>分为头信息和补全信息，头信息里面有锁信息等，如果头信息的字节不够被8整除，就会被补全到让8能够整除。</p>
<p>没有加锁的对象与加锁的对象的内存布局对比</p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210226112221.png" alt="image-20210226112218624"></p>
<h4 id="轻量级锁的种类"><a href="#轻量级锁的种类" class="headerlink" title="轻量级锁的种类"></a>轻量级锁的种类</h4><p><img data-src="https://xuemingde.com/pages/image/others/20210226113106.png" alt="image-20210226113105033"></p>
<h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p><img data-src="https://xuemingde.com/pages/image/others/20210226114604.png" alt="image-20210226114602603"></p>
<p>有一个线程持有着这把锁，其他想要获得锁的线程进入等待队列，等持有锁的线程释放锁后，操作系统会让一个等待线程获得锁。不消耗CPU资源。</p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>有一个线程持有着这把锁，其他想要获得锁的线程就循环等待，等持有锁的线程释放锁后，其他等待锁的线程就是抢锁，谁抢到是谁的，会消耗CPU资源。</p>
<h4 id="CAS存在的问题"><a href="#CAS存在的问题" class="headerlink" title="CAS存在的问题"></a>CAS存在的问题</h4><p>ABA 问题</p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210226134646.png" alt="image-20210226134644249"></p>
<p>解决：加版本号</p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210226135543.png" alt="image-20210226135541370"></p>
<h4 id="synchronized-与-reentrantlock-的共同点"><a href="#synchronized-与-reentrantlock-的共同点" class="headerlink" title="synchronized 与 reentrantlock 的共同点"></a>synchronized 与 reentrantlock 的共同点</h4><p><img data-src="https://xuemingde.com/pages/image/others/20210226141427.png" alt="image-20210226141426173"></p>
<h4 id="synchronized-与-reentrantlock-的区别"><a href="#synchronized-与-reentrantlock-的区别" class="headerlink" title="synchronized 与 reentrantlock 的区别"></a>synchronized 与 reentrantlock 的区别</h4><p><img data-src="https://xuemingde.com/pages/image/others/20210226141654.png" alt="image-20210226141652907"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210226141850.png" alt="image-20210226141849362"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210226142156.png" alt="image-20210226142154906"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210226142315.png" alt="image-20210226142314198"></p>
<h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><p>用两个线程,一个输出字母,一个输出数字,交替输出1A2B3C4D…26Z</p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210226145644.png" alt="image-20210226145643215"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210226150103.png" alt="image-20210226150102063"></p>
<p> 如何让第二个线程先执行</p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210226150342.png" alt="image-20210226150339682"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210226150748.png" alt="image-20210226150746706"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/20210226150827.png" alt="image-20210226150826706"> </p>
]]></content>
      <categories>
        <category>面试资料</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>C</tag>
        <tag>内存</tag>
        <tag>CPU</tag>
        <tag>面试</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题集合四</title>
    <url>/posts/SR6PT0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div style="text-align: center;"></div>


<h4 id="安全框架Shiro和SpringSecurity的比较"><a href="#安全框架Shiro和SpringSecurity的比较" class="headerlink" title="安全框架Shiro和SpringSecurity的比较"></a>安全框架Shiro和SpringSecurity的比较</h4><p><img data-src="https://xuemingde.com/pages/image/others/image-20210315114047330.png" alt="image-20210315114047330"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210315114157472.png" alt="image-20210315114157472"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210315114401023.png" alt="image-20210315114401023"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210315181140447.png" alt="image-20210315181140447"></p>
<blockquote>
<p>如果更深一些，会问一些Shiro的工作流程或者原理，需要对源码有一些了解了，SpringSecurity也是如此。所以在工作中多看一些源码，会对实现原理和工作流程有很大的帮助。</p>
<p>推荐文章：<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veXVsdW94aW5na29uZy9wLzgzODU3MTEuaHRtbA==">https://www.cnblogs.com/yuluoxingkong/p/8385711.html<i class="fa fa-external-link-alt"></i></span></p>
<h4 id="shiro认证流程"><a href="#shiro认证流程" class="headerlink" title="shiro认证流程"></a>shiro认证流程</h4></blockquote>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210315151223390.png" alt="image-20210315151223390"></p>
<h4 id="shiro授权流程"><a href="#shiro授权流程" class="headerlink" title="shiro授权流程"></a>shiro授权流程</h4><p><img data-src="https://xuemingde.com/pages/image/others/image-20210315151208566.png" alt="image-20210315151208566"></p>
<h4 id="Shiro的权限控制方式"><a href="#Shiro的权限控制方式" class="headerlink" title="Shiro的权限控制方式"></a>Shiro的权限控制方式</h4><p><img data-src="https://xuemingde.com/pages/image/others/image-20210315120723741.png" alt="image-20210315120723741"></p>
<h4 id="Shiro-的三大核心组件"><a href="#Shiro-的三大核心组件" class="headerlink" title="Shiro 的三大核心组件"></a>Shiro 的三大核心组件</h4><p><img data-src="https://xuemingde.com/pages/image/others/image-20210315120609581.png" alt="image-20210315120609581"></p>
<h4 id="什么是粗颗粒和细颗粒权限"><a href="#什么是粗颗粒和细颗粒权限" class="headerlink" title="什么是粗颗粒和细颗粒权限"></a>什么是粗颗粒和细颗粒权限</h4><p><img data-src="https://xuemingde.com/pages/image/others/image-20210315120812562.png" alt="image-20210315120812562"></p>
<h4 id="粗颗粒和细颗粒如何授权"><a href="#粗颗粒和细颗粒如何授权" class="headerlink" title="粗颗粒和细颗粒如何授权"></a>粗颗粒和细颗粒如何授权</h4><p><img data-src="https://xuemingde.com/pages/image/others/image-20210315120915946.png" alt="image-20210315120915946"></p>
]]></content>
      <categories>
        <category>面试资料</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题集合五</title>
    <url>/posts/Q62E85.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div style="text-align: center;"></div>


<h2 id="ConcurrentHashMap在Jdk1-7和1-8的区别"><a href="#ConcurrentHashMap在Jdk1-7和1-8的区别" class="headerlink" title="ConcurrentHashMap在Jdk1.7和1.8的区别"></a>ConcurrentHashMap在Jdk1.7和1.8的区别</h2><ul>
<li><p>数据结构<br>1.7：分段的数组+链表<br>1.8：基于数组+链表/红黑树。  </p>
</li>
<li><p>线程安全<br>1.7：使用分段所segment，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。<br>1.8：摒弃了 Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized<br>和 CAS 来操作。synchronized只锁定当前链表或红黑二叉树的首节点   </p>
</li>
</ul>
<h2 id="HashMap在Jdk1-7和1-8的区别"><a href="#HashMap在Jdk1-7和1-8的区别" class="headerlink" title="HashMap在Jdk1.7和1.8的区别"></a>HashMap在Jdk1.7和1.8的区别</h2><p>在jdk1.7之前HashMap是基于数组和链表实现的，而且采用头插法。</p>
<p>而jdk1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）<br>（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。采用尾插法。</p>
<p>HashMap默认的初始化大小为 16。当HashMap中的元素个数之和大于负载因子*当前容量的时候就要进行扩充，容量变为原来的 2 倍。<br>（这里注意不是数组中的个数，而且数组中和链/树中的所有元素个数之和！）</p>
<h2 id="内存泄漏和内存溢出"><a href="#内存泄漏和内存溢出" class="headerlink" title="内存泄漏和内存溢出"></a>内存泄漏和内存溢出</h2><ul>
<li><p>内存泄漏<br>是指程序在申请内存后，无法释放已申请的内存空间就造成了内存泄漏，一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。</p>
</li>
<li><p>内存溢出<br>指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错OOM,即所谓的内存溢出，简单来说就是自己所需要使用的空间比我们拥有的内存大内存不够使用所造成的内存溢出。</p>
</li>
</ul>
<h2 id="轻量级锁一定比重量级锁效率高吗？"><a href="#轻量级锁一定比重量级锁效率高吗？" class="headerlink" title="轻量级锁一定比重量级锁效率高吗？"></a>轻量级锁一定比重量级锁效率高吗？</h2><p>并不是。<br>在使用轻量级锁（CAS）的时候，当线程非常多的时候，比如1W条线程在竞争锁，这些线程循环的获取锁，这些线程的锁竞争是很消耗CPU资源的，很多内存都用到了线程切换上，从而效率很低。<br>在竞争锁的线程很多时，使用重量级锁，会把这些线程放在一个队列里，不会消耗CPU资源，需要操作系统调用来获取锁。  </p>
]]></content>
      <categories>
        <category>面试资料</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>内存</tag>
        <tag>堆</tag>
        <tag>数组</tag>
        <tag>CPU</tag>
        <tag>锁</tag>
        <tag>并发</tag>
        <tag>容器</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题集合七</title>
    <url>/posts/2FR9QJ0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div style="text-align: center;"></div>


<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpVeU9UZzFPVGt5TUE9PSZhbXA7bWlkPTIyNDc0ODQ5MTAmYW1wO2lkeD0xJmFtcDtzbj1jNjg2YTM4MjkxNWUxOGJmYzdiY2ExNTJhYTg1OTBkZSZhbXA7c2NlbmU9MjEjd2VjaGF0X3JlZGlyZWN0">社招一年半面经分享(含阿里美团头条京东滴滴) (qq.com)<i class="fa fa-external-link-alt"></i></span></li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MDY3MzIyMjYwNTExNTIyODIzP3V0bV9zb3VyY2U9Z29sZF9icm93c2VyX2V4dGVuc2lvbg==">消息队列经典十连问 - 掘金 (juejin.cn)<i class="fa fa-external-link-alt"></i></span></p>
<p>​</p>
</li>
</ul>
]]></content>
      <categories>
        <category>面试资料</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题集合六</title>
    <url>/posts/M7HW86.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div style="text-align: center;"></div>




<ul>
<li>项目的限流怎么实现的</li>
<li>mysql的优化</li>
<li>B+树相比于哈希索引有什么优点？</li>
<li>索引的优点？</li>
<li>hashmap的底层实现？</li>
<li>list和set的区别</li>
<li>说一下你在项目中遇到的困难，怎么解决的？</li>
<li>抽象类和普通类的区别？</li>
<li>接口和抽象类的区别？</li>
<li>接口和抽象类中可以有main() 方法么？</li>
<li>final 关键字的作用？</li>
<li>ConcurrentHashMap为什么是线程安全的？</li>
<li>G1 和 CMS 的区别</li>
<li>类加载过程（类的生命周期），解释各个阶段的意义。</li>
<li>springboot的启动原理</li>
<li>问循环注入，怎么解决</li>
<li>redis都怎么使用的？</li>
<li>redis集群怎么部署的？</li>
<li>​</li>
</ul>
<p><img data-src="https://xuemingde.com/pages/image/others/6hNQ2n.png" alt=""></p>
]]></content>
      <categories>
        <category>面试资料</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Spring</tag>
        <tag>SpringBoot</tag>
        <tag>sql</tag>
        <tag>Mysql</tag>
        <tag>索引</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>死锁产生的原因有哪些</title>
    <url>/posts/9MAECS.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>原文：<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MDk2Mjg2OTQwMzQwNjgyNzY1">面试突击47：死锁产生的原因有哪些？ - 掘金<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>死锁（Dead Lock）指的是两个或两个以上的运算单元（进程、线程或协程），都在等待对方释放资源，但没有一方提起释放资源，从而造成了一种阻塞的现象就称为死锁。</p>
<p>比如线程 1 拥有了锁 A 的情况下试图获取锁 B，而线程 2 又在拥有了锁 B 的情况下试图获取锁 A，这样双方就进入相互阻塞等待的情况，如下图所示：</p>
<p> <img data-src="https://xuemingde.com/pages/image/2022/05/12/0955-fqncX4.awebp" alt="img"> 死锁的代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object lockA = <span class="keyword">new</span> Object();</span><br><span class="line">        Object lockB = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="comment">// 创建线程 1</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 1.占有锁 A</span></span><br><span class="line">            <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1：获得锁A。&quot;</span>);</span><br><span class="line">                <span class="comment">// 休眠 1s（让线程 2 有时间先占有锁 B）</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 2.获取线程 2 的锁 B</span></span><br><span class="line">                <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程1：获得锁B。&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">// 创建线程 2</span></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 1.占有锁 B</span></span><br><span class="line">            <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2：获得锁B。&quot;</span>);</span><br><span class="line">                <span class="comment">// 休眠 1s（保证线程 1 能有充足的时间得到锁 A）</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 2.获取线程 1 的锁 A</span></span><br><span class="line">                <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程2：获得锁A。&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上程序的执行结果如下图所示：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/12/0956-DCgUAx.awebp" alt="image.png"> </p>
<p>从上述结果可以看出，线程 1 和线程 2 都在等待对方释放锁，这样就造成了死锁问题。</p>
<h2 id="死锁产生原因"><a href="#死锁产生原因" class="headerlink" title="死锁产生原因"></a>死锁产生原因</h2><p>死锁的产生需要满足以下 4 个条件：</p>
<ol>
<li><strong>互斥条件</strong>：指运算单元（进程、线程或协程）对所分配到的资源具有排它性，也就是说在一段时间内某个锁资源只能被一个运算单元所占用。</li>
<li><strong>请求和保持条件</strong>：指运算单元已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它运算单元占有，此时请求运算单元阻塞，但又对自己已获得的其它资源保持不放。</li>
<li><strong>不可剥夺条件</strong>：指运算单元已获得的资源，在未使用完之前，不能被剥夺。</li>
<li><strong>环路等待条件</strong>：指在发生死锁时，必然存在运算单元和资源的环形链，即运算单元正在等待另一个运算单元占用的资源，而对方又在等待自己占用的资源，从而造成环路等待的情况。</li>
</ol>
<p>只有以上 4 个条件同时满足，才会造成死锁。</p>
<h2 id="解决死锁"><a href="#解决死锁" class="headerlink" title="解决死锁"></a>解决死锁</h2><p>死锁产生要满足以上 4 个必要条件，那么我们只需要改变其中的 1 个或多个条件就可以解决死锁的问题了，比如我们可以通过修改获取锁的顺序来改变环路等待条件。</p>
<p>在未修改获取锁的顺序前，程序的执行流程是这样的：</p>
<p> <img data-src="https://xuemingde.com/pages/image/2022/05/12/0956-sCDNd1.awebp" alt="image.png"> 其中 ① 表示先执行，② 表示后执行。 而改变锁的获取顺序之后的执行流程是这样的： </p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/12/0956-AaAM59.awebp" alt="image.png"> 此时线程 1 和线程 2 获取锁的顺序是一致的，都是先获取锁 A，再获取锁 B，此时它们的执行流程如下：</p>
<ol>
<li>线程 1 先获取到锁 A；</li>
<li>线程 1 获取到锁 B；</li>
<li>线程 1 释放了锁 B；</li>
<li>线程 1 释放了锁 A；</li>
<li>线程 2 获取到了锁 A；</li>
<li>线程 2 获取到了锁 B；</li>
<li>线程 2 释放了锁 B；</li>
<li>线程 2 释放了锁 A。</li>
</ol>
<p>对应的实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeadLockTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object lockA = <span class="keyword">new</span> Object();</span><br><span class="line">        Object lockB = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="comment">// 创建线程 1</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 1.获取锁 A</span></span><br><span class="line">            <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1：获得锁A。&quot;</span>);</span><br><span class="line">                <span class="comment">// 休眠 1s</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 2.获取锁 B</span></span><br><span class="line">                <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程1：获得锁B。&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程1：释放锁B。&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1：释放锁A。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">// 创建线程 2</span></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 1.获取锁 A</span></span><br><span class="line">            <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2：获得锁A。&quot;</span>);</span><br><span class="line">                <span class="comment">// 2.获取锁</span></span><br><span class="line">                <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程2：获得锁B。&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程2：释放锁B。&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2：释放锁A。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上程序的执行结果如下图所示：</p>
<p> <img data-src="https://xuemingde.com/pages/image/2022/05/12/0956-FtqaT9.awebp" alt="image.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>死锁（Dead Lock）指的是两个或两个以上的运算单元（进程、线程或协程），都在等待对方释放资源，但没有一方提前释放资源，从而造成了一种阻塞的现象就称为死锁。<strong>产生死锁需要同时满足 4 个条件：互斥条件、请求和保持条件、不可剥夺条件、环路等待条件，因此我们只需要破坏其中 1 个或多个条件就可以解决死锁的问题了</strong>。</p>
]]></content>
      <categories>
        <category>面试资料</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>面试</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title>垃圾回收器</title>
    <url>/posts/3Z8MTNB.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><div style="text-align: center;"></div><br><span id="more"></span></p>
<p><img data-src="https://xuemingde.com/pages/image/others/LZUtcy.png" alt=""></p>
<p>面试官：你了解JVM的内存管理模型吗？</p>
<p>菜鸟：你指的是哪种垃圾回收器？</p>
<h2 id="分代模型"><a href="#分代模型" class="headerlink" title="分代模型"></a>分代模型</h2><p><img data-src="https://xuemingde.com/pages/image/others/g8I7rx.png" alt=""></p>
<p>年轻代的垃圾是容易被回收的垃圾，而老年代里是不容易被回收的垃圾。根据工业统计，年轻代的一次垃圾回收，就能回收接近90% 的垃圾。</p>
<blockquote>
<p>JDK1,7还有永久代</p>
</blockquote>
<p>年轻代使用的是Copying算法。</p>
<p>老年代使用的是Mark Compact 或者 Mark Sweep 算法</p>
<p>年轻代Copy过程：</p>
<p>第一次GC，eden里存活的对象被copy到 s1里，eden里剩余的全部被清除。</p>
<p>第二次GC，eden和s1里存活的对象copy到s2里，eden和s1里剩余的被清除。</p>
<p>死三次GC，eden和s2里存活的对象copy到s1里，eden和s2里剩余的被清除。</p>
<p>………..</p>
<p>依次循环。</p>
<p>有些对象实在无法被清除，到了一定年龄就会进入老年代。</p>
<p>年轻代与老年代的比例：1:2</p>
<p>eden与s1和s2的比例：8:1:1</p>
<p><img data-src="https://xuemingde.com/pages/2022/03/05/11jvPE.png" alt="11jvPE"></p>
<h2 id="垃圾回收器组合"><a href="#垃圾回收器组合" class="headerlink" title="垃圾回收器组合"></a>垃圾回收器组合</h2><p><strong>分代模型里的垃圾回收器一定是成对出现的。</strong></p>
<p>常见的有三种：</p>
<ol>
<li>ParNew + CMS</li>
<li>Serial + Serial Old </li>
<li>Parallel Scavenge + Parallel Old <strong>（1.8默认）</strong></li>
</ol>
<blockquote>
<p>JDK1.8 可用分代模型，也可不用分代模型，可用G1。JDK1.9默认G1</p>
</blockquote>
<h3 id="Serial-Serial-Old"><a href="#Serial-Serial-Old" class="headerlink" title="Serial + Serial Old"></a>Serial + Serial Old</h3><p>现在很少使用了，是最早的垃圾回收器组合。</p>
<p><img data-src="https://xuemingde.com/pages/2022/03/05/SWtNk6.png" alt="SWtNk6"></p>
<p><img data-src="https://xuemingde.com/pages/2022/03/05/q8ZlBS.png" alt="q8ZlBS"></p>
<p>当有线程在工作时，突然有一个<strong>单线程的垃圾回收器</strong>来回收垃圾，所有工作的线程都有停止，等垃圾回收器工作完成以后，所有工作的线程才能恢复工作。所以在实际业务中，会出现卡顿的现象，很有可能是垃圾回收器在工作。</p>
<h3 id="Parallel-Scavenge-Parallel-Old"><a href="#Parallel-Scavenge-Parallel-Old" class="headerlink" title="Parallel Scavenge + Parallel Old"></a>Parallel Scavenge + Parallel Old</h3><p><img data-src="https://xuemingde.com/pages/2022/03/05/GkjELD.png" alt="GkjELD"></p>
<p><img data-src="https://xuemingde.com/pages/2022/03/05/Ti59QE.png" alt="Ti59QE"></p>
<p>当有线程在工作时，突然有一个<strong>多线程的垃圾回收器</strong>来回收垃圾，所有工作的线程都有停止，等垃圾回收器工作完成以后，所有工作的线程才能恢复工作。所以在实际业务中，会出现卡顿的现象，很有可能是垃圾回收器在工作。</p>
<blockquote>
<p>Parallel Scavenge 与 Serial 的区别就是多线程和单线程</p>
</blockquote>
<h3 id="ParNew-CMS"><a href="#ParNew-CMS" class="headerlink" title="ParNew + CMS"></a>ParNew + CMS</h3><blockquote>
<p>因为Serial和Parallel Scavenge不能与CMS配对，为了与CMS配对，才有了ParNew。</p>
</blockquote>
<p><img data-src="https://xuemingde.com/pages/2022/03/05/hsq0A5.png" alt="hsq0A5"></p>
<p><img data-src="https://xuemingde.com/pages/2022/03/05/mab8Ry.png" alt="mab8Ry"></p>
<p>CMS工作原理</p>
<p><img data-src="https://xuemingde.com/pages/2022/03/05/GgREZm.png" alt="GgREZm"></p>
<p>初始标记：再根据根可达性算法标记垃圾的时候，此时并不会往下继续执行，而是只标记根对像就可以了，所以此处的停顿时间也是很少的，基本上也就是几百个毫秒，可以接收。</p>
<p>并发标记：垃圾回收线程与业务线程同时运行，在运行中如有业务线程产生了垃圾，会被垃圾回收吧线程直接标记为垃圾。但这里会有一些问题，如果一个对象被标记为垃圾后，又有其他对象指向了它，如果这个对象被当做垃圾处理会出问题，此时就会产生错标的问题。此处也有可能产生浮动垃圾，就是没有被标记的垃圾，但是没关系，等下次标记的时候再次处理。</p>
<p>重新标记：就是为了解决错标的问题。时间也和短。</p>
<p>并发清理：清理被标记的垃圾。此处也有可能产生浮动垃圾，没关系，等下次被标记为垃圾然后清除。</p>
<h2 id="CMS错标对象修正的算法"><a href="#CMS错标对象修正的算法" class="headerlink" title="CMS错标对象修正的算法"></a>CMS错标对象修正的算法</h2><p><strong>三色标记算法</strong></p>
<p>第一种情况：B—&gt;D消失，增加 A—&gt;D</p>
<p>正常情况</p>
<p> <img data-src="https://xuemingde.com/pages/2022/03/05/xfQbVc.png" alt="xfQbVc"></p>
<p>此时，垃圾回收器标记，标记完了，ABD都不是垃圾。</p>
<p> <img data-src="https://xuemingde.com/pages/2022/03/05/io2ZlR.png" alt="io2ZlR"></p>
<p>运行过程之中，B指向D的引用消失了，D成了浮动垃圾，等下次执行的时候会被标记为垃圾清理掉。</p>
<p> <img data-src="https://xuemingde.com/pages/2022/03/05/25pzvC.png" alt="25pzvC"></p>
<p>在B指向D的引用消失的与此同时，A增加了指向D的引用。因为A已经被标记为黑色了，（被标记为黑色是他的孩子都已经被标记过了，不会被重新标记），所以D，不会被找到，就会当做垃圾处理掉。</p>
<p>如何解决这个问题：</p>
<ul>
<li><p>CMS解决方式</p>
<p>Incremental Update</p>
<p>就是把A变成灰色，就可以再次扫描标记了。</p>
<p>会产生的问题：并发标记，产生漏标。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
        <category>GC</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>C</tag>
        <tag>内存</tag>
        <tag>GC</tag>
        <tag>面试</tag>
        <tag>并发</tag>
        <tag>算法</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>怎么确定是垃圾及垃圾回收算法</title>
    <url>/posts/45THTG.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="怎么确定是垃圾"><a href="#怎么确定是垃圾" class="headerlink" title="怎么确定是垃圾"></a>怎么确定是垃圾</h1><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>给每个对象添加一个引用计数器，每当有一个地方引用它时，引用计数值就+1，当引用失效时，引用计数值就-1，任何时刻引用计数值为0的对象就可以被回收，当一个对象被垃圾收集器收集时，被它引用的对象引用计数值就-1，所以在这种方法中一个对象被垃圾收集会导致后续其他对象的垃圾收集行动。</p>
<p>优点：简单、高效；</p>
<p>缺点：当两个对象相互引用的时候就无法回收，导致内存泄漏。</p>
<h2 id="Root-Searching-（可达性分析法）"><a href="#Root-Searching-（可达性分析法）" class="headerlink" title="Root Searching （可达性分析法）"></a>Root Searching （可达性分析法）</h2><p>为了解决对象间相互引用问题，Java 采用了可达性分析法，基本实现思路为：通过一系列 “GC Roots” 对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到 “GC Roots” 没有任何引用链相连时，则称该对象是不可达的，此时，该对象还处于缓刑阶段，要真正宣判一个对象为可回收对象，至少要经历两次标记过程。</p>
<blockquote>
<p>JVM 采用的就是该方法</p>
</blockquote>
<h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><h2 id="Mark-Sweep-（标记清除）"><a href="#Mark-Sweep-（标记清除）" class="headerlink" title="Mark - Sweep （标记清除）"></a>Mark - Sweep （标记清除）</h2><p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1700-TnRLui.jpg" alt="1700-TnRLui"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1700-sCjXPS.jpg" alt="1700-sCjXPS"></p>
<h2 id="Copying-（拷贝）"><a href="#Copying-（拷贝）" class="headerlink" title="Copying （拷贝）"></a>Copying （拷贝）</h2><p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1701-JeW0z5.jpg" alt="1701-JeW0z5"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1701-Cnn47j.jpg" alt="1701-Cnn47j"></p>
<h2 id="Mark-Compact-（标记压缩）"><a href="#Mark-Compact-（标记压缩）" class="headerlink" title="Mark - Compact （标记压缩）"></a>Mark - Compact （标记压缩）</h2><p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1701-yXfVJ7.jpg" alt="1701-yXfVJ7"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1702-jCjA6g.jpg" alt="1702-jCjA6g"></p>
]]></content>
      <categories>
        <category>JVM</category>
        <category>GC</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>C</tag>
        <tag>内存</tag>
        <tag>GC</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>从实际案例聊聊Java应用的GC优化</title>
    <url>/posts/1B1Q39D.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><div style="text-align: center;"></div><br><span id="more"></span></p>
<p>在线查看：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYWxpeXVuZHJpdmUuY29tL3MvN05maW5qRUJqVmk=">阿里云盘<i class="fa fa-external-link-alt"></i></span></p>
<hr>
<p>原文：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TWpNNU5qUTVNVEk1T0E9PSZhbXA7bWlkPTI2NTE3NDcyNzMmYW1wO2lkeD0xJmFtcDtzbj03Zjk0NzA2NGE0MWVlZWNiNjgxNmE1ZDA4Mzg1ODFhZSZhbXA7Y2hrc209YmQxMmFhODQ4YTY1MjM5Mjg5ZDVjMzkyNjRlODliZDE3NWYzNzdmNjU1NGJmZTkzYjM3YWQ2NDk4Y2YxM2RlZmYzNTYzMzNjNTM5OCZhbXA7c2NlbmU9MjEjd2VjaGF0X3JlZGlyZWN0">从实际案例聊聊Java应用的GC优化<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>JVM</category>
        <category>GC</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title>OAuth2的一个简单解释</title>
    <url>/posts/3E561CR.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>原文：<span class="exturl" data-url="aHR0cHM6Ly93d3cucnVhbnlpZmVuZy5jb20vYmxvZy8yMDE5LzA0L29hdXRoX2Rlc2lnbi5odG1s">OAuth 2.0 的一个简单解释<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cucnVhbnlpZmVuZy5jb20vYmxvZy8yMDE0LzA1L29hdXRoXzJfMC5odG1s">OAuth 2.0<i class="fa fa-external-link-alt"></i></span> 是目前最流行的授权机制，用来授权第三方应用，获取用户数据。</p>
<p>这个标准比较抽象，使用了很多术语，初学者不容易理解。其实说起来并不复杂，下面我就通过一个简单的类比，帮助大家轻松理解，OAuth 2.0 到底是什么。</p>
<h2 id="快递员问题"><a href="#快递员问题" class="headerlink" title="快递员问题"></a>快递员问题</h2><p>我住在一个大型的居民小区。</p>
<p>小区有门禁系统。</p>
<p>进入的时候需要输入密码。</p>
<p>我经常网购和外卖，每天都有快递员来送货。我必须找到一个办法，让快递员通过门禁系统，进入小区。</p>
<p>如果我把自己的密码，告诉快递员，他就拥有了与我同样的权限，这样好像不太合适。万一我想取消他进入小区的权力，也很麻烦，我自己的密码也得跟着改了，还得通知其他的快递员。</p>
<p>有没有一种办法，让快递员能够自由进入小区，又不必知道小区居民的密码，而且他的唯一权限就是送货，其他需要密码的场合，他都没有权限？</p>
<h2 id="授权机制的设计"><a href="#授权机制的设计" class="headerlink" title="授权机制的设计"></a>授权机制的设计</h2><p>于是，我设计了一套授权机制。</p>
<p>第一步，门禁系统的密码输入器下面，增加一个按钮，叫做”获取授权”。快递员需要首先按这个按钮，去申请授权。</p>
<p>第二步，他按下按钮以后，屋主（也就是我）的手机就会跳出对话框：有人正在要求授权。系统还会显示该快递员的姓名、工号和所属的快递公司。</p>
<p>我确认请求属实，就点击按钮，告诉门禁系统，我同意给予他进入小区的授权。</p>
<p>第三步，门禁系统得到我的确认以后，向快递员显示一个进入小区的令牌（access token）。令牌就是类似密码的一串数字，只在短期内（比如七天）有效。</p>
<p>第四步，快递员向门禁系统输入令牌，进入小区。</p>
<p>有人可能会问，为什么不是远程为快递员开门，而要为他单独生成一个令牌？这是因为快递员可能每天都会来送货，第二天他还可以复用这个令牌。另外，有的小区有多重门禁，快递员可以使用同一个令牌通过它们。</p>
<h2 id="互联网场景"><a href="#互联网场景" class="headerlink" title="互联网场景"></a>互联网场景</h2><p>我们把上面的例子搬到互联网，就是 OAuth 的设计了。</p>
<p>首先，居民小区就是储存用户数据的网络服务。比如，微信储存了我的好友信息，获取这些信息，就必须经过微信的”门禁系统”。</p>
<p>其次，快递员（或者说快递公司）就是第三方应用，想要穿过门禁系统，进入小区。</p>
<p>最后，我就是用户本人，同意授权第三方应用进入小区，获取我的数据。</p>
<p><strong>简单说，OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。</strong></p>
<h2 id="令牌与密码"><a href="#令牌与密码" class="headerlink" title="令牌与密码"></a>令牌与密码</h2><p>令牌（token）与密码（password）的作用是一样的，都可以进入系统，但是有三点差异。</p>
<p>（1）令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。</p>
<p>（2）令牌可以被数据所有者撤销，会立即失效。以上例而言，屋主可以随时取消快递员的令牌。密码一般不允许被他人撤销。</p>
<p>（3）令牌有权限范围（scope），比如只能进小区的二号门。对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。</p>
<p>上面这些设计，保证了令牌既可以让第三方应用获得权限，同时又随时可控，不会危及系统安全。这就是 OAuth 2.0 的优点。</p>
<p>注意，只要知道了令牌，就能进入系统。系统一般不会再次确认身份，所以<strong>令牌必须保密，泄漏令牌与泄漏密码的后果是一样的。</strong> 这也是为什么令牌的有效期，一般都设置得很短的原因。</p>
<p>OAuth 2.0 对于如何颁发令牌的细节，规定得非常详细。具体来说，一共分成四种授权类型（authorization grant），即四种颁发令牌的方式，适用于不同的互联网场景。<span class="exturl" data-url="aHR0cHM6Ly93d3cucnVhbnlpZmVuZy5jb20vYmxvZy8yMDE5LzA0L29hdXRoLWdyYW50LXR5cGVzLmh0bWw=">下一篇文章<i class="fa fa-external-link-alt"></i></span>，我就来介绍这四种类型，并给出代码实例。</p>
<p>（完）</p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>安全框架</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>OAuth2的四种方式</title>
    <url>/posts/1Q13J82.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>原文：<span class="exturl" data-url="aHR0cHM6Ly93d3cucnVhbnlpZmVuZy5jb20vYmxvZy8yMDE5LzA0L29hdXRoLWdyYW50LXR5cGVzLmh0bWw=">OAuth 2.0 的四种方式<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cucnVhbnlpZmVuZy5jb20vYmxvZy8yMDE5LzA0L29hdXRoX2Rlc2lnbi5odG1s">上一篇文章<i class="fa fa-external-link-alt"></i></span>介绍了 OAuth 2.0 是一种授权机制，主要用来颁发令牌（token）。本文接着介绍颁发令牌的实务操作。</p>
<p>下面我假定，你已经理解了 OAuth 2.0 的含义和设计思想，否则请先阅读这个系列的<span class="exturl" data-url="aHR0cHM6Ly93d3cucnVhbnlpZmVuZy5jb20vYmxvZy8yMDE5LzA0L29hdXRoX2Rlc2lnbi5odG1s">上一篇文章<i class="fa fa-external-link-alt"></i></span>。</p>
<h2 id="RFC-6749"><a href="#RFC-6749" class="headerlink" title="RFC 6749"></a>RFC 6749</h2><p>OAuth 2.0 的标准是 <span class="exturl" data-url="aHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY3NDk=">RFC 6749<i class="fa fa-external-link-alt"></i></span> 文件。该文件先解释了 OAuth 是什么。</p>
<blockquote>
<p>OAuth 引入了一个授权层，用来分离两种不同的角色：客户端和资源所有者。……资源所有者同意以后，资源服务器可以向客户端颁发令牌。客户端通过令牌，去请求数据。</p>
</blockquote>
<p>这段话的意思就是，<strong>OAuth 的核心就是向第三方应用颁发令牌。</strong>然后，RFC 6749 接着写道：</p>
<blockquote>
<p>（由于互联网有多种场景，）本标准定义了获得令牌的四种授权方式（authorization grant ）。</p>
</blockquote>
<p>也就是说，<strong>OAuth 2.0 规定了四种获得令牌的流程。你可以选择最适合自己的那一种，向第三方应用颁发令牌。</strong>下面就是这四种授权方式。</p>
<blockquote>
<ul>
<li>授权码（authorization-code）</li>
<li>隐藏式（implicit）</li>
<li>密码式（password）：</li>
<li>客户端凭证（client credentials）</li>
</ul>
</blockquote>
<p>注意，不管哪一种授权方式，第三方应用申请令牌之前，都必须先到系统备案，说明自己的身份，然后会拿到两个身份识别码：客户端 ID（client ID）和客户端密钥（client secret）。这是为了防止令牌被滥用，没有备案过的第三方应用，是不会拿到令牌的。</p>
<h2 id="第一种授权方式：授权码"><a href="#第一种授权方式：授权码" class="headerlink" title="第一种授权方式：授权码"></a>第一种授权方式：授权码</h2><p><strong>授权码（authorization code）方式，指的是第三方应用先申请一个授权码，然后再用该码获取令牌。</strong></p>
<p>这种方式是最常用的流程，安全性也最高，它适用于那些有后端的 Web 应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。</p>
<p>第一步，A 网站提供一个链接，用户点击后就会跳转到 B 网站，授权用户数据给 A 网站使用。下面就是 A 网站跳转 B 网站的一个示意链接。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//b.com/oauth/authorize?</span></span><br><span class="line">  response_type=code&amp;</span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  redirect_uri=CALLBACK_URL&amp;</span><br><span class="line">  scope=read</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面 URL 中，<code>response_type</code>参数表示要求返回授权码（<code>code</code>），<code>client_id</code>参数让 B 知道是谁在请求，<code>redirect_uri</code>参数是 B 接受或拒绝请求后的跳转网址，<code>scope</code>参数表示要求的授权范围（这里是只读）。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/26/2034-mWwOGA.jpg" alt="img"></p>
<p>第二步，用户跳转后，B 网站会要求用户登录，然后询问是否同意给予 A 网站授权。用户表示同意，这时 B 网站就会跳回<code>redirect_uri</code>参数指定的网址。跳转时，会传回一个授权码，就像下面这样。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//a.com/callback?code=AUTHORIZATION_CODE</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面 URL 中，<code>code</code>参数就是授权码。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/26/2035-KL6o8Z.jpg" alt="img"></p>
<p>第三步，A 网站拿到授权码以后，就可以在后端，向 B 网站请求令牌。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//b.com/oauth/token?</span></span><br><span class="line"> client_id=CLIENT_ID&amp;</span><br><span class="line"> client_secret=CLIENT_SECRET&amp;</span><br><span class="line"> grant_type=authorization_code&amp;</span><br><span class="line"> code=AUTHORIZATION_CODE&amp;</span><br><span class="line"> redirect_uri=CALLBACK_URL</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面 URL 中，<code>client_id</code>参数和<code>client_secret</code>参数用来让 B 确认 A 的身份（<code>client_secret</code>参数是保密的，因此只能在后端发请求），<code>grant_type</code>参数的值是<code>AUTHORIZATION_CODE</code>，表示采用的授权方式是授权码，<code>code</code>参数是上一步拿到的授权码，<code>redirect_uri</code>参数是令牌颁发后的回调网址。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/26/2034-632Y9b.jpg" alt="img"></p>
<p>第四步，B 网站收到请求以后，就会颁发令牌。具体做法是向<code>redirect_uri</code>指定的网址，发送一段 JSON 数据。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">  <span class="string">&quot;access_token&quot;</span>:<span class="string">&quot;ACCESS_TOKEN&quot;</span>,</span><br><span class="line">  <span class="string">&quot;token_type&quot;</span>:<span class="string">&quot;bearer&quot;</span>,</span><br><span class="line">  <span class="string">&quot;expires_in&quot;</span>:<span class="number">2592000</span>,</span><br><span class="line">  <span class="string">&quot;refresh_token&quot;</span>:<span class="string">&quot;REFRESH_TOKEN&quot;</span>,</span><br><span class="line">  <span class="string">&quot;scope&quot;</span>:<span class="string">&quot;read&quot;</span>,</span><br><span class="line">  <span class="string">&quot;uid&quot;</span>:<span class="number">100101</span>,</span><br><span class="line">  <span class="string">&quot;info&quot;</span>:&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面 JSON 数据中，<code>access_token</code>字段就是令牌，A 网站在后端拿到了。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/26/2034-QzfDeQ.jpg" alt="img"></p>
<h2 id="第二种方式：隐藏式"><a href="#第二种方式：隐藏式" class="headerlink" title="第二种方式：隐藏式"></a>第二种方式：隐藏式</h2><p>有些 Web 应用是纯前端应用，没有后端。这时就不能用上面的方式了，必须将令牌储存在前端。<strong>RFC 6749 就规定了第二种方式，允许直接向前端颁发令牌。这种方式没有授权码这个中间步骤，所以称为（授权码）”隐藏式”（implicit）。</strong></p>
<p>第一步，A 网站提供一个链接，要求用户跳转到 B 网站，授权用户数据给 A 网站使用。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//b.com/oauth/authorize?</span></span><br><span class="line">  response_type=token&amp;</span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  redirect_uri=CALLBACK_URL&amp;</span><br><span class="line">  scope=read</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面 URL 中，<code>response_type</code>参数为<code>token</code>，表示要求直接返回令牌。</p>
<p>第二步，用户跳转到 B 网站，登录后同意给予 A 网站授权。这时，B 网站就会跳回<code>redirect_uri</code>参数指定的跳转网址，并且把令牌作为 URL 参数，传给 A 网站。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//a.com/callback#token=ACCESS_TOKEN</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面 URL 中，<code>token</code>参数就是令牌，A 网站因此直接在前端拿到令牌。</p>
<p>注意，令牌的位置是 URL 锚点（fragment），而不是查询字符串（querystring），这是因为 OAuth 2.0 允许跳转网址是 HTTP 协议，因此存在”中间人攻击”的风险，而浏览器跳转时，锚点不会发到服务器，就减少了泄漏令牌的风险。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/26/2035-vRAlMY.jpg" alt="img"></p>
<p>这种方式把令牌直接传给前端，是很不安全的。因此，只能用于一些安全要求不高的场景，并且令牌的有效期必须非常短，通常就是会话期间（session）有效，浏览器关掉，令牌就失效了。</p>
<h2 id="第三种方式：密码式"><a href="#第三种方式：密码式" class="headerlink" title="第三种方式：密码式"></a>第三种方式：密码式</h2><p><strong>如果你高度信任某个应用，RFC 6749 也允许用户把用户名和密码，直接告诉该应用。该应用就使用你的密码，申请令牌，这种方式称为”密码式”（password）。</strong></p>
<p>第一步，A 网站要求用户提供 B 网站的用户名和密码。拿到以后，A 就直接向 B 请求令牌。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//oauth.b.com/token?</span></span><br><span class="line">  grant_type=password&amp;</span><br><span class="line">  username=USERNAME&amp;</span><br><span class="line">  password=PASSWORD&amp;</span><br><span class="line">  client_id=CLIENT_ID</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面 URL 中，<code>grant_type</code>参数是授权方式，这里的<code>password</code>表示”密码式”，<code>username</code>和<code>password</code>是 B 的用户名和密码。</p>
<p>第二步，B 网站验证身份通过后，直接给出令牌。注意，这时不需要跳转，而是把令牌放在 JSON 数据里面，作为 HTTP 回应，A 因此拿到令牌。</p>
<p>这种方式需要用户给出自己的用户名/密码，显然风险很大，因此只适用于其他授权方式都无法采用的情况，而且必须是用户高度信任的应用。</p>
<h2 id="第四种方式：凭证式"><a href="#第四种方式：凭证式" class="headerlink" title="第四种方式：凭证式"></a>第四种方式：凭证式</h2><p><strong>最后一种方式是凭证式（client credentials），适用于没有前端的命令行应用，即在命令行下请求令牌。</strong></p>
<p>第一步，A 应用在命令行向 B 发出请求。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//oauth.b.com/token?</span></span><br><span class="line">  grant_type=client_credentials&amp;</span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  client_secret=CLIENT_SECRET</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面 URL 中，<code>grant_type</code>参数等于<code>client_credentials</code>表示采用凭证式，<code>client_id</code>和<code>client_secret</code>用来让 B 确认 A 的身份。</p>
<p>第二步，B 网站验证通过以后，直接返回令牌。</p>
<p>这种方式给出的令牌，是针对第三方应用的，而不是针对用户的，即有可能多个用户共享同一个令牌。</p>
<h2 id="令牌的使用"><a href="#令牌的使用" class="headerlink" title="令牌的使用"></a>令牌的使用</h2><p>A 网站拿到令牌以后，就可以向 B 网站的 API 请求数据了。</p>
<p>此时，每个发到 API 的请求，都必须带有令牌。具体做法是在请求的头信息，加上一个<code>Authorization</code>字段，令牌就放在这个字段里面。</p>
<blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -H <span class="string">&quot;Authorization: Bearer ACCESS_TOKEN&quot;</span> \</span><br><span class="line"><span class="string">&quot;https://api.b.com&quot;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令中，<code>ACCESS_TOKEN</code>就是拿到的令牌。</p>
<h2 id="更新令牌"><a href="#更新令牌" class="headerlink" title="更新令牌"></a>更新令牌</h2><p>令牌的有效期到了，如果让用户重新走一遍上面的流程，再申请一个新的令牌，很可能体验不好，而且也没有必要。OAuth 2.0 允许用户自动更新令牌。</p>
<p>具体方法是，B 网站颁发令牌的时候，一次性颁发两个令牌，一个用于获取数据，另一个用于获取新的令牌（refresh token 字段）。令牌到期前，用户使用 refresh token 发一个请求，去更新令牌。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">https:<span class="comment">//b.com/oauth/token?</span></span><br><span class="line">  grant_type=refresh_token&amp;</span><br><span class="line">  client_id=CLIENT_ID&amp;</span><br><span class="line">  client_secret=CLIENT_SECRET&amp;</span><br><span class="line">  refresh_token=REFRESH_TOKEN</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面 URL 中，<code>grant_type</code>参数为<code>refresh_token</code>表示要求更新令牌，<code>client_id</code>参数和<code>client_secret</code>参数用于确认身份，<code>refresh_token</code>参数就是用于更新令牌的令牌。</p>
<p>B 网站验证通过以后，就会颁发新的令牌。</p>
<p>写到这里，颁发令牌的四种方式就介绍完了。<span class="exturl" data-url="aHR0cHM6Ly93d3cucnVhbnlpZmVuZy5jb20vYmxvZy8yMDE5LzA0L2dpdGh1Yi1vYXV0aC5odG1s">下一篇文章<i class="fa fa-external-link-alt"></i></span>会编写一个真实的 Demo，演示如何通过 OAuth 2.0 向 GitHub 的 API 申请令牌，然后再用令牌获取数据。</p>
<p>（正文完）</p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>安全框架</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>彻底讲透Elasticsearch</title>
    <url>/posts/3N8921N.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>原文： <span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vamFqaWFuL3AvMTEyMjM5OTIuaHRtbA==">Elasticsearch 技术分析（九）：全文搜索引擎Elasticsearch，这篇文章给讲透了！ - JaJian - 博客园<i class="fa fa-external-link-alt"></i></span>  </p>
</blockquote>
<p>由于近期在公司内部做了一次 Elasticsearch 的分享，所以本篇主要是做一个总结，希望通过这篇文章能让读者大致了解 Elasticsearch 是做什么的以及它的使用和基本原理。</p>
<h2 id="生活中的数据"><a href="#生活中的数据" class="headerlink" title="生活中的数据"></a>生活中的数据</h2><p>搜索引擎是对数据的检索，所以我们先从生活中的数据说起。我们生活中的数据总体分为两种：</p>
<blockquote>
<ul>
<li>结构化数据</li>
<li>非结构化数据</li>
</ul>
</blockquote>
<p><strong>结构化数据：</strong> 也称作行数据，是由二维表结构来逻辑表达和实现的数据，严格地遵循数据格式与长度规范，主要通过关系型数据库进行存储和管理。指具有固定格式或有限长度的数据，如数据库，元数据等。</p>
<p><strong>非结构化数据：</strong> 又可称为全文数据，不定长或无固定格式，不适于由数据库二维表来表现，包括所有格式的办公文档、XML、HTML、Word 文档，邮件，各类报表、图片和咅频、视频信息等。</p>
<p>说明：如果要更细致的区分的话，XML、HTML 可划分为半结构化数据。因为它们也具有自己特定的标签格式，所以既可以根据需要按结构化数据来处理，也可抽取出纯文本按非结构化数据来处理。</p>
<p>根据两种数据分类，搜索也相应的分为两种：</p>
<blockquote>
<ul>
<li>结构化数据搜索</li>
<li>非结构化数据搜索</li>
</ul>
</blockquote>
<p>对于结构化数据，因为它们具有特定的结构，所以我们一般都是可以通过关系型数据库（MySQL，Oracle 等）的二维表（Table）的方式存储和搜索，也可以建立索引。</p>
<p>对于非结构化数据，也即对全文数据的搜索主要有两种方法：</p>
<blockquote>
<ul>
<li>顺序扫描</li>
<li>全文检索</li>
</ul>
</blockquote>
<p><strong>顺序扫描：</strong> <code>通过文字名称也可了解到它的大概搜索方式，即按照顺序扫描的方式查询特定的关键字</code>。</p>
<p>例如给你一张报纸，让你找到该报纸中“平安”的文字在哪些地方出现过。你肯定需要从头到尾把报纸阅读扫描一遍然后标记出关键字在哪些版块出现过以及它的出现位置。</p>
<p>这种方式无疑是最耗时的最低效的，如果报纸排版字体小，而且版块较多甚至有多份报纸，等你扫描完你的眼睛也差不多了。</p>
<p><strong>全文搜索：</strong> 对非结构化数据顺序扫描很慢，我们是否可以进行优化？把我们的非结构化数据想办法弄得有一定结构不就行了吗？</p>
<p>将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对此有一定结构的数据进行搜索，从而达到搜索相对较快的目的。</p>
<p>这种方式就构成了全文检索的基本思路。这部分从非结构化数据中提取出的然后重新组织的信息，我们称之为索引。</p>
<p>这种方式的主要工作量在前期索引的创建，但是对于后期搜索却是快速高效的。</p>
<h2 id="先说说-Lucene"><a href="#先说说-Lucene" class="headerlink" title="先说说 Lucene"></a>先说说 Lucene</h2><p>通过对生活中数据的类型作了一个简短了解之后，我们知道关系型数据库的 SQL 检索是处理不了这种非结构化数据的。</p>
<p>这种非结构化数据的处理需要依赖全文搜索，而目前市场上开放源代码的最好全文检索引擎工具包就属于 Apache 的 Lucene了。</p>
<p>但是 Lucene 只是一个工具包，它不是一个完整的全文检索引擎。Lucene 的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能，或者是以此为基础建立起完整的全文检索引擎。</p>
<p>目前以 Lucene 为基础建立的开源可用全文搜索引擎主要是 Solr 和 Elasticsearch。</p>
<p>Solr 和 Elasticsearch 都是比较成熟的全文搜索引擎，能完成的功能和性能也基本一样。</p>
<p>但是 ES 本身就具有分布式的特性和易安装使用的特点，而 Solr 的分布式需要借助第三方来实现，例如通过使用 ZooKeeper 来达到分布式协调管理。</p>
<p>不管是 Solr 还是 Elasticsearch 底层都是依赖于 Lucene，而 Lucene 能实现全文搜索主要是因为它实现了倒排索引的查询结构。</p>
<p>如何理解倒排索引呢？ 假如现有三份数据文档，文档的内容如下分别是：</p>
<blockquote>
<ul>
<li>Java is the best programming language.</li>
<li>PHP is the best programming language.</li>
<li>Javascript is the best programming language.</li>
</ul>
</blockquote>
<p>为了创建倒排索引，我们通过分词器将每个文档的内容域拆分成单独的词（我们称它为词条或 Term），创建一个包含所有不重复词条的排序列表，然后列出每个词条出现在哪个文档。</p>
<p>结果如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Term          Doc_1    Doc_2   Doc_3  </span><br><span class="line"></span><br><span class="line">Java        |   X   |        |  </span><br><span class="line">is          |   X   |   X    |   X  </span><br><span class="line">the         |   X   |   X    |   X  </span><br><span class="line">best        |   X   |   X    |   X  </span><br><span class="line">programming |   x   |   X    |   X  </span><br><span class="line">language    |   X   |   X    |   X  </span><br><span class="line">PHP         |       |   X    |  </span><br><span class="line">Javascript  |       |        |   X  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这种结构由文档中所有不重复词的列表构成，对于其中每个词都有一个文档列表与之关联。</p>
<p>这种由属性值来确定记录的位置的结构就是倒排索引。带有倒排索引的文件我们称为倒排文件。</p>
<p>我们将上面的内容转换为图的形式来说明倒排索引的结构信息，如下图所示：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/10/1024-IMR8gD.png" alt="图片"></p>
<p>其中主要有如下几个核心术语需要理解：</p>
<blockquote>
<ul>
<li><strong>词条（Term）：</strong> 索引里面最小的存储和查询单元，对于英文来说是一个单词，对于中文来说一般指分词后的一个词。</li>
<li><strong>词典（Term Dictionary）：</strong> 或字典，是词条 Term 的集合。搜索引擎的通常索引单位是单词，单词词典是由文档集合中出现过的所有单词构成的字符串集合，单词词典内每条索引项记载单词本身的一些信息以及指向“倒排列表”的指针。</li>
<li><strong>倒排表（Post list）：</strong> 一个文档通常由多个词组成，倒排表记录的是某个词在哪些文档里出现过以及出现的位置。每条记录称为一个倒排项（Posting）。倒排表记录的不单是文档编号，还存储了词频等信息。</li>
<li><strong>倒排文件（Inverted File）：</strong> 所有单词的倒排列表往往顺序地存储在磁盘的某个文件里，这个文件被称之为倒排文件，倒排文件是存储倒排索引的物理文件。</li>
</ul>
</blockquote>
<p>从上图我们可以了解到倒排索引主要由两个部分组成：</p>
<blockquote>
<ul>
<li>词典</li>
<li>倒排文件</li>
</ul>
</blockquote>
<p>词典和倒排表是 Lucene 中很重要的两种数据结构，是实现快速检索的重要基石。词典和倒排文件是分两部分存储的，词典在内存中而倒排文件存储在磁盘上。</p>
<h2 id="ES-核心概念"><a href="#ES-核心概念" class="headerlink" title="ES 核心概念"></a>ES 核心概念</h2><p>一些基础知识的铺垫之后我们正式进入今天的主角 Elasticsearch 的介绍。</p>
<p>ES 是使用 Java 编写的一种开源搜索引擎，它在内部使用 Lucene 做索引与搜索，通过对 Lucene 的封装，隐藏了 Lucene 的复杂性，取而代之的提供一套简单一致的 RESTful API。</p>
<p>然而，Elasticsearch 不仅仅是 Lucene，并且也不仅仅只是一个全文搜索引擎。</p>
<p>它可以被下面这样准确的形容：</p>
<blockquote>
<ul>
<li>一个分布式的实时文档存储，每个字段可以被索引与搜索。</li>
<li>一个分布式实时分析搜索引擎。</li>
<li>能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据。</li>
</ul>
</blockquote>
<p>官网对 Elasticsearch 的介绍是 Elasticsearch 是一个分布式、可扩展、近实时的搜索与数据分析引擎。</p>
<p>我们通过一些核心概念来看下 Elasticsearch 是如何做到分布式，可扩展和近实时搜索的。</p>
<h3 id="集群（Cluster）"><a href="#集群（Cluster）" class="headerlink" title="集群（Cluster）"></a>集群（Cluster）</h3><p>ES 的集群搭建很简单，不需要依赖第三方协调管理组件，自身内部就实现了集群的管理功能。</p>
<p>ES 集群由一个或多个 Elasticsearch 节点组成，每个节点配置相同的 cluster.name 即可加入集群，默认值为 “elasticsearch”。</p>
<p>确保不同的环境中使用不同的集群名称，否则最终会导致节点加入错误的集群。</p>
<p>一个 Elasticsearch 服务启动实例就是一个节点（Node）。节点通过 node.name 来设置节点名称，如果不设置则在启动时给节点分配一个随机通用唯一标识符作为名称。</p>
<h4 id="①发现机制"><a href="#①发现机制" class="headerlink" title="①发现机制"></a>①发现机制</h4><p>那么有一个问题，ES 内部是如何通过一个相同的设置 cluster.name 就能将不同的节点连接到同一个集群的？答案是 Zen Discovery。</p>
<p>Zen Discovery 是 Elasticsearch 的内置默认发现模块（发现模块的职责是发现集群中的节点以及选举 Master 节点）。</p>
<p>它提供单播和基于文件的发现，并且可以扩展为通过插件支持云环境和其他形式的发现。</p>
<p>Zen Discovery 与其他模块集成，例如，节点之间的所有通信都使用 Transport 模块完成。节点使用发现机制通过 Ping 的方式查找其他节点。</p>
<p>Elasticsearch 默认被配置为使用单播发现，以防止节点无意中加入集群。只有在同一台机器上运行的节点才会自动组成集群。</p>
<p>如果集群的节点运行在不同的机器上，使用单播，你可以为 Elasticsearch 提供一些它应该去尝试连接的节点列表。</p>
<p>当一个节点联系到单播列表中的成员时，它就会得到整个集群所有节点的状态，然后它会联系 Master 节点，并加入集群。</p>
<p>这意味着单播列表不需要包含集群中的所有节点， 它只是需要足够的节点，当一个新节点联系上其中一个并且说上话就可以了。</p>
<p>如果你使用 Master 候选节点作为单播列表，你只要列出三个就可以了。这个配置在 elasticsearch.yml 文件中：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">discovery<span class="selector-class">.zen</span><span class="selector-class">.ping</span><span class="selector-class">.unicast</span><span class="selector-class">.hosts</span>: <span class="selector-attr">[<span class="string">&quot;host1&quot;</span>, <span class="string">&quot;host2:port&quot;</span>]</span>  </span><br></pre></td></tr></table></figure>
<p>节点启动后先 Ping ，如果 <code>discovery.zen.ping.unicast.hosts</code> 有设置，则 Ping 设置中的 Host ，否则尝试 ping localhost 的几个端口。</p>
<p>Elasticsearch 支持同一个主机启动多个节点，Ping 的 Response 会包含该节点的基本信息以及该节点认为的 Master 节点。</p>
<p>选举开始，先从各节点认为的 Master 中选，规则很简单，按照 ID 的字典序排序，取第一个。如果各节点都没有认为的 Master ，则从所有节点中选择，规则同上。</p>
<p>这里有个限制条件就是 <code>discovery.zen.minimum_master_nodes</code> ，如果节点数达不到最小值的限制，则循环上述过程，直到节点数足够可以开始选举。</p>
<p>最后选举结果是肯定能选举出一个 Master ，如果只有一个 Local 节点那就选出的是自己。</p>
<p>如果当前节点是 Master ，则开始等待节点数达到 <code>discovery.zen.minimum_master_nodes</code>，然后提供服务。</p>
<p>如果当前节点不是 Master ，则尝试加入 Master 。Elasticsearch 将以上服务发现以及选主的流程叫做 Zen Discovery 。</p>
<p>由于它支持任意数目的集群（ 1- N ），所以不能像 Zookeeper 那样限制节点必须是奇数，也就无法用投票的机制来选主，而是通过一个规则。</p>
<p>只要所有的节点都遵循同样的规则，得到的信息都是对等的，选出来的主节点肯定是一致的。</p>
<p>但分布式系统的问题就出在信息不对等的情况，这时候很容易出现脑裂（Split-Brain）的问题。</p>
<p>大多数解决方案就是设置一个 Quorum 值，要求可用节点必须大于 Quorum（一般是超过半数节点），才能对外提供服务。</p>
<p>而 Elasticsearch 中，这个 Quorum 的配置就是 <code>discovery.zen.minimum_master_nodes</code> 。</p>
<h4 id="②节点的角色"><a href="#②节点的角色" class="headerlink" title="②节点的角色"></a>②节点的角色</h4><p>每个节点既可以是候选主节点也可以是数据节点，通过在配置文件 ../config/elasticsearch.yml 中设置即可，默认都为 true。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">node.master: <span class="literal">true</span>  <span class="comment">//是否候选主节点  </span></span><br><span class="line">node.<span class="keyword">data</span>: <span class="literal">true</span>    <span class="comment">//是否数据节点  </span></span><br></pre></td></tr></table></figure>
<p>数据节点负责数据的存储和相关的操作，例如对数据进行增、删、改、查和聚合等操作，所以数据节点（Data 节点）对机器配置要求比较高，对 CPU、内存和 I/O 的消耗很大。</p>
<p>通常随着集群的扩大，需要增加更多的数据节点来提高性能和可用性。</p>
<p>候选主节点可以被选举为主节点（Master 节点），集群中只有候选主节点才有选举权和被选举权，其他节点不参与选举的工作。</p>
<p>主节点负责创建索引、删除索引、跟踪哪些节点是群集的一部分，并决定哪些分片分配给相关的节点、追踪集群中节点的状态等，稳定的主节点对集群的健康是非常重要的。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/10/1100-aOqGch.jpeg" alt="图片"></p>
<p>一个节点既可以是候选主节点也可以是数据节点，但是由于数据节点对 CPU、内存核 I/O 消耗都很大。</p>
<p>所以如果某个节点既是数据节点又是主节点，那么可能会对主节点产生影响从而对整个集群的状态产生影响。</p>
<p>因此为了提高集群的健康性，我们应该对 Elasticsearch 集群中的节点做好角色上的划分和隔离。可以使用几个配置较低的机器群作为候选主节点群。</p>
<p>主节点和其他节点之间通过 Ping 的方式互检查，主节点负责 Ping 所有其他节点，判断是否有节点已经挂掉。其他节点也通过 Ping 的方式判断主节点是否处于可用状态。</p>
<p>虽然对节点做了角色区分，但是用户的请求可以发往任何一个节点，并由该节点负责分发请求、收集结果等操作，而不需要主节点转发。</p>
<p>这种节点可称之为协调节点，协调节点是不需要指定和配置的，集群中的任何节点都可以充当协调节点的角色。</p>
<h4 id="③脑裂现象"><a href="#③脑裂现象" class="headerlink" title="③脑裂现象"></a>③脑裂现象</h4><p>同时如果由于网络或其他原因导致集群中选举出多个 Master 节点，使得数据更新时出现不一致，这种现象称之为脑裂，即集群中不同的节点对于 Master 的选择出现了分歧，出现了多个 Master 竞争。</p>
<p>“脑裂”问题可能有以下几个原因造成：</p>
<ul>
<li><strong>网络问题：</strong> 集群间的网络延迟导致一些节点访问不到 Master，认为 Master 挂掉了从而选举出新的 Master，并对 Master 上的分片和副本标红，分配新的主分片。</li>
<li><strong>节点负载：</strong> 主节点的角色既为 Master 又为 Data，访问量较大时可能会导致 ES 停止响应（假死状态）造成大面积延迟，此时其他节点得不到主节点的响应认为主节点挂掉了，会重新选取主节点。</li>
<li><strong>内存回收：</strong> 主节点的角色既为 Master 又为 Data，当 Data 节点上的 ES 进程占用的内存较大，引发 JVM 的大规模内存回收，造成 ES 进程失去响应。</li>
</ul>
<p>为了避免脑裂现象的发生，我们可以从原因着手通过以下几个方面来做出优化措施：</p>
<ul>
<li><strong>适当调大响应时间，减少误判。</strong> 通过参数 discovery.zen.ping_timeout 设置节点状态的响应时间，默认为 3s，可以适当调大。</li>
</ul>
<p>如果 Master 在该响应时间的范围内没有做出响应应答，判断该节点已经挂掉了。调大参数（如 6s，<code>discovery.zen.ping_timeout:6</code>），可适当减少误判。</p>
<ul>
<li><strong>选举触发。</strong> 我们需要在候选集群中的节点的配置文件中设置参数 <code>discovery.zen.munimum_master_nodes</code> 的值。</li>
</ul>
<p>这个参数表示在选举主节点时需要参与选举的候选主节点的节点数，默认值是 1，官方建议取值(<code>master_eligibel_nodes2)+1</code>，其中 <code>master_eligibel_nodes</code> 为候选主节点的个数。</p>
<p>这样做既能防止脑裂现象的发生，也能最大限度地提升集群的高可用性，因为只要不少于 <code>discovery.zen.munimum_master_nodes</code> 个候选节点存活，选举工作就能正常进行。</p>
<p>当小于这个值的时候，无法触发选举行为，集群无法使用，不会造成分片混乱的情况。</p>
<ul>
<li><strong>角色分离。</strong> 即是上面我们提到的候选主节点和数据节点进行角色分离，这样可以减轻主节点的负担，防止主节点的假死状态发生，减少对主节点“已死”的误判。</li>
</ul>
<h3 id="分片（Shards）"><a href="#分片（Shards）" class="headerlink" title="分片（Shards）"></a>分片（Shards）</h3><p>ES 支持 PB 级全文搜索，当索引上的数据量太大的时候，ES 通过水平拆分的方式将一个索引上的数据拆分出来分配到不同的数据块上，拆分出来的数据库块称之为一个分片。</p>
<p>这类似于 MySQL 的分库分表，只不过 MySQL 分库分表需要借助第三方组件而 ES 内部自身实现了此功能。</p>
<p>在一个多分片的索引中写入数据时，通过路由来确定具体写入哪一个分片中，所以在创建索引的时候需要指定分片的数量，并且分片的数量一旦确定就不能修改。</p>
<p>分片的数量和下面介绍的副本数量都是可以通过创建索引时的 Settings 来配置，ES 默认为一个索引创建 5 个主分片, 并分别为每个分片创建一个副本。</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">PUT /myIndex  </span><br><span class="line">&#123;  </span><br><span class="line">   <span class="string">&quot;settings&quot;</span> : &#123;  </span><br><span class="line">      <span class="string">&quot;number_of_shards&quot;</span> : 5,  </span><br><span class="line">      <span class="string">&quot;number_of_replicas&quot;</span> : 1  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>ES 通过分片的功能使得索引在规模上和性能上都得到提升，每个分片都是 Lucene 中的一个索引文件，每个分片必须有一个主分片和零到多个副本。</p>
<h3 id="副本（Replicas）"><a href="#副本（Replicas）" class="headerlink" title="副本（Replicas）"></a>副本（Replicas）</h3><p>副本就是对分片的 Copy，每个主分片都有一个或多个副本分片，当主分片异常时，副本可以提供数据的查询等操作。</p>
<p>主分片和对应的副本分片是不会在同一个节点上的，所以副本分片数的最大值是 N-1（其中 N 为节点数）。</p>
<p>对文档的新建、索引和删除请求都是写操作，必须在主分片上面完成之后才能被复制到相关的副本分片。</p>
<p>ES 为了提高写入的能力这个过程是并发写的，同时为了解决并发写的过程中数据冲突的问题，ES 通过乐观锁的方式控制，每个文档都有一个<code>_version</code> （版本）号，当文档被修改时版本号递增。</p>
<p>一旦所有的副本分片都报告写成功才会向协调节点报告成功，协调节点向客户端报告成功。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/10/1101-yqpKgY.png" alt="图片"></p>
<p>从上图可以看出为了达到高可用，Master 节点会避免将主分片和副本分片放在同一个节点上。</p>
<p>假设这时节点 Node1 服务宕机了或者网络不可用了，那么主节点上主分片 S0 也就不可用了。</p>
<p>幸运的是还存在另外两个节点能正常工作，这时 ES 会重新选举新的主节点，而且这两个节点上存在我们所需要的 S0 的所有数据。</p>
<p>我们会将 S0 的副本分片提升为主分片，这个提升主分片的过程是瞬间发生的。此时集群的状态将会为  Yellow。</p>
<p>为什么我们集群状态是 Yellow 而不是 Green 呢？虽然我们拥有所有的 2 个主分片，但是同时设置了每个主分片需要对应两份副本分片，而此时只存在一份副本分片。所以集群不能为 Green 的状态。</p>
<p>如果我们同样关闭了 Node2 ，我们的程序依然可以保持在不丢失任何数据的情况下运行，因为 Node3 为每一个分片都保留着一份副本。</p>
<p>如果我们重新启动 Node1 ，集群可以将缺失的副本分片再次进行分配，那么集群的状态又将恢复到原来的正常状态。</p>
<p>如果 Node1 依然拥有着之前的分片，它将尝试去重用它们，只不过这时 Node1 节点上的分片不再是主分片而是副本分片了，如果期间有更改的数据只需要从主分片上复制修改的数据文件即可。</p>
<h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><ul>
<li>将数据分片是为了提高可处理数据的容量和易于进行水平扩展，为分片做副本是为了提高集群的稳定性和提高并发量。</li>
<li>副本是乘法，越多消耗越大，但也越保险。分片是除法，分片越多，单分片数据就越少也越分散。</li>
<li>副本越多，集群的可用性就越高，但是由于每个分片都相当于一个 Lucene 的索引文件，会占用一定的文件句柄、内存及 CPU。并且分片间的数据同步也会占用一定的网络带宽，所以索引的分片数和副本数也不是越多越好。</li>
</ul>
<h3 id="映射（Mapping）"><a href="#映射（Mapping）" class="headerlink" title="映射（Mapping）"></a>映射（Mapping）</h3><p>映射是用于定义 ES 对索引中字段的存储类型、分词方式和是否存储等信息，就像数据库中的 Schema ，描述了文档可能具有的字段或属性、每个字段的数据类型。</p>
<p>只不过关系型数据库建表时必须指定字段类型，而 ES 对于字段类型可以不指定然后动态对字段类型猜测，也可以在创建索引时具体指定字段的类型。</p>
<p>对字段类型根据数据格式自动识别的映射称之为动态映射（Dynamic Mapping），我们创建索引时具体定义字段类型的映射称之为静态映射或显示映射（Explicit Mapping）。</p>
<p>在讲解动态映射和静态映射的使用前，我们先来了解下 ES 中的数据有哪些字段类型？之后我们再讲解为什么我们创建索引时需要建立静态映射而不使用动态映射。</p>
<p>ES（v6.8）中字段数据类型主要有以下几类：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/10/1101-aQjEet.png" alt="图片"></p>
<p>Text 用于索引全文值的字段，例如电子邮件正文或产品说明。这些字段是被分词的，它们通过分词器传递 ，以在被索引之前将字符串转换为单个术语的列表。</p>
<p>分析过程允许 Elasticsearch 搜索单个单词中每个完整的文本字段。文本字段不用于排序，很少用于聚合。</p>
<p>Keyword 用于索引结构化内容的字段，例如电子邮件地址，主机名，状态代码，邮政编码或标签。它们通常用于过滤，排序，和聚合。Keyword 字段只能按其确切值进行搜索。</p>
<p>通过对字段类型的了解我们知道有些字段需要明确定义的，例如某个字段是 Text 类型还是 Keyword 类型差别是很大的，时间字段也许我们需要指定它的时间格式，还有一些字段我们需要指定特定的分词器等等。</p>
<p>如果采用动态映射是不能精确做到这些的，自动识别常常会与我们期望的有些差异。</p>
<p>所以创建索引的时候一个完整的格式应该是指定分片和副本数以及 Mapping 的定义，如下：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">PUT my_index   </span><br><span class="line">&#123;  </span><br><span class="line">   <span class="string">&quot;settings&quot;</span> : &#123;  </span><br><span class="line">      <span class="string">&quot;number_of_shards&quot;</span> : 5,  </span><br><span class="line">      <span class="string">&quot;number_of_replicas&quot;</span> : 1  </span><br><span class="line">   &#125;  </span><br><span class="line">  <span class="string">&quot;mappings&quot;</span>: &#123;  </span><br><span class="line">    <span class="string">&quot;_doc&quot;</span>: &#123;   </span><br><span class="line">      <span class="string">&quot;properties&quot;</span>: &#123;   </span><br><span class="line">        <span class="string">&quot;title&quot;</span>:    &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>  &#125;,   </span><br><span class="line">        <span class="string">&quot;name&quot;</span>:     &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>  &#125;,   </span><br><span class="line">        <span class="string">&quot;age&quot;</span>:      &#123; <span class="string">&quot;type&quot;</span>: <span class="string">&quot;integer&quot;</span> &#125;,    </span><br><span class="line">        <span class="string">&quot;created&quot;</span>:  &#123;  </span><br><span class="line">          <span class="string">&quot;type&quot;</span>:   <span class="string">&quot;date&quot;</span>,   </span><br><span class="line">          <span class="string">&quot;format&quot;</span>: <span class="string">&quot;strict_date_optional_time||epoch_millis&quot;</span>  </span><br><span class="line">        &#125;  </span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h2 id="ES-的基本使用"><a href="#ES-的基本使用" class="headerlink" title="ES 的基本使用"></a>ES 的基本使用</h2><p>在决定使用 Elasticsearch 的时候首先要考虑的是版本问题，Elasticsearch （排除 0.x 和 1.x）目前有如下常用的稳定的主版本：2.x，5.x，6.x，7.x（current）。</p>
<p>你可能会发现没有 3.x 和 4.x，ES 从 2.4.6 直接跳到了 5.0.0。其实是为了 ELK（ElasticSearch，Logstash，Kibana）技术栈的版本统一，免的给用户带来混乱。</p>
<p>在 Elasticsearch 是 2.x （2.x 的最后一版 2.4.6 的发布时间是 July 25, 2017） 的情况下，Kibana 已经是 4.x（Kibana 4.6.5 的发布时间是 July 25, 2017）。</p>
<p>那么在 Kibana 的下一主版本肯定是 5.x 了，所以 Elasticsearch 直接将自己的主版本发布为 5.0.0 了。</p>
<p>统一之后，我们选版本就不会犹豫困惑了，我们选定 Elasticsearch 的版本后再选择相同版本的 Kibana 就行了，不用担忧版本不兼容的问题。</p>
<p>Elasticsearch 是使用 Java 构建，所以除了注意 ELK 技术的版本统一，我们在选择 Elasticsearch 的版本的时候还需要注意 JDK 的版本。</p>
<p>因为每个大版本所依赖的 JDK 版本也不同，目前 7.2 版本已经可以支持 JDK11。</p>
<h3 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h3><p><img data-src="https://xuemingde.com/pages/image/2022/04/10/1103-zUwx70.png" alt="图片"></p>
<p>①下载和解压 Elasticsearch，无需安装解压后即可用，解压后目录如上图：</p>
<blockquote>
<ul>
<li><code>bin</code>：二进制系统指令目录，包含启动命令和安装插件命令等。</li>
<li><code>config</code>：配置文件目录。</li>
<li><code>data</code>：数据存储目录。</li>
<li><code>lib</code>：依赖包目录。</li>
<li><code>logs</code>：日志文件目录。</li>
<li><code>modules</code>：模块库，例如 x-pack 的模块。</li>
<li><code>plugins</code>：插件目录。</li>
</ul>
</blockquote>
<p>②安装目录下运行 <code>bin/elasticsearch</code> 来启动 ES。</p>
<p>③默认在 9200 端口运行，请求 curl <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo5MjAwLw==">http://localhost:9200/<i class="fa fa-external-link-alt"></i></span> 或者浏览器输入 <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo5MjAw77yM5b6X5Yiw5LiA5Liq">http://localhost:9200，得到一个<i class="fa fa-external-link-alt"></i></span> JSON 对象，其中包含当前节点、集群、版本等信息。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">  <span class="attr">&quot;name&quot;</span> : <span class="string">&quot;U7fp3O9&quot;</span>,  </span><br><span class="line">  <span class="attr">&quot;cluster_name&quot;</span> : <span class="string">&quot;elasticsearch&quot;</span>,  </span><br><span class="line">  <span class="attr">&quot;cluster_uuid&quot;</span> : <span class="string">&quot;-Rj8jGQvRIelGd9ckicUOA&quot;</span>,  </span><br><span class="line">  <span class="attr">&quot;version&quot;</span> : &#123;  </span><br><span class="line">    <span class="attr">&quot;number&quot;</span> : <span class="string">&quot;6.8.1&quot;</span>,  </span><br><span class="line">    <span class="attr">&quot;build_flavor&quot;</span> : <span class="string">&quot;default&quot;</span>,  </span><br><span class="line">    <span class="attr">&quot;build_type&quot;</span> : <span class="string">&quot;zip&quot;</span>,  </span><br><span class="line">    <span class="attr">&quot;build_hash&quot;</span> : <span class="string">&quot;1fad4e1&quot;</span>,  </span><br><span class="line">    <span class="attr">&quot;build_date&quot;</span> : <span class="string">&quot;2019-06-18T13:16:52.517138Z&quot;</span>,  </span><br><span class="line">    <span class="attr">&quot;build_snapshot&quot;</span> : <span class="literal">false</span>,  </span><br><span class="line">    <span class="attr">&quot;lucene_version&quot;</span> : <span class="string">&quot;7.7.0&quot;</span>,  </span><br><span class="line">    <span class="attr">&quot;minimum_wire_compatibility_version&quot;</span> : <span class="string">&quot;5.6.0&quot;</span>,  </span><br><span class="line">    <span class="attr">&quot;minimum_index_compatibility_version&quot;</span> : <span class="string">&quot;5.0.0&quot;</span>  </span><br><span class="line">  &#125;,  </span><br><span class="line">  <span class="attr">&quot;tagline&quot;</span> : <span class="string">&quot;You Know, for Search&quot;</span>  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h3 id="集群健康状态"><a href="#集群健康状态" class="headerlink" title="集群健康状态"></a>集群健康状态</h3><p>要检查群集运行状况，我们可以在 Kibana 控制台中运行以下命令 GET /_cluster/health，得到如下信息：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">  <span class="attr">&quot;cluster_name&quot;</span> : <span class="string">&quot;wujiajian&quot;</span>,  </span><br><span class="line">  <span class="attr">&quot;status&quot;</span> : <span class="string">&quot;yellow&quot;</span>,  </span><br><span class="line">  <span class="attr">&quot;timed_out&quot;</span> : <span class="literal">false</span>,  </span><br><span class="line">  <span class="attr">&quot;number_of_nodes&quot;</span> : <span class="number">1</span>,  </span><br><span class="line">  <span class="attr">&quot;number_of_data_nodes&quot;</span> : <span class="number">1</span>,  </span><br><span class="line">  <span class="attr">&quot;active_primary_shards&quot;</span> : <span class="number">9</span>,  </span><br><span class="line">  <span class="attr">&quot;active_shards&quot;</span> : <span class="number">9</span>,  </span><br><span class="line">  <span class="attr">&quot;relocating_shards&quot;</span> : <span class="number">0</span>,  </span><br><span class="line">  <span class="attr">&quot;initializing_shards&quot;</span> : <span class="number">0</span>,  </span><br><span class="line">  <span class="attr">&quot;unassigned_shards&quot;</span> : <span class="number">5</span>,  </span><br><span class="line">  <span class="attr">&quot;delayed_unassigned_shards&quot;</span> : <span class="number">0</span>,  </span><br><span class="line">  <span class="attr">&quot;number_of_pending_tasks&quot;</span> : <span class="number">0</span>,  </span><br><span class="line">  <span class="attr">&quot;number_of_in_flight_fetch&quot;</span> : <span class="number">0</span>,  </span><br><span class="line">  <span class="attr">&quot;task_max_waiting_in_queue_millis&quot;</span> : <span class="number">0</span>,  </span><br><span class="line">  <span class="attr">&quot;active_shards_percent_as_number&quot;</span> : <span class="number">64.28571428571429</span>  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>集群状态通过 绿，黄，红 来标识：</p>
<blockquote>
<ul>
<li>绿色：集群健康完好，一切功能齐全正常，所有分片和副本都可以正常工作。</li>
<li>黄色：预警状态，所有主分片功能正常，但至少有一个副本是不能正常工作的。此时集群是可以正常工作的，但是高可用性在某种程度上会受影响。</li>
<li>红色：集群不可正常使用。某个或某些分片及其副本异常不可用，这时集群的查询操作还能执行，但是返回的结果会不准确。对于分配到这个分片的写入请求将会报错，最终会导致数据的丢失。</li>
</ul>
</blockquote>
<p>当集群状态为红色时，它将会继续从可用的分片提供搜索请求服务，但是你需要尽快修复那些未分配的分片。</p>
<h2 id="ES-机制原理"><a href="#ES-机制原理" class="headerlink" title="ES 机制原理"></a>ES 机制原理</h2><p>ES 的基本概念和基本操作介绍完了之后，我们可能还有很多疑惑：</p>
<blockquote>
<ul>
<li>它们内部是如何运行的？</li>
<li>主分片和副本分片是如何同步的？</li>
<li>创建索引的流程是什么样的？</li>
<li>ES 如何将索引数据分配到不同的分片上的？以及这些索引数据是如何存储的？</li>
<li>为什么说 ES 是近实时搜索引擎而文档的 CRUD (创建-读取-更新-删除) 操作是实时的？</li>
<li>以及 Elasticsearch 是怎样保证更新被持久化在断电时也不丢失数据？</li>
<li>还有为什么删除文档不会立刻释放空间？</li>
</ul>
</blockquote>
<p>带着这些疑问我们进入接下来的内容。</p>
<h3 id="写索引原理"><a href="#写索引原理" class="headerlink" title="写索引原理"></a>写索引原理</h3><p>下图描述了 3 个节点的集群，共拥有 12 个分片，其中有 4 个主分片（S0、S1、S2、S3）和 8 个副本分片（R0、R1、R2、R3），每个主分片对应两个副本分片，节点 1 是主节点（Master 节点）负责整个集群的状态。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/10/1104-dX9QIi.png" alt="图片"></p>
<p>写索引是只能写在主分片上，然后同步到副本分片。这里有四个主分片，一条数据 ES 是根据什么规则写到特定分片上的呢？</p>
<p>这条索引数据为什么被写到 S0 上而不写到 S1 或 S2 上？那条数据为什么又被写到 S3 上而不写到 S0 上了？</p>
<p>首先这肯定不会是随机的，否则将来要获取文档的时候我们就不知道从何处寻找了。</p>
<p>实际上，这个过程是根据下面这个公式决定的：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">shard</span> = hash(routing) % number_of_primary_shards  </span><br></pre></td></tr></table></figure>
<p>Routing 是一个可变值，默认是文档的<code>_id</code> ，也可以设置成一个自定义的值。</p>
<p>Routing 通过 Hash 函数生成一个数字，然后这个数字再除以 <code>number_of_primary_shards</code> （主分片的数量）后得到余数。</p>
<p>这个在 0 到 <code>number_of_primary_shards-1</code> 之间的余数，就是我们所寻求的文档所在分片的位置。</p>
<p>这就解释了为什么我们要在创建索引的时候就确定好主分片的数量并且永远不会改变这个数量：因为如果数量变化了，那么所有之前路由的值都会无效，文档也再也找不到了。</p>
<p>由于在 ES 集群中每个节点通过上面的计算公式都知道集群中的文档的存放位置，所以每个节点都有处理读写请求的能力。</p>
<p>在一个写请求被发送到某个节点后，该节点即为前面说过的协调节点，协调节点会根据路由公式计算出需要写到哪个分片上，再将请求转发到该分片的主分片节点上。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/10/1104-FD6fKO.jpeg" alt="图片"></p>
<p>假如此时数据通过路由计算公式取余后得到的值是 <code>shard=hash(routing)%4=0</code>。</p>
<p>则具体流程如下：</p>
<blockquote>
<ul>
<li>客户端向 ES1 节点（协调节点）发送写请求，通过路由计算公式得到值为 0，则当前数据应被写到主分片 S0 上。</li>
<li>ES1 节点将请求转发到 S0 主分片所在的节点 ES3，ES3 接受请求并写入到磁盘。</li>
<li>并发将数据复制到两个副本分片 R0 上，其中通过乐观并发控制数据的冲突。一旦所有的副本分片都报告成功，则节点 ES3 将向协调节点报告成功，协调节点向客户端报告成功。</li>
</ul>
</blockquote>
<h3 id="存储原理"><a href="#存储原理" class="headerlink" title="存储原理"></a>存储原理</h3><p>上面介绍了在 ES 内部索引的写处理流程，这个流程是在 ES 的内存中执行的，数据被分配到特定的分片和副本上之后，最终是存储到磁盘上的，这样在断电的时候就不会丢失数据。</p>
<p>具体的存储路径可在配置文件 <code>../config/elasticsearch.yml</code>中进行设置，默认存储在安装目录的 Data 文件夹下。</p>
<p>建议不要使用默认值，因为若 ES 进行了升级，则有可能导致数据全部丢失：</p>
<figure class="highlight xl"><table><tr><td class="code"><pre><span class="line"><span class="built_in">path</span>.<span class="keyword">data</span>: /<span class="built_in">path</span>/to/<span class="keyword">data</span>  <span class="comment">//索引数据  </span></span><br><span class="line"><span class="built_in">path</span>.logs: /<span class="built_in">path</span>/to/logs  <span class="comment">//日志记录  </span></span><br></pre></td></tr></table></figure>
<h4 id="①分段存储"><a href="#①分段存储" class="headerlink" title="①分段存储"></a>①分段存储</h4><p>索引文档以段的形式存储在磁盘上，何为段？索引文件被拆分为多个子文件，则每个子文件叫作段，每一个段本身都是一个倒排索引，并且段具有不变性，一旦索引的数据被写入硬盘，就不可再修改。</p>
<p>在底层采用了分段的存储模式，使它在读写时几乎完全避免了锁的出现，大大提升了读写性能。</p>
<p>段被写入到磁盘后会生成一个提交点，提交点是一个用来记录所有提交后段信息的文件。</p>
<p>一个段一旦拥有了提交点，就说明这个段只有读的权限，失去了写的权限。相反，当段在内存中时，就只有写的权限，而不具备读数据的权限，意味着不能被检索。</p>
<p>段的概念提出主要是因为：在早期全文检索中为整个文档集合建立了一个很大的倒排索引，并将其写入磁盘中。</p>
<p>如果索引有更新，就需要重新全量创建一个索引来替换原来的索引。这种方式在数据量很大时效率很低，并且由于创建一次索引的成本很高，所以对数据的更新不能过于频繁，也就不能保证时效性。</p>
<p>索引文件分段存储并且不可修改，那么新增、更新和删除如何处理呢？</p>
<blockquote>
<ul>
<li>新增，新增很好处理，由于数据是新的，所以只需要对当前文档新增一个段就可以了。</li>
<li>删除，由于不可修改，所以对于删除操作，不会把文档从旧的段中移除而是通过新增一个 .del 文件，文件中会列出这些被删除文档的段信息。这个被标记删除的文档仍然可以被查询匹配到， 但它会在最终结果被返回前从结果集中移除。</li>
<li>更新，不能修改旧的段来进行反映文档的更新，其实更新相当于是删除和新增这两个动作组成。会将旧的文档在 .del 文件中标记删除，然后文档的新版本被索引到一个新的段中。可能两个版本的文档都会被一个查询匹配到，但被删除的那个旧版本文档在结果集返回前就会被移除。</li>
</ul>
</blockquote>
<p>段被设定为不可修改具有一定的优势也有一定的缺点，优势主要表现在：</p>
<blockquote>
<ul>
<li>不需要锁。如果你从来不更新索引，你就不需要担心多进程同时修改数据的问题。</li>
<li>一旦索引被读入内核的文件系统缓存，便会留在哪里，由于其不变性。只要文件系统缓存中还有足够的空间，那么大部分读请求会直接请求内存，而不会命中磁盘。这提供了很大的性能提升。</li>
<li>其它缓存(像 Filter 缓存)，在索引的生命周期内始终有效。它们不需要在每次数据改变时被重建，因为数据不会变化。</li>
<li>写入单个大的倒排索引允许数据被压缩，减少磁盘 I/O 和需要被缓存到内存的索引的使用量。</li>
</ul>
</blockquote>
<p>段的不变性的缺点如下：</p>
<blockquote>
<ul>
<li>当对旧数据进行删除时，旧数据不会马上被删除，而是在 .del 文件中被标记为删除。而旧数据只能等到段更新时才能被移除，这样会造成大量的空间浪费。</li>
<li>若有一条数据频繁的更新，每次更新都是新增新的标记旧的，则会有大量的空间浪费。</li>
<li>每次新增数据时都需要新增一个段来存储数据。当段的数量太多时，对服务器的资源例如文件句柄的消耗会非常大。</li>
<li>在查询的结果中包含所有的结果集，需要排除被标记删除的旧数据，这增加了查询的负担。</li>
</ul>
</blockquote>
<h4 id="②延迟写策略"><a href="#②延迟写策略" class="headerlink" title="②延迟写策略"></a>②延迟写策略</h4><p>介绍完了存储的形式，那么索引写入到磁盘的过程是怎样的？是否是直接调 Fsync 物理性地写入磁盘？</p>
<p>答案是显而易见的，如果是直接写入到磁盘上，磁盘的 I/O 消耗上会严重影响性能。</p>
<p>那么当写数据量大的时候会造成 ES 停顿卡死，查询也无法做到快速响应。如果真是这样 ES 也就不会称之为近实时全文搜索引擎了。</p>
<p>为了提升写的性能，ES 并没有每新增一条数据就增加一个段到磁盘上，而是采用延迟写的策略。</p>
<p>每当有新增的数据时，就将其先写入到内存中，在内存和磁盘之间是文件系统缓存。</p>
<p>当达到默认的时间（1 秒钟）或者内存的数据达到一定量时，会触发一次刷新（Refresh），将内存中的数据生成到一个新的段上并缓存到文件缓存系统 上，稍后再被刷新到磁盘中并生成提交点。</p>
<p>这里的内存使用的是 ES 的 JVM 内存，而文件缓存系统使用的是操作系统的内存。</p>
<p>新的数据会继续的被写入内存，但内存中的数据并不是以段的形式存储的，因此不能提供检索功能。</p>
<p>由内存刷新到文件缓存系统的时候会生成新的段，并将段打开以供搜索使用，而不需要等到被刷新到磁盘。</p>
<p>在 Elasticsearch 中，写入和打开一个新段的轻量的过程叫做 Refresh （即内存刷新到文件缓存系统）。</p>
<p>默认情况下每个分片会每秒自动刷新一次。这就是为什么我们说 Elasticsearch 是近实时搜索，因为文档的变化并不是立即对搜索可见，但会在一秒之内变为可见。</p>
<p>我们也可以手动触发 Refresh，<code>POST /_refresh</code> 刷新所有索引，<code>POST /nba/_refresh</code> 刷新指定的索引。</p>
<p>Tips：尽管刷新是比提交轻量很多的操作，它还是会有性能开销。当写测试的时候， 手动刷新很有用，但是不要在生产&gt;环境下每次索引一个文档都去手动刷新。而且并不是所有的情况都需要每秒刷新。</p>
<p>可能你正在使用 Elasticsearch 索引大量的日志文件， 你可能想优化索引速度而不是&gt;近实时搜索。</p>
<p>这时可以在创建索引时在 Settings 中通过调大 <code>refresh_interval = &quot;30s&quot;</code>的值 ， 降低每个索引的刷新频率，设值时需要注意后面带上时间单位，否则默认是毫秒。当 <code>refresh_interval=-1</code> 时表示关闭索引的自动刷新。</p>
<p>虽然通过延时写的策略可以减少数据往磁盘上写的次数提升了整体的写入能力，但是我们知道文件缓存系统也是内存空间，属于操作系统的内存，只要是内存都存在断电或异常情况下丢失数据的危险。</p>
<p>为了避免丢失数据，Elasticsearch 添加了事务日志（Translog），事务日志记录了所有还没有持久化到磁盘的数据。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/10/1105-gr8og8.jpeg" alt="图片"></p>
<p>添加了事务日志后整个写索引的流程如上图所示：</p>
<blockquote>
<ul>
<li><p>一个新文档被索引之后，先被写入到内存中，但是为了防止数据的丢失，会追加一份数据到事务日志中。</p>
<p>不断有新的文档被写入到内存，同时也都会记录到事务日志中。这时新数据还不能被检索和查询。</p>
</li>
<li><p>当达到默认的刷新时间或内存中的数据达到一定量后，会触发一次  Refresh，将内存中的数据以一个新段形式刷新到文件缓存系统中并清空内存。这时虽然新段未被提交到磁盘，但是可以提供文档的检索功能且不能被修改。</p>
</li>
<li><p>随着新文档索引不断被写入，当日志数据大小超过 512M 或者时间超过 30 分钟时，会触发一次 Flush。</p>
<p>内存中的数据被写入到一个新段同时被写入到文件缓存系统，文件系统缓存中数据通过 Fsync 刷新到磁盘中，生成提交点，日志文件被删除，创建一个空的新日志。</p>
</li>
</ul>
</blockquote>
<p>通过这种方式当断电或需要重启时，ES 不仅要根据提交点去加载已经持久化过的段，还需要工具 Translog 里的记录，把未持久化的数据重新持久化到磁盘上，避免了数据丢失的可能。</p>
<p>③段合并</p>
<p>由于自动刷新流程每秒会创建一个新的段 ，这样会导致短时间内的段数量暴增。而段数目太多会带来较大的麻烦。</p>
<p>每一个段都会消耗文件句柄、内存和 CPU 运行周期。更重要的是，每个搜索请求都必须轮流检查每个段然后合并查询结果，所以段越多，搜索也就越慢。</p>
<p>Elasticsearch 通过在后台定期进行段合并来解决这个问题。小的段被合并到大的段，然后这些大的段再被合并到更大的段。</p>
<p>段合并的时候会将那些旧的已删除文档从文件系统中清除。被删除的文档不会被拷贝到新的大段中。合并的过程中不会中断索引和搜索。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/10/1105-VeGjfe.png" alt="图片">图片</p>
<p>段合并在进行索引和搜索时会自动进行，合并进程选择一小部分大小相似的段，并且在后台将它们合并到更大的段中，这些段既可以是未提交的也可以是已提交的。</p>
<p>合并结束后老的段会被删除，新的段被 Flush 到磁盘，同时写入一个包含新段且排除旧的和较小的段的新提交点，新的段被打开可以用来搜索。</p>
<p>段合并的计算量庞大， 而且还要吃掉大量磁盘 I/O，段合并会拖累写入速率，如果任其发展会影响搜索性能。</p>
<p>Elasticsearch 在默认情况下会对合并流程进行资源限制，所以搜索仍然有足够的资源很好地执行。</p>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="存储设备"><a href="#存储设备" class="headerlink" title="存储设备"></a>存储设备</h3><p>磁盘在现代服务器上通常都是瓶颈。Elasticsearch 重度使用磁盘，你的磁盘能处理的吞吐量越大，你的节点就越稳定。</p>
<p>这里有一些优化磁盘 I/O 的技巧：</p>
<blockquote>
<ul>
<li>使用 SSD。就像其他地方提过的， 他们比机械磁盘优秀多了。</li>
<li>使用 RAID 0。条带化 RAID 会提高磁盘 I/O，代价显然就是当一块硬盘故障时整个就故障了。不要使用镜像或者奇偶校验 RAID 因为副本已经提供了这个功能。</li>
<li>另外，使用多块硬盘，并允许 Elasticsearch 通过多个 path.data 目录配置把数据条带化分配到它们上面。</li>
<li>不要使用远程挂载的存储，比如 NFS 或者 SMB/CIFS。这个引入的延迟对性能来说完全是背道而驰的。</li>
<li>如果你用的是 EC2，当心 EBS。即便是基于 SSD 的 EBS，通常也比本地实例的存储要慢。</li>
</ul>
</blockquote>
<h3 id="内部索引优化"><a href="#内部索引优化" class="headerlink" title="内部索引优化"></a>内部索引优化</h3><p><img data-src="https://xuemingde.com/pages/image/2022/04/10/1106-4LKvYu.jpeg" alt="图片">图片</p>
<p>Elasticsearch 为了能快速找到某个 Term，先将所有的 Term 排个序，然后根据二分法查找 Term，时间复杂度为 logN，就像通过字典查找一样，这就是 Term Dictionary。</p>
<p>现在再看起来，似乎和传统数据库通过 B-Tree 的方式类似。但是如果 Term 太多，Term Dictionary 也会很大，放内存不现实，于是有了 Term Index。</p>
<p>就像字典里的索引页一样，A 开头的有哪些 Term，分别在哪页，可以理解 Term Index是一棵树。</p>
<p>这棵树不会包含所有的 Term，它包含的是 Term 的一些前缀。通过 Term Index 可以快速地定位到 Term Dictionary 的某个 Offset，然后从这个位置再往后顺序查找。</p>
<p>在内存中用 FST 方式压缩 Term Index，FST 以字节的方式存储所有的 Term，这种压缩方式可以有效的缩减存储空间，使得 Term Index 足以放进内存，但这种方式也会导致查找时需要更多的 CPU 资源。</p>
<p>对于存储在磁盘上的倒排表同样也采用了压缩技术减少存储所占用的空间。</p>
<h3 id="调整配置参数"><a href="#调整配置参数" class="headerlink" title="调整配置参数"></a>调整配置参数</h3><p>调整配置参数建议如下：</p>
<blockquote>
<ul>
<li><p>给每个文档指定有序的具有压缩良好的序列模式 ID，避免随机的 UUID-4 这样的 ID，这样的 ID 压缩比很低，会明显拖慢 Lucene。</p>
</li>
<li><p>对于那些不需要聚合和排序的索引字段禁用 Doc values。Doc Values 是有序的基于 <code>document=&gt;field value</code> 的映射列表。</p>
</li>
<li><p>不需要做模糊检索的字段使用 Keyword 类型代替 Text 类型，这样可以避免在建立索引前对这些文本进行分词。</p>
</li>
<li><p>如果你的搜索结果不需要近实时的准确度，考虑把每个索引的 <code>index.refresh_interval</code> 改到 30s 。</p>
<p>如果你是在做大批量导入，导入期间你可以通过设置这个值为 -1 关掉刷新，还可以通过设置 <code>index.number_of_replicas: 0</code> 关闭副本。别忘记在完工的时候重新开启它。</p>
</li>
<li><p>避免深度分页查询建议使用 Scroll 进行分页查询。普通分页查询时，会创建一个 <code>from+size</code> 的空优先队列，每个分片会返回 <code>from+size</code> 条数据，默认只包含文档 ID 和得分 Score 给协调节点。</p>
<p>如果有 N 个分片，则协调节点再对（from+size）×n 条数据进行二次排序，然后选择需要被取回的文档。当 from 很大时，排序过程会变得很沉重，占用 CPU 资源严重。</p>
</li>
<li><p>减少映射字段，只提供需要检索，聚合或排序的字段。其他字段可存在其他存储设备上，例如 Hbase，在 ES 中得到结果后再去 Hbase 查询这些字段。</p>
</li>
<li><p>创建索引和查询时指定路由 Routing 值，这样可以精确到具体的分片查询，提升查询效率。路由的选择需要注意数据的分布均衡。</p>
</li>
</ul>
</blockquote>
<h3 id="JVM-调优"><a href="#JVM-调优" class="headerlink" title="JVM 调优"></a>JVM 调优</h3><p>JVM 调优建议如下：</p>
<blockquote>
<ul>
<li>确保堆内存最小值（ Xms ）与最大值（ Xmx ）的大小是相同的，防止程序在运行时改变堆内存大小。Elasticsearch 默认安装后设置的堆内存是 1GB。可通过<code>../config/jvm.option</code> 文件进行配置，但是最好不要超过物理内存的50%和超过 32GB。</li>
<li>GC 默认采用 CMS 的方式，并发但是有 STW 的问题，可以考虑使用 G1 收集器。</li>
<li>ES 非常依赖文件系统缓存（Filesystem Cache），快速搜索。一般来说，应该至少确保物理上有一半的可用内存分配到文件系统缓存。</li>
</ul>
</blockquote>
<hr>
<blockquote>
<p>备份链接：<a href="https://xuemingde.com/JavaNotes/中间件-搜索/20220411-彻底讲透Elasticsearch">20220411-彻底讲透Elasticsearch</a>  </p>
</blockquote>
]]></content>
      <categories>
        <category>中间件</category>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>C</tag>
        <tag>内存</tag>
        <tag>sql</tag>
        <tag>集合</tag>
        <tag>GC</tag>
        <tag>事务</tag>
        <tag>数据库</tag>
        <tag>堆</tag>
        <tag>栈</tag>
        <tag>函数</tag>
        <tag>CPU</tag>
        <tag>指针</tag>
        <tag>Mysql</tag>
        <tag>锁</tag>
        <tag>索引</tag>
        <tag>分布式</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ防止数据丢失问题简单介绍</title>
    <url>/posts/12VZ51X.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>推荐文章：<span class="exturl" data-url="aHR0cHM6Ly93d3cucGlhbnNoZW4uY29tL2FydGljbGUvNTg1MTIxODI2Ny8=">消息Ack确认机制<i class="fa fa-external-link-alt"></i></span> ，<br><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxOTEyNTUxMg==">RabbitMQ如何处理消息丢失<i class="fa fa-external-link-alt"></i></span> ，<br><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzc2OTg4Mg==">RabbitMQ防止数据丢失<i class="fa fa-external-link-alt"></i></span>   </p>
</blockquote>
<h2 id="数据丢失的原因"><a href="#数据丢失的原因" class="headerlink" title="数据丢失的原因"></a>数据丢失的原因</h2><p><img data-src="https://xuemingde.com/pages/image/others/1616125932796-190b38de-df34-41af-89dc-b05abf8e6603.png" alt="image.png"></p>
<h2 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h2><p><img data-src="https://xuemingde.com/pages/image/others/1616126025417-8eb9b06d-f0fa-43c0-ad8f-d04b8065ffde.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1616126007166-5079fa45-6134-4ab5-ae37-abe0b0ae1ceb.png" alt="image.png"></p>
<h2 id="消息确认机制"><a href="#消息确认机制" class="headerlink" title="消息确认机制"></a>消息确认机制</h2><h3 id="confirm机制"><a href="#confirm机制" class="headerlink" title="confirm机制"></a>confirm机制</h3><p><img data-src="https://xuemingde.com/pages/image/others/1616126107133-56e7d1aa-f8d3-40c4-b32a-8b4ad1ead2b0.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1616126141908-248347ce-82e1-4e93-a90b-944f0ce1f663.png" alt="image.png"></p>
<p><strong><img data-src="https://xuemingde.com/pages/image/others/1616061939812-fd18b222-64ad-499a-8077-c70510157ba5.png" alt="image.png"></strong></p>
<h4 id="生产者确认模式实现原理"><a href="#生产者确认模式实现原理" class="headerlink" title="生产者确认模式实现原理"></a>生产者确认模式实现原理</h4><p><img data-src="https://xuemingde.com/pages/image/others/1616120057595-7d700569-69fc-4dd4-81f3-a4028f8222bc.png" alt="image.png"></p>
<h3 id=""><a href="#" class="headerlink" title=" "></a> </h3><h4 id="理解RabbitMQ-Confirm消息确认机制"><a href="#理解RabbitMQ-Confirm消息确认机制" class="headerlink" title="理解RabbitMQ Confirm消息确认机制"></a>理解RabbitMQ Confirm消息确认机制</h4><p><img data-src="https://xuemingde.com/pages/image/others/1616119562697-fcbf2cdd-7abe-4797-8e75-54ae2c4e4c5e.png" alt="image.png"></p>
<h4 id="RabbitMQ-Confirm确认机制流程图"><a href="#RabbitMQ-Confirm确认机制流程图" class="headerlink" title="RabbitMQ Confirm确认机制流程图"></a>RabbitMQ Confirm确认机制流程图</h4><p><img data-src="https://xuemingde.com/pages/image/others/1616119588730-57000588-f975-418a-854c-11c80ccee25b.png" alt="image.png"></p>
<h3 id="事务机制-ACK"><a href="#事务机制-ACK" class="headerlink" title="事务机制(ACK)"></a>事务机制(ACK)</h3><p><img data-src="https://xuemingde.com/pages/image/others/1616126238189-76f84851-3cee-4279-adf9-83c13dee0230.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1616126256931-80467414-4679-44ae-8446-b50df502dc49.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1616123500213-61b0b20e-ba8f-497d-aba7-5f92e0f26fe2.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1616121122072-5f1d10e2-8701-4070-8af1-b06a1a725e6d.png" alt="image.png"></p>
<h4 id="ACK工作原理"><a href="#ACK工作原理" class="headerlink" title="ACK工作原理"></a>ACK工作原理</h4><p><img data-src="https://xuemingde.com/pages/image/others/1616121190328-6e7acd85-85e6-461a-a49b-8b294e3c19b4.png" alt="image.png"></p>
<blockquote>
<p>推荐文章：<span class="exturl" data-url="aHR0cHM6Ly93d3cucGlhbnNoZW4uY29tL2FydGljbGUvNTg1MTIxODI2Ny8=">消息Ack确认机制<i class="fa fa-external-link-alt"></i></span> ， <span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxOTEyNTUxMg==">RabbitMQ如何处理消息丢失<i class="fa fa-external-link-alt"></i></span> ， <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzc2OTg4Mg==">RabbitMQ防止数据丢失<i class="fa fa-external-link-alt"></i></span>   </p>
</blockquote>
]]></content>
      <categories>
        <category>中间件</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>事务</tag>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot-Rabbitmq实现延迟队列</title>
    <url>/posts/R5RB64.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h2 id="MAC-系统"><a href="#MAC-系统" class="headerlink" title="MAC 系统"></a>MAC 系统</h2><p>安装命令：brew install rabbitmq<br>​</p>
<p>安装的路径是 /usr/local/Cellar/rabbitmq/3.8.3，具体情况要视版本而定，我安装的版本是 3.8.3。<br>​</p>
<p>接下来就可以启动了，进入安装目录，执行命令：./sbin/rabbitmq-server </p>
<p>接下来可以在浏览器打开 <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDoxNTY3Mu+8jOWPr+S7peeci+WIsA==">http://localhost:15672，可以看到<i class="fa fa-external-link-alt"></i></span> RabbitMQ 的管理页面。<br>​</p>
<p>登录账号密码：guest/guest</p>
<h2 id="导入-Maven-依赖"><a href="#导入-Maven-依赖" class="headerlink" title="导入 Maven 依赖"></a>导入 Maven 依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">&lt;/dependency</span><br></pre></td></tr></table></figure>
<h2 id="TTL-方式"><a href="#TTL-方式" class="headerlink" title="TTL 方式"></a>TTL 方式</h2><h3 id="application-properties-配置信息"><a href="#application-properties-配置信息" class="headerlink" title="application.properties 配置信息"></a>application.properties 配置信息</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 应用名称</span></span><br><span class="line"><span class="string">spring.application.name=rabbitMq</span></span><br><span class="line"><span class="comment"># 应用服务 WEB 访问端口</span></span><br><span class="line"><span class="string">server.port=8080</span></span><br><span class="line"><span class="string">spring.rabbitmq.host=127.0.0.1</span></span><br><span class="line"><span class="string">spring.rabbitmq.port=5672</span></span><br><span class="line"><span class="string">spring.rabbitmq.username=guest</span></span><br><span class="line"><span class="string">spring.rabbitmq.password=guest</span></span><br><span class="line"><span class="comment"># 开启消息确认机制 confirm 异步</span></span><br><span class="line"><span class="string">spring.rabbitmq.publisher-confirm-type=correlated</span></span><br><span class="line"><span class="comment"># 之前的旧版本 开启消息确认机制的方式</span></span><br><span class="line"><span class="comment"># spring.rabbitmq.publisher-confirms=true</span></span><br><span class="line"><span class="comment"># 开启return机制</span></span><br><span class="line"><span class="string">spring.rabbitmq.publisher-returns=true</span></span><br><span class="line"><span class="comment"># 消息开启手动确认</span></span><br><span class="line"><span class="string">spring.rabbitmq.listener.direct.acknowledge-mode=manual</span></span><br><span class="line"><span class="string">spring.rabbitmq.listener.simple.acknowledge-mode=manual</span></span><br><span class="line"><span class="comment"># 消费者每次从队列获取的消息数量。此属性当不设置时为：轮询分发，设置为1为：公平分发</span></span><br><span class="line"><span class="string">spring.rabbitmq.listener.simple.prefetch=1</span></span><br><span class="line"><span class="comment"># 是否支持重试</span></span><br><span class="line"><span class="string">spring.rabbitmq.listener.simple.retry.enabled=true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#消费者最小数量</span></span><br><span class="line"><span class="string">spring.rabbitmq.listener.simple.concurrency=1</span></span><br><span class="line"><span class="comment">#消费之最大数量</span></span><br><span class="line"><span class="string">spring.rabbitmq.listener.simple.max-concurrency=10</span></span><br></pre></td></tr></table></figure>
<h3 id="RabbitmqConfig-配置信息"><a href="#RabbitmqConfig-配置信息" class="headerlink" title="RabbitmqConfig 配置信息"></a>RabbitmqConfig 配置信息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bean.springcloudproduct.config;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.amqp.SimpleRabbitListenerContainerFactoryConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span> //TODO</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span> huangwb</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitmqConfig</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 死信交换机</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">userOrderDelayExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(<span class="string">&quot;user.order.delay_exchange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 死信队列</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">userOrderDelayQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">        map.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, <span class="string">&quot;user.order.receive_exchange&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, <span class="string">&quot;user.order.receive_key&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;user.order.delay_queue&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, map);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 给死信队列绑定交换机</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">userOrderDelayBinding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(userOrderDelayQueue()).to(userOrderDelayExchange()).with(<span class="string">&quot;user.order.delay_key&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 死信接收交换机</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> DirectExchange <span class="title">userOrderReceiveExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(<span class="string">&quot;user.order.receive_exchange&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 死信接收队列</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Queue <span class="title">userOrderReceiveQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;user.order.receive_queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 死信交换机绑定消费队列</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Binding <span class="title">userOrderReceiveBinding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(userOrderReceiveQueue()).to(userOrderReceiveExchange()).with(<span class="string">&quot;user.order.receive_key&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLetterSenderServiceImpl</span> <span class="keyword">implements</span> <span class="title">DeadLetterSenderService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendLetterSenderMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">&quot;confirm&quot;</span>, <span class="string">&quot;confirm123456&quot;</span>);</span><br><span class="line">        MessagePostProcessor postProcessor = message -&gt; &#123;</span><br><span class="line">            <span class="comment">//在这里也可以设置超时时间,也可以设置x-message-ttl</span></span><br><span class="line">            message.getMessageProperties().setExpiration(<span class="string">&quot;5000&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;;</span><br><span class="line">        rabbitTemplate.setMandatory(<span class="keyword">true</span>);</span><br><span class="line">        rabbitTemplate.setConfirmCallback(confirmCallback);</span><br><span class="line">        rabbitTemplate.setReturnCallback(returnCallback);</span><br><span class="line">        CorrelationData correlationData = <span class="keyword">new</span> CorrelationData(<span class="string">&quot;confirm-&quot;</span> + System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate.convertAndSend(<span class="string">&quot;user.order.delay_exchange&quot;</span>, <span class="string">&quot;user.order.delay_key&quot;</span>, user, postProcessor, correlationData);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置 confirm 机制</span></span><br><span class="line"><span class="comment">     * 交换机错误出发</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RabbitTemplate.ConfirmCallback confirmCallback = <span class="keyword">new</span> RabbitTemplate.ConfirmCallback() &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> correlationData 消息相关的数据，一般用于获取 唯一标识 id</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> b true 消息确认成功，false 失败</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> s 确认失败的原因</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> b, String s)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (b) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;confirm 消息确认成功...&quot;</span> + correlationData.getId() + <span class="keyword">new</span> Date());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;confirm 消息确认失败...&quot;</span> + correlationData.getId() + <span class="string">&quot; cause: &quot;</span> + s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置 return 消息机制</span></span><br><span class="line"><span class="comment">     * 找不到路由才会触发</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RabbitTemplate.ReturnCallback returnCallback = <span class="keyword">new</span> RabbitTemplate.ReturnCallback() &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *  return 的回调方法（找不到路由才会触发）</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> message 消息的相关信息</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> i 错误状态码</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> s 错误状态码对应的文本信息</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> s1 交换机的名字</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> s2 路由的key</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(Message message, <span class="keyword">int</span> i, String s, String s1, String s2)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;消息：&quot;</span> + message);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">            System.out.println(<span class="string">&quot;回应码：&quot;</span> + i);</span><br><span class="line">            System.out.println(<span class="string">&quot;回应信息：&quot;</span> + s);</span><br><span class="line">            System.out.println(<span class="string">&quot;交换机：&quot;</span> + s1);</span><br><span class="line">            System.out.println(<span class="string">&quot;路由键：&quot;</span> + s2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Slf4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLetterSenderListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 延迟队列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Author</span> jxb</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Date</span> 2019-04-04 16:34:28</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getDLMessage</span><span class="params">(User user, Channel channel, Message message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;延迟队列参数数据 ： &quot;</span> + user +  <span class="keyword">new</span> Date());</span><br><span class="line">            <span class="comment">//basicAck:表示成功确认，使用此回执方法后，消息会被rabbitmq broker 删除。</span></span><br><span class="line">            <span class="comment">//deliveryTag：表示消息投递序号，每次消费消息或者消息重新投递后，deliveryTag都会增加。手动消息确认模式下，我们可以对指定deliveryTag的消息进行ack、nack、reject等操作。</span></span><br><span class="line">            <span class="comment">//multiple(false/true)：是否批量确认，false只确认当前consumer一个消息收到,值为 true 则会一次性 ack所有小于当前消息 deliveryTag 的消息。</span></span><br><span class="line">            <span class="comment">//举个栗子： 假设我先发送三条消息deliveryTag分别是5、6、7，可它们都没有被确认，当我发第四条消息此时deliveryTag为8，multiple设置为 true，会将5、6、7、8的消息全部进行确认。</span></span><br><span class="line">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;延迟队列接受到的消息为:&quot;</span> + <span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (message.getMessageProperties().getRedelivered()) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;延迟队列消息已重复处理失败,拒绝再次接收...&quot;</span>);</span><br><span class="line">                <span class="comment">// 拒绝消息</span></span><br><span class="line">                <span class="comment">//basicReject：拒绝消息，与basicNack区别在于不能进行批量操作，其他用法很相似。</span></span><br><span class="line">                <span class="comment">//deliveryTag：表示消息投递序号。</span></span><br><span class="line">                <span class="comment">//requeue：值为 true 消息将重新入队列。</span></span><br><span class="line">                channel.basicReject(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.error(<span class="string">&quot;延迟队列消息即将再次返回队列处理...&quot;</span>);</span><br><span class="line">                <span class="comment">//basicNack ：表示失败确认，一般在消费消息业务异常时用到此方法，可以将消息重新投递入队列。</span></span><br><span class="line">                <span class="comment">//deliveryTag：表示消息投递序号。</span></span><br><span class="line">                <span class="comment">//multiple：是否批量确认。</span></span><br><span class="line">                <span class="comment">//requeue：值为 true 消息将重新入队列。</span></span><br><span class="line">                channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="DLX"><a href="#DLX" class="headerlink" title="DLX"></a>DLX</h2><blockquote>
<p>首先我们需要下载并安装 RabbitMQ 的延迟插件。</p>
</blockquote>
<p>地址：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JhYmJpdG1xL3JhYmJpdG1xLWRlbGF5ZWQtbWVzc2FnZS1leGNoYW5nZS9yZWxlYXNlcw==">https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases<i class="fa fa-external-link-alt"></i></span><br>​</p>
<p>将插件文件复制到 RabbitMQ 安装目录的 plugins 目录下；<br>​</p>
<p>进入 RabbitMQ 安装目录的 sbin 目录下，使用如下命令启用延迟插件</p>
<blockquote>
<p>rabbitmq-plugins enable rabbitmq_delayed_message_exchange</p>
</blockquote>
<p>代码实现：<br>​</p>
<h3 id="配置文件："><a href="#配置文件：" class="headerlink" title="配置文件："></a>配置文件：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 延时队列交换机 DLX方式</span></span><br><span class="line"><span class="comment"> * 注意这里的交换机类型：CustomExchange</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CustomExchange <span class="title">delayExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; args = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">    args.put(<span class="string">&quot;x-delayed-type&quot;</span>, <span class="string">&quot;direct&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CustomExchange(<span class="string">&quot;exchange.xdelay.delayed&quot;</span>, <span class="string">&quot;x-delayed-message&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 延时队列</span></span><br><span class="line"><span class="comment"> *  DLX方式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">immediateQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一个参数是创建的queue的名字，第二个参数是是否支持持久化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Queue(<span class="string">&quot;queue.xdelay.immediate&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 给延时队列绑定交换机</span></span><br><span class="line"><span class="comment"> *   DLX方式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">bindingNotify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(immediateQueue()).to(delayExchange()).with(<span class="string">&quot;exchange.xdelay.delayed&quot;</span>).noargs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="生产者-1"><a href="#生产者-1" class="headerlink" title="生产者"></a>生产者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendLetterDLXSenderMsg</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">&quot;confirm&quot;</span>, <span class="string">&quot;confirm123456&quot;</span>);</span><br><span class="line">        MessagePostProcessor postProcessor = message -&gt; &#123;</span><br><span class="line">            message.getMessageProperties().setDelay(<span class="number">5000</span>);</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;;</span><br><span class="line">        rabbitTemplate.setMandatory(<span class="keyword">true</span>);</span><br><span class="line">        rabbitTemplate.setConfirmCallback(confirmCallback);</span><br><span class="line"><span class="comment">//        rabbitTemplate.setReturnCallback(returnCallback);</span></span><br><span class="line">        CorrelationData correlationData = <span class="keyword">new</span> CorrelationData(<span class="string">&quot;confirm-&quot;</span> + System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate.convertAndSend(<span class="string">&quot;exchange.xdelay.delayed&quot;</span>, <span class="string">&quot;exchange.xdelay.delayed&quot;</span>, user, postProcessor, correlationData);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="消费者-1"><a href="#消费者-1" class="headerlink" title="消费者"></a>消费者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * DLX方式</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> channel</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getDLXMessage</span><span class="params">(User user, Channel channel, Message message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;DLX延迟队列参数数据 ： &quot;</span> + user +  <span class="keyword">new</span> Date());</span><br><span class="line">          <span class="comment">//basicAck:表示成功确认，使用此回执方法后，消息会被rabbitmq broker 删除。</span></span><br><span class="line">          <span class="comment">//deliveryTag：表示消息投递序号，每次消费消息或者消息重新投递后，deliveryTag都会增加。手动消息确认模式下，我们可以对指定deliveryTag的消息进行ack、nack、reject等操作。</span></span><br><span class="line">          <span class="comment">//multiple(false/true)：是否批量确认，false只确认当前consumer一个消息收到,值为 true 则会一次性 ack所有小于当前消息 deliveryTag 的消息。</span></span><br><span class="line">          <span class="comment">//举个栗子： 假设我先发送三条消息deliveryTag分别是5、6、7，可它们都没有被确认，当我发第四条消息此时deliveryTag为8，multiple设置为 true，会将5、6、7、8的消息全部进行确认。</span></span><br><span class="line">          channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">          System.out.println(<span class="string">&quot;DLX延迟队列接受到的消息为:&quot;</span> + <span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="keyword">if</span> (message.getMessageProperties().getRedelivered()) &#123;</span><br><span class="line">              log.error(<span class="string">&quot;DLX延迟队列消息已重复处理失败,拒绝再次接收...&quot;</span>);</span><br><span class="line">              <span class="comment">// 拒绝消息</span></span><br><span class="line">              <span class="comment">//basicReject：拒绝消息，与basicNack区别在于不能进行批量操作，其他用法很相似。</span></span><br><span class="line">              <span class="comment">//deliveryTag：表示消息投递序号。</span></span><br><span class="line">              <span class="comment">//requeue：值为 true 消息将重新入队列。</span></span><br><span class="line">              channel.basicReject(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              log.error(<span class="string">&quot;DLX延迟队列消息即将再次返回队列处理...&quot;</span>);</span><br><span class="line">              <span class="comment">//basicNack ：表示失败确认，一般在消费消息业务异常时用到此方法，可以将消息重新投递入队列。</span></span><br><span class="line">              <span class="comment">//deliveryTag：表示消息投递序号。</span></span><br><span class="line">              <span class="comment">//multiple：是否批量确认。</span></span><br><span class="line">              <span class="comment">//requeue：值为 true 消息将重新入队列。</span></span><br><span class="line">              channel.basicNack(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考文章：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3ODkyOTU3L2FydGljbGUvZGV0YWlscy84OTI5NjE1Nw==">https://blog.csdn.net/qq_37892957/article/details/89296157<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
]]></content>
      <categories>
        <category>中间件</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>Spring</tag>
        <tag>GC</tag>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title>关于一些MQ的面试题</title>
    <url>/posts/11RZTJV.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="你们公司生产环境用的是什么消息中间件？"><a href="#你们公司生产环境用的是什么消息中间件？" class="headerlink" title="你们公司生产环境用的是什么消息中间件？"></a>你们公司生产环境用的是什么消息中间件？</h2><p><img data-src="https://xuemingde.com/pages/image/others/1615963827333-90292131-d863-4697-be3c-76cb14e89560.png" alt="image.png"></p>
<h2 id="消息的重复问题"><a href="#消息的重复问题" class="headerlink" title="消息的重复问题"></a><strong>消息的重复问题</strong></h2><p><img data-src="https://xuemingde.com/pages/image/others/1615964526920-75a7c395-7b8e-476f-9077-873c7aa990f9.png" alt="image.png"></p>
<h2 id="消息队列Kafka、RocketMQ、RabbitMQ的选择"><a href="#消息队列Kafka、RocketMQ、RabbitMQ的选择" class="headerlink" title="消息队列Kafka、RocketMQ、RabbitMQ的选择"></a>消息队列Kafka、RocketMQ、RabbitMQ的选择</h2><p><img data-src="https://xuemingde.com/pages/image/others/1615962984036-416ef0f2-2c69-4a18-a76b-250354e6d8d4.jpeg" alt="image"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1615963003485-633ef8ce-4f9a-41c4-9909-f96aff77f3d6.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1615963014165-e1772ed0-3df6-4d69-9488-927dc60d9c53.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1615963057530-92a0d024-244d-48fc-b512-1b348de7dcf8.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1615963100182-3bbdf65e-9570-4123-915b-75fcf7b65b79.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1615963142096-6433cf7c-2d01-49a9-8dc6-f4be3795c6be.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1615963393063-c9869bc4-f32a-46de-ac2d-627f425f1649.png" alt="image.png"></p>
<h2 id="如何确保消息正确地发送至-RabbitMQ？"><a href="#如何确保消息正确地发送至-RabbitMQ？" class="headerlink" title="如何确保消息正确地发送至 RabbitMQ？"></a>如何确保消息正确地发送至 RabbitMQ？</h2><p><img data-src="https://xuemingde.com/pages/image/others/1615963649216-cc648c58-d318-47fc-8d35-d74a1c03ed47.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1615964728815-7fd6fb2a-aee5-4a51-88b2-e6f25c7effe4.png" alt="image.png"></p>
<h2 id="如何保证RabbitMQ消息的顺序性？"><a href="#如何保证RabbitMQ消息的顺序性？" class="headerlink" title="如何保证RabbitMQ消息的顺序性？"></a>如何保证RabbitMQ消息的顺序性？</h2><p><img data-src="https://xuemingde.com/pages/image/others/1615964620500-fb42c3de-cb6e-4e9f-9f34-5659945c8ef9.png" alt="image.png"></p>
<h2 id="如何保证RabbitMQ消息的可靠传输？"><a href="#如何保证RabbitMQ消息的可靠传输？" class="headerlink" title="如何保证RabbitMQ消息的可靠传输？"></a>如何保证RabbitMQ消息的可靠传输？</h2><p><img data-src="https://xuemingde.com/pages/image/others/1615964775696-738f85a6-f39f-42db-855b-0a7d18be418f.png" alt="image.png"></p>
<blockquote>
<p>推荐文章：<span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vY2Fzb25vbC9pbnRlcnZpZXdfbm90ZXMvYmxvYi9tYXN0ZXIv5raI5oGv6Zif5YiXUmFiYml0TVHpnaLor5UyMDIwLm1k">文章一<i class="fa fa-external-link-alt"></i></span> ， <span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8wMmZkY2I5ZTg3ODQ=">如何保证消息按顺序执行<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
]]></content>
      <categories>
        <category>中间件</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>面试</tag>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka面试连环炮-上</title>
    <url>/posts/3DS4M6Q.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Kafka-是什么-适应场景有哪些"><a href="#Kafka-是什么-适应场景有哪些" class="headerlink" title="Kafka 是什么, 适应场景有哪些"></a>Kafka 是什么, 适应场景有哪些</h2><p>Kafka 是一个分布式的流式处理平台，用于实时构建流处理应用。主要应用在大数据实时处理领域。Kafka 凭借「<strong>高性能</strong>」、「<strong>高吞吐</strong>」、「<strong>高可用</strong>」、「<strong>低延迟</strong>」、「<strong>可伸缩</strong>」几大特性，成为「<strong>消息队列」</strong>的首选。</p>
<p><strong>其主要设计目标如下：</strong></p>
<blockquote>
<p>1）<strong>高性能：</strong>以时间复杂度为 O(1) 的方式提供消息持久化能力，即使对TB级以上数据也能保证常数时间的访问性能。</p>
<p>2）<strong>高吞吐、低延迟：</strong>在非常廉价的机器上也能做到单机支持每秒几十万条消息的传输，并保持毫秒级延迟。</p>
<p>3）<strong>持久性、可靠性：</strong>消息最终被持久化到磁盘，且提供数据备份机制防止数据丢失。</p>
<p>4）<strong>容错性：</strong>支持集群节点故障容灾恢复，即使 Kafka 集群中的某一台 Kafka 服务节点宕机，也不会影响整个系统的功能（若副本数量为N， 则允许N-1台节点故障）。</p>
<p>5）<strong>高并发：</strong>可以支撑数千个客户端同时进行读写操作。</p>
</blockquote>
<p><strong>其适应场景主要有：</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/08/0931-ZCwdNL.png" alt="图片"></p>
<blockquote>
<p>1）<strong>日志收集方向：</strong>可以用 Kafka 来收集各种服务的 log，然后统一输出，比如日志系统 elk，用 Kafka 进行数据中转。</p>
<p>2）<strong>消息系统方向：</strong>Kafka 具备系统解耦、副本冗余、流量削峰、消息缓冲、可伸缩性、容错性等功能，同时还提供了消息顺序性保障以及消息回溯功能等。</p>
<p>3）<strong>大数据实时计算方向：</strong>Kafka 提供了一套完整的流式处理框架， 被广泛应用到大数据处理，如与 flink、spark、storm 等整合。</p>
</blockquote>
<h2 id="Kafka-核心组件有哪些-分别有什么作用呢"><a href="#Kafka-核心组件有哪些-分别有什么作用呢" class="headerlink" title="Kafka 核心组件有哪些, 分别有什么作用呢"></a>Kafka 核心组件有哪些, 分别有什么作用呢</h2><p><img data-src="https://xuemingde.com/pages/image/2022/04/08/0932-MsBc1g.png" alt="图片"></p>
<p><strong>Kafka 核心组件的基础概念：</strong></p>
<blockquote>
<p>1）<strong>Producer：</strong>即消息生产者，向 Kafka Broker 发消息的客户端。</p>
<p>2）<strong>Consumer：</strong>即消息消费者，从 Kafka Broker 读消息的客户端。</p>
<p>3）<strong>Consumer Group：</strong>即消费者组，<strong>由多个 Consumer 组成</strong>。消费者组内每个消费者负责消费不同分区的数据，以提高消费能力。<strong>一个分区只能由组内一个消费者消费，不同消费者组之间互不影响</strong>。</p>
<p>4）<strong>Broker：</strong> <strong>一台 Kafka 服务节点就是一个 Broker</strong>。一个集群是由1个或者多个 Broker 组成的，且一个 Broker 可以容纳多个 Topic。</p>
<p>5）<strong>Topic：</strong>一个逻辑上的概念，Topic 将消息分类，生产者和消费者面向的都是同一个 Topic, <strong>同一个 Topic 下的 Partition 的消息内容是不相同的</strong>。</p>
<p>6）<strong>Partition：</strong>为了实现 Topic 扩展性，提高并发能力，一个非常大的 Topic 可以分布到多个 Broker 上，<strong>一个 Topic 可以分为多个 Partition 进行存储，且每个 Partition 是消息内容是有序的</strong>。</p>
<p>7）<strong>Replica：</strong>即副本，为实现<strong>数据备份</strong>的功能，保证集群中的某个节点发生故障时，该节点上的 Partition 数据不丢失，且 Kafka 仍然能够继续工作，为此 Kafka 提供了副本机制，<strong>一个 Topic 的每个 Partition 都有若干个副本，一个 Leader 副本和若干个 Follower 副本</strong>。</p>
<p>8）<strong>Leader：</strong>即每个分区多个副本的主副本，<strong>生产者发送数据的对象，以及消费者消费数据的对象，都是 Leader</strong>。</p>
<p>9）<strong>Follower：</strong>即每个分区多个副本的从副本，<strong>会实时从 Leader 副本中同步数据，并保持和 Leader 数据的同步</strong>。Leader 发生故障时，某个 Follower 还会被选举并成为新的 Leader , 且不能跟 Leader 在同一个 Broker 上, 防止崩溃数据可恢复。</p>
<p>10）<strong>Offset：</strong>消费者消费的位置信息，<strong>监控数据消费到什么位置</strong>，当消费者挂掉再重新恢复的时候，可以从消费位置继续消费。</p>
</blockquote>
<h2 id="在-Kafka-中-Zookeeper-作用是什么"><a href="#在-Kafka-中-Zookeeper-作用是什么" class="headerlink" title="在 Kafka 中 Zookeeper 作用是什么"></a>在 Kafka 中 Zookeeper 作用是什么</h2><p>Kafka 集群能够正常工作，<strong>目前还是</strong>需要依赖于 ZooKeeper，主要用来「<strong>负责 Kafka集群元数据管理，集群协调工作</strong>」，在每个 Kafka 服务器启动的时候去连接并将自己注册到 Zookeeper，类似注册中心。</p>
<p>Kafka 使用 Zookeeper 存放「<strong>集群元数据</strong>」、「<strong>集群成员管理</strong>」、 「<strong>Controller 选举</strong>」、「<strong>其他管理类任务</strong>」等。待 KRaft 提案完成后，Kafka 将完全不依赖 Zookeeper。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/08/0934-e4kwIb.png" alt="图片"></p>
<blockquote>
<p>1）<strong>集群元数据：</strong>Topic 对应 Partition 的所有数据都存放在 Zookeeper 中，且以 Zookeeper 保存的数据为准。</p>
<p>2）<strong>集群成员管理：</strong>Broker 节点的注册、删除以及属性变更操作等。主要包括两个方面：<strong>成员数量的管理</strong>，主要体现在新增成员和移除现有成员；<strong>单个成员的管理</strong>，如变更单个 Broker 的数据等。</p>
<p>3）<strong>Controller 选举：</strong>即选举 Broker 集群的控制器 Controller。其实它除了具有一般 Broker 的功能之外，还具有<strong>选举主题分区 Leader 节点的功能</strong>。在启动 Kafka系统时，其中一个 Broker 会被选举为控制器，负责管理主题分区和副本状态，还会执行分区重新分配的管理任务。如果在 Kafka  系统运行过程中，当前的控制器出现故障导致不可用，那么 Kafka 系统会从其他正常运行的 Broker 中重新选举出新的控制器。</p>
<p>4）<strong>其他管理类任务：</strong>包括但不限于 Topic 的管理、参数配置等等。</p>
</blockquote>
<p>Kafka 3.X 「<strong>2.8版本开始</strong>」为什么移除 Zookeeper 的依赖的原因有以下2点：</p>
<blockquote>
<p>1）<strong>集群运维层面：</strong>Kafka 本身就是一个分布式系统，如果还需要重度依赖 Zookeeper，集群运维成本和系统复杂度都很高。</p>
<p>2）<strong>集群性能层面：</strong>Zookeeper 架构设计并不适合这种高频的读写更新操作, 由于之前的提交位移的操作都是保存在 Zookeeper 里面的，这样的话会严重影响 Zookeeper 集群的性能。</p>
</blockquote>
<h2 id="生产者有哪些发消息的模式"><a href="#生产者有哪些发消息的模式" class="headerlink" title="生产者有哪些发消息的模式"></a>生产者有哪些发消息的模式</h2><p>Kafka 生产者发送消息主要有三种模式:</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/08/0936-L44AG0.png" alt="图片"></p>
<h3 id="发后即忘发送模式"><a href="#发后即忘发送模式" class="headerlink" title="发后即忘发送模式"></a>发后即忘发送模式</h3><p><strong>发后即忘模式「fire-and-forget」，它只管发送消息，并不需要关心消息是否发送成功</strong>。其本质上也是一种<strong>异步发送</strong>的方式，消息先存储在缓冲区中，达到设定条件后再批量进行发送。<strong>这是 kafka 吞吐量最高的方式，但同时也是消息最不可靠的方式</strong>，因为对于发送失败的消息并没有做任何处理，某些异常情况下会导致消息丢失。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ProducerRecord&lt;k,v&gt; record = <span class="keyword">new</span> ProducerRecord&lt;k,v&gt;(<span class="string">&quot;this-topic&quot;</span>, key, value);</span><br><span class="line"><span class="keyword">try</span> &#123;  </span><br><span class="line">  <span class="comment">//fire-and-forget 模式     </span></span><br><span class="line">  producer.send(record);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="同步发送模式"><a href="#同步发送模式" class="headerlink" title="同步发送模式"></a>同步发送模式</h3><p>同步发送模式 「<strong>sync</strong>」，调用 send() 方法会返回一个 Future 对象，再通过调用 Future 对象的 get() 方法，等待结果返回，根据返回的结果可以判断消息是否发送成功， 由于是同步发送会阻塞，只有当消息通过 <strong>get()</strong> 返回数据时，才会继续下一条消息的发送。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ProducerRecord&lt;k,v&gt; record = <span class="keyword">new</span> ProducerRecord&lt;k,v&gt;(<span class="string">&quot;this-topic&quot;</span>, key, value);</span><br><span class="line"><span class="keyword">try</span> &#123; <span class="comment">//sync 模式 调用future.get() </span></span><br><span class="line">  future = producer.send(record); </span><br><span class="line">  RecordMetadata metadata = future.get();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;producer.flush();</span><br><span class="line">producer.close();</span><br></pre></td></tr></table></figure>
<h3 id="异步发送模式"><a href="#异步发送模式" class="headerlink" title="异步发送模式"></a>异步发送模式</h3><p>异步发送模式「<strong>async</strong>」，在调用 send() 方法的时候指定一个 callback 函数，当 Broker 接收到返回的时候，该 callback 函数会被触发执行，通过回调函数能够对异常情况进行处理，当调用了回调函数时，只有回调函数执行完毕生产者才会结束，否则一直会阻塞。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Future&lt;RecordMetadata&gt; <span class="title">send</span><span class="params">(ProducerRecord&lt;K, V&gt; record, Callback callback)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;RecordMetadata&gt; <span class="title">send</span><span class="params">(ProducerRecord&lt;K, V&gt; record, Callback callback)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//intercept the record, which can be potentially modified; this method does not throw exceptions        </span></span><br><span class="line">  ProducerRecord&lt;K, V&gt; interceptedRecord = <span class="keyword">this</span>.interceptors == <span class="keyword">null</span> ? record :<span class="keyword">this</span>.interceptors.onSend(record);        </span><br><span class="line">  <span class="keyword">return</span> doSend(interceptedRecord, callback);&#125;</span><br></pre></td></tr></table></figure>
<p><strong>以上三种方式各有各的特点，具体还要看业务的应用场景适合哪一种：</strong></p>
<blockquote>
<p>1）<strong>场景1：</strong>如果业务只是关心消息的吞吐量，且允许少量消息发送失败，也不关注消息的发送顺序的话，那么可以使用发后即忘发送「<strong>fire-and-forget</strong>」的方式，配合参数 acks = 0，这样生产者并不需要等待服务器的响应，以网络能支持的最大速度发送消息。</p>
<p>2）<strong>场景2：</strong>如果业务要求消息必须是按<strong>顺序发送</strong>的话，且数据只能落在一个 Partition 上，那么可以使用同步发送「<strong>sync</strong>」的方式，并结合参数来设置 retries 的值让消息发送失败时可以进行多次重试「<strong>retries &gt; 0</strong>」，再结合参数设置「<strong>acks=all &amp; max_in_flight_requests_per_connection=1</strong>」，可以控制生产者在收到服务器成功响应之前只能发送1条消息，在消息发送成功后立即进行 flush, 从而达到控制消息顺序发送。</p>
<p>3）<strong>场景3：</strong>如果业务需要知道消息是否发送成功，但对消息的顺序并不关心的话，那么可以用「<strong>异步async + 回调 callback 函数</strong>」的方式来发送消息，并配合参数 retries=0，待发送失败时将失败的消息记录到日志文件中进行后续处理。</p>
</blockquote>
<h2 id="Kafka-为什么要设计分区"><a href="#Kafka-为什么要设计分区" class="headerlink" title="Kafka 为什么要设计分区"></a>Kafka 为什么要设计分区</h2><p>其实这个问题说来很简单, 假如不进行分区的话就如同 MySQL 单表存储一样，发消息就会被集中存储，这样会导致某台 Kafka 服务器存储 Topic  消息过多，如果在写消息压力很大的情况下，最终会导致这台 Kafka 服务器吞吐量出现瓶颈, 因此 Kafka 设计了分区的概念，同时也带来了「<strong>负载均衡</strong>」、「<strong>横向扩展</strong>」的能力，如下图所示：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/08/0944-PgOS8q.png" alt="图片"></p>
<blockquote>
<p>1）<strong>负载均衡：</strong>发送消息时可以根据分区的数量进行数据均匀分布，使其落在不同的分区上, 这样可以提高并发写性能；同时消费的时候多个订阅者可以从一个或者多个分区中同时消费数据，以支撑海量数据处理能力，提高读消息性能。</p>
<p>2）<strong>横向扩展：</strong>可以将一个 Topic 分成了多个 Partition，将不同的 Partition 尽可能的部署在不同的物理节点上，这样扩展起来非常方便，另外一个消费者可以消费多个分区中的数据，但是这样还是不能够充分的发挥横向扩展，<strong>这时候消费者组就出现了</strong>，我们用消费者组，来消费整个的 Topic，一个消费者消费 Topic 中的一个分区。</p>
</blockquote>
<h2 id="生产者发送消息时如何选择分区的"><a href="#生产者发送消息时如何选择分区的" class="headerlink" title="生产者发送消息时如何选择分区的"></a>生产者发送消息时如何选择分区的</h2><p>生产者发送消息的时候选择分区的策略方式主要有以下4种：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/08/0945-fF7vL4.png" alt="图片"></p>
<blockquote>
<p>1）<strong>轮询策略：</strong>顺序分配消息，即按照消息顺序依次发送到某Topic下不同的分区，它总是能保证消息最大限度地被平均分配到所有分区上，<strong>如果消息在创建的时候 key 为 null， 那么Kafka 默认会采用这种策略</strong>。</p>
<p>2）<strong>消息key指定分区策略：</strong>Kafka 允许为每条消息定义 key，即消息在创建的时候 key 不为空，此时 Kafka 会根据消息的 key 进行 hash, 然后根据 hash 值对 Partition 进行取模映射到指定的分区上， 这样的好处就是相同 key的消息会发送到同一个分区上， 这样 <strong>Kafka 虽然不能保证全局有序，但是可以保证每个分区的消息是有序的，这就是消息分区有序性</strong>，适应场景有下单支付的时候希望消息有序，可以通过订单 id 作为 key 发送消息达到分区有序性。</p>
<p>3）<strong>随机策略：</strong>随机发送到某个分区上，看似也是将消息均匀打散分配到各个分区，但是性能还是无法跟轮询策略比，「<strong>如果追求数据的均匀分布，最好还是使用轮询策略</strong>」。</p>
<p>4）<strong>自定义策略：</strong>可以通过实现 org.apache.kafka.clients.producer.Partitioner 接口，重写 partition 方法来达到自定义分区效果。</p>
</blockquote>
<h2 id="Kafka-如何合理设置分区数-越多越好吗"><a href="#Kafka-如何合理设置分区数-越多越好吗" class="headerlink" title="Kafka 如何合理设置分区数,越多越好吗"></a>Kafka 如何合理设置分区数,越多越好吗</h2><p><strong>一、Kafka 如何合理设置分区数</strong></p>
<p>首先我们要<strong>了解在 Partition 级别上达到负载均衡是实现高吞吐量的关键</strong>，合适的 Partition 数量可以达到并行读写和负载均衡的目的，<strong>需要根据每个分区的生产者和消费者的目标吞吐量进行估计</strong>。</p>
<p>此时我们可以遵循一定的步骤来计算确定分区数：</p>
<blockquote>
<p>1）首先根据某个 Topic 当前接收的数据量等经验来确定分区的初始值。</p>
<p>2）然后针对这个 Topic，进行测试 Producer 端吞吐量和 Consumer 端的吞吐量。</p>
<p>3）测试的结果， 假设此时他们的值分别是 Tp「<strong>Producer 端吞吐量</strong>」、Tc「<strong>负Consumer 端吞吐量</strong>」，总的目标吞吐量是 Tt， 单位是 MB/s， 那么结果 numPartition = Tt / max (Tp, Tc)。</p>
<p>4）<strong>特殊说明：</strong>测试 Tp 通常是很容易的，因为它的逻辑非常简单，就是直接发送消息到 Kafka 就好了。而测试 Tc 通常与应用消费消息后进行其他什么处理有关，相对复杂一些。</p>
</blockquote>
<p><strong>二、分区设置越多越好吗？</strong></p>
<p>首先 <strong>Kafka 高吞吐量的原因之一就是通过 Partition 将 Topic 中的消息均衡保存到 Kafka 集群中不同的 Broker 中</strong>。</p>
<p>「<strong>理论上说，如果一个 Topic 分区越多，整个集群所能达到的吞吐量就越大</strong>」。但是，实际生产中 Kafka Topic 的分区数真的配置越多越好吗？<strong>很显然不是！分区数过多会有什么弊端和问题呢，我们可以从下面4个方向进行深度分析：</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/08/0946-lFzucv.png" alt="图片"></p>
<h3 id="使用内存方面分析"><a href="#使用内存方面分析" class="headerlink" title="使用内存方面分析"></a><strong>使用内存方面分析</strong></h3><blockquote>
<p>1）<strong>Broker端：</strong>有很多组件都在内存中维护了分区级别的缓存，比如 Controller，FetcherManager 等，因此分区数越多，这类缓存的成本就越大。</p>
<p>2）<strong>Producer端：</strong>比如参数 batch.size，默认是16KB。它会为每个分区缓存消息，在数据积累到一定大小或者足够的时间时，累积的消息将会从缓存中移除并发往Broker 节点。这个功能是为了提高性能而设计，但是随着分区数增多，这部分缓存所需的内存占用也会更多。</p>
<p>3）<strong>Consumer端：</strong>消费者数跟分区数是直接挂钩的，在消费消息时的内存占用、以及为达到更高的吞吐性能需要开启的 Consumer 数也会随着分区数增加而增加。</p>
</blockquote>
<h3 id="消耗文件句柄方面分析"><a href="#消耗文件句柄方面分析" class="headerlink" title="消耗文件句柄方面分析"></a><strong>消耗文件句柄方面分析</strong></h3><p><strong>在 Kafka 的 Broker 中，每个 Partition 都会对应磁盘文件系统中一个目录</strong>。在 Kafka 的日志文件目录中，每个日志数据段都会分配三个文件，两个索引文件和一个数据文件。<strong>每个 Broker 会为每个日志段文件打开两个 index 文件句柄和一个 log 数据文件句柄</strong>。因此，随着 Partition 的增多，所需要保持打开状态的文件句柄数也就越多，最终可能超过底层操作系统配置的文件句柄数量限制。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/08/0947-XYbmGY.png" alt="图片"></p>
<h3 id="端到端的延迟方面分析"><a href="#端到端的延迟方面分析" class="headerlink" title="端到端的延迟方面分析"></a><strong>端到端的延迟方面分析</strong></h3><p>首先我们得先了解 Kafka 端对端延迟是什么? Producer 端发布消息到 Consumer 端接收消息所需要的时间，<strong>即 Consumer 端接收消息的时间减去 Producer 端发布消息的时间</strong>。</p>
<p>在 Kafka 中只对「<strong>已提交的消息做最大限度的持久化保证不丢失</strong>」，因此 Kafka 只有在消息提交之后，才会将消息暴露给消费者。<strong>此时如果分区越多那么副本之间需要同步的数据就会越多</strong>，假如消息需要在所有 ISR 副本集合列表同步复制完成之后才能进行暴露。<strong>因此 ISR 副本集合间复制数据所花时间将是 kafka 端对端延迟的最主要部分</strong>。</p>
<p>此时我们可以通过加大 kafka 集群来进行缓解。比如，我们将 100 个分区 Leader 放到一个 Broker 节点和放到 10 个 Broker  节点，它们之间的延迟是不一样的。如在 10 个 Broker 节点的集群中，每个 Broker 节点平均只需要处理  10 个分区的数据复制。此时端对端的延迟将会变成原来的十分之一。</p>
<p><strong>因此根据实战经验，如果你特别关心消息延迟问题的话，此时限制每个 Broker 节点的 Partition 数量是一个非常不错的主意：</strong>对于 N 个 Broker 节点和复制副本因子「<strong>replication-factor</strong>」为 F 的 Kafka 集群，那么整个 Kafka 集群的 Partition 数量最好不超过 「<strong>100 * N * F</strong>」 个，即单个  Broker 节点 Partition 的 Leader 数量不超过100。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/08/0948-jPFAuB.png" alt="图片"></p>
<h3 id="高可用性方面分析"><a href="#高可用性方面分析" class="headerlink" title="高可用性方面分析"></a><strong>高可用性方面分析</strong></h3><p><strong>我们知道 Kafka 是通过多副本复制技术来实现集群的高可用和稳定性的</strong>。每个 Partition 都会有多个数据副本，每个副本分别存在于不同的 Broker 上。所有的数据副本中，其中一个数据副本为 Leader，其他的数据副本为 Follower。</p>
<p><strong>在Kafka集群内部，所有的数据副本采用自动化的方式管理且会确保所有副本之间的数据是保持同步状态的。</strong>当 Broker 发生故障时，对于 Leader 副本所在 Broker 的所有 Partition 将会变得暂不可用。Kafka  将自动在其它副本中选择出一个 Leader，用于接收客户端的请求。这个过程由 Kafka Controller 节点 Broker  自动选举完成。</p>
<p>正常情况下，当一个 Broker 在有计划地停止服务时候，那么 Controller 会在服务停止之前，将该 Broker上 的所有 Leader  副本一个个地移走。对于单个 Leader 副本的移动速度非常快，从客户层面看，有计划的服务停服只会导致系统很短时间窗口不可用。</p>
<p>但是，当 Broker 不是正常停止服务时「<strong>kill -9 强杀方式</strong>」，系统的不可用时间窗口将会与受影响的 Partition 数量有关。如果此时发生宕机的 Broker 是 Controller 节点时, 这时 Controller 节点故障恢复会自动的进行，<strong>但是新的 Controller 节点需要从 Zookeeper 中读取每一个 Partition 的元数据信息用于初始化数据</strong>。假设一个 Kafka 集群存在10000个 Partition，从 Zookeeper 中恢复元数据时每个 Partition 大约花费2ms，则 Controller 恢复将会增加约20秒的不可用时间窗口。</p>
<p><strong>总之，通常情况下 Kafka 集群中越多的 P**</strong>artition 会带来越高的吞吐量。但是，如果 Kafka 集群中 Partition 总量过大或者单个 Broker 节点 Partition 过多，都可能会对系统的可用性和消息延迟带来潜在的负面影响，需要引起我们的重视。</p>
<h2 id="如何保证-Kafka-中的消息是有序的"><a href="#如何保证-Kafka-中的消息是有序的" class="headerlink" title="如何保证 Kafka 中的消息是有序的"></a>如何保证 Kafka 中的消息是有序的</h2><p>我们知道在 Kafka 中，并不保证消息全局有序，但是可以<strong>保证分区有序性，</strong>分区与分区之间是无序的。<strong>那么如何保证 Kafka 中的消息是有序的呢？</strong> 可以从以下三个方面来入手分析：</p>
<h3 id="生产端-Producer"><a href="#生产端-Producer" class="headerlink" title="生产端 Producer"></a><strong>生产端 Producer</strong></h3><p>在第4道题「<strong>生产者有哪些发送模式</strong>」的最后的场景分析里面简单的说明了下, 这里再详细的进行分析下：</p>
<p>首先 Kafka 的 Producer 端发送消息，如果是不对默认参数进行任何设置且网络没有抖动的情况下，消息是可以一批批的按消息发送的顺序被发送到 Kafka Broker 端。但是，一旦有网络波动了，则消息就可能出现乱序。</p>
<p><strong>所以，要严格保证 Kafka 发消息有序，首先要考虑用同步的方式来发送消息, 两种同步发送的方式如下:</strong></p>
<blockquote>
<p>1）<strong>设置消息响应参数 acks = all &amp;  max.in.flight.requests.per.connection = 1：</strong>发送端将会在一条消息发出后，响应必须满足 acks 设置的参数后，才会发送下一条消息。虽然在使用时还是异步发送的方式，其实底层已经是一条接一条的发送了。</p>
<p>2）<strong>Sync发送方式：</strong>当调用 KafkaProducer 的 send() 后，返回的 Future 对象的 get 方式阻塞等待结果。根据返回的结果可以判断是否发送成功, <strong>由于是同步发送会阻塞, 只有当消息通过 get() 返回数据时，才会继续下一条消息的发送</strong>。</p>
<p>通过上面方式还可能出现消息重发和幂等问题:</p>
<p>1）<strong>重发问题：</strong>Kafka 在消息发送出现问题时，通过判断是否可以自动重试恢复，如果是可以自动恢复的问题，设置 retries &gt; 0，让 Kafka 自动重试。</p>
<p>2）<strong>幂等问题：Kafka 1.0 之后的版本，Producer 端引入了幂等特性。设置enable.idempotence = true,  幂等特性可以给消息添加序列号，即每次发送会把序列号递增 1。</strong>开启了 Kafka Producer端的幂等特性后，我们就可以通过设置参数max.in.flight.requests.per.connection = 5 「默认值」, 这样当 Kafka 发消息的时候，由于消息有了序列号当发送消息出现错误的时候，Kafka 底层会通过获取服务器端的最近几条日志的序列号和发送端需要重新发送的消息序列号做对比，如果是连续的，那么就可以继续发送消息，保证消息顺序。</p>
</blockquote>
<h3 id="服务端-Broker"><a href="#服务端-Broker" class="headerlink" title="服务端 Broker"></a><strong>服务端 Broker</strong></h3><p>在 Kafka 中，Topic 只是一个逻辑上的概念，<strong>而组成 Topic 的分区 Partition 才是真正存消息的地方</strong>。</p>
<p>Kafka 只保证单分区内的消息是有序的，<strong>所以如果要保证业务全局严格有序，就要设置 Topic 为单分区的方式</strong>。不过对业务来说一般不需要考虑全局有序的，只需要<strong>保证业务中不同类别的消息有序</strong>即可。</p>
<p><strong>但是这里有个必须要受到重视的问题</strong>，就是当我们对分区 Partition 进行数量改变的时候，由于是简单的 Hash 算法会把以前可能分到相同分区的消息分到别的分区上。这样就不能保证消息顺序了。面对这种情况，<strong>就需要在动态变更分区的时候，考虑对业务的影响。有可能需要根据业务和当前分区需求，重新划分消息类别</strong>。</p>
<h3 id="消费端-Consumer"><a href="#消费端-Consumer" class="headerlink" title="消费端 Consumer"></a><strong>消费端 Consumer</strong></h3><p>在 Consumer 端，<strong>根据 Kafka 的模型，一个 Topic 下的每个分区只能从属于这个 Topic 的消费者组中的某一个消费者</strong>。</p>
<p>当消息被发送分配到同一个 Partition 中，消费者从 Partition 中取出来数据的时候，也一定是有顺序的，没有错乱。</p>
<p>但是消费者可能会有多个线程来并发来消费消息。如果单线程消费数据，吞吐量太低了，而多个线程并发消费的话，顺序可能就乱掉了。</p>
<p><strong>此时可以通过写多个内存队列，将相同 key 的消息都写入同一个队列，然后对于多个线程，每个线程分别消息一个队列即可保证消息顺序</strong>。</p>
<h2 id="Kafka-为什么不支持读写分离呢"><a href="#Kafka-为什么不支持读写分离呢" class="headerlink" title="Kafka 为什么不支持读写分离呢"></a>Kafka 为什么不支持读写分离呢</h2><p>在很多主从模型系统中，是允许从节点可以对外提供读服务的，<strong>只不过 Kafka 当初为了避免数据不一致的问题，而采用了通过主节点来统一提供服务的方式。</strong></p>
<p><strong>不支持读写分离的原因有2点：</strong></p>
<blockquote>
<p>1）<strong>场景不一致：</strong>读写分离架构适用于那种读操作负载很大，但写操作相对不频繁的场景，但是 Kafka 显然不适合这种场景。</p>
<p>2）<strong>延迟问题：</strong>Kafka 通过 PULL 方式来实现数据同步，因此 Leader 副本和 Follower 副本存在数据不一致的情况， 如果允许 Follower 副本提供读服务的话，就会带来消息滞后的问题。</p>
</blockquote>
<h2 id="Kafka-副本有哪两种，作用是什么"><a href="#Kafka-副本有哪两种，作用是什么" class="headerlink" title="Kafka 副本有哪两种，作用是什么"></a>Kafka 副本有哪两种，作用是什么</h2><p>在 Kafka 中，为实现「<strong>数据备份</strong>」的功能，保证集群中的某个节点发生故障时，该节点上的 Partition 数据不丢失，且 Kafka 仍然能够继续工作，<strong>为此 Kafka 提供了副本机制，</strong> <strong>一个 Topic 的每个 Partition 都有若干个副本，一个 Leader 副本和若干个 Follower 副本</strong>。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/08/0953-dFYtYN.png" alt="图片"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/08/0953-0rZ5gK.png" alt="图片"></p>
<blockquote>
<p>1）Leader 主副本负责对外提供读写数据服务。</p>
<p>2）Follower 从副本只负责和 Leader 副本保持数据同步，并不对外提供任何服务。</p>
</blockquote>
<h2 id="Kafka-能否手动删除消息"><a href="#Kafka-能否手动删除消息" class="headerlink" title="Kafka 能否手动删除消息"></a>Kafka 能否手动删除消息</h2><p>首先 Kafka 是支持手动删除消息的， 当然它本身提供了消息留存策略，能够自动删除过期的消息。</p>
<p>Kafka 将消息存储到磁盘中，随着写入数据不断增加，磁盘占用空间越来越大，为了控制占用空间就需要对消息做一定的清理操作。Kafka  存储日志结构分析中每一个分区副本（Replica）都对应一个 Log，而 Log 又可以分为多个日志分段（LogSegment），这样就便于  Kafka 对日志的清理操作。</p>
<blockquote>
<p>1）<strong>普通消息：</strong>我们可以使用 Kafka-delete-records 命令或者通过程序调用 Admin.deleteRecords 方法来删除消息。两者底层都是调用 Admin 的 deleteRecords 的方法，通过将分区的 LEO 值抬高来间接删除消息。</p>
<p>2）<strong>设置key且参数 cleanup.policy=delete/campact 的消息：</strong>可以依靠 Log Cleaner 组件提供的功能删除该 Key 的消息。</p>
<p><strong>日志删除（Log Retention）：</strong>按照一定的保留策略直接删除不符合条件的日志分段（LogSegment）。</p>
<p><strong>日志压缩（Log Compaction）：</strong>针对每个消息的key进行整合，对于有相同key的不同value值，只保留最后一个版本。</p>
</blockquote>
<h3 id="日志删除"><a href="#日志删除" class="headerlink" title="日志删除"></a><strong>日志删除</strong></h3><p>Kafka 的日志管理器（LogManager）中有一个专门的日志清理任务通过周期性检测和删除不符合条件的日志分段文件（LogSegment），这里我们可以通过设置 Kafka Broker 端的参数「 <strong>log.retention.check.interval.ms</strong>」，默认值为300000，即5分钟。</p>
<p>在 Kafka 中一共有3种保留策略：</p>
<h4 id="基于时间策略"><a href="#基于时间策略" class="headerlink" title="基于时间策略"></a>基于时间策略</h4><p>日志删除任务会周期检查当前日志文件中是否有保留时间超过设定的阈值<strong>(retentionMs)</strong> 来寻找可删除的日志段文件集合(deletableSegments)。</p>
<p>其中 <strong>retentionMs</strong> 可以通过 Kafka Broker 端的这几个参数的大小判断的</p>
<p><code>log.retention.ms &gt; log.retention.minutes &gt; log.retention.hours</code>优先级来设置，<strong>默认情况只会配置 log.retention.hours 参数，值为168即为7天。</strong></p>
<p>这里需要注意：删除过期的日志段文件，并不是简单的根据该日志段文件的修改时间计算的，而是要根据该日志段中最大的时间戳 largestTimeStamp  来计算的，首先要查询该日志分段所对应的时间戳索引文件，查找该时间戳索引文件的最后一条索引数据，如果时间戳值大于0，则取值，否则才会使用最近修改时间（lastModifiedTime）。</p>
<p><strong>【删除步骤】：</strong></p>
<ol>
<li><p>首先从 Log 对象所维护的日志段的跳跃表中移除要删除的日志段，用来确保已经没有线程来读取这些日志段。</p>
</li>
<li><p>将日志段所对应的所有文件，包括索引文件都添加上“.deleted”的后缀。</p>
</li>
<li><p>最后交给一个以“delete-file”命名的延迟任务来删除这些以“ .deleted ”为后缀的文件。默认1分钟执行一次， 可以通过 <code>file.delete.delay.ms</code> 来配置。</p>
</li>
</ol>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/08/0958-azAo2i.png" alt="图片"></p>
<h4 id="基于日志大小策略"><a href="#基于日志大小策略" class="headerlink" title="基于日志大小策略"></a>基于日志大小策略</h4><p>日志删除任务会周期检查当前日志大小是否超过设定的阈值<strong>(retentionSize)</strong> 来寻找可删除的日志段文件集合<strong>(deletableSegments)</strong>。</p>
<p>其中<strong>retentionSize</strong>这里我们可以通过 Kafka Broker 端的参数log.retention.bytes 来设置， 默认值为-1，即无穷大。</p>
<p>这里需要注意的是 log.retention.bytes 设置的是Log中所有日志文件的大小，而不是单个日志段的大小。单个日志段可以通过参数 log.segment.bytes 来设置，默认大小为1G。</p>
<p>【删除步骤】：</p>
<ol>
<li><p>首先计算日志文件的总大小Size和 retentionSize 的差值，即需要删除的日志总大小。</p>
</li>
<li><p>然后从日志文件中的第一个日志段开始进行查找可删除的日志段的文件集合(deletableSegments)</p>
</li>
<li><p>找到后就可以进行删除操作了</p>
</li>
</ol>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/08/0959-3TFZgh.png" alt="图片"></p>
<h4 id="基于日志起始偏移量"><a href="#基于日志起始偏移量" class="headerlink" title="基于日志起始偏移量"></a>基于日志起始偏移量</h4><p>该策略判断依据是日志段的下一个日志段的起始偏移量 baseOffset 是否小于等于 logStartOffset，如果是，则可以删除此日志分段。</p>
<p><strong>【如下图所示 删除步骤】：</strong></p>
<ol>
<li><p>首先从头开始遍历每个日志段，日志段 1 的下一个日志分段的起始偏移量为20，小于 logStartOffset 的大小，将日志段1加入deletableSegments。</p>
</li>
<li><p>日志段2的下一个日志偏移量的起始偏移量为35，也小于 logStartOffset 的大小，将日志分段2页加入 deletableSegments。</p>
</li>
<li><p>日志段3的下一个日志偏移量的起始偏移量为50，也小于 logStartOffset 的大小，将日志分段3页加入 deletableSegments。</p>
</li>
<li><p>日志段4的下一个日志偏移量通过对比后，在 logStartOffset 的右侧，那么从日志段4开始的所有日志段都不会加入 deletableSegments。</p>
</li>
<li><p>待收集完所有的可删除的日志集合后就可以直接删除了。</p>
</li>
</ol>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/08/1000-4Y1EXb.png" alt="图片"></p>
<h3 id="日志压缩"><a href="#日志压缩" class="headerlink" title="日志压缩"></a><strong>日志压缩</strong></h3><p><strong>日志压缩 Log Compaction 对于有相同key的不同value值，只保留最后一个版本。</strong>如果应用只关心 key 对应的最新 value 值，则可以开启 Kafka 相应的日志清理功能，Kafka 会定期将相同 key 的消息进行合并，只保留最新的 value 值。</p>
<p>Log Compaction 可以类比 Redis 中的 RDB 的持久化模式。我们可以想象下，如果每次消息变更都存 Kafka，在某一时刻，  Kafka 异常崩溃后，如果想快速恢复，可以直接使用日志压缩策略， 这样在恢复的时候只需要恢复最新的数据即可，这样可以加快恢复速度。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/08/1001-iEOvMX.png" alt="图片"></p>
<h2 id="Kafka-读写数据这么快是如何做到的"><a href="#Kafka-读写数据这么快是如何做到的" class="headerlink" title="Kafka 读写数据这么快是如何做到的"></a>Kafka 读写数据这么快是如何做到的</h2><h3 id="顺序追加写"><a href="#顺序追加写" class="headerlink" title="顺序追加写"></a><strong>顺序追加写</strong></h3><p>kafka 在写数据的时是以「<strong>磁盘顺序写」</strong>的方式来进行落盘的, 即将数据追加到文件的末尾。对于普通机械磁盘, 如果是随机写的话, 涉及到磁盘寻址的问题, 导致性能极低,  <strong>但是如果只是按照顺序的方式追加文件末尾的话, 这种磁盘顺序写的性能基本可以跟写内存的性能差不多的</strong>。下图所示普通机械磁盘的顺序I/O性能指标是53.2M values/s。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/08/1002-MuNvh7.png" alt="图片"></p>
<h3 id="Page-Cache"><a href="#Page-Cache" class="headerlink" title="Page Cache"></a><strong>Page Cache</strong></h3><p>首先 Kafka 为了保证磁盘写入性能，<strong>通过 mmap 内存映射的方式利用操作系统的 Page Cache 异步写入 。</strong>也可以称为 os cache，意思就是操作系统自己管理的缓存。<strong>那么在写磁盘文件的时候，就可以先直接写入 os cache 中，接下来由操作系统自己决定什么时候把 os cache 里的数据真正刷入到磁盘中, 这样大大提高写入效率和性能</strong>。 如下图所示:</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/08/1002-MQuUfH.png" alt="图片"></p>
<h3 id="零拷贝技术"><a href="#零拷贝技术" class="headerlink" title="零拷贝技术"></a><strong>零拷贝技术</strong></h3><p>kafka 为了解决<strong>内核态和用户态数据不必要 Copy</strong> 这个问题, 在读取数据的时候就引入了「<strong>零拷贝技术</strong>」。即让操作系统的 os cache 中的数据<strong>直接发送到</strong>网卡后传出给下游的消费者，中间跳过了两次拷贝数据的步骤，从而减少拷贝的 CPU 开销, 减少用户态内核态的上下文切换次数, 从而优化数据传输的性能, <strong>而Socket缓存中仅仅会拷贝一个描述符过去，不会拷贝数据到Socket缓存</strong>，如下图所示：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/08/1003-KggNcw.png" alt="图片"></p>
<p>在 Kafka 中主要有以下两个地方使用到了「<strong>零拷贝技术</strong>」<strong>:</strong></p>
<blockquote>
<p>1）<strong>基于 mmap 机制实现的索引文件：</strong>首先索引文件都是<strong>基于 MappedByBuffer 实现</strong>，即让用户态和内核态来共享内核态的数据缓冲区，此时数据不需要 Copy 到用户态空间。虽然 mmap 避免了不必要的 Copy，但是在不同操作系统下， 其创建和销毁成功是不一样的，不一定都能保证高性能。所以在 Kafka 中只有索引文件使用了 mmap。</p>
<p>2）<strong>基于sendfile 机制实现的日志文件读写：</strong>在 Kafka 传输层接口中有个 TransportLayer 接口，它的实现类中有使用了 Java FileChannel 中  transferTo 方法。该方法底层就是使用 sendfile 实现的零拷贝机制， 目前只是在 I/O 通道是普通的 PLAINTEXT  的时候才会使用到零拷贝机制。</p>
</blockquote>
<h3 id="消息批量发送"><a href="#消息批量发送" class="headerlink" title="消息批量发送"></a><strong>消息批量发送</strong></h3><p>Kafka 在发送消息的时候并不是一条条的发送的，而是会<strong>把多条消息合并成一个批次**</strong>Batch<strong> </strong>进行处理发送**，消费消息也是同样，一次拉取一批次的消息进行消费。如下图所示：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/08/1003-aQzv4L.png" alt="图片"></p>
<h3 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a><strong>数据压缩</strong></h3><p>在 Kafka 中三个端都使用了优化后的压缩算法，<strong>压缩有助于提高吞吐量, 降低延迟并提高磁盘利用率</strong>。Kafka 底层支持多种压缩算法: <strong>lz4, snappy, gzip</strong>, 从Kafka 2.1.0 开始新增了 <strong>ZStandard</strong> 算法, 该算法是 Facebook 开源的压缩算法,  能提供超高的压缩比。</p>
<p>在 Kafka 中, 压缩可能会发生在两个地方: <strong>生产者端和Broker端</strong>。一句话总结下压缩和解压缩, 即 Producer 端压缩, Broker 端保持, Consumer 端解压缩，这样可以节省大量的网络和磁盘开销。</p>
<h2 id="Kafka-消费模型有哪些"><a href="#Kafka-消费模型有哪些" class="headerlink" title="Kafka 消费模型有哪些"></a>Kafka 消费模型有哪些</h2><p>一般情况下消息消费总共有两种模式：「<strong>推模型</strong>」和 「<strong>拉模型</strong>」。在 Kafka 中的消费模型是属于「<strong>拉模型</strong>」，此模式的消息消费方式实现有两种：「<strong>点对点方式</strong>」和 「<strong>发布订阅方式</strong>」。</p>
<h3 id="点对点方式"><a href="#点对点方式" class="headerlink" title="点对点方式"></a><strong>点对点方式</strong></h3><p><img data-src="https://xuemingde.com/pages/image/2022/04/08/1005-qX8nJg.png" alt="图片"></p>
<p><strong>点对点方式:</strong> 假如所有消费者都同属于一个消费组的话，此时所有的消息都会被分配给每一个消费者，<strong>但是消息只会被其中一个消费者进行消费</strong>。</p>
<h3 id="发布订阅方式"><a href="#发布订阅方式" class="headerlink" title="发布订阅方式"></a><strong>发布订阅方式</strong></h3><p><img data-src="https://xuemingde.com/pages/image/2022/04/08/1005-TENKds.png" alt="图片"></p>
<p><strong>发布订阅:</strong> 假如所有消费者属于不同的消费组，此时所有的消息都会被分配给每一个消费者，<strong>每个消费者都会收到该消息</strong>。</p>
<h2 id="什么是消费者组-有什么作用"><a href="#什么是消费者组-有什么作用" class="headerlink" title="什么是消费者组,有什么作用"></a>什么是消费者组,有什么作用</h2><p>首先我来看看什么是「<strong>消费者组</strong>」:</p>
<p>消费者组 Consumer Group，顾名思义就是由多个 Consumer 组成，且拥有一个公共且唯一的 Group ID。组内每个消费者负责消费不同分区的数据，<strong>但一个分区只能由一个组内消费者消费，</strong>消费者组之间互不影响。</p>
<p><strong>为什么 Kafka 要设计 Consumer Group,  只有 Consumer 不可以吗？</strong> </p>
<p>我们知道 Kafka 是一款高吞吐量，低延迟，高并发, 高可扩展的消息队列产品， 那么如果某个 Topic 拥有数百万到数千万的数据量， 仅仅依靠 Consumer 进程消费， 消费速度可想而知， <strong>所以需要一个扩展性较好的机制来保障消费进度， 这个时候 Consumer Group 应运而生， Consumer Group 是 Kafka 提供的可扩展且具有容错性的消费者机制</strong>。</p>
<p>Kafka Consumer Group 特点如下:</p>
<blockquote>
<p>1）每个 Consumer Group 有一个或者多个 Consumer。</p>
<p>2）每个 Consumer Group 拥有一个公共且唯一的 Group ID。</p>
<p>3）Consumer Group 在消费 Topic 的时候，Topic 的每个 Partition 只能分配给组内的某个  Consumer，只要被任何 Consumer 消费一次, 那么这条数据就可以认为被当前 Consumer Group 消费成功。</p>
</blockquote>
<h2 id="Kafka中Offset的作用是什么-如何进行维护"><a href="#Kafka中Offset的作用是什么-如何进行维护" class="headerlink" title="Kafka中Offset的作用是什么,如何进行维护"></a>Kafka中Offset的作用是什么,如何进行维护</h2><p>在 <strong>Kafka</strong> 中每个 <strong>Topic</strong> 分区下面的每条消息都被赋予了一个唯一的<strong>ID</strong>值，用来标识它在分区中的位置。这个<strong>ID</strong>值就被称为位移「<strong>Offset</strong>」或者叫偏移量，一旦消息被写入到日志分区中，它的位移值将不能被修改。</p>
<h3 id="位移-Offset-管理方式"><a href="#位移-Offset-管理方式" class="headerlink" title="位移 Offset 管理方式"></a><strong>位移 Offset 管理方式</strong></h3><p>Kafka 旧版本（0.9版本之前）是把位移保存在 ZooKeeper 中，减少 Broker 端状态存储开销。</p>
<p>鉴于 Zookeeper 不适合频繁写更新，而 Consumer Group 的位移提交又是高频写操作，这样会拖慢 ZooKeeper 集群的性能， 于是在新版 Kafka 中， 社区采用了将位移保存在 Kafka 内部「<strong>Kafka Topic 天然支持高频写且持久化</strong>」，这就是所谓大名鼎鼎的__consumer_offsets。</p>
<p><strong>__consumer_offsets：</strong>用来保存 Kafka Consumer 提交的位移信息，另外它是由 Kafka 自动创建的，和普通的 Topic 相同，它的消息格式也是 Kafka 自己定义的，我们无法进行修改。</p>
<p><strong>__consumer_offsets 有3种消息格式：</strong></p>
<blockquote>
<p>1）用来保存 Consumer Group 信息的消息。</p>
<p>2）用来删除 Group 过期位移甚至是删除 Group 的消息，也可以称为 tombstone 消息，即墓碑消息，它的主要特点是空消息体，一旦某个  Consumer Group 下的所有Consumer 位移数据都已被删除时，Kafka会向 __consumer_offsets  主题的对应分区写入 tombstone 消息，表明要彻底删除这个 Group 的信息。</p>
<p>3）用来保存位移值。</p>
</blockquote>
<p><strong>__consumer_offsets 消息格式分析揭秘：</strong></p>
<blockquote>
<p>1) 消息格式我们可以简单理解为是一个 KV 对。Key 和 Value 分别表示消息的键值和消息体。</p>
<p>2) 那么 Key 存什么呢？既然是存储 Consumer 的位移信息，在 Kafka 中，Consumer  数量会很多，必须有字段来标识位移数据是属于哪个 Consumer 的，怎么来标识 Consumer 字段呢？我们知道 Consumer  Group 会共享一个公共且唯一的 Group ID，那么只保存它就可以了吗？我们知道 Consumer  提交位移是在分区的维度进行的，很显然，key中还应该保存 Consumer 要提交位移的分区。</p>
<p>3) 总结：位移主题的 Key 中应该保存 3 部分内容：&lt;<strong>Group ID，主题名，分区号</strong>&gt;</p>
<p>4) value 可以简单认为存储的是 offset 值，当然底层还存储其他一些元数据，帮助 Kafka 来完成一些其他操作，比如删除过期位移数据等。</p>
</blockquote>
<p><strong>__consumer_offsets 消息格式示意图：</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/08/1009-1e9GuY.png" alt="图片"></p>
<h3 id="consumer-offsets-创建"><a href="#consumer-offsets-创建" class="headerlink" title="__consumer_offsets 创建"></a><strong>__consumer_offsets 创建</strong></h3><p><strong>consumer_offsets 是怎么被创建出来的呢？ 当 Kafka 集群中的第一个 Consumer 启动时，Kafka 会自动创建</strong>consumer_offsets。</p>
<p>它就是普通的 Topic，也有对应的分区数，如果由 Kafka 自动创建的，那么分区数又是怎么设置的呢？</p>
<p>这个依赖 Broker 端参数主题分区位移个数即「<strong>offsets.topic.num.partitions</strong>」 默认值是50，因此 Kafka 会自动创建一个有 50 个分区的 __consumer_offsets 。既然有分区数，必然就会有分区对应的副本个数，这个是依赖Broker 端另外一个参数来完成的，即 「<strong>offsets.topic.replication.factor</strong>」默认值为3。</p>
<p>总结一下， __consumer_offsets 由 Kafka 自动创建的，那么该 Topic 的分区数是 50，副本数是 3，而具体 Consumer Group 的消费情况要存储到哪个 Partition ，根据<strong>abs(GroupId.hashCode()) % NumPartitions</strong> 来计算的，这样就可以保证 Consumer Offset 信息与 Consumer Group 对应的 Coordinator 处于同一个 Broker 节点上。如下图所示：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/08/1010-lBt3Xy.png" alt="图片"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/08/1011-6lXNYd.png" alt="图片"></p>
<hr>
<blockquote>
<p>原文：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvOE9BUXpaNWpaWVYyRnZ0ZzBwZlpvUQ==">【建议收藏】Kafka 面试连环炮, 看看你能撑到哪一步?（上）<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
]]></content>
      <categories>
        <category>中间件</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>内存</tag>
        <tag>sql</tag>
        <tag>集合</tag>
        <tag>函数</tag>
        <tag>CPU</tag>
        <tag>全局</tag>
        <tag>面试</tag>
        <tag>Mysql</tag>
        <tag>索引</tag>
        <tag>分布式</tag>
        <tag>Redis</tag>
        <tag>MQ</tag>
        <tag>并发</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka面试连环炮-下</title>
    <url>/posts/2P9AR21.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>原文：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvSGtzUXRsaFlHMmhSSE1LRDg1a3Rudw==">【建议收藏】Kafka 面试连环炮, 看看你能撑到哪一步?（下）<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>我们知道 Kafka 网络通信架构使用到了 Java NIO 以及 Reactor 设计模式。我们先从整体上看一下完整的网络通信层架构，如下图所示：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/10/0957-7aENgd.png" alt="图片"></p>
<blockquote>
<p>1）从上图中我们可以看出，Kafka 网络通信架构中用到的组件主要由两大部分构成：<code>SocketServer 和 RequestHandlerPool</code>。</p>
<p>2）<code>SocketServer 组件是 Kafka 超高并发网络通信层中最重要的子模块</code>。它包含 Acceptor 线程、Processor 线程和 RequestChannel 等对象，都是网络通信的重要组成部分。</p>
<p>3）<strong>RequestHandlerPool 组件</strong>就是我们常说的 I/O 工作线程池，里面定义了若干个 I/O 线程，<code>主要用来执行真实的请求处理逻辑</code>。</p>
</blockquote>
<h3 id="Accept-线程"><a href="#Accept-线程" class="headerlink" title="Accept 线程"></a>Accept 线程</h3><p>在经典的 Reactor 设计模式有个「<strong>Dispatcher</strong>」的角色，<code>主要用来接收外部请求并分发给下面的实际处理线程</code>。在 Kafka 网络架构设计中，这个 Dispatcher 就是「<strong>Acceptor 线程</strong>」, 用来接收和创建外部 TCP 连接的线程。在 Broker 端每个 SocketServer 实例只会创建一个 Acceptor 线程。<code>它的主要功能就是创建连接，并将接收到的 Request 请求传递给下游的 Processor 线程处理</code>。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/10/0958-SHDgkB.png" alt="图片"></p>
<blockquote>
<p>1）我们可以看出 Acceptor 线程主要使用了 Java NIO 的 Selector 以及 SocketChannel 的方式循环的轮询准备就绪的 I/O 事件。</p>
<p>2）将 ServerSocketChannel 通道注册到nioSelector 上，并关注网络连接创事件：SelectionKey.OP_ACCEPT。</p>
<p>3）事件注册好后，一旦后续接收到连接请求后，Acceptor 线程就会指定一个 Processor 线程，并将该请求交给它并创建网络连接用于后续处理。</p>
</blockquote>
<h3 id="Processor-线程"><a href="#Processor-线程" class="headerlink" title="Processor 线程"></a>Processor 线程</h3><p>Acceptor 只是做了请求入口连接处理的，那么，<code>真正创建网络连接以及分发网络请求是由 Processor 线程来完成的</code>。而每个 Processor 线程在创建时都会创建 3 个队列。</p>
<blockquote>
<p>1）<strong>newConnections 队列:</strong> 它主要是用来保存要创建的新连接信息，也就是SocketChannel 对象，<strong>目前是硬编码队列长度大小为20</strong>。每当 Processor 线程接收到新的连接请求时，都会将对应的 SocketChannel 对象放入队列，等到后面创建连接时，从该队列中获取 SocketChannel，然后注册新的连接。</p>
<p>2）<strong>inflightResponse 队列：</strong>它是一个临时的 Response 队列，当 Processor 线程将 Repsonse 返回给 Client 之后，要将 Response 放入该队列。它存在的意义：<code>由于有些 Response 回调逻辑要在 Response 被发送回 Request 发送方后，才能执行，因此需要暂存到临时队列</code>。</p>
<p>3）<strong>ResponseQueue 队列：</strong>它主要是存放需要返回给Request 发送方的所有 Response 对象。每个 Processor 线程都会维护自己的 Response 队列。</p>
</blockquote>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/10/1000-Vza3z2.png" alt="图片"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/10/1000-x5A3wg.png" alt="图片"></p>
<h3 id="RequestHandlerPool-线程池"><a href="#RequestHandlerPool-线程池" class="headerlink" title="RequestHandlerPool 线程池"></a>RequestHandlerPool 线程池</h3><p>Acceptor 线程和 Processor 线程只是请求和响应的「<strong>搬运工</strong>」，而「<strong>真正处理 Kafka 请求</strong>」是 <code>KafkaRequestHandlerPool</code> 线程池，在上面网络超高并发通信架构图，有两个参数跟整个流程有关系，分别是「<code>num.network.threads</code>」、「<code>num.io.threads</code>」。其中 num.io.threads 就是 I/O 工作线程池的大小配置。</p>
<p>​        <img data-src="https://xuemingde.com/pages/image/2022/04/10/1001-NqZsqB.png" alt="图片"></p>
<p>下面我们结合 Kafka 超高并发网络架构图来讲解下一个完整请求处理核心流程：</p>
<blockquote>
<p>1）Clients 发送请求给 Acceptor 线程。</p>
<p>2）Acceptor 线程会创建 NIO Selector 对象，并创建 ServerSocketChannel 通道实例，然后将 Channel 和 OP_ACCEPT 事件绑定到 Selector 多路复用器上。</p>
<p>3）Acceptor 线程默认创建3个Processor 线程参数：num.network.threads, 并轮询的将请求对象 SocketChannel 放入到连接队列中。</p>
<p>4）这时候连接队列就源源不断有请求数据了，然后不停地执行 NIO Poll, 获取对应 SocketChannel 上已经准备就绪的 I/O 事件。</p>
<p>5）Processor 线程向 SocketChannel 注册了 OP_READ/OP_WRITE 事件，这样 客户端发过来的请求就会被该 SocketChannel 对象获取到，具体就是 processCompleteReceives 方法。</p>
<p>6）这个时候客户端就可以源源不断进行请求发送了，服务端通过 Selector NIO Poll 不停的获取准备就绪的 I/O 事件。</p>
<p>7）然后根据Channel中获取已经完成的 Receive 对象，构建 Request 对象，并将其存入到 Requestchannel 的 RequestQueue 请求队列中 。</p>
<p>8）这个时候就该 I/O 线程池上场了，KafkaRequestHandler 线程循环地从请求队列RequestQueue 中获取 Request 实例，然后交由KafkaApis 的 handle 方法，执行真正的请求处理逻辑，并最终将数据存储到磁盘中。</p>
<p>9）待处理完请求后，KafkaRequestHandler 线程会将 Response 对象放入 Processor 线程的 Response 队列。</p>
<p>10）然后 Processor 线程通过 Request 中的 ProcessorID 不停地从 Response 队列中来定位并取出 Response 对象，返还给 Request 发送方。</p>
</blockquote>
<h2 id="了解Kafka高吞吐日志存储架构是如何设计吗"><a href="#了解Kafka高吞吐日志存储架构是如何设计吗" class="headerlink" title="了解Kafka高吞吐日志存储架构是如何设计吗"></a>了解Kafka高吞吐日志存储架构是如何设计吗</h2><p>对于 Kafka 来说， 它主要用来处理海量数据流，这个场景的特点主要包括：</p>
<blockquote>
<p>1) <strong>写操作：</strong>写并发要求非常高，基本得达到百万级 TPS，顺序追加写日志即可，无需考虑更新操作。</p>
<ol>
<li><strong>读操作：</strong>相对写操作来说，比较简单，只要能按照一定规则高效查询即可,支持（offset或者时间戳）读取。</li>
</ol>
</blockquote>
<p>根据上面两点分析，对于写操作来说，直接采用「<strong>顺序追加写日志</strong>」的方式就可以满足 Kafka 对于百万TPS写入效率要求。</p>
<p>如何解决高效查询这些日志呢？我们可以设想把消息的 Offset 设计成一个有序的字段，这样消息在日志文件中也就有序存放了，也不需要<strong>额外引入哈希表结构</strong>，可以直接将消息划分成若干个块，<code>对于每个块我们只需要索引当前块的第一条消息的 Offset ，这个是不是有点二分查找算法的意思</code>。即先根据 Offset 大小找到对应的块， 然后再从块中顺序查找。如下图所示：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/10/1003-2UplC7.png" alt="图片"></p>
<p>这样就可以快速定位到要查找的消息的位置了，在 Kafka 中，我们将这种索引结构叫做「<strong>稀疏哈希索引</strong>」。</p>
<p>上面得出了 Kafka 最终的存储实现方案， 即<code>基于顺序追加写日志 + 稀疏哈希索引</code>。</p>
<p>接下来我们来看看 Kafka 日志存储结构：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/10/1004-DqnnDS.png" alt="图片"></p>
<p>从上图看出来，Kafka 是基于「<code>主题 + 分区 + 副本 + 分段 + 索引</code>」的结构进行日志存储的。</p>
<p>了解了整体的日志存储架构，我们来看下 Kafka 日志格式，Kafka 日志格式也经历了多个版本迭代，这里我们主要看下V2版本的日志格式：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/10/1004-2KZQhv.png" alt="图片"></p>
<p>通过上图可以得出：<code>V2 版本日志格式主要是通过可变长度提高了消息格式的空间使用率</code>，并将某些字段抽取到消息批次（RecordBatch）中，同时消息批次可以存放多条消息，从而在批量发送消息时，可以大幅度地节省了磁盘空间。</p>
<p>接下来我们来看看日志消息写入磁盘的整体过程如下图所示：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/10/1005-Tad6Ll.png" alt="图片"></p>
<h2 id="针对-Kafka-线上集群部署方案-你是怎么做的"><a href="#针对-Kafka-线上集群部署方案-你是怎么做的" class="headerlink" title="针对 Kafka 线上集群部署方案, 你是怎么做的"></a>针对 Kafka 线上集群部署方案, 你是怎么做的</h2><p>这里我们从架构师必备能力出发， 以电商平台为例讲述了 Kafka 生产级容量评估方案该如何做？如何让公司领导以及运维部门得到认可， 获准你的方案。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/10/1005-ikMfte.png" alt="图片"></p>
<p>详细可以深读：<a href="http://mp.weixin.qq.com/s?__biz=Mzg3MTcxMDgxNA==&amp;mid=2247488846&amp;idx=1&amp;sn=1d77a05c7e94abd8044502c433d9aeee&amp;chksm=cefb3c7ff98cb569910c99de953ecce956a454a3d8e63be9e3a2b7639f633848ba4bb989bb87&amp;scene=21#wechat_redirect"><strong>八大步骤带你深度剖析Kafka生产级容量评估方案</strong></a></p>
<h2 id="针对-Kafka-线上系统-你是如何进行监控的"><a href="#针对-Kafka-线上系统-你是如何进行监控的" class="headerlink" title="针对 Kafka 线上系统, 你是如何进行监控的"></a>针对 Kafka 线上系统, 你是如何进行监控的</h2><p>Kafka 作为大型系统架构中重要的一环，有着举足轻重的作用，因此 Kafka 集群的稳定性尤为重要，我们要对生产的 Kafka 集群进行全方位的监控， 一般线上系统可以从以下五个维度进行监控：</p>
<h3 id="主机节点监控"><a href="#主机节点监控" class="headerlink" title="主机节点监控"></a>主机节点监控</h3><p>所谓主机节点监控就是监控 Kafka 集群 Broker 所在节点机器的性能。主机节点监控对于 Kafka 来说是最重要的，因为很多线上环境问题首先就是由于主机的某些性能出现了问题。</p>
<p>因此对于 Kafka 来说，主机监控通常是发现问题的第一步，主要性能指标如下：</p>
<p>「<strong>机器负载（Load）</strong>」、「<strong>CPU 使用率</strong>」、「<strong>内存使用率</strong>」、「<strong>磁盘 I/O 使用率</strong>」、「<strong>网络 I/O 使用率</strong>」、「<strong>TCP 连接数</strong>」、「<strong>打开文件数</strong>」、「<strong>inode 使用情况</strong>」。</p>
<p>如果想要更好的监控主机性能的话，有以下两个教程可以学习和参考：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/10/1006-p36iiv.png" alt="图片"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/10/1006-X46ebB.png" alt="图片"></p>
<h3 id="JVM-监控"><a href="#JVM-监控" class="headerlink" title="JVM 监控"></a>JVM 监控</h3><p>另一个重要的监控维度就是 JVM 监控。<code>监控 JVM 进程主要是为了让你全面地了解Kafka Broker 进程</code>。</p>
<p>要监控 JVM 进程，需要关注 3 个指标：</p>
<p>「<code>监控 Full GC 发生频率和时长</code>」、「<code>监控堆上活跃对象大小</code>」、「<code>监控应用线程总数</code>」</p>
<h3 id="Kafka-集群监控"><a href="#Kafka-集群监控" class="headerlink" title="Kafka 集群监控"></a>Kafka 集群监控</h3><p>另外一个重要监控维度就是 Kafka Broker 集群和各类客户端的监控，主要有3个方法：</p>
<blockquote>
<p>1）<strong>查看 Broker 端重要日志：</strong>主要包括 Broker 端服务器日志 server.log，控制器日志 controller.log 以及主题分区状态变更日志  state-change.log。其中，server.log 是最重要的，如果你的 Kafka 集群出现了故障，你要第一时间查看  server.log，定位故障原因。</p>
<p>2）<strong>查看 Broker 端关键线程运行状态，例如:</strong> </p>
<p>Log Compaction 线程：日志压缩清理。一旦它挂掉了，所有 Compaction 操作都会中断，但用户对此通常是无感知的。</p>
<p>副本拉取消息的线程：主要执行 Follower 副本向 Leader 副本拉取消息的逻辑。如果它们挂掉了，系统会表现为 Follower 副本延迟 Leader 副本越来越大 。</p>
<p>3）<strong>查看 Broker 端关键的 JMX 性能指标:</strong> 主要有BytesIn/BytesOut、NetworkProcessorAvgIdlePercent、RequestHandlerAvgIdlePercent、UnderReplicatedPartitions、ISRShrink/ISRExpand、ActiveControllerCount 这几个指标 。</p>
</blockquote>
<h3 id="Kafka-客户端监控"><a href="#Kafka-客户端监控" class="headerlink" title="Kafka 客户端监控"></a>Kafka 客户端监控</h3><p>客户端监控主要是生产者和消费者的监控，生产者往 Kafka 发送消息，此时我们要了解客户端机器与 Broker 机器之间的往返时延 RTT 是多少，对于跨数据中心或者异地集群来说，RTT 会更大，很难支撑很大的 TPS。</p>
<p><strong>Producer角度:</strong> request-latency 是需要重点关注的JMX指标，即消息生产请求的延时；另外 Sender 线程的运行状态也是非常重要的， 如果 Sender 线程挂了，对于用户是无感知的，表象只是 Producer 端消息发送失败。</p>
<p><strong>Consumer角度:</strong> 对于 Consumer Group，需要重点关注 join rate 和 sync rate 指标，它表示 Rebalance 的频繁程度。另外还包括消息消费偏移量、消息堆积数量等。</p>
<h3 id="Broker-之间的监控"><a href="#Broker-之间的监控" class="headerlink" title="Broker 之间的监控"></a>Broker 之间的监控</h3><p>最后一个监控维度就是 Broker 之间的监控，主要指副本拉取的性能。Follower 副本实时拉取 Leader 副本的数据，此时我们希望拉取过程越快越好。Kafka 提供了一个特别重要的 JMX 指标，叫做「<code>under replicated partitions</code>」，意思就是比如我们规定这条消息，应该在两个 Broker 上面保存，假设只有一个 Broker 上保存该消息，那么这条消息所在的分区就叫 under replicated partitions，这种情况是特别关注的，因为有可能造成数据的丢失。</p>
<p>另外还有一个比较重要的指标是「<code>active controllor count</code>」。在整个 Kafka  集群中应该确保只能有一台机器的指标是1，其他全应该是0，如果发现有一台机器大于1，一定是出现脑裂了，此时应该去检查下是否出现了网络分区。Kafka本身是不能对抗脑裂的，完全依靠 Zookeeper 来做，但是如果真正出现网络分区的话，也是没有办法处理的，应该让其快速失败重启。</p>
<h2 id="针对-Kafka-线上系统-你是如何进行调优的"><a href="#针对-Kafka-线上系统-你是如何进行调优的" class="headerlink" title="针对 Kafka 线上系统, 你是如何进行调优的"></a>针对 Kafka 线上系统, 你是如何进行调优的</h2><p>对 Kafka 来说，「<strong>吞吐量</strong>」和「<strong>延时</strong>」是非常重要的优化指标。</p>
<p><strong>吞吐量 TPS：</strong>是指 Broker 端或 Client 端每秒能处理的消息数，越大越好。</p>
<p><strong>延时：</strong>表示从 Producer 端发送消息到 Broker 端持久化完成到 Consumer 端成功消费之间的时间间隔。与吞吐量 TPS 相反，延时越短越好。</p>
<p>总之，<code>高吞吐量、低延时是我们调优 Kafka 集群的主要目标</code>。</p>
<h3 id="提升吞吐量"><a href="#提升吞吐量" class="headerlink" title="提升吞吐量"></a>提升吞吐量</h3><p>首先是提升吞吐量参数和措施：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/10/1011-xiyY76.png" alt="image-20220410101150338"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/10/1012-TlxxM5.png" alt="image-20220410101218929"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/10/1012-nCB2xr.png" alt="image-20220410101239687"></p>
<h3 id="降低延时"><a href="#降低延时" class="headerlink" title="降低延时"></a>降低延时</h3><p>降低延时的目的就是尽量减少端到端的延时。</p>
<p>对比上面提升吞吐量的参数，我们只能调整 Producer 端和 Consumer 端的参数配置。</p>
<p>对于 Producer 端，此时我们希望可以快速的将消息发送出去，必须设置 linger.ms=0，同时关闭压缩，另外设置 acks = 1，减少副本同步时间。</p>
<p>而对于 Consumer 端我们只保持 fetch.min.bytes=1 ，即 Broker 端只要有能返回的数据，就立即返回给 Consumer，减少延时。</p>
<h3 id="合理设置分区数"><a href="#合理设置分区数" class="headerlink" title="合理设置分区数"></a>合理设置分区数</h3><p>分区数不是越多越好，也不是越少越好，需要搭建完集群，进行压测，再灵活调整分区个数。 </p>
<p>这里可以用 Kafka 官方自带的脚本，对 Kafka 进行压测。</p>
<blockquote>
<p><strong>1）生产者压测：</strong>kafka-producer-perf-test.sh</p>
<p><strong>2）消费者压测：</strong>kafka-consumer-perf-test.sh </p>
</blockquote>
<hr>
<blockquote>
<p>备份链接：<a href="https://xuemingde.com/JavaNotes/消息队列/20220410-Kafka面试连环炮-下">20220410-Kafka面试连环炮-下</a>   </p>
</blockquote>
]]></content>
      <categories>
        <category>中间件</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>C</tag>
        <tag>内存</tag>
        <tag>GC</tag>
        <tag>堆</tag>
        <tag>CPU</tag>
        <tag>面试</tag>
        <tag>线程池</tag>
        <tag>Qt</tag>
        <tag>索引</tag>
        <tag>并发</tag>
        <tag>算法</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka面试连环炮-中</title>
    <url>/posts/1Z9HSDW.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="谈谈你对-kafka-的集群架构是如何理解的"><a href="#谈谈你对-kafka-的集群架构是如何理解的" class="headerlink" title="谈谈你对 kafka 的集群架构是如何理解的"></a>谈谈你对 kafka 的集群架构是如何理解的</h2><h3 id="Kafka-整体架构图"><a href="#Kafka-整体架构图" class="headerlink" title="Kafka 整体架构图"></a>Kafka 整体架构图</h3><p><img data-src="https://xuemingde.com/pages/image/2022/04/09/1102-jB6bMF.png" alt="图片"></p>
<p>一个典型的 Kafka 集群中包含若干 Producer，若干 Broker「<code>Kafka支持水平扩展，一般 Broker 数量越多，集群吞吐率越高</code>」，若干 Consumer Group，以及一个 Zookeeper集群。</p>
<p>Kafka 通过 Zookeeper 管理集群配置，选举 Leader，以及在 Consumer Group 发生变化时进行  Rebalance。Producer 使用 push 模式将消息发布到 Broker，Consumer使用 pull 模式从 Broker  订阅并消费消息。</p>
<h3 id="Kafka-存储机制"><a href="#Kafka-存储机制" class="headerlink" title="Kafka 存储机制"></a>Kafka 存储机制</h3><p><img data-src="https://xuemingde.com/pages/image/2022/04/09/1104-3TFhEL.png" alt="图片"></p>
<p>Producer 端生产的消息会不断追加到 log 文件末尾，这样文件就会越来越大, 为了防止 log 文件过大导致数据定位效率低下，Kafka 采取了分片和索引机制。</p>
<p>它将每个 Partition 分为多个 Segment每个 Segment 对应3个文件：</p>
<blockquote>
<p>1）.index 索引文件</p>
<p>2）.log 数据文件</p>
<p>3）.timeindex 时间索引文件</p>
</blockquote>
<p>这些文件都位于同一文件夹下面，该文件夹的命名规则为：<code>topic 名称-分区号</code>。</p>
<h3 id="Kafka-副本机制"><a href="#Kafka-副本机制" class="headerlink" title="Kafka 副本机制"></a>Kafka 副本机制</h3><p><img data-src="https://xuemingde.com/pages/image/2022/04/09/1106-LIXgWy.png" alt="图片"></p>
<p>Kafka中的 Partition 为了保证数据安全，每个 Partition 可以设置多个副本。此时我们对分区0,1,2分别设置3个副本。而且每个副本都是有「<code>角色</code>」之分的，<code>它们会选取一个副本作为 Leader 副本，而其他的作为 Follower 副本</code>，我们的 Producer 端在发送数据的时候，只能发送到Leader Partition 里面 ，然后 Follower Partition 会去  Leader Partition 自行同步数据, Consumer 消费数据的时候，也只能从 Leader 副本那去消费数据的。</p>
<h3 id="Kafka-网络模型"><a href="#Kafka-网络模型" class="headerlink" title="Kafka 网络模型"></a>Kafka 网络模型</h3><p><img data-src="https://xuemingde.com/pages/image/2022/04/09/1108-cuVayj.png" alt="图片"></p>
<p>Kafka 采用多路复用方案，Reactor 设计模式，并引用 Java NIO 的方式更好的解决网络超高并发请求问题。</p>
<h2 id="谈谈Kafka客户端如何巧妙解决JVM-GC问题"><a href="#谈谈Kafka客户端如何巧妙解决JVM-GC问题" class="headerlink" title="谈谈Kafka客户端如何巧妙解决JVM GC问题"></a>谈谈Kafka客户端如何巧妙解决JVM GC问题</h2><h3 id="Kafka-客户端缓冲机制"><a href="#Kafka-客户端缓冲机制" class="headerlink" title="Kafka 客户端缓冲机制"></a>Kafka 客户端缓冲机制</h3><p>首先，大家知道的就是在客户端发送消息给 Kafka 服务端的时候，存在一个「<code>内存缓冲池机制</code>」 的。即消息会先写入一个内存缓冲池中，然后直到多条消息组成了一个 Batch，达到一定条件才会一次网络通信把 Batch 发送过去。</p>
<p>整个发送过程图如下所示：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/09/1109-hKDJ5D.png" alt="图片"></p>
<p><strong>Kafka Producer 发送消息流程如下</strong>：</p>
<blockquote>
<p>1）进行 Producer 初始化，加载配置参数，开启网络线程。</p>
<p>2）执行拦截器逻辑，预处理消息, 封装 Producer Record。</p>
<p>3）调用 Serializer.serialize() 方法进行消息的 key/value 序列化。</p>
<p>4）调用 partition() 选择合适的分区策略，给消息体 Producer Record 分配要发送的 Topic 分区号。</p>
<p>5）从 Kafka Broker 集群获取集群元数据 metadata。</p>
<p>6）将消息缓存到 RecordAccumulator 收集器中, 最后判断是否要发送。这个加入消息收集器，首先得从 Deque<RecordBatch> 里找到自己的目标分区，如果没有就新建一个 Batch 消息 Deque 加进入。</p>
<p>7）当达到发送阈值，唤醒 Sender 线程，实例化 NetWorkClient 将 batch record 转换成 request client 的发送消息体, 并将待发送的数据按 【Broker Id &lt;=&gt; List】的数据进行归类。</p>
<p>8）与服务端不同的 Broker 建立网络连接，将对应 Broker 待发送的消息 List 发送出去。</p>
<p>9）批次发送的条件为: 缓冲区数据大小达到 batch.size 或者 linger.ms 达到上限，哪个先达到就算哪个。</p>
</blockquote>
<h3 id="内存缓冲造成的频繁GC问题"><a href="#内存缓冲造成的频繁GC问题" class="headerlink" title="内存缓冲造成的频繁GC问题"></a>内存缓冲造成的频繁GC问题</h3><p>内存缓冲机制说白了，其实就是<code>把多条消息组成一个Batch，一次网络请求就是一个Batch 或者多个 Batch</code>。这样避免了一条消息一次网络请求，从而提升了吞吐量。</p>
<p>那么问题来了，试想一下一个 Batch 中的数据取出来封装到网络包里，通过网络发送到达 Kafka 服务端。<strong>此时**</strong>这个 Batch 里的数据都发送过去了，里面的数据该怎么处理？**这些 Batch 里的数据还存在客户端的 JVM 的内存里！那么一定要避免任何变量去引用 Batch 对应的数据，然后尝试触发 JVM 自动回收掉这些内存垃圾。这样不断的让 JVM 进行垃圾回收，就可以不断的腾出来新的内存空间让后面新的数据来使用。</p>
<p>想法是挺好，但<code>实际生产运行的时候最大的问题，就是 JVM Full GC 问题</code>。JVM GC 在回收内存垃圾的时候，会有一个「<code>Stop the World</code>」的过程，即垃圾回收线程运行的时候，会导致其他工作线程短暂的停顿，这样可以踏踏实实的回收内存垃圾。</p>
<p><code>试想一下，在回收内存垃圾的时候，工作线程还在不断的往内存里写数据，那如何让JVM 回收垃圾呢？</code>我们看看下面这张图就更加清楚了：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/09/1112-t0PQaN.png" alt="图片"></p>
<p>虽然现在 JVM GC 演进越来越先进，从 CMS 垃圾回收器到 G1 垃圾回收器，<code>核心的目标之一就是不断的缩减垃圾回收的时候，导致其他工作线程停顿的时间</code>。但是再先进的垃圾回收器这个停顿的时间还是存在的。</p>
<p>因此，如何尽可能在设计上避免 JVM 频繁的 Full GC 就是一个非常考验其设计水平了。</p>
<h3 id="Kafka-实现的缓冲机制"><a href="#Kafka-实现的缓冲机制" class="headerlink" title="Kafka 实现的缓冲机制"></a>Kafka 实现的缓冲机制</h3><p>在 Kafka 客户端内部，针对这个问题实现了一个非常优秀的机制，就是「<code>缓冲池机制</code>」。即每个 Batch 底层都对应一块内存空间，这个内存空间就是专门用来存放写进去的消息。</p>
<p>当一个 Batch 数据被发送到了 kafka 服务端，这个 Batch 的内存空间不再使用了。<code>此时这个 Batch 底层的内存空间先不交给 JVM 去垃圾回收，而是把这块内存空间给放入一个缓冲池里</code>。</p>
<p>这个缓冲池里存放了很多块内存空间，下次如果有一个新的 Batch 数据了，那么直接从缓冲池获取一块内存空间是不是就可以了？然后如果一个 Batch 数据发送出去了之后，再把内存空间还回来是不是就可以了？以此类推，循环往复。</p>
<p>我们看看下面这张图就更加清楚了：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/09/1116-5yWo2x.png" alt="图片"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/09/1117-j0gteO.png" alt="图片"></p>
<p>一旦使用了这个缓冲池机制之后，就不涉及到频繁的大量内存的 GC 问题了。</p>
<p><code>初始化分配固定的内存，即32MB。然后把 32MB 划分为 N 多个内存块，一个内存块默认是16KB，这样缓冲池里就会有很多的内存块</code>。然后如果需要创建一个新的 Batch，就从缓冲池里取一个 16KB 的内存块就可以了。</p>
<p>接着如果 Batch 数据被发送到 Kafka 服务端了，此时 Batch  底层的内存块就直接还回缓冲池就可以了。这样循环往复就可以利用有限的内存，那么就不涉及到垃圾回收了。没有频繁的垃圾回收，自然就避免了频繁导致的工作线程的停顿了，JVM Full GC 问题是不是就得到了大幅度的优化？</p>
<p><code>没错，正是这个设计思想让 Kafka 客户端的性能和吞吐量都非常的高，这里蕴含了大量的优秀的机制</code><strong>。</strong></p>
<h2 id="谈谈你对-Kafka-消息语义是如何理解的"><a href="#谈谈你对-Kafka-消息语义是如何理解的" class="headerlink" title="谈谈你对 Kafka 消息语义是如何理解的"></a>谈谈你对 Kafka 消息语义是如何理解的</h2><p>对于 Kafka 来说，当消息从 Producer 到 Consumer，有许多因素来影响消息的消费，因此「<code>消息传递语义</code>」就是 Kafka 提供的 Producer 和 Consumer 之间的消息传递过程中消息传递的保证性。主要分为三种， 如下图所示：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/09/1118-eogRgs.jpeg" alt="图片"></p>
<p>对于这三种语义，我们来看一下可能出现的场景：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/09/1118-2W86JT.png" alt="图片"></p>
<h3 id="Producer端"><a href="#Producer端" class="headerlink" title="Producer端"></a>Producer端</h3><p><strong>生产者发送语义</strong>：首先当 Producer 向 Broker 发送数据后，会进行消息提交，如果成功消息不会丢失。因此发送一条消息后，可能会有几种情况发生：</p>
<blockquote>
<p>1）遇到网络问题造成通信中断， 导致 Producer 端无法收到 ack，Producer 无法准确判断该消息是否已经被提交， 又重新发送消息，这就可能造成 「<strong>at least once</strong>」语义。</p>
<p>2）在 Kafka 0.11之前的版本，会导致消息在 Broker 上重复写入（保证至少一次语义），但在0.11版本开始，通过引入「<strong>PID及Sequence Number</strong>」支持幂等性，保证精确一次「<strong>exactly once</strong>」语义。</p>
<p><strong>其中启用幂等传递的方法配置</strong>：enable.idempotence = true。<strong>启用事务支持的方法配置</strong>：设置属性 transcational.id = “指定值”。</p>
<p>3）可以根据 Producer 端 request.required.acks 的配置来取值。</p>
<p><strong>acks = 0</strong>：由于发送后就自认为发送成功，这时如果发生网络抖动， Producer 端并不会校验 ACK 自然也就丢了，且无法重试。</p>
<p><strong>acks = 1</strong>：消息发送 Leader Parition 接收成功就表示发送成功，这时只要 Leader Partition 不 Crash 掉，就可以保证 Leader Partition 不丢数据，保证 「<strong>at least once</strong>」语义。</p>
<p><strong>acks = -1 或者 all</strong>： 消息发送需要等待 ISR 中 Leader Partition 和 所有的 Follower Partition 都确认收到消息才算发送成功, 可靠性最高, 但也不能保证不丢数据,比如当 ISR 中只剩下 Leader Partition 了, 这样就变成 acks = 1 的情况了，保证 「<strong>at least once</strong>」语义。 </p>
</blockquote>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/09/1121-kMQFze.png" alt="图片"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/09/1121-jOqsh8.png" alt="图片"></p>
<h3 id="Consumer端"><a href="#Consumer端" class="headerlink" title="Consumer端"></a>Consumer端</h3><p><strong>消费者接收语义</strong>：从 Consumer 角度来剖析，我们知道 Offset 是由 Consumer 自己来维护的。</p>
<p>Consumer 消费消息时，有以下2种选择:</p>
<blockquote>
<p>1）<strong>读取消息 -&gt; 提交offset -&gt; 处理消息</strong>: 如果此时保存 offset 成功，但处理消息失败，Consumer 又挂了，会发生 Reblance，新接管的 Consumer 将从上次保存的 offset 的下一条继续消费，导致消息丢失，保证「<strong>at most once</strong>」语义。</p>
<p>2）<strong>读取消息 -&gt; 处理消息 -&gt; 提交offset：</strong>如果此时消息处理成功，但保存 offset 失败，Consumer 又挂了，导致刚才消费的 offset 没有被成功提交，会发生 Reblance，新接管的 Consumer 将从上次保存的 offset 的下一条继续消费，导致消息重复消费，保证「<strong>at least once</strong>」语义。</p>
</blockquote>
<p><strong>总结</strong>：默认 Kafka 提供 「<strong>at least once</strong>」语义的消息传递，允许用户通过在处理消息之前保存 Offset 的方式提供 「<strong>at most once</strong>」 语义。如果我们可以自己实现消费幂等，理想情况下这个系统的消息传递就是严格的「<strong>exactly once</strong>」, 也就是保证不丢失、且只会被精确的处理一次，但是这样是很难做到的。</p>
<h2 id="谈谈你对-Kafka-副本机制是如何理解的"><a href="#谈谈你对-Kafka-副本机制是如何理解的" class="headerlink" title="谈谈你对 Kafka 副本机制是如何理解的"></a>谈谈你对 Kafka 副本机制是如何理解的</h2><p>在上篇中，我们简单的分析了 Kafka 副本机制，这里我们再详细分析下 Kafka 的副本机制，说白了就是一个「<strong>数据备份机制</strong>」。</p>
<p>保证集群中的某个节点发生故障时，该节点上的 Partition 数据不丢失，且 Kafka 仍然能够继续工作，提高了系统可用性和数据持久性。</p>
<p><strong>同一个分区下的所有副本保存相同的消息数据，这些副本分散保存在不同的 Broker 上，保证了 Broker 的整体可用性</strong>。</p>
<p>如下图所示：一个由 3 台 Broker 组成的 Kafka 集群上的副本分布情况。从这张图中，我们可以看到，主题 1 分区 1 的 3 个副本分散在 3 台 Broker 上，其他主题分区的副本也都散落在不同的 Broker 上，从而实现数据冗余。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/09/1123-92qV6d.png" alt="图片"></p>
<h3 id="副本同步机制"><a href="#副本同步机制" class="headerlink" title="副本同步机制"></a>副本同步机制</h3><p>既然所有副本的消息内容相同，我们该如何保证副本中所有的数据都是一致的呢？当 Producer 发送消息到某个 Topic 后，消息是如何同步到对应的所有副本 Replica 中的呢？Kafka 中 只有 Leader  副本才能对外进行读写服务，所以解决同步问题，Kafka 是采用基于 <strong>Leader</strong> 的副本机制来完成的。</p>
<blockquote>
<p>1）在 Kafka 中，一个 Topic 的每个 Partition 都有若干个副本，<strong>副本分成两类：领导者副本「Leader Replica」和追随者副本「Follower Replica」</strong>。每个分区在创建时都要选举一个副本作为领导者副本，其余的副本作为追随者副本。</p>
<p>2）在 Kafka 中，Follower 副本是不对外提供服务的。也就是说，任何一个Follower 副本都不能响应客户端的读写请求。<strong>所有的读写请求都必须先发往 Leader 副本所在的 Broker，由该 Broker 负责处理。Follower 副本不处理客户端请求，它唯一的任务就是从 Leader 副本异步拉取消息，并写入到自己的提交日志中，从而实现与 Leader 副本的同步</strong>。</p>
<p>3）在 Kafka 2.X 版本中，当 Leader 副本 所在的 Broker 宕机时，ZooKeeper 提供的监控功能能够实时感知到，并立即开启新一轮的 Leader 选举，从 ISR 副本集合中 Follower 副本中选一个作为新的 Leader ，当旧的 Leader 副本重启回来后，只能作为 Follower 副本加入到集群中。3.x 的选举后续会有单篇去介绍。</p>
</blockquote>
<h3 id="副本管理"><a href="#副本管理" class="headerlink" title="副本管理"></a>副本管理</h3><p><img data-src="https://xuemingde.com/pages/image/2022/04/09/1125-A7BEEJ.png" alt="图片"></p>
<blockquote>
<p>1）<strong>AR 副本集合</strong>: 分区 Partition 中的所有 Replica 组成 AR 副本集合。</p>
<p>2）<strong>ISR 副本集合</strong>: 所有与 Leader 副本能保持一定程度同步的 Replica 组成 ISR 副本集合， 其中也包括 Leader 副本。</p>
<p>3）<strong>OSR 副本集合</strong>: 与 Leader 副本同步滞后过多的 Replica 组成 OSR 副本集合。</p>
</blockquote>
<p>这里我们重点来分析下 <strong>ISR 副本集合。</strong></p>
<h3 id="ISR-副本集合"><a href="#ISR-副本集合" class="headerlink" title="ISR 副本集合"></a>ISR 副本集合</h3><p>上面强调过，Follower 副本不提供服务，只是定期地异步拉取 Leader 副本中的数据。既然是异步的，就一定会存在不能与 Leader 实时同步的情况出现。</p>
<p>Kafka 为了解决这个问题， 引入了「 <strong>In-sync Replicas</strong>」机制，即 ISR 副本集合。要求 ISR 副本集合中的 Follower 副本都是与 Leader 同步的副本。</p>
<p><strong>那么，到底什么样的副本能够进入到 ISR 副本集合中呢？</strong></p>
<p>首先要明确的，Leader 副本天然就在 ISR 副本集合中。也就是说，ISR 不只是有 Follower 副本集合，它必然包括 Leader 副本。另外，能够进入到 ISR 副本集合的 Follower 副本要满足一定的条件。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/09/1126-mBDiIQ.png" alt="图片"></p>
<p>图中有 3 个副本：1 个 Leader 副本和 2 个 Follower 副本。Leader 副本当前写入了 6 条消息，Follower1  副本同步了其中的 4 条消息，而 Follower2 副本只同步了其中的 3 条消息。那么，对于这 2 个 Follower 副本，你觉得哪个  Follower 副本与 Leader 不同步？</p>
<p>事实上，这2个 Follower 副本都有可能与 Leader 副本同步，但也可能不与 Leader 副本同步，这个完全依赖于<strong>Broker 端参数 replica.lag.time.max.ms 参数值</strong>。</p>
<p>这个参数是指 <strong>Follower 副本能够落后 Leader 副本的最长时间间隔，当前默认值是 10 秒，从 2.5 版本开始，默认值从 10 秒增加到 30 秒</strong>。即只要一个 Follower 副本落后Leader 副本的时间不连续超过 30 秒，Kafka 就认为该 Follower 副本与 Leader 是同步的，即使 Follower 副本中保存的消息明显少于 Leader 副本中的消息。</p>
<p>此时如果这个副本同步过程的速度持续慢于 Leader 副本的消息写入速度的时候，那么在 replica.lag.time.max.ms 时间后，该 Follower 副本就会被认为与 Leader 副本是不同步的，因此 Kafka 会自动收缩，将其踢出 ISR 副本集合中。后续如果该副本追上了 Leader 副本的进度的话，那么它是能够重新被加回 ISR副本集合的。</p>
<p>在默认情况下，当 Leader 副本发生故障时，只有在 ISR 副本集合中的 Follower 副本才有资格被选举为新Leader，而 OSR 中副本集合的副本是没有机会的（可以通过<strong>unclean.leader.election.enable</strong> 进行配置执行脏选举）。</p>
<p><strong>总结：ISR 副本集合是一个动态调整的集合。</strong></p>
<h2 id="谈谈你对Kafka-Leader选举机制是如何理解"><a href="#谈谈你对Kafka-Leader选举机制是如何理解" class="headerlink" title="谈谈你对Kafka Leader选举机制是如何理解"></a>谈谈你对Kafka Leader选举机制是如何理解</h2><p>这里所说的 Leader 选举是指分区 Leader 副本的选举，<strong>它是由 Kafka Controller 负责具体执行的，当创建分区或分区副本上线的时候都需要执行 Leader 的选举动作</strong>。</p>
<p>有以下场景可能会触发选举：</p>
<p>1）当 Controller 感知到分区 Leader 下线需要执行 Leader 选举。</p>
<p>此时的选举策略是：Controller 会从 AR 副本集合（同时也在ISR 副本集合）中按照副本的顺序取出第一个存活的副本作为 Leader。</p>
<p>⼀个分区的 AR 副本集合在分配的时候就被指定，并且只要不发⽣重分配集合内部副本的顺序是保持不变的，而分区的 ISR 副本集合中副本的顺序可能会改变。</p>
<p><strong>注意这里是根据 AR 副本集合的顺序而不是 ISR 副本结合的顺序进行选举的。</strong></p>
<p>此时如果 ISR 副本集合中没有可用的副本，还需要再检查⼀下所配置的 unclean.leader.election.enable 参数「 <strong>默认值为false</strong>」。<strong>如果这个参数配置为true，那么表示允许从非 ISR 副本集合中选举 Leader，从 AR 副本集合列表中找到第⼀个存活的副本即为 Leader</strong>。</p>
<p>2）当分区进行重分配的时候也需要进行 Leader 选举。</p>
<p>此时的选举策略是：<strong>从重分配的 AR 副本集合中找到第⼀个存活的副本，且这个副本在当前的 ISR 副本集合中。当发生优先副本的选举时，直接将优先副本设置为 Leader 即可，AR 副本集合中的第⼀个副本即为优先副本</strong>。</p>
<p>3）当某节点执⾏ ControlledShutdown 被优雅地关闭时，位于这个节点上的 Leader 副本都会下线，所以与此对应的分区需要执行 Leader 的选举。</p>
<p>此时的选举策略是：<strong>从 AR 副本集合中找到第⼀个存活的副本，且这个副本在当前的 ISR 副本集合中，同时还要确保这个副本不处于正在被关闭的节点上</strong>。</p>
<h2 id="谈谈你对Kafka控制器及选举机制是如何理解"><a href="#谈谈你对Kafka控制器及选举机制是如何理解" class="headerlink" title="谈谈你对Kafka控制器及选举机制是如何理解"></a>谈谈你对Kafka控制器及选举机制是如何理解</h2><p>所谓的控制器「<strong>Controller</strong>」就是通过 ZooKeeper 来管理和协调整个 Kafka 集群的组件。集群中任意一台 Broker 都可以充当控制器的角色，但是在正常运行过程中，只能有一个 Broker 成为控制器。</p>
<p><strong>控制器的职责主要包括：</strong></p>
<blockquote>
<p>1）集群元信息管理及更新同步 (Topic路由信息等)。</p>
<p>2）主题管理（创建、删除、增加分区等）。</p>
<p>3）分区重新分配。</p>
<p>4）副本故障转移、 Leader 选举、ISR 变更。</p>
<p>5）集群成员管理（通过 watch 机制自动检测新增 Broker、Broker 主动关闭、Broker 宕机等）。</p>
</blockquote>
<h3 id="控制器机制"><a href="#控制器机制" class="headerlink" title="控制器机制"></a>控制器机制</h3><p>我们知道 Kafka 2.X 版本是依赖 Zookeeper 来维护集群成员的信息：</p>
<blockquote>
<p>1）Kafka 使用 Zookeeper 的临时节点来选举 Controller。</p>
<p>2）Zookeeper 在 Broker 加入集群或退出集群时通知 Controller。</p>
<p>3）Controller 负责在 Broker 加入或离开集群时进行分区 Leader 选举。</p>
</blockquote>
<h3 id="控制器数据分布"><a href="#控制器数据分布" class="headerlink" title="控制器数据分布"></a>控制器数据分布</h3><p><img data-src="https://xuemingde.com/pages/image/2022/04/09/1132-l7T1Os.png" alt="1132-XtrOlE"></p>
<p>从上面表格可以看出,存储的大概有3大类:</p>
<blockquote>
<p>1）<strong>所有topic信息</strong>：包括具体的分区信息，比如 Leader 副本是谁，ISR 集合中有哪些副本等。</p>
<p>2）<strong>所有 Broker 信息</strong>：包括当前都有哪些运行中的 Broker，哪些正在关闭中的 Broker 等。</p>
<p>3）<strong>涉及运维任务的副本分区</strong>：包括当前正在进行 Leader 选举以及分区重分配的分区列表等。</p>
</blockquote>
<h3 id="控制器故障转移"><a href="#控制器故障转移" class="headerlink" title="控制器故障转移"></a>控制器故障转移</h3><p>在 Kafka 集群运行过程中，只能有一台 Broker 充当控制器的角色，存在「<strong>单点故障</strong>」的风险，Kafka 如何应对单点故障呢？</p>
<p>其实 Kafka 为控制器提供故障转移功能「<strong>Failover</strong>」。<strong>指当运行中的控制器突然宕机时，Kafka 能够快速地感知到，并立即启用备用控制器来代替之前失败控制器的过程</strong>。</p>
<p>下面通过一张图来展示控制器故障转移的过程：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/09/1133-yarAzV.png" alt="图片"></p>
<h3 id="控制器触发选举场景"><a href="#控制器触发选举场景" class="headerlink" title="控制器触发选举场景"></a>控制器触发选举场景</h3><p>至此你一定想知道控制器是如何被选出来的？前面说过，每台 Broker 都能充当控制器，当集群启动后，Kafka 是如何确认控制器在哪台 Broker 呢？</p>
<p>实际上这个问题很简单，即 <strong>Broker 启动时， 会尝试去 ZooKeeper 中创建 /controller 节点， 第一个成功创建 /controller 节点的 Broker 会被选为控制器</strong>。</p>
<p>接下来我们看下<strong>触发 Controller 选举的场景</strong>有哪些？</p>
<p><strong>场景一、集群首次启动时</strong>：</p>
<p>集群首次启动时，Controller 还未被选举出来，因此 Broker 启动后，会干4件事：</p>
<blockquote>
<p>1）先注册 Zookeeper 状态变更监听器，用来监听 Broker 与 Zookeeper 之间的会话是否过期。</p>
<p>2）然后将 Startup 这个控制器事件写入到事件队列中。</p>
<p>3）然后开始启动对应的控制器事件处理线程即「<strong>ControllerEventThread</strong>」、以及 「<strong>ControllerChangeHandler</strong>」 Zookeeper 监听器，开始处理事件队列中Startup 事件。</p>
<p>4）最后依赖事件处理线程来选举 Controller。</p>
</blockquote>
<p><strong>场景二、Broker 监听 /controller 节点消失时</strong>：</p>
<p>集群运行过程中，当 <strong>Broker 监听到 /controller 节点消失时，就表示此时当前整个集群中已经没有 Controller 了</strong>。所有监听到 /controller 节点消失的 Broker，此时都会开始执行竞选操作。 </p>
<p>那么 Broker 是如何监听到 ZooKeeper 上的变化呢？主要依赖 ZooKeeper 监听器提供的功能，所以 Kafka 是依赖 ZooKeeper 来完成 Controller 的选举。</p>
<p>对于 Kafka 3.X 版本中，内部实现一个类似于 Raft 的共识算法来选举 Controller。</p>
<p><strong>场景三、Broker 监听 /controller 节点数据变化时</strong>：</p>
<p>集群运行过程中，当 <strong>Broker 检测到 /controller 节点数据发生变化，此时 Controller 可能已经被「易主」了</strong>，这时有以下两种情况：</p>
<blockquote>
<p>1）假如 Broker 是 Controller，那么该 Broker 需要首先执「<strong>退位</strong>」操作，然后再尝试进行竞选 Controller。</p>
<p>2）假如 Broker 不是 Controller，那么，该 Broker 直接去竞选新 Controller。</p>
</blockquote>
<h3 id="控制器选举机制"><a href="#控制器选举机制" class="headerlink" title="控制器选举机制"></a>控制器选举机制</h3><p>其实选举最终都是通过调用底层的 elect 方法进行选举，如下图所示：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/09/1136-lra2F8.png" alt="图片"></p>
<h2 id="谈谈-kafka-的数据可靠性是怎么保证的"><a href="#谈谈-kafka-的数据可靠性是怎么保证的" class="headerlink" title="谈谈 kafka 的数据可靠性是怎么保证的"></a>谈谈 kafka 的数据可靠性是怎么保证的</h2><p>开始数据可靠性之前先看几个重要的概念：AR、OSR、ISR、HW、LEO，前面已经讲了 AR、OSR、ISR。这里我们重点讲下 HW、LEO。</p>
<p><strong>HW：</strong>全称「<strong>Hign WaterMark</strong>」 ，即高水位，它标识了一个特定的消息偏移量 offset ，消费者只能拉取到这个水位 offset 之前的消息。</p>
<p><strong>LEO：</strong>全称「<strong>Log End Offset</strong>」，它标识当前日志文件中下一条待写入的消息的 offset，在 ISR 副本集合中的每个副本都会维护自身的LEO。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/09/1137-xMwgU3.png" alt="图片"></p>
<p>从上图可以看出 HW 和 LEO 的作用：</p>
<blockquote>
<p><strong>HW 作用</strong>：</p>
<p>1）用来标识分区下的哪些消息是可以被消费者消费的。</p>
<p>2）协助 Kafka 完成副本数据同步。</p>
<p><strong>LEO 作用</strong>：</p>
<p>1）如果 Follower 和 Leader 的 LEO 数据同步了, 那么 HW 就可以更新了。</p>
<p>2）HW 之前的消息数据对消费者是可见的，属于 commited 状态, HW 之后的消息数据对消费者是不可见的。</p>
</blockquote>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/09/1137-JexxNf.png" alt="图片"></p>
<p><strong>HW 更新是需要一轮额外的拉取请求才能实现，</strong>Follower 副本要拉取 Leader 副本的数据，也就是说，Leader 副本 HW 更新和 Follower 副本 HW 更新在时间上是存在错配的。<strong>这种错配是很多“数据丢失”或“数据不一致”问题的根源</strong>。因此社区在 0.11 版本正式引入了 「<strong>Leader Epoch</strong>」 概念，来规避因 HW 更新错配导致的各种不一致问题。</p>
<p> 所谓 Leader Epoch，我们大致可以认为是 Leader 版本。它由两部分数据组成：</p>
<blockquote>
<p>1）<strong>Epoch</strong>: 一个单调递增的版本号。每当副本 Leader 权力发生变更时，都会增加该版本号。小版本号的 Leader 被认为是过期 Leader，不能再行使 Leader 权力。</p>
<p>2）<strong>起始位移（Start Offset）:</strong> Leader 副本在该 Epoch 值上写入的首条消息的位移。</p>
</blockquote>
<p>Kafka Broker 会在<strong>内存中为每个分区都缓存 Leader Epoch 数据</strong>，同时它还会定期地将这些信息<strong>持久化到一个 checkpoint 文件</strong>中。当 Leader Partition 写入消息到磁盘时，Broker 会尝试更新这部分缓存。如果该 Leader 是首次写入消息，那么  Broker 会向缓存中增加一个 Leader Epoch 条目，否则就不做更新。这样，每次有 Leader 变更时，新的 Leader  副本会查询这部分缓存，取出对应的 Leader Epoch 的起始位移，以避免数据丢失和不一致的情况。</p>
<p>严格来说，这个场景发生的前提是 <strong>Broker 端参数 min.insync.replicas 设置为 1</strong>。此时一旦消息被写入到 Leader 副本的磁盘，就会被认为是 commited 状态，但因存在时间错配问题导致 Follower 的 HW 更新是有滞后的。如果在这个短暂的滞后时间内，接连发生 Broker 宕机，那么这类数据的丢失就是无法避免的。</p>
<p>接下来, 我们来看下如何利用 Leader Epoch 机制来规避这种数据丢失。如下图所示:</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/09/1138-wdHb98.png" alt="图片"></p>
<p>因此 Kafka 只对 「<strong>已提交</strong>」的消息做「<strong>最大限度的持久化保证不丢失</strong>」<strong>。</strong>由于篇幅详细请看：<span class="exturl" data-url="aHR0cDovL21wLndlaXhpbi5xcS5jb20vcz9fX2Jpej1NemczTVRjeE1EZ3hOQT09JmFtcDttaWQ9MjI0NzQ5MDQ4OSZhbXA7aWR4PTEmYW1wO3NuPTE3ODE3ZjZkOTgzN2FkNmE4ODIzMzYyZDVlZDM4Njg3JmFtcDtjaGtzbT1jZWZiMzI4OGY5OGNiYjllZGViNTY4ZTUxMTI3YzI1Y2FhOTBkYTZkZDA2NDkzNjU2MGE4NTFhOWM5ZTViODY1YmI0OWNhMDQzMTJkJmFtcDtzY2VuZT0yMSN3ZWNoYXRfcmVkaXJlY3Q=">刨根问底: Kafka 到底会不会丢数据<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="谈谈-Kafka-消息分配策略都有哪些"><a href="#谈谈-Kafka-消息分配策略都有哪些" class="headerlink" title="谈谈 Kafka 消息分配策略都有哪些"></a>谈谈 Kafka 消息分配策略都有哪些</h2><p><img data-src="https://xuemingde.com/pages/image/2022/04/09/1139-ygE1jr.png" alt="图片"></p>
<p>这里主要说的是<strong>消费的分区分配策略</strong>，我们知道一个 Consumer Group 中有多个 Consumer，一个 Topic 也有多个 Partition，所以必然会有 Partition 分配问题「 <strong>确定哪个 Partition 由哪个 Consumer 来消费的问题</strong>」。</p>
<p>Kafka 客户端提供了3 种分区分配策略：RangeAssignor、RoundRobinAssignor 和 StickyAssignor，前两种分配方案相对简单一些StickyAssignor 分配方案相对复杂一些。</p>
<h3 id="RangeAssignor"><a href="#RangeAssignor" class="headerlink" title="RangeAssignor"></a>RangeAssignor</h3><p><strong>RangeAssignor 是 Kafka 默认的分区分配算法，它是按照 Topic 的维度进行分配的</strong>，首先对 每个Topic 的 Partition 按照分区ID进行排序，然后对订阅该 Topic 的 Consumer Group 的 Consumer 按名称字典进行排序，之后<strong>尽量均衡的按照范围区段将分区分配给 Consumer</strong>。此时也可能会造成先分配分区的 Consumer 任务过重（分区数无法被消费者数量整除）。</p>
<p><strong>分区分配场景分析如下图所示（同一个消费者组下的多个 consumer）：</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/09/1141-HeOa2X.png" alt="图片"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/09/1141-WDb11i.png" alt="图片"></p>
<p><strong>总结：该分配方式明显的问题就是随着消费者订阅的Topic的数量的增加，不均衡的问题会越来越严重。</strong></p>
<h3 id="RoundRobinAssignor"><a href="#RoundRobinAssignor" class="headerlink" title="RoundRobinAssignor"></a>RoundRobinAssignor</h3><p><strong>该分区分配策略是将 Consumer Group 订阅的所有 Topic 的 Partition 及所有 Consumer 按照字典进行排序后尽量均衡的挨个进行分配。</strong>如果 Consumer Group 内，每个 Consumer 订阅都订阅了相同的Topic，那么分配结果是均衡的。如果订阅 Topic 是不同的，那么分配结果是不保证「 <strong>尽量均衡</strong>」的，因为某些 Consumer 可能不参与一些 Topic 的分配。</p>
<p><strong>分区分配场景分析如下图所示：</strong></p>
<p><strong>1) 当组内每个 Consumer 订阅的相同 Topic ：</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/09/1142-VQUTaw.png" alt="图片"></p>
<p> <strong>2) 当组内每个订阅的不同的 Topic ，这样就可能会造成分区订阅的倾斜:</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/09/1143-4QBLYi.png" alt="图片"></p>
<h3 id="StickyAssignor"><a href="#StickyAssignor" class="headerlink" title="StickyAssignor"></a>StickyAssignor</h3><p>该分区分配算法是最复杂的一种，<code>可以通过 partition.assignment.strategy 参数去设置</code>，从 0.11 版本开始引入，目的就是在执行新分配时，尽量在上一次分配结果上少做调整，其主要实现了以下2个目标：</p>
<blockquote>
<p><strong>1、Topic Partition 的分配要尽量均衡。</strong></p>
<p><strong>2、当 Rebalance 发生时，尽量与上一次分配结果保持一致。</strong></p>
</blockquote>
<p>注意：<code>当两个目标发生冲突的时候，优先保证第一个目标，这样可以使分配更加均匀</code>，其中第一个目标是3种分配策略都尽量去尝试完成的， 而第二个目标才是该算法的精髓所在。</p>
<p>下面我们看看该策略与RoundRobinAssignor策略的不同：</p>
<p><strong>分区分配场景分析如下图所示：</strong></p>
<p>1）组内每个 Consumer 订阅的相同的 Topic ，RoundRobinAssignor 跟StickyAssignor 分配一致：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/09/1145-sl6JNK.png" alt="图片"></p>
<p><strong>当发生 Rebalance 情况后，可能分配会不太一样，假如这时候C1发生故障下线：</strong></p>
<p><strong>RoundRobinAssignor：</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/09/1145-w3iSze.png" alt="图片"></p>
<p><strong>StickyAssignor</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/09/1146-woSiuw.png" alt="图片"></p>
<p><strong>结论: 从上面 Rebalance 发生后的结果可以看出，虽然两种分配策略最后都是均匀分配的，但是 RoundRoubinAssignor 分区分配策略完全是重新分配了一遍，而 StickyAssignor则是在原先的基础上达到了均匀的状态。</strong></p>
<p><strong>2) 当组内每个 Consumer 订阅的 Topic 是不同情况:</strong></p>
<p><strong>RoundRobinAssignor：</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/09/1147-O04CtK.png" alt="图片"></p>
<p><strong>StickyAssignor</strong>：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/09/1148-4ceydf.png" alt="图片"></p>
<p><strong>当发生 Rebalance 情况后，可能分配会不太一样，假如这时候C1发生故障下线：</strong></p>
<p><strong>RoundRobinAssignor：</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/09/1148-b4AYOl.png" alt="图片"></p>
<p><strong>StickyAssignor：</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/09/1149-rLbj0n.png" alt="图片"></p>
<p>从上面结果可以看出，RoundRoubin 的分配策略在 Rebalance 之后造成了严重的分配倾斜。<strong>因此在生产环境上如果想要减少重分配带来的开销，可以选用 StickyAssignor 的分区分配策略。</strong> </p>
<h2 id="谈谈-Kafka-消费者重平衡机制是怎样的"><a href="#谈谈-Kafka-消费者重平衡机制是怎样的" class="headerlink" title="谈谈 Kafka 消费者重平衡机制是怎样的"></a>谈谈 Kafka 消费者重平衡机制是怎样的</h2><p><strong>所谓的消费者组的重平衡目的就是让组内所有的消费者实例对消费哪些主题分区达成一致。</strong></p>
<p>对于 Consumer Group 来说，可能随时都会有 Consumer 加入或退出，那么 Consumer 列表的变化必定会引起 Partition 的重新分配。我们将这个分配过程叫做 Consumer Rebalance，但是<strong>这个分配过程需要借助 Broker 端的 Coordinator 协调者组件，在 Coordinator 的帮助下完成整个消费者组的分区重分配，也是通过监听ZooKeeper 的 /admin/reassign_partitions 节点触发的。</strong></p>
<h3 id="Rebalance-触发与通知"><a href="#Rebalance-触发与通知" class="headerlink" title="Rebalance 触发与通知"></a>Rebalance 触发与通知</h3><p>Rebalance 的触发条件有三种:</p>
<blockquote>
<p>1）当 Consumer Group 组成员数量发生变化(主动加入或者主动离组，故障下线等)。</p>
<p>2）当订阅主题数量发生变化。</p>
<p>3）当订阅主题的分区数发生变化。</p>
</blockquote>
<p>Rebalance 触发后如何通知其他 Consumer 进程？</p>
<blockquote>
<p>Rebalance 的通知机制就是<strong>靠 Consumer 端的心跳线程</strong>，它会定期发送心跳请求到 Broker 端的 Coordinator 协调者组件,当协调者决定开启 Rebalance 后，它会将「<strong>REBALANCE_IN_PROGRESS</strong>」封装进心跳请求的响应中发送给 Consumer ,当 Consumer 发现心跳响应中包含了「<strong>REBALANCE_IN_PROGRESS</strong>」，就知道是 Rebalance 开始了。</p>
</blockquote>
<h3 id="Rebalance-协议说明"><a href="#Rebalance-协议说明" class="headerlink" title="Rebalance 协议说明"></a>Rebalance 协议说明</h3><p>其实 Rebalance 本质上也是一组协议，Consumer Group 与 Coordinator 共同使用它来完成 Consumer Group 的 Rebalance。</p>
<p>下面我看看这5种协议完成了什么功能： </p>
<blockquote>
<p>1）<strong>Heartbeat 请求：</strong>Consumer 需要定期给 Coordinator 发送心跳来证明自己还活着。</p>
<p>2）<strong>LeaveGroup 请求：</strong>主动告诉 Coordinator 要离开 Consumer Group。</p>
<p>3）<strong>SyncGroup 请求：</strong>Group Leader Consumer 把分配方案告诉组内所有成员。</p>
<p>4）<strong>JoinGroup 请求：</strong>成员请求加入组。</p>
<p>5）<strong>DescribeGroup 请求：</strong>显示组的所有信息，包括成员信息，协议名称，分配方案，订阅信息等。通常该请求是给管理员使用。</p>
</blockquote>
<p><strong>Coordinator 在 Rebalance 的时候主要用到了前面4种请求。</strong></p>
<h3 id="Consumer-Group-状态机"><a href="#Consumer-Group-状态机" class="headerlink" title="Consumer Group 状态机"></a>Consumer Group 状态机</h3><p>如果 Rebalance 一旦发生，就会涉及到 Consumer Group 的状态流转，此时 Kafka 为我们设计了一套完整的状态机机制，来帮助 Broker Coordinator 完成整个重平衡流程。</p>
<p>了解整个状态流转过程可以帮助我们深入理解 Consumer Group 的设计原理。5种状态，定义分别如下：</p>
<blockquote>
<p>1）<strong>Empty 状态</strong>：表示当前组内无成员， 但是可能存在 Consumer Group 已提交的位移数据，且未过期，这种状态只能响应 JoinGroup 请求。。</p>
<p>2）<strong>Dead 状态</strong>：表示组内已经没有任何成员的状态，组内的元数据已经被 Broker Coordinator 移除，这种状态响应各种请求都是一个Response：UNKNOWN_MEMBER_ID。</p>
<p>3）<strong>PreparingRebalance 状态</strong>：表示准备开始新的 Rebalance, 等待组内所有成员重新加入组内。</p>
<p>4）<strong>CompletingRebalance 状态</strong>：表示组内成员都已经加入成功，正在等待分配方案，旧版本中叫「<strong>AwaitingSync</strong>」。</p>
<p>5）<strong>Stable 状态</strong>：表示 Rebalance 已经完成， 组内 Consumer 可以开始消费了。</p>
</blockquote>
<p>5种状态流转图如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/09/1153-gTWZRv.png" alt="图片"></p>
<h3 id="Rebalance-流程分析"><a href="#Rebalance-流程分析" class="headerlink" title="Rebalance 流程分析"></a>Rebalance 流程分析</h3><p>通过上面5种状态可以看出，Rebalance 主要分为两个步骤：加入组「<strong>JoinGroup请求</strong>」和等待 Leader Consumer 分配方案「<strong>SyncGroup 请求</strong>」。</p>
<p><strong>JoinGroup请求</strong></p>
<p>组内所有成员向 Coordinator 发送 JoinGroup 请求，请求加入组，顺带会上报自己订阅的 Topic，这样 Coordinator  就能收集到所有成员的 JoinGroup 请求和订阅 Topic 信息，Coordinator 就会从这些成员中选择一个担任这个Consumer Group 的 Leader「<strong>一般情况下，第一个发送请求的 Consumer 会成为 Leader</strong>」。</p>
<p><strong>这里说的 Leader 是指具体的某一个 Consumer，它的任务就是收集所有成员的订阅 Topic 信息，然后制定具体的消费分区分配方案。</strong>待选出 Leader 后，Coordinator 会把 Consumer Group 的订阅 Topic 信息封装进 JoinGroup 请求的 Response 中，然后发给 Leader ，然后由 Leader 统一做出分配方案后，进入到下一步</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/09/1154-gZhBei.png" alt="图片"></p>
<p><strong>SyncGroup 请求</strong></p>
<p>Leader 开始分配消费方案，<code>即哪个 Consumer 负责消费哪些 Topic 的哪些 Partition</code>。</p>
<p>一旦完成分配，Leader 会将这个分配方案封装进 SyncGroup 请求中发给 Coordinator ，其他成员也会发 SyncGroup 请求，只是内容为空，待  Coordinator 接收到分配方案之后会把方案封装进 SyncGroup 的 Response 中发给组内各成员,  这样各自就知道应该消费哪些 Partition 了。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/09/1155-E4Jbcx.png" alt="图片"></p>
<h3 id="Rebalance-场景分析"><a href="#Rebalance-场景分析" class="headerlink" title="Rebalance 场景分析"></a>Rebalance 场景分析</h3><p>刚刚详细的分析了关于 Rebalance 的状态流转，接下来我们通过时序图来重点分析几个场景来加深对 Rebalance 的理解。</p>
<p><strong>场景一：新成员(c1)加入组</strong></p>
<p>这里新成员加入组是指组处于 Stable 稳定状态后，有新成员加入的情况。当协调者收到新的 JoinGroup 请求后，它会通过心跳机制通知组内现有的所有成员，强制开启新一轮的重平衡。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/09/1156-fR76r7.png" alt="图片"></p>
<p><strong>场景二：成员(c2)主动离组</strong></p>
<p>这里主动离组是指消费者所在线程或进程调用 close() 方法主动通知协调者它要退出。当协调者收到 LeaveGroup 请求后，依然会以心跳机制通知其他成员，强制开启新一轮的重平衡。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/09/1156-tzCaWi.png" alt="图片"></p>
<p><strong>场景三：成员(c2)超时被踢出组</strong></p>
<p>这里超时被踢出组是指消费者实例出现故障或者处理逻辑耗时过长导致的离组。此时离组是被动的，协调者需要等待一段时间才能感知到，<strong>一般是由消费者端参数 session.timeout.ms 控制的</strong>。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/09/1157-4FAVNu.png" alt="图片"></p>
<p><strong>场景四：成员(c2)提交位移数据</strong></p>
<p>当重平衡开启时，协调者会要求组内成员必须在这段缓冲时间内快速地提交自己的位移信息，然后再开启正常的 JoinGroup/SyncGroup 请求发送。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/09/1157-KbV0VC.png" alt="图片"></p>
<h2 id="谈谈Kafka线上大量消息积压你是如何处理的"><a href="#谈谈Kafka线上大量消息积压你是如何处理的" class="headerlink" title="谈谈Kafka线上大量消息积压你是如何处理的"></a>谈谈Kafka线上大量消息积压你是如何处理的</h2><p><code>消息大量积压这个问题，直接原因一定是某个环节出现了性能问题，来不及消费消息，才会导致消息积压。</code>接着就比较坑爹了，此时假如 Kafka 集群的磁盘都快写满了，都没有被消费，这个时候怎么办？或者消息积压了⼏个⼩时，这个时候怎么办？生产环境挺常⻅的问题，⼀般不出问题，而⼀出就是⼤事故。</p>
<p>所以，我们先来分析下，在使用 Kafka 时如何来优化代码的性能，避免出现消息积压。如果你的线上 Kafka 系统出现了消息积压，该如何进行紧急处理，最大程度地避免消息积压对业务的影响。</p>
<h3 id="优化性能来避免消息积压"><a href="#优化性能来避免消息积压" class="headerlink" title="优化性能来避免消息积压"></a>优化性能来避免消息积压</h3><p>对于 Kafka 性能的优化，主要体现在生产者和消费者这两部分业务逻辑中。而 Kafka 本身不需要多关注的主要原因是，对于绝大多数使用Kafka 的业务来说，Kafka  本身的处理能力要远大于业务系统的处理能力。Kafka 单个节点，消息收发的性能可以达到每秒钟处理几十万条消息的水平，还可以通过水平扩展  Broker 的实例数成倍地提升处理能力。</p>
<p>对于业务系统处理的业务逻辑要复杂一些，单个节点每秒钟处理几百到几千次请求，已经非常不错了，所以我们应该更关注的是消息的收发两端。</p>
<p><strong>1. 发送端性能优化</strong></p>
<p>发送端即生产者业务代码都是先执行自己的业务逻辑，最后再发送消息。<strong>如果说性能上不去，需要你优先检查一下，是不是发消息之前的业务逻辑耗时太多导致的</strong>。</p>
<p>对于发送消息的业务逻辑，只需要注意设置合适的并发和批量大小，就可以达到很好的发送性能。我们知道 Producer 发消息给 Broker 且收到消息并返回 ack 响应，假设这一次过程的平均时延是 1ms，它包括了下面这些步骤的耗时：</p>
<blockquote>
<p>1）发送端在发送网络请求之前的耗时。</p>
<p>2）发送消息和返回响应在网络传输中的耗时。</p>
<p>3）Broker 端处理消息的时延。</p>
</blockquote>
<p>假设此时你的发送端是单线程，每次只能发送 1 条消息，那么每秒只能发送 1000 条消息，这种情况下并不能发挥出 Kafka 的真实性能。此时无论是增加每次发送消息的批量大小，还是增加并发，都可以成倍地提升发送性能。</p>
<p>如果当前发送端是在线服务的话，比较在意请求响应时延，此时可以采用并发方式来提升性能。</p>
<p>如果当前发送端是离线服务的话，更关注系统的吞吐量，发送数据一般都来自数据库，此时更适合批量读取，批量发送来提升性能。</p>
<p><strong>另外还需要关注下消息体是否过大</strong>，如果消息体过大，势必会增加 IO 的耗时，影响 Kafka 生产和消费的速度，也可能会造成消息积压。</p>
<p><strong>2. 消费端性能优化</strong></p>
<p>而在使用 Kafka 时，大部分的性能问题都出现在消费端，如果消费的速度跟不上发送端生产消息的速度，就会造成消息积压。如果只是暂时的，那问题不大，只要消费端的性能恢复之后，超过发送端的性能，那积压的消息是可以逐渐被消化掉的。</p>
<p>要是消费速度一直比生产速度慢，时间长了系统就会出现问题，比如Kafka 的磁盘存储被写满无法提供服务，或者消息丢失，对于整个系统来说都是严重故障。</p>
<p>所以我们在设计的时候，<strong>一定要保证消费端的消费性能要高于生产端的发送性能，这样的系统才能健康的持续运行</strong>。</p>
<p>消费端的性能优化除了优化业务逻辑外，也可以通过水平扩容，增加消费端的并发数来提升总体的消费性能。需要注意的是，<strong>在扩容 Consumer 的实例数量的同时，必须同步扩容主题中的分区数量，确保 Consumer 的实例数和分区数量是相等的，如果 Consumer 的实例数量超过分区数量，这样的扩容实际上是没有效果的</strong>。</p>
<h3 id="消息积压后如何处理"><a href="#消息积压后如何处理" class="headerlink" title="消息积压后如何处理"></a>消息积压后如何处理</h3><p>日常系统正常时候，没有积压或者只有少量积压很快就消费掉了，但某时刻，突然开始积压消息且持续上涨。这种情况下需要你在短时间内找到消息积压的原因，迅速解决问题。</p>
<p><strong>导致消息积压突然增加，只有两种：发送变快了或者消费变慢了。</strong></p>
<p>假如赶上大促或者抢购时，短时间内不太可能优化消费端的代码来提升消费性能，<strong>此时唯一的办法是通过扩容消费端的实例数来提升总体的消费能力</strong>。如果短时间内没有足够的服务器资源进行扩容，只能降级一些不重要的业务，减少发送方发送的数据量，最低限度让系统还能正常运转，保证重要业务服务正常。</p>
<p>假如通过内部监控到消费变慢了，需要你检查消费实例，分析一下是什么原因导致消费变慢？</p>
<blockquote>
<p>1、优先查看日志是否有大量的消费错误。</p>
<p>2、此时如果没有错误的话，可以通过打印堆栈信息，看一下你的消费线程是不是卡在哪里「<strong>触发死锁或者卡在某些等待资源</strong>」。</p>
</blockquote>
<hr>
<blockquote>
<p>原文：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvQ0c5M3hCNnViakpSbFlKbHhodGNTZw==">【建议收藏】Kafka 面试连环炮, 看看你能撑到哪一步?（中）<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
]]></content>
      <categories>
        <category>中间件</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>C</tag>
        <tag>内存</tag>
        <tag>集合</tag>
        <tag>GC</tag>
        <tag>事务</tag>
        <tag>数据库</tag>
        <tag>堆</tag>
        <tag>栈</tag>
        <tag>变量</tag>
        <tag>面试</tag>
        <tag>锁</tag>
        <tag>索引</tag>
        <tag>MQ</tag>
        <tag>并发</tag>
        <tag>算法</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>RocketMQ 消息积压了，增加消费者有用吗</title>
    <url>/posts/12P0DCH.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>面试官</strong>：RocketMQ 消息积压了，增加消费者有用吗？</p>
<p><strong>我</strong>：这个要看具体的场景，不同的场景下情况是不一样的。</p>
<p><strong>面试官</strong>：可以详细说一下吗？</p>
<p><strong>我</strong>：如果消费者的数量小于 MessageQueue 的数量，增加消费者可以加快消息消费速度，减少消息积压。比如一个 Topic 有 4 个 MessageQueue，2 个消费者进行消费，如果增加一个消费者，明细可以加快拉取消息的频率。如下图：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/11/1057-EAQoGV.png" alt="图片"></p>
<p>如果消费者的数量大于等于 MessageQueue 的数量，增加消费者是没有用的。比如一个 Topic 有 4 个 MessageQueue，并且有 4 个消费者进行消费。如下图</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/11/1057-Uu40Ny.png" alt="图片"></p>
<p><strong>面试官</strong>：你说的第一种情况，增加消费者一定能加快消息消费的速度吗？</p>
<p><strong>我</strong>：这…，一般情况下是可以的。</p>
<p><strong>面试官</strong>：有特殊的情况吗？</p>
<p><strong>我</strong>：当然有。消费者消息拉取的速度也取决于本地消息的消费速度，如果本地消息消费的慢，就会延迟一段时间后再去拉取。</p>
<p><strong>面试官</strong>：在什么情况下消费者会延迟一段时间后后再去拉取呢？</p>
<p><strong>我</strong>：消费者拉取的消息存在 ProcessQueue，消费者是有流量控制的，如果出现下面三种情况，就不会主动去拉取：</p>
<ul>
<li>ProcessQueue 保存的消息数量超过阈值（默认 1000，可以配置）；</li>
<li>ProcessQueue 保存的消息大小超过阈值（默认 100M，可以配置）；</li>
<li>对于非顺序消费的场景，ProcessQueue 中保存的最后一条和第一条消息偏移量之差超过阈值（默认 2000，可以配置）。</li>
</ul>
<blockquote>
<p>这部分源码请参考类：<code>org.apache.rocketmq.client.impl.consumer.DefaultMQPushConsumerImpl</code>。</p>
</blockquote>
<p><strong>面试官</strong>：还有其他情况吗？</p>
<p><strong>我</strong>：对于顺序消费的场景，ProcessQueue 加锁失败，也会延迟拉取，这个延迟时间是 3s。消费者消费慢，可是能下面的原因：</p>
<ul>
<li>消费者处理的业务逻辑复杂，耗时很长；</li>
<li>消费者有慢查询，或者数据库负载高导致响应慢；</li>
<li>缓存等中间件响应慢，比如 Redis 响应慢；</li>
<li>调用外部服务接口响应慢。</li>
</ul>
<p><strong>面试官</strong>：对于外部接口响应慢的情况，有什么应对措施吗？</p>
<p><strong>我</strong>：这个要分情况讨论。</p>
<p>如果调用外部系统<code>只是一个通知，或者调用外部接口的结果并不处理</code>，可以采用异步的方式，异步逻辑里采用重试的方式保证接口调成功。</p>
<p>如果外部接口返回结果必须要处理，可以考虑接口返回的结果是否可以缓存默认值（要考虑业务可行），在调用失败后采用快速降级的方式，使用默认值替代返回接口返回值。</p>
<p>如果这个接口返回结果必须要处理，并且不能缓存，可以把拉取到的消息存入本地然后给 Broker 直接返回 CONSUME_SUCCESS。等外部系统恢复正常后再从本地取出来进行处理。</p>
<p><strong>面试官</strong>：如果消费者数小于 MessageQueue 数量，并且外部系统响应正常，为了快速消费积压消息而增加消费者，有什么需要考虑的吗？</p>
<p><strong>我</strong>：外部系统虽然响应正常，但是增加多个消费者后，外部系统的接口调用量会突增，如果达到吞吐量上限，外部系统会响应变慢，甚至被打挂。</p>
<p>同时也要考虑本地数据库、缓存的压力，如果数据库响应变慢，处理消息的速度就会变慢，起不到缓解消息积压的作用。</p>
<p><strong>面试官</strong>：新增加了消费者后，怎么给它分配 MessageQueue 呢？</p>
<p><strong>我</strong>：Consumer 在拉取消息之前，需要对 MessageQueue 进行负载操作。RocketMQ 使用一个定时器来完成负载操作，默认每间隔 20s 重新负载一次。</p>
<p><strong>面试官</strong>：能详细说一下都有哪些负载策略吗？</p>
<p><strong>我</strong>：RocketMQ 提供了 6 种负载策略，依次来看一下。</p>
<p><strong>平均负载策略：</strong></p>
<ol>
<li>把消费者进行排序；</li>
<li>计算每个消费者可以平均分配的 MessageQueue 数量；</li>
<li>如果消费者数量大于 MessageQueue 数量，多出的消费者就分不到；</li>
<li>如果不可以平分，就使用 MessageQueue 总数量对消费者数量求余数 mod；</li>
<li>对前 mod 数量消费者，每个消费者加一个，这样就获取到了每个消费者分配的 MessageQueue 数量。</li>
</ol>
<p>比如 4 个 MessageQueue 和 3 个消费者的情况：</p>
<p><strong>面试官</strong>：消费者延迟拉取消息，一般可能是什么原因导致的呢？</p>
<p><strong>我</strong>：其实延迟拉取的<code>本质就是消费者消费慢</code>，导致下次去拉取的时候 ProcessQueue 中积压的消息超过阈值。以下面这张架构图为例：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/11/1059-yKOaQS.png" alt="图片"></p>
<p>消费者消费慢，可是能下面的原因：</p>
<ul>
<li>消费者处理的业务逻辑复杂，耗时很长；</li>
<li>消费者有慢查询，或者数据库负载高导致响应慢；</li>
<li>缓存等中间件响应慢，比如 Redis 响应慢；</li>
<li>调用外部服务接口响应慢。</li>
</ul>
<p><strong>面试官</strong>：对于外部接口响应慢的情况，有什么应对措施吗？</p>
<p><strong>我</strong>：这个要分情况讨论。</p>
<p>如果调用外部系统<strong>只是一个通知，或者调用外部接口的结果并不处理</strong>，可以采用异步的方式，异步逻辑里采用重试的方式保证接口调成功。</p>
<p>如果外部接口返回结果必须要处理，可以考虑接口返回的结果是否可以缓存默认值（要考虑业务可行），在调用失败后采用快速降级的方式，使用默认值替代返回接口返回值。</p>
<p>如果这个接口返回结果必须要处理，并且不能缓存，可以把拉取到的消息存入本地然后给 Broker 直接返回 CONSUME_SUCCESS。等外部系统恢复正常后再从本地取出来进行处理。</p>
<p><strong>面试官</strong>：如果消费者数小于 MessageQueue 数量，并且外部系统响应正常，为了快速消费积压消息而增加消费者，有什么需要考虑的吗？</p>
<p><strong>我</strong>：外部系统虽然响应正常，但是增加多个消费者后，外部系统的接口调用量会突增，如果达到吞吐量上限，外部系统会响应变慢，甚至被打挂。</p>
<p>同时也要考虑本地数据库、缓存的压力，如果数据库响应变慢，处理消息的速度就会变慢，起不到缓解消息积压的作用。</p>
<p><strong>面试官</strong>：新增加了消费者后，怎么给它分配 MessageQueue 呢？</p>
<p><strong>我</strong>：Consumer 在拉取消息之前，需要对 MessageQueue 进行负载操作。RocketMQ 使用一个定时器来完成负载操作，默认每间隔 20s 重新负载一次。</p>
<p><strong>面试官</strong>：能详细说一下都有哪些负载策略吗？</p>
<p><strong>我</strong>：RocketMQ 提供了 6 种负载策略，依次来看一下。</p>
<p><strong>平均负载策略：</strong></p>
<ol>
<li>把消费者进行排序；</li>
<li>计算每个消费者可以平均分配的 MessageQueue 数量；</li>
<li>如果消费者数量大于 MessageQueue 数量，多出的消费者就分不到；</li>
<li>如果不可以平分，就使用 MessageQueue 总数量对消费者数量求余数 mod；</li>
<li>对前 mod 数量消费者，每个消费者加一个，这样就获取到了每个消费者分配的 MessageQueue 数量。</li>
</ol>
<p>比如 4 个 MessageQueue 和 3 个消费者的情况：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/11/1103-dHKsfY.png" alt="图片"></p>
<p>源代码的逻辑非常简单，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AllocateMessageQueueAveragely 这个类</span></span><br><span class="line"><span class="comment">// 4 个 MessageQueue 和 3 个消费者的情况，假如第一个，index = 0</span></span><br><span class="line"><span class="keyword">int</span> index = cidAll.indexOf(currentCID);</span><br><span class="line"><span class="comment">// mod = 1</span></span><br><span class="line"><span class="keyword">int</span> mod = mqAll.size() % cidAll.size();</span><br><span class="line"><span class="comment">// averageSize = 2</span></span><br><span class="line"><span class="keyword">int</span> averageSize =</span><br><span class="line">    mqAll.size() &lt;= cidAll.size() ? <span class="number">1</span> : (mod &gt; <span class="number">0</span> &amp;&amp; index &lt; mod ? mqAll.size() / cidAll.size()</span><br><span class="line">                                         + <span class="number">1</span> : mqAll.size() / cidAll.size());</span><br><span class="line"><span class="comment">// startIndex = 0</span></span><br><span class="line"><span class="keyword">int</span> startIndex = (mod &gt; <span class="number">0</span> &amp;&amp; index &lt; mod) ? index * averageSize : index * averageSize + mod;</span><br><span class="line"><span class="comment">// range = 2,所以第一个消费者分配到了2个</span></span><br><span class="line"><span class="keyword">int</span> range = Math.min(averageSize, mqAll.size() - startIndex);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; range; i++) &#123;</span><br><span class="line">    result.add(mqAll.get((startIndex + i) % mqAll.size()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>循环分配策略:</strong></p>
<p>这个很容易理解，遍历消费者，把 MessageQueue 分一个给遍历到的消费者，如果 MessageQueue 数量比消费者多，需要进行多次遍历，遍历次数等于  （MessageQueue 数量/消费者数量），还是以 4 个 MessageQueue 和 3 个消费者的情况，如下图：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/11/1103-4fvcvc.png" alt="图片"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AllocateMessageQueueAveragelyByCircle 这个类</span></span><br><span class="line"><span class="comment">//4 个 MessageQueue 和 3 个消费者的情况，假如第一个，index = 0</span></span><br><span class="line"><span class="keyword">int</span> index = cidAll.indexOf(currentCID);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; mqAll.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i % cidAll.size() == index) &#123;</span><br><span class="line">        <span class="comment">//i == 0 或者 i == 3 都会走到这里</span></span><br><span class="line">        result.add(mqAll.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>自定义分配策略：</strong></p>
<p>这种策略在消费者启动的时候可以指定消费哪些 MessageQueue。可以参考下面代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AllocateMessageQueueByConfig allocateMessageQueueByConfig = <span class="keyword">new</span> AllocateMessageQueueByConfig();</span><br><span class="line"><span class="comment">//绑定消费 messageQueue1</span></span><br><span class="line">allocateMessageQueueByConfig.setMessageQueueList(Arrays.asList(<span class="keyword">new</span> MessageQueue(<span class="string">&quot;messageQueue1&quot;</span>,<span class="string">&quot;broker1&quot;</span>,<span class="number">0</span>)));</span><br><span class="line">consumer.setAllocateMessageQueueStrategy(allocateMessageQueueByConfig);</span><br><span class="line">consumer.start();</span><br></pre></td></tr></table></figure>
<p><strong>按照机房分配策略：</strong></p>
<p>这种方式 Consumer 只消费指定机房的 MessageQueue，如下图：Consumer0、Consumer1、Consumer2 绑定 room1 和 room2 这两个机房，而 room3 这个机房没有消费者。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/11/1104-xQcBq5.png" alt="图片"></p>
<p>Consumer 启动的时候需要绑定机房名称。可以参考下面代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AllocateMessageQueueByMachineRoom allocateMessageQueueByMachineRoom = <span class="keyword">new</span> AllocateMessageQueueByMachineRoom();</span><br><span class="line"><span class="comment">//绑定消费 room1 和 room2 这两个机房</span></span><br><span class="line">allocateMessageQueueByMachineRoom.setConsumeridcs(<span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="string">&quot;room1&quot;</span>,<span class="string">&quot;room2&quot;</span>)));</span><br><span class="line">consumer.setAllocateMessageQueueStrategy(allocateMessageQueueByMachineRoom);</span><br><span class="line">consumer.start();</span><br></pre></td></tr></table></figure>
<p>这种策略 broker 的命名必须按照格式：机房名@brokerName，因为消费者分配队列的时候，首先按照机房名称过滤出所有的 MessageQueue，然后<code>再按照平均分配策略进行分配</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AllocateMessageQueueByMachineRoom 这个类</span></span><br><span class="line">List&lt;MessageQueue&gt; premqAll = <span class="keyword">new</span> ArrayList&lt;MessageQueue&gt;();</span><br><span class="line"><span class="keyword">for</span> (MessageQueue mq : mqAll) &#123;</span><br><span class="line">    String[] temp = mq.getBrokerName().split(<span class="string">&quot;@&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (temp.length == <span class="number">2</span> &amp;&amp; consumeridcs.contains(temp[<span class="number">0</span>])) &#123;</span><br><span class="line">        premqAll.add(mq);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上面按照机房名称过滤出所有的 MessageQueue 放入premqAll，后面就是平均分配策略</span></span><br></pre></td></tr></table></figure>
<p><strong>按照机房就近分配：</strong></p>
<p>跟按照机房分配原则相比，就近分配的好处是可以对没有消费者的机房进行分配。如下图，机房 3 的 MessageQueue 也分配到了消费者：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/11/1105-GcF8UO.png" alt="图片"></p>
<p>如果一个机房没有消费者，则会把这个机房的 MessageQueue 分配给集群中所有的消费者。</p>
<blockquote>
<p>源码所在类：<code>AllocateMachineRoomNearby</code>。</p>
</blockquote>
<p><strong>一致性 Hash 算法策略：</strong></p>
<p>把所有的消费者经过 Hash 计算分布到 Hash 环上，对所有的 MessageQueue  进行 Hash  计算，找到顺时针方向最近的消费者节点进行绑定。如下图：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/11/1105-5VDzq8.png" alt="图片"></p>
<p>源代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//所在类 AllocateMessageQueueConsistentHash</span></span><br><span class="line">Collection&lt;ClientNode&gt; cidNodes = <span class="keyword">new</span> ArrayList&lt;ClientNode&gt;();</span><br><span class="line"><span class="keyword">for</span> (String cid : cidAll) &#123;</span><br><span class="line">    cidNodes.add(<span class="keyword">new</span> ClientNode(cid));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用消费者构建 Hash 环，把消费者分布在 Hash 环节点上</span></span><br><span class="line"><span class="keyword">final</span> ConsistentHashRouter&lt;ClientNode&gt; router; <span class="comment">//for building hash ring</span></span><br><span class="line"><span class="keyword">if</span> (customHashFunction != <span class="keyword">null</span>) &#123;</span><br><span class="line">    router = <span class="keyword">new</span> ConsistentHashRouter&lt;ClientNode&gt;(cidNodes, virtualNodeCnt, customHashFunction);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    router = <span class="keyword">new</span> ConsistentHashRouter&lt;ClientNode&gt;(cidNodes, virtualNodeCnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对 MessageQueue 做 Hash 运算，找到环上距离最近的消费者</span></span><br><span class="line">List&lt;MessageQueue&gt; results = <span class="keyword">new</span> ArrayList&lt;MessageQueue&gt;();</span><br><span class="line"><span class="keyword">for</span> (MessageQueue mq : mqAll) &#123;</span><br><span class="line">    ClientNode clientNode = router.routeNode(mq.toString());</span><br><span class="line">    <span class="keyword">if</span> (clientNode != <span class="keyword">null</span> &amp;&amp; currentCID.equals(clientNode.getKey())) &#123;</span><br><span class="line">        results.add(mq);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>面试官</strong>：恭喜你，通过了。</p>
<hr>
<blockquote>
<p>原文：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvVXF5MTNFOXFZQU9ONDNoM1hGVW4zZw==">RocketMQ 消息积压了，增加消费者有用吗？<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
]]></content>
      <categories>
        <category>中间件</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>GC</tag>
        <tag>数据库</tag>
        <tag>面试</tag>
        <tag>锁</tag>
        <tag>Redis</tag>
        <tag>MQ</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker下RabbitMQ延时队列实战两部曲之一：极速体验</title>
    <url>/posts/3V74DRG.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>原文： <span class="exturl" data-url="aHR0cHM6Ly94aWUuaW5mb3EuY24vYXJ0aWNsZS8xMTQwYjQ4Y2I5YTFlN2RiZmNmODU1Njk4">Docker下RabbitMQ延时队列实战两部曲之一：极速体验<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/03/1105OoFOJe.jpg" alt=""></p>
<h3 id="关于延时队列"><a href="#关于延时队列" class="headerlink" title="关于延时队列"></a>关于延时队列</h3><p>有的应用场景中，向 RabbitMQ 发出消息后，我们希望消费方不要立即消费，可以通过延时队列来实现，思路是将消息发送到 A  队列，此队列没有消费者，等消息过期后会进入 A 队列的 Dead Letter Exchange 中，B 队列绑定了这个 Dead Letter Exchange，消费方只要消费 B 队列的消息，就能实现延时消费了，如下图所示：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/03/1106Vy0IMl.png" alt=""></p>
<h3 id="延时的时长"><a href="#延时的时长" class="headerlink" title="延时的时长"></a>延时的时长</h3><ul>
<li>从上面的描述可以看出，延时时长就是消息的过期时间 TTL（Time To Live），这个参数可以通过以下两种方式设置：</li>
</ul>
<ol>
<li><p>生产消息时，设置该消息的 TTL；</p>
</li>
<li><p>设置整个队列的 TTL，队列中每个消息的 TTL 都是一样的；</p>
</li>
</ol>
<ul>
<li>接下来的实战，我们将上述两种方式都体验一次；</li>
</ul>
<h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ol>
<li>操作系统：Ubuntu 16.04.3 LTS</li>
<li>Docker：1.12.6</li>
<li>RabbitMQ：3.7.5-rc.1</li>
</ol>
<h3 id="极速体验"><a href="#极速体验" class="headerlink" title="极速体验"></a>极速体验</h3><ul>
<li><p>本章是《Docker 下 RabbitMQ 延时队列实战两部曲》系列的第一篇，重点是极速体验，先看一下即将体验的整体结构图：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/03/1108hShQ3h.png" alt=""></p>
</li>
<li><p>简单说一下上图中应用的身份：</p>
<ol>
<li>delayrabbitmqconsumer：SpringBoot 框架的应用，连接 RabbitMQ 的两个队列，消费消息；</li>
<li>messagettlproducer：SpringBoot 框架的应用，收到 web 请求后向 RabbitMQ 发送消息，消息中带有过期时间（TTL）；</li>
<li>queuettlproducer：SpringBoot 框架的应用，收到 web 请求后向 RabbitMQ 发送消息，消息中不带过期时间（TTL），但是对应的消息队列已经设置了过期时间；</li>
</ol>
</li>
<li><p>开始实战：</p>
</li>
<li><p>确保当前电脑上 Docker 可用，创建 docker-compose.yml 文件，内容如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">rabbit1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">bolingcavalry/rabbitmq-server:0.0.3</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">rabbit1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;15672:15672&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">RABBITMQ_DEFAULT_USER=admin</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">RABBITMQ_DEFAULT_PASS=888888</span></span><br><span class="line">  <span class="attr">rabbit2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">bolingcavalry/rabbitmq-server:0.0.3</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">rabbit2</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rabbit1</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rabbit1</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">CLUSTERED=true</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">CLUSTER_WITH=rabbit1</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">RAM_NODE=true</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">HA_ENABLE=true</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;15673:15672&quot;</span></span><br><span class="line">  <span class="attr">rabbit3:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">bolingcavalry/rabbitmq-server:0.0.3</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">rabbit3</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rabbit2</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rabbit1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rabbit2</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLUSTERED=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLUSTER_WITH=rabbit1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;15675:15672&quot;</span></span><br><span class="line">  <span class="attr">messagettlproducer:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">bolingcavalry/messagettlproducer:0.0.1-SNAPSHOT</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">messagettlproducer</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rabbit3</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rabbit1:rabbitmqhost1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rabbit2:rabbitmqhost2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rabbit3:rabbitmqhost3</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;18080:8080&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mq.rabbit.address=rabbitmqhost1:5672,rabbitmqhost2:5672,rabbitmqhost3:5672</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mq.rabbit.username=admin</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mq.rabbit.password=888888</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">message.ttl.exchange=message.ttl.exchange</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">message.ttl.queue.source=message.ttl.queue.source</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">message.ttl.queue.process=message.ttl.queue.process</span></span><br><span class="line">  <span class="attr">queuettlproducer:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">bolingcavalry/queuettlproducer:0.0.1-SNAPSHOT</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">queuettlproducer</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">messagettlproducer</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rabbit1:rabbitmqhost1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rabbit2:rabbitmqhost2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rabbit3:rabbitmqhost3</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;18081:8080&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mq.rabbit.address=rabbitmqhost1:5672,rabbitmqhost2:5672,rabbitmqhost3:5672</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mq.rabbit.username=admin</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mq.rabbit.password=888888</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">queue.ttl.exchange=queue.ttl.exchange</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">queue.ttl.queue.source=queue.ttl.queue.source</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">queue.ttl.queue.process=queue.ttl.queue.process</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">queue.ttl.value=5000</span></span><br><span class="line">  <span class="attr">delayrabbitmqconsumer:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">bolingcavalry/delayrabbitmqconsumer:0.0.1-SNAPSHOT</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">delayrabbitmqconsumer</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">queuettlproducer</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rabbit1:rabbitmqhost1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rabbit2:rabbitmqhost2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rabbit3:rabbitmqhost3</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">mq.rabbit.address=rabbitmqhost1:5672,rabbitmqhost2:5672,rabbitmqhost3:5672</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">mq.rabbit.username=admin</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">mq.rabbit.password=888888</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">message.ttl.queue.process=message.ttl.queue.process</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">queue.ttl.queue.process=queue.ttl.queue.process</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>在 docker-compose.yml 文件所在目录执行命令 <strong>docker-compose up -d</strong>，docker 会先去下载镜像，然后创建多个容器，请静候启动完成，如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">root@willzhao-Vostro-3267:/usr/local/work/github/blog_demos/rabbitmq_docker_files/delaymq#</span> <span class="string">docker-compose</span> <span class="string">up</span> <span class="string">-d</span></span><br><span class="line"><span class="string">Creating</span> <span class="string">network</span> <span class="string">&quot;delaymq_default&quot;</span> <span class="string">with</span> <span class="string">the</span> <span class="string">default</span> <span class="string">driver</span></span><br><span class="line"><span class="string">Creating</span> <span class="string">delaymq_rabbit1_1</span> <span class="string">...</span> <span class="string">done</span></span><br><span class="line"><span class="string">Creating</span> <span class="string">delaymq_rabbit2_1</span> <span class="string">...</span> <span class="string">done</span></span><br><span class="line"><span class="string">Creating</span> <span class="string">delaymq_rabbit3_1</span> <span class="string">...</span> <span class="string">done</span></span><br><span class="line"><span class="string">Creating</span> <span class="string">delaymq_messagettlproducer_1</span> <span class="string">...</span> <span class="string">done</span></span><br><span class="line"><span class="string">Creating</span> <span class="string">delaymq_queuettlproducer_1</span>   <span class="string">...</span> <span class="string">done</span></span><br><span class="line"><span class="string">Creating</span> <span class="string">delaymq_delayrabbitmqconsumer_1</span> <span class="string">...</span> <span class="string">done</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>一共启动了 5 个容器，将他们的名称和作用列举到下面表格中：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/03/1111M3kYEP.png" alt=""></p>
</li>
<li><p>我的电脑 IP 地址是 <strong>192.168.31.102</strong>，因此在浏览器输入：<span class="exturl" data-url="aHR0cDovLzoxOTIuMTY4LjMxLjEwMjoxNTY3Mg==">http://:192.168.31.102:15672<i class="fa fa-external-link-alt"></i></span> ，可以进入 RabbitMQ 的登录页面，如下图：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/03/1111USpaye.png" alt=""></p>
</li>
<li><p>登录用户名：<strong>admin</strong>，密码：<strong>888888</strong>，登录后页面如下图，可以见到 RabbitMQ 集群已经就绪：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/03/1112mC9tZP.png" alt=""></p>
</li>
<li><p>如果您的页面中的三个 RabbitMQ 还没有完全就绪（绿色状态），建议稍等几分钟后再刷新页面；</p>
</li>
<li><p>我的电脑 IP 地址是 <strong>192.168.31.102</strong>，因此在浏览器输入：<span class="exturl" data-url="aHR0cDovLzE5Mi4xNjguMzEuMTAyOjE4MDgwL21lc3NhZ2V0dGwvYWFhL2JiYi8z">http://192.168.31.102:18080/messagettl/aaa/bbb/3<i class="fa fa-external-link-alt"></i></span> ，即可向 delaymq_messagettlproducer_1 容器发起一次请求，容器会发送一条带有 TTL  的消息，然后页面提示发送成功，如下图：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/03/11120vsfud.png" alt=""></p>
</li>
<li><p>在浏览器输入：<span class="exturl" data-url="aHR0cDovLzE5Mi4xNjguMzEuMTAyOjE4MDgxL3F1ZXVldHRsL2NjYy9kZGQ=">http://192.168.31.102:18081/queuettl/ccc/ddd<i class="fa fa-external-link-alt"></i></span> ，即可向  delaymq_queuettlproducer_1 容器发起一次请求，容器会向一个已经设置了 TTL  的队列发送一条消息，然后页面提示发送成功，如下图：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/03/1113xOGFtE.png" alt=""></p>
</li>
<li><p>再次进入 RabbitMQ 管理页面 <span class="exturl" data-url="aHR0cDovLzoxOTIuMTY4LjMxLjEwMjoxNTY3Mg==">http://:192.168.31.102:15672<i class="fa fa-external-link-alt"></i></span> ，查看队列情况如下图，已经有四个队列了：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/03/1113gawCLe.png" alt=""></p>
</li>
<li><p>用下列表格对上述四个队列简单说明：</p>
</li>
<li><p>容器 delaymq_delayrabbitmqconsumer_1 中的 tomcat 在启动时候，由于此时队列还没创建，因此无法连接队列，会导致 tomcat 启动失败，进而导致容器退出(因为 tomcat 进程占据了控制台，它退出容器就会退出)，此时请执行 <strong>docker restart delaymq_delayrabbitmqconsumer_1</strong> 重启容器；</p>
</li>
<li><p>重启后，执行命令 <strong>docker logs -f delaymq_delayrabbitmqconsumer_1</strong>，开始实时打印消费者容器的日志，可以看到 SpringBoot 刚刚启动就把之前的两条消息给消费了，如下图红框所示：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/03/11140q4wiY.png" alt=""></p>
</li>
<li><p>在浏览器输入：<span class="exturl" data-url="aHR0cDovLzE5Mi4xNjguMzEuMTAyOjE4MDgwL21lc3NhZ2V0dGwvYWFhMDEvYmJiMDEvMTA=">http://192.168.31.102:18080/messagettl/aaa01/bbb01/10<i class="fa fa-external-link-alt"></i></span> ，url 中的 10  表示延时十秒，去看 delaymq_delayrabbitmqconsumer_1 的日志，果然，10  秒钟后日志才会打印出来，如下所示，消息中的时间和日志的时间戳相差 10 秒：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2018-06-09 07:13:25.878  INFO 1 --- [cTaskExecutor-1] c.b.d.receiver.MessageTtlReceiver        : receive message : hello, aaa01 , bbb01, from queue [message.ttl.queue.source], delay 10&#x27;s, 2018-06-09 07:13:15</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>在浏览器输入：<span class="exturl" data-url="aHR0cDovLzE5Mi4xNjguMzEuMTAyOjE4MDgxL3F1ZXVldHRsL2NjYzAxL2RkZDAx">http://192.168.31.102:18081/queuettl/ccc01/ddd01<i class="fa fa-external-link-alt"></i></span> ，会发送消息到队列  queue.ttl.queue.source，这个队列的 TTL 是 5 秒，在 delaymq_delayrabbitmqconsumer_1 的日志中可以看见发起和收到时间正好差 5 秒，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">2018-06-09 07:31:05.101  INFO 1 --- [cTaskExecutor-1] c.b.d.receiver.QueueTtlReceiver          : receive message : hello, ccc01 , ddd01, from queue [queue.ttl.queue.source], 2018-06-09 07:31:00</span><br></pre></td></tr></table></figure>
</li>
<li><p>至此，咱们的极速体验延时队列实战就结束了，接下来的章节，我们一起实战详细的开发过程《Docker 下 RabbitMQ 延时队列实战两部曲之二：细说开发》</p>
</li>
</ul>
]]></content>
      <categories>
        <category>中间件</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Spring</tag>
        <tag>SpringBoot</tag>
        <tag>GC</tag>
        <tag>MQ</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker下RabbitMQ延时队列实战两部曲之二：细说开发</title>
    <url>/posts/33KCKKX.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>原文：<span class="exturl" data-url="aHR0cHM6Ly94aWUuaW5mb3EuY24vYXJ0aWNsZS81MDMwN2Q5Y2NmN2M1YTNmOWViYTZjYjdm">Docker下RabbitMQ延时队列实战两部曲之二：细说开发<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/03/1124QWMauu.png" alt=""></p>
<h3 id="本章涉及的脚本和源码下载"><a href="#本章涉及的脚本和源码下载" class="headerlink" title="本章涉及的脚本和源码下载"></a>本章涉及的脚本和源码下载</h3><p>本章会开发一个 yml 脚本，三个基于 SpringBoot 的应用，功能如下：</p>
<ol>
<li>docker-compose.yml：启动所有容器的 docker-compose 脚本；</li>
<li>delayrabbitmqconsumer：SpringBoot 框架的应用，连接 RabbitMQ 的两个队列，消费消息；</li>
<li>messagettlproducer：SpringBoot 框架的应用，收到 web 请求后向 RabbitMQ 发送消息，消息中带有过期时间（TTL）；</li>
<li>queuettlproducer：SpringBoot 框架的应用，收到 web 请求后向 RabbitMQ 发送消息，消息中不带过期时间（TTL），但是对应的消息队列已经设置了过期时间；</li>
</ol>
<p>整体部署情况如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/03/1125YmrCjd.png" alt=""> </p>
<p>上述脚本和工程的源码都可以在 github 下载，地址和链接信息如下表所示：</p>
<p>这个 git 项目中有多个文件夹，三个 SpringBoot 工程分别在 delayrabbitmqconsumer、messagettlproducer、queuettlproducer 这三个文件夹下，如下图的三个红框所示：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/03/1126if9cLf.png" alt=""> </p>
<p>docker-compose.yml 文件在 rabbitmq_docker_files 文件夹下面的 delaymq 文件夹下，如下图：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/03/1126iKUR8H.png" alt=""> </p>
<h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><ul>
<li>操作系统：Ubuntu 16.04.3 LTS</li>
<li>Docker：1.12.6</li>
<li>RabbitMQ：3.7.5-rc.1</li>
<li>JDK：1.8.0_111</li>
<li>SpringBoot：1.4.1.RELEASE</li>
<li>Maven：3.5.0</li>
</ul>
<h3 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h3><ul>
<li>本次开发实战的步骤如下：</li>
</ul>
<ol>
<li>开发 messagettlproducer 应用，制作镜像；</li>
<li>开发 queuettlproducer 应用，制作镜像；</li>
<li>开发 delayrabbitmqconsumer 应用，制作镜像；</li>
<li>开发 docker-compose.yml 脚本；</li>
</ol>
<h3 id="messagettlproducer-应用"><a href="#messagettlproducer-应用" class="headerlink" title="messagettlproducer 应用"></a>messagettlproducer 应用</h3><ul>
<li><p>messagettlproducer 是个基于 SpringBoot 的 web 工程，有一个 Controller 可以响应 web 请求，收到请求后发送一条带有过期时间的消息到 RabbitMQ 的 message.ttl.queue.source 队列；</p>
</li>
<li><p>pom.xml 内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.bolingcavalry<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>messagettlproducer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>messagettlproducer<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spotify<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>docker-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                                <span class="comment">&lt;!--docker镜像相关的配置信息--&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                                        <span class="comment">&lt;!--镜像名，这里用工程名--&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">imageName</span>&gt;</span>bolingcavalry/$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">imageName</span>&gt;</span></span><br><span class="line">                                        <span class="comment">&lt;!--TAG,这里用工程版本号--&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">imageTags</span>&gt;</span></span><br><span class="line">                                                <span class="tag">&lt;<span class="name">imageTag</span>&gt;</span>$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">imageTag</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;/<span class="name">imageTags</span>&gt;</span></span><br><span class="line">                                        <span class="comment">&lt;!--镜像的FROM，使用java官方镜像--&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">baseImage</span>&gt;</span>java:8u111-jdk<span class="tag">&lt;/<span class="name">baseImage</span>&gt;</span></span><br><span class="line">                                        <span class="comment">&lt;!--该镜像的容器启动后，直接运行spring boot工程--&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">entryPoint</span>&gt;</span>[&quot;java&quot;, &quot;-jar&quot;, &quot;/$&#123;project.build.finalName&#125;.jar&quot;]<span class="tag">&lt;/<span class="name">entryPoint</span>&gt;</span></span><br><span class="line">                                        <span class="comment">&lt;!--构建镜像的配置信息--&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">                                                <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                                                        <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>/<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">                                                        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.build.directory&#125;<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                                                        <span class="tag">&lt;<span class="name">include</span>&gt;</span>$&#123;project.build.finalName&#125;.jar<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                                                <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">                                        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>上面的内容中有以下两点需要注意：a. 添加对 spring-boot-starter-amqp 的依赖，这里面是操作 RabbitMQ 所需的库；b. 添加 docker-maven-plugin 插件，可以将当前工程直接制作成 Docker 镜像；</p>
</li>
<li><p>src/main/resources 文件夹下面创建 application.properties 文件，内容如下，只配置了应用名称和 RabbitMQ 的 virtualHost 路径：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.application.name</span>=<span class="string">messagettlproducer</span></span><br><span class="line"><span class="meta">mq.rabbit.virtualHost</span>=<span class="string">/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>RabbitTemplateConfig.java 文件中是应用连接 RabbitMQ 的配置信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitTemplateConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;mq.rabbit.address&#125;&quot;)</span></span><br><span class="line">    String address;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;mq.rabbit.username&#125;&quot;)</span></span><br><span class="line">    String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;mq.rabbit.password&#125;&quot;)</span></span><br><span class="line">    String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;mq.rabbit.virtualHost&#125;&quot;)</span></span><br><span class="line">    String mqRabbitVirtualHost;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建mq连接</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;connectionFactory&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConnectionFactory <span class="title">connectionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CachingConnectionFactory connectionFactory = <span class="keyword">new</span> CachingConnectionFactory();</span><br><span class="line"></span><br><span class="line">        connectionFactory.setUsername(username);</span><br><span class="line">        connectionFactory.setPassword(password);</span><br><span class="line">        connectionFactory.setVirtualHost(mqRabbitVirtualHost);</span><br><span class="line">        connectionFactory.setPublisherConfirms(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//该方法配置多个host，在当前连接host down掉的时候会自动去重连后面的host</span></span><br><span class="line">        connectionFactory.setAddresses(address);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> connectionFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line">    <span class="comment">//必须是prototype类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RabbitTemplate <span class="title">rabbitTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RabbitTemplate template = <span class="keyword">new</span> RabbitTemplate(connectionFactory());</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上面的代码有以下几点要注意：a. address、username、password 这些变量的值，是从操作系统的环境变量中获取的，我们在启动 Docker 容器的时候将这些值配置到容器的环境变量中，程序运行的时候就能取到了；b. connectionFactory()方法根据上述配置参数和 RabbitMQ 建立连接；c. rabbitTemplate()创建 RabbitTemplate 对象，我们可以在其他 Bean 中通过 Autowire 使用；</p>
</li>
<li><p>MessageTtlRabbitConfig.java 类中是和消息队列相关的配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 成为死信后，重新发送到的交换机的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;message.ttl.exchange&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String MESSAGE_TTL_EXCHANGE_NAME;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不会被消费的队列，投递到此队列的消息会成为死信</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;message.ttl.queue.source&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String MESSAGE_TTL_QUEUE_SOURCE;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该队列被绑定到接收死信的交换机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Value(&quot;$&#123;message.ttl.queue.process&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String MESSAGE_TTL_QUEUE_PROCESS;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置一个队列，该队列的消息如果没有被消费，就会投递到死信交换机中，并且带上指定的routekey</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">Queue <span class="title">messageTtlQueueSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(MESSAGE_TTL_QUEUE_SOURCE)</span><br><span class="line">            .withArgument(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, MESSAGE_TTL_EXCHANGE_NAME)</span><br><span class="line">            .withArgument(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, MESSAGE_TTL_QUEUE_PROCESS)</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="meta">@Bean(&quot;messageTtlQueueProcess&quot;)</span></span><br><span class="line"><span class="function">Queue <span class="title">messageTtlQueueProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.durable(MESSAGE_TTL_QUEUE_PROCESS) .build();</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="meta">@Bean(&quot;messageTtlExchange&quot;)</span></span><br><span class="line"><span class="function">DirectExchange <span class="title">messageTtlExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(MESSAGE_TTL_EXCHANGE_NAME);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 绑定指定的队列到死信交换机上</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> messageTtlQueueProcess</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> messageTtlExchange</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function">Binding <span class="title">bindingExchangeMessage</span><span class="params">(<span class="meta">@Qualifier(&quot;messageTtlQueueProcess&quot;)</span> Queue messageTtlQueueProcess, <span class="meta">@Qualifier(&quot;messageTtlExchange&quot;)</span> DirectExchange messageTtlExchange)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;11111111111111111111111111111111111111111111111111&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;11111111111111111111111111111111111111111111111111&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;11111111111111111111111111111111111111111111111111&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;11111111111111111111111111111111111111111111111111&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(messageTtlQueueProcess)</span><br><span class="line">            .to(messageTtlExchange)</span><br><span class="line">            .with(MESSAGE_TTL_QUEUE_PROCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上面的代码有以下几点要注意：a. MESSAGE_TTL_EXCHANGE_NAME、MESSAGE_TTL_QUEUE_SOURCE、MESSAGE_TTL_QUEUE_PROCESS 这些变量的值，是从操作系统的环境变量中获取的，我们在启动 Docker 容器的时候将这些值配置到容器的环境变量中，程序运行的时候就能取到了；b. connectionFactory()方法根据上述配置参数和 RabbitMQ 建立连接；c. rabbitTemplate()创建 RabbitTemplate 对象，我们可以在其他 Bean 中通过 Autowire 使用；d. messageTtlQueueSource()方法创建了一个队列用于投递消息，通过 <strong>x-dead-letter-exchange</strong> 和 <strong>x-dead-letter-routing-key</strong> 这两个参数，设置了队列消息过期后转发的交换机名称，以及携带的 routing key；</p>
</li>
<li><p>为了设置消息过期，我们还要定制一个 ExpirationMessagePostProcessor 类，作用是将给消息类设置过期时间，后面发送消息时会用到这个类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.bolingcavalry.messagettlproducer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.AmqpException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.MessagePostProcessor;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> :</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : zq2599@gmail.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> : 2018-06-02 23:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpirationMessagePostProcessor</span> <span class="keyword">implements</span> <span class="title">MessagePostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Long ttl; <span class="comment">// 毫秒</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExpirationMessagePostProcessor</span><span class="params">(Long ttl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ttl = ttl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Message <span class="title">postProcessMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> AmqpException </span>&#123;</span><br><span class="line">        message.getMessageProperties() .setExpiration(ttl.toString()); <span class="comment">// 设置per-message的失效时间</span></span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用于处理 web 请求的 SendMessageController 类，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> : 用于生产消息的web接口类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : zq2599@gmail.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> : 2018-06-02 23:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMessageController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;message.ttl.queue.source&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String MESSAGE_TTL_QUEUE_SOURCE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产一条消息，消息中带有过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delaytime</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/messagettl/&#123;name&#125;/&#123;message&#125;/&#123;delaytime&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function">String <span class="title">messagettl</span><span class="params">(<span class="meta">@PathVariable(&quot;name&quot;)</span> <span class="keyword">final</span> String name, <span class="meta">@PathVariable(&quot;message&quot;)</span> <span class="keyword">final</span> String message, <span class="meta">@PathVariable(&quot;delaytime&quot;)</span> <span class="keyword">final</span> <span class="keyword">int</span> delaytime)</span> </span>&#123;</span><br><span class="line">        SimpleDateFormat simpleDateFormat=<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        String timeStr = simpleDateFormat.format(<span class="keyword">new</span> Date());</span><br><span class="line">        String queueName = MESSAGE_TTL_QUEUE_SOURCE;</span><br><span class="line">        String  sendMessage = String.format(<span class="string">&quot;hello, %s , %s, from queue [%s], delay %d&#x27;s, %s&quot;</span>, name, message, MESSAGE_TTL_QUEUE_SOURCE, delaytime, timeStr);</span><br><span class="line">        rabbitTemplate.convertAndSend(MESSAGE_TTL_QUEUE_SOURCE,</span><br><span class="line">                                        (Object)sendMessage,</span><br><span class="line">                                        <span class="keyword">new</span> ExpirationMessagePostProcessor(delaytime*<span class="number">1000L</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;send message to [&quot;</span> +  name + <span class="string">&quot;] success , queue is : &quot;</span> + queueName + <span class="string">&quot; (&quot;</span> + timeStr + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>如上所示，发送消息的代码很简单，调用 rabbitTemplate 的 convertAndSend 就能发送消息到 message.ttl.queue.source 队列（指定路由键的 Direct 方式），再传入 ExpirationMessagePostProcessor 作为处理消息的工具；</li>
<li>以上就是 messagettlproducer 应用的主要代码介绍，编码完毕后，在 pom.xml 文件所在目录执行 <strong>mvn clean package -U -DskipTests docker:build</strong>，即可编译、构建、制作 Docker 镜像；</li>
</ul>
<h3 id="queuettlproducer-应用"><a href="#queuettlproducer-应用" class="headerlink" title="queuettlproducer 应用"></a>queuettlproducer 应用</h3><ul>
<li><p>queuettlproducer 和 messagettlproducer 极为相似，都是接受 web 请求后向 RabbitMQ 发送消息，不同之处有以下两点：</p>
<ol>
<li>queuettlproducer 在绑定队列的时候，会设置队列上所有消息的过期时间，messagettlproducer 没做这个设置；</li>
<li>queuettlproducer 在发送消息的时候，没有设置该消息的过期时间，messagettlproducer 会对每条消息都设置过期时间；</li>
</ol>
</li>
<li><p>因此，queuettlproducer 和 messagettlproducer 这两个应用的代码大部分是相同的，这里只要关注不同的部分即可；</p>
</li>
<li><p>队列和交换机的配置类，QueueTtlRabbitConfig：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueTtlRabbitConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 成为死信后，重新发送到的交换机的名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;queue.ttl.exchange&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String QUEUE_TTL_EXCHANGE_NAME;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不会被消费的队列，投递到此队列的消息会成为死信</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;queue.ttl.queue.source&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String QUEUE_TTL_QUEUE_SOURCE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 该队列被绑定到接收死信的交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;queue.ttl.queue.process&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String QUEUE_TTL_QUEUE_PROCESS;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;queue.ttl.value&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> QUEUE_TTL_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置一个队列，该队列有消息过期时间，消息如果没有被消费，就会投递到死信交换机中，并且带上指定的routekey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Queue <span class="title">queueTtlQueueSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_TTL_QUEUE_SOURCE)</span><br><span class="line">                .withArgument(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, QUEUE_TTL_EXCHANGE_NAME)</span><br><span class="line">                .withArgument(<span class="string">&quot;x-dead-letter-routing-key&quot;</span>, QUEUE_TTL_QUEUE_PROCESS)</span><br><span class="line">                .withArgument(<span class="string">&quot;x-message-ttl&quot;</span>, QUEUE_TTL_VALUE)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;queueTtlQueueProcess&quot;)</span></span><br><span class="line">    <span class="function">Queue <span class="title">queueTtlQueueProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> QueueBuilder.durable(QUEUE_TTL_QUEUE_PROCESS) .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;queueTtlExchange&quot;)</span></span><br><span class="line">    <span class="function">DirectExchange <span class="title">queueTtlExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectExchange(QUEUE_TTL_EXCHANGE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queueTtlQueueProcess</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> queueTtlExchange</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Binding <span class="title">bindingExchangeMessage</span><span class="params">(<span class="meta">@Qualifier(&quot;queueTtlQueueProcess&quot;)</span> Queue queueTtlQueueProcess, <span class="meta">@Qualifier(&quot;queueTtlExchange&quot;)</span> DirectExchange queueTtlExchange)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;22222222222222222222222222222222222222222222222222&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;22222222222222222222222222222222222222222222222222&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;22222222222222222222222222222222222222222222222222&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;22222222222222222222222222222222222222222222222222&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(queueTtlQueueProcess)</span><br><span class="line">                .to(queueTtlExchange)</span><br><span class="line">                .with(QUEUE_TTL_QUEUE_PROCESS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上述代码请注意以下两点：a. queueTtlQueueSource()方法用来设置队列，除了 <strong>x-dead-letter-exchange</strong> 和 <strong>x-dead-letter-routing-key</strong> 这两个参数，还多了 <strong>x-message-ttl</strong>，此参数对应的值就是进入该队列的每一条消息的过期时间；b. bindingExchangeMessage()方法将队列 queue.ttl.queue.source 绑定到 Direct 模式的交换机；</p>
</li>
<li><p>处理 web 请求的 SendMessageController 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMessageController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;queue.ttl.queue.source&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String QUEUE_TTL_QUEUE_SOURCE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生产一条消息，消息中不带过期时间，但是对应的队列中已经配置了过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/queuettl/&#123;name&#125;/&#123;message&#125;&quot;, method = RequestMethod.GET)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function">String <span class="title">queuettl</span><span class="params">(<span class="meta">@PathVariable(&quot;name&quot;)</span> <span class="keyword">final</span> String name, <span class="meta">@PathVariable(&quot;message&quot;)</span> <span class="keyword">final</span> String message)</span> </span>&#123;</span><br><span class="line">        SimpleDateFormat simpleDateFormat=<span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        String timeStr = simpleDateFormat.format(<span class="keyword">new</span> Date());</span><br><span class="line">        String queueName = QUEUE_TTL_QUEUE_SOURCE;</span><br><span class="line">        String  sendMessage = String.format(<span class="string">&quot;hello, %s , %s, from queue [%s], %s&quot;</span>, name, message, queueName, timeStr);</span><br><span class="line">        rabbitTemplate.convertAndSend(queueName, sendMessage);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;send message to [&quot;</span> +  name + <span class="string">&quot;] success , queue is : &quot;</span> + queueName + <span class="string">&quot; (&quot;</span> + timeStr + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如上所示，发送消息时只有 routing key 和消息对象这两个参数；</p>
</li>
<li>以上就是发送消息到队列的应用源码，编码完毕后，在 pom.xml 文件所在目录执行 <strong>mvn clean package -U -DskipTests docker:build</strong>，即可编译、构建、制作 Docker 镜像；</li>
<li>接下来我们看看消息消费者工程 delayrabbitmqconsumer 的源码；</li>
</ul>
<h3 id="delayrabbitmqconsumer-应用"><a href="#delayrabbitmqconsumer-应用" class="headerlink" title="delayrabbitmqconsumer 应用"></a>delayrabbitmqconsumer 应用</h3><ul>
<li><p>delayrabbitmqconsumer 应用连接到消息队列，消费收到的每条消息；</p>
</li>
<li><p>RabbitTemplateConfig.java 是连接到 RabbitMQ 的配置信息，和前面两个应用一样，不再赘述；</p>
</li>
<li><p>消费 message.ttl.queue.process 这个队列发出的消息，对应实现类是 MessageTtlReceiver：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> : 消息接受类，接收第一类延时消息(在每条消息中指定过期时间)的转发结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> : zq2599@gmail.com</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> : 2018-06-03 9:52</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;$&#123;message.ttl.queue.process&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageTtlReceiver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(MessageTtlReceiver.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;receive message : &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>如上所示，只要用注解 RabbitListener 配置好队列的名称即可，编码完毕后，在 pom.xml 文件所在目录执行 <strong>mvn clean package -U -DskipTests docker:build</strong>，即可编译、构建、制作 Docker 镜像；</li>
</ul>
<h3 id="docker-compose-yml-配置"><a href="#docker-compose-yml-配置" class="headerlink" title="docker-compose.yml 配置"></a>docker-compose.yml 配置</h3><ul>
<li><p>最后我们看一下所有容器的配置文件 docker-compose.yml：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">rabbit1:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">bolingcavalry/rabbitmq-server:0.0.3</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">rabbit1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;15672:15672&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">RABBITMQ_DEFAULT_USER=admin</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">RABBITMQ_DEFAULT_PASS=888888</span></span><br><span class="line">  <span class="attr">rabbit2:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">bolingcavalry/rabbitmq-server:0.0.3</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">rabbit2</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rabbit1</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rabbit1</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">CLUSTERED=true</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">CLUSTER_WITH=rabbit1</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">RAM_NODE=true</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">HA_ENABLE=true</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;15673:15672&quot;</span></span><br><span class="line">  <span class="attr">rabbit3:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">bolingcavalry/rabbitmq-server:0.0.3</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">rabbit3</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rabbit2</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rabbit1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rabbit2</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLUSTERED=true</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">CLUSTER_WITH=rabbit1</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;15675:15672&quot;</span></span><br><span class="line">  <span class="attr">messagettlproducer:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">bolingcavalry/messagettlproducer:0.0.1-SNAPSHOT</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">messagettlproducer</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rabbit3</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rabbit1:rabbitmqhost1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rabbit2:rabbitmqhost2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rabbit3:rabbitmqhost3</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;18080:8080&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mq.rabbit.address=rabbitmqhost1:5672,rabbitmqhost2:5672,rabbitmqhost3:5672</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mq.rabbit.username=admin</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mq.rabbit.password=888888</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">message.ttl.exchange=message.ttl.exchange</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">message.ttl.queue.source=message.ttl.queue.source</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">message.ttl.queue.process=message.ttl.queue.process</span></span><br><span class="line">  <span class="attr">queuettlproducer:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">bolingcavalry/queuettlproducer:0.0.1-SNAPSHOT</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">queuettlproducer</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">messagettlproducer</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rabbit1:rabbitmqhost1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rabbit2:rabbitmqhost2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rabbit3:rabbitmqhost3</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;18081:8080&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mq.rabbit.address=rabbitmqhost1:5672,rabbitmqhost2:5672,rabbitmqhost3:5672</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mq.rabbit.username=admin</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mq.rabbit.password=888888</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">queue.ttl.exchange=queue.ttl.exchange</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">queue.ttl.queue.source=queue.ttl.queue.source</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">queue.ttl.queue.process=queue.ttl.queue.process</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">queue.ttl.value=5000</span></span><br><span class="line">  <span class="attr">delayrabbitmqconsumer:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">bolingcavalry/delayrabbitmqconsumer:0.0.1-SNAPSHOT</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">delayrabbitmqconsumer</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">queuettlproducer</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rabbit1:rabbitmqhost1</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rabbit2:rabbitmqhost2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">rabbit3:rabbitmqhost3</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">mq.rabbit.address=rabbitmqhost1:5672,rabbitmqhost2:5672,rabbitmqhost3:5672</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">mq.rabbit.username=admin</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">mq.rabbit.password=888888</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">message.ttl.queue.process=message.ttl.queue.process</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">queue.ttl.queue.process=queue.ttl.queue.process</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>上述配置文件有以下几点需要注意：</li>
<li>rabbit1、rabbit2、rabbit3 是 RabbitMQ 高可用集群，如果您对 RabbitMQ 高可用集群感兴趣，推荐您请看<span class="exturl" data-url="aHR0cHM6Ly94aWUuaW5mb3EuY24vbGluaz90YXJnZXQ9aHR0cHMlM0ElMkYlMkZibG9nLjUxY3RvLmNvbSUyRnVfMTM2NzQ0NjUlMkY1MzMxNzc4">《Docker下RabbitMQ四部曲》<i class="fa fa-external-link-alt"></i></span>系列文章；</li>
<li>三个 SpringBoot 应用都配置了 <strong>mq.rabbit.address</strong> 参数，值是三个 RabbitMQ server 的 IP 加端口，这样如果 RabbitMQ 集群中有一台机器故障了也不会影响正常的消息收发；</li>
<li>使用了 link 参数后，容器内就能通过 link 的参数取代对应的 IP；</li>
<li>至此，Docker 下的 RabbitMQ 延时队列实战就完成了，实战中 Docker 发挥的作用并不大，只是用来快速搭建环境，关键还是三个工程中对队列的各种操作，希望本系列能帮助您快速构建延时队列相关服务；</li>
</ul>
]]></content>
      <categories>
        <category>中间件</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>Spring</tag>
        <tag>SpringBoot</tag>
        <tag>GC</tag>
        <tag>变量</tag>
        <tag>MQ</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt基础学习笔记01</title>
    <url>/posts/3V8G3VM.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><QtGlobal>头文件包含了Qt类库的一些全局定义，包括基本数据类型、函数和宏，一般的Qt类的头文件都会包含该文件，所以不用显式包含这个头文件也可以使用其中的定义。</p>
<h2 id="数据类型定义"><a href="#数据类型定义" class="headerlink" title="数据类型定义"></a>数据类型定义</h2><p><img data-src="https://xuemingde.com/pages/image/2022/12/01/142148yi18pE.png" alt=""></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><img data-src="https://xuemingde.com/pages/image/2022/12/01/152327E1M2Pg.png" alt=""></p>
<h2 id="容器类"><a href="#容器类" class="headerlink" title="容器类"></a>容器类</h2><p>字符串列表类QStringList就是从容器类QList<QString>继承的，实现对字符串列表的添加、存储、删除等操作。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/153248tsdG7P.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/153450kFMr4y.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/153639pw8d6P.png" alt=""></p>
<h3 id="顺序容器类"><a href="#顺序容器类" class="headerlink" title="顺序容器类"></a>顺序容器类</h3><p>Qt的顺序容器类有QList、QLinkedList、QVector、QStack和QQueue。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/154140lipzsB.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/154228cvqtqS.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/154320lPlewQ.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/1544149aKShL.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/154440JhsHyq.png" alt=""></p>
<h3 id="关联容器类"><a href="#关联容器类" class="headerlink" title="关联容器类"></a>关联容器类</h3><p>Qt还提供关联容器类QMap、QMultiMap、QHash、QMultiHash和QSet。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/154749eh9GjD.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/155539JL2xWV.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/155755rEv1ya.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/1600342ZL5vE.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/160134XvWC3v.png" alt=""></p>
<h2 id="容器类的迭代"><a href="#容器类的迭代" class="headerlink" title="容器类的迭代"></a>容器类的迭代</h2><p>迭代器(iterator)为访问容器类里的数据项提供了统一的方法，Qt有两种迭代器类：Java类型的迭代器和STL类型的迭代器。<br>Java类型的迭代器更易于使用，且提供一些高级功能，而STL类型的迭代器效率更高。<br>Qt还提供一个关键字foreach(实际是<QtGlobal>里定义的一个宏)用于方便地访问容器里所有数据项。</p>
<h3 id="java类型迭代器"><a href="#java类型迭代器" class="headerlink" title="java类型迭代器"></a>java类型迭代器</h3><p><img data-src="https://xuemingde.com/pages/image/2022/12/01/161658qhNpCu.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/162648qxdRsk.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/1630500gEZ7S.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/164737i7iJef.png" alt=""></p>
<h3 id="STL类型迭代器"><a href="#STL类型迭代器" class="headerlink" title="STL类型迭代器"></a>STL类型迭代器</h3><p>STL迭代器与Qt和STL的原生算法兼容，并且进行了速度优化。<br>对于每一个容器类，都有两个STL类型迭代器：一个用于只读访问，一个用于读写访问。<code>无需修改数据时一定使用只读迭代器，因为它们速度更快。</code></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/165029ahXnvM.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/165157sCic3c.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/172406EVXyOj.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/172637JF92Z6.png" alt=""></p>
<h3 id="foreach-关键字"><a href="#foreach-关键字" class="headerlink" title="foreach 关键字"></a>foreach 关键字</h3><p>如果只是想遍历容器中所有的项，可以使用foreach关键字。foreach是<QtGlobal>头文件中定义的一个宏。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/1728538fAXpi.png" alt=""></p>
<h2 id="Qt类库的模块"><a href="#Qt类库的模块" class="headerlink" title="Qt类库的模块"></a>Qt类库的模块</h2><p><img data-src="https://xuemingde.com/pages/image/2022/12/01/173613OH5ro9.png" alt=""></p>
<h3 id="基本模块"><a href="#基本模块" class="headerlink" title="基本模块"></a>基本模块</h3><p>Qt基本模块是Qt在所有平台上的基本功能，它们在所有的开发平台和目标平台上都可用，在Qt5所有版本上是源代码和二进制兼容的。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/173407GFWHl1.png" alt=""></p>
<p>Ot Core模块是Qt类库的核心，所有其他模块都依赖于此模块，如果使用qmake构建项目，则Qt Core模块是自动被加入项目的。</p>
<p>Qt GUI模块提供了用于开发GUI应用程序的必要的类，使用qmake构建应用程序时，Qt GUI模块是自动被加入项目的。如果项目中不使用GUI功能，则需要在项目配置文件中加入如下的一行：<br><code>QT -= gui</code></p>
<p>其他的模块一般不会被自动加入到项目，如果需要在项目中使用某个模块，则可以在项目配置中添加此模块。例如，如果需要在项目中使用Qt Multimedia和Qt Multimedia Widgets模块，需要在项目配置文件中加入如下的语句：<br><code>OT += multimedia multimediawidgets</code><br>需要在项目中使用Qt SQL模块，就在项目配置文件中加入如下的语句：<br><code>OT += sql</code></p>
<h3 id="附加模块"><a href="#附加模块" class="headerlink" title="附加模块"></a>附加模块</h3><p>Q附加模块可以实现一些特定目的。这些模块可能只在某些开发平台上有，或只能用于某些操作系统，或只是为了向后兼容。用户安装时可以选择性地安装这些附加模块。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/173738uWsVMZ.png" alt=""></p>
<h3 id="增值模块"><a href="#增值模块" class="headerlink" title="增值模块"></a>增值模块</h3><p>除了随Q5发布的上述这些模块，还有一些模块（见表3-8）是单独发布的，这些模块只在商业版许可的Qt里才有。</p>
<h3 id="技术预览模块"><a href="#技术预览模块" class="headerlink" title="技术预览模块"></a>技术预览模块</h3><p>技术预览模块就是一些还处于开发和测试阶段的模块，一般技术预览模块经过几个版本的发布后会变成正式的模块。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/173948dKlybJ.png" alt=""></p>
<h3 id="Qt工具"><a href="#Qt工具" class="headerlink" title="Qt工具"></a>Qt工具</h3><p><img data-src="https://xuemingde.com/pages/image/2022/12/01/174047wHXBsi.png" alt=""></p>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>sql</tag>
        <tag>函数</tag>
        <tag>全局</tag>
        <tag>Qt</tag>
        <tag>算法</tag>
        <tag>容器</tag>
        <tag>Widget</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt基础学习笔记02</title>
    <url>/posts/1QR2QPE.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="常用界面设计组件"><a href="#常用界面设计组件" class="headerlink" title="常用界面设计组件"></a>常用界面设计组件</h1><p>Qt类库为应用程序设计提供了大量的类，本章主要介绍设计GUI应用程序常用的各种界面组件的使用，这些是设计GUI应用程序的基础。</p>
<h2 id="字符串与输人输出"><a href="#字符串与输人输出" class="headerlink" title="字符串与输人输出"></a>字符串与输人输出</h2><h3 id="字符串与数值之间的转换"><a href="#字符串与数值之间的转换" class="headerlink" title="字符串与数值之间的转换"></a>字符串与数值之间的转换</h3><p>QString类从字符串转换为整数的函数有：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/184855au1f62.png" alt=""></p>
<p>这些函数如果不设置参数，缺省表示从十进制表示的字符串转换为整数：若指定整数基参数，<br>还可以直接将二进制、十六进制字符串转换为整数。</p>
<p>QString将字符串转换为浮点数的函数有：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/1850513cGQ9R.png" alt=""></p>
<p>在得到单价和数量后做相乘运算，得到计算结果变量total,再将此数值显示在编辑框editTotal中。由于计算结果是浮点数，希望显示两位小数，下面4行语句都可以实现这个功能。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/190006lxrgug.png" alt=""></p>
<p><strong>进制转换</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/190322otwcAX.png" alt=""></p>
<p>下面是读取二进制字符串，然后转换为十进制和十六进制显示的按钮的槽函数代码。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/190511lILf3S.png" alt=""></p>
<h3 id="QString的常用功能"><a href="#QString的常用功能" class="headerlink" title="QString的常用功能"></a>QString的常用功能</h3><p>QString是Qt编程中常用的类，除了用作数字量的输入输出之外，QString还有很多其他功能，熟悉这些常见的功能，有助于灵活地实现字符串处理功能。<br>QString存储字符串采用的是Unicode码，每一个字符是一个l6位的QChar,.而不是8位的char,所以QString处理中文字符没有问题，而且一个汉字算作是一个字符。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/1913169zdmyV.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/191337hPNhX7.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/191353n5IBSk.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/191410ms5DlV.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/191428eRF1YD.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/1915174F8LTt.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/191538FsrOWM.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/191551iNS3DL.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/191606Fdxh83.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/191621CpGrO1.png" alt=""></p>
<h2 id="SpinBox的使用"><a href="#SpinBox的使用" class="headerlink" title="SpinBox的使用"></a>SpinBox的使用</h2><p>QSpinBox用于整数的显示和输入，一般显示十进制数，也可以显示二进制、十六进制的数，而且可以在显示框中增加前缀或后缀。<br>QDoubleSpinBox用于浮点数的显示和输入，可以设置显示小数位数，也可以设置显示的前缀和后缀。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/192935HBMCEz.png" alt=""></p>
<h2 id="其他数值输人和显示组件"><a href="#其他数值输人和显示组件" class="headerlink" title="其他数值输人和显示组件"></a>其他数值输人和显示组件</h2><p><img data-src="https://xuemingde.com/pages/image/2022/12/01/193803TLT3P4.png" alt=""></p>
<h2 id="时间日期与定时器"><a href="#时间日期与定时器" class="headerlink" title="时间日期与定时器"></a>时间日期与定时器</h2><h3 id="时间日期相关的类"><a href="#时间日期相关的类" class="headerlink" title="时间日期相关的类"></a>时间日期相关的类</h3><p><img data-src="https://xuemingde.com/pages/image/2022/12/01/200634hBDAtp.png" alt=""></p>
<p>Qt中的定时器类是QTimer,它直接从QObject类继承而来，不是界面组件类。</p>
<h3 id="日期时间数据与字符串之间的转换"><a href="#日期时间数据与字符串之间的转换" class="headerlink" title="日期时间数据与字符串之间的转换"></a>日期时间数据与字符串之间的转换</h3><p><img data-src="https://xuemingde.com/pages/image/2022/12/01/204225TRQc9N.png" alt=""></p>
<p>时间格式转字符串：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/204656e0k0uH.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/204725GLfhqE.png" alt=""></p>
<p>字符串转时间格式</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/204824MfJb98.png" alt=""></p>
<p>静态函数QDateTime::fromString(将一个字符串按照格式转换为日期时间类型</p>
<p>这里将字符串str按照格式”yyyy-MM-ddhh:mm:ss”转换为日期时间变量，格式是指字符串str所表示的日期时间的格式。</p>
<h3 id="定时器的使用"><a href="#定时器的使用" class="headerlink" title="定时器的使用"></a>定时器的使用</h3><p>Qt中的定时器类是QTimer。QTimer不是一个可见的界面组件，在UI设计器的组件面板里找不到它。实例程序实现了一个计时器的功能，就是计算定时器开始到停止持续的时间长度，计时器是QTime类。</p>
<p>QTimer主要的属性是interval,是定时中断的周期，单位毫秒。QTimer主要的信号是timeout(),在定时中断时发射此信号，要想在定时中断里做出响应，这就需要编写timeout()信号的槽函数。<br><img data-src="https://xuemingde.com/pages/image/2022/12/01/205311MRWga8.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/205408gZ5kS3.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/205427dj3sov.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/01/210127f0loKk.png" alt=""></p>
<h2 id="QComboBox-QPlainTextEdit"><a href="#QComboBox-QPlainTextEdit" class="headerlink" title="QComboBox QPlainTextEdit"></a>QComboBox QPlainTextEdit</h2><p>QComboBox是下拉列表框组件类，它提供一个下拉列表供用户选择，也可以直接当作一个QLineEdit用作输入。QComboBox除了显示可见下拉列表外，每个项(item,或称列表项)还可以关联一个QVariant类型的变量，用于存储一些不可见数据。</p>
<p>QPlainTextEdit是一个多行文本编辑器，用于显示和编辑多行简单文本。</p>
<h3 id="QComboBox"><a href="#QComboBox" class="headerlink" title="QComboBox"></a>QComboBox</h3><p>添加具有用户数据的项</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ui-&gt;comboBox-&gt;addItem(<span class="string">&quot;tes&quot;</span>,<span class="string">&quot;200&quot;</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QString zone = ui-&gt;comboBox-&gt;currentData().toString();</span><br></pre></td></tr></table></figure>
<h3 id="QPlain-TextEdit的使用"><a href="#QPlain-TextEdit的使用" class="headerlink" title="QPlain TextEdit的使用"></a>QPlain TextEdit的使用</h3><p>QPlainTextEdit是用于编辑多行文本的编辑器，可以编辑普通文本。另外，还有一个QTextEdit组件，是一个所见即所得的可以编辑带格式文本的组件，以HTML格式标记符定义文本格式。<br>从前面的代码已经看出，使用QPlainTextEdit:appendPlainText((const QString&amp;text)函数就可以向PlainTextEdit组件添加一行字符串。</p>
<p>QPlainTextEdit提供cutO、copy()、paste()、undo()、redo()、clear()、selectAllO等标准编辑功能的槽函数，QPlainTextEdit还提供一个标准的右键快捷菜单。</p>
<p>但是如果要逐行读取QPlainTextEdit组件里的字符串，则稍微麻烦一点。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/02/105305da3lcO.png" alt=""></p>
<h3 id="创建右键快捷菜单"><a href="#创建右键快捷菜单" class="headerlink" title="创建右键快捷菜单"></a>创建右键快捷菜单</h3><ol>
<li><p>创建Action</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/02/165916Oj3Nda.png" alt=""></p>
</li>
<li><p>添加QListWidget</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/02/170041ae0Spo.png" alt=""></p>
</li>
<li><p>QListWidget 转到槽</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/02/170204PJ6LAs.png" alt=""></p>
</li>
<li><p>添加代码</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/02/170302eJKuPJ.png" alt=""></p>
</li>
<li><p>效果</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/02/170325HAS886.png" alt=""></p>
</li>
</ol>
<h3 id="工具栏显式图片和文字"><a href="#工具栏显式图片和文字" class="headerlink" title="工具栏显式图片和文字"></a>工具栏显式图片和文字</h3><p><img data-src="https://xuemingde.com/pages/image/2022/12/05/102701OwKG3n.png" alt=""></p>
<h3 id="QTableWidget操作"><a href="#QTableWidget操作" class="headerlink" title="QTableWidget操作"></a>QTableWidget操作</h3><ul>
<li><p>设置表头</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/06/133950IenYkB.png" alt=""></p>
<p>​</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QTableWidgetItem *headerItem;</span><br><span class="line">    QStringList headerText;</span><br><span class="line">    headerText &lt;&lt; <span class="string">&quot;姓名&quot;</span> &lt;&lt; <span class="string">&quot;性别&quot;</span> &lt;&lt; <span class="string">&quot;出生日期&quot;</span> &lt;&lt; <span class="string">&quot;民族&quot;</span> &lt;&lt; <span class="string">&quot;分数&quot;</span> &lt;&lt; <span class="string">&quot;是否党员&quot;</span>;</span><br><span class="line">    ui-&gt;tableInfo-&gt;setColumnCount(headerText.count());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; ui-&gt;tableInfo-&gt;columnCount(); i++) &#123;</span><br><span class="line">        headerItem = <span class="keyword">new</span> QTableWidgetItem(headerText.at(i));</span><br><span class="line">        QFont font = headerItem-&gt;font();</span><br><span class="line">        font.setBold(<span class="literal">true</span>);</span><br><span class="line">        font.setPointSize(<span class="number">12</span>);</span><br><span class="line">        headerItem-&gt;setForeground(Qt::red);</span><br><span class="line">        headerItem-&gt;setFont(font);</span><br><span class="line">        ui-&gt;tableInfo-&gt;setHorizontalHeaderItem(i,headerItem);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/06/134124PDZAx7.png" alt=""></p>
<ul>
<li><p>初始化表格数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化表格数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::on_butIniData_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString strName,strSex;</span><br><span class="line">    <span class="keyword">bool</span> isParty = <span class="literal">false</span>;</span><br><span class="line">    QDate birth;</span><br><span class="line">    birth.setDate(<span class="number">1980</span>,<span class="number">3</span>,<span class="number">6</span>);</span><br><span class="line">    <span class="comment">//清除表格数据区的所有内容，但是不清除表头</span></span><br><span class="line">    ui-&gt;tableInfo-&gt;clearContents();</span><br><span class="line">    <span class="comment">//返回表格数据区的行数</span></span><br><span class="line">    <span class="keyword">int</span> Rows = ui-&gt;tableInfo-&gt;rowCount();</span><br><span class="line">    qDebug() &lt;&lt; Rows;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; Rows; i++) &#123;</span><br><span class="line">        strName = QString::asprintf(<span class="string">&quot;学生%d&quot;</span>,i);</span><br><span class="line">        <span class="keyword">if</span>((i % <span class="number">2</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            strSex = <span class="string">&quot;男&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">           strSex = <span class="string">&quot;女&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        createItemsARow(i,strName,strSex,birth,<span class="string">&quot;汉族&quot;</span>,isParty,<span class="number">70</span>);</span><br><span class="line">        birth = birth.addDays(<span class="number">20</span>);</span><br><span class="line">        isParty = !isParty;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::createItemsARow</span><span class="params">(<span class="keyword">int</span> rowNo, QString Name, QString Sex, QDate birth, QString Nation, <span class="keyword">bool</span> isPM, <span class="keyword">int</span> score)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    QTableWidgetItem *item;</span><br><span class="line">    QString str;</span><br><span class="line">    uint StudID = <span class="number">2022120600</span>;</span><br><span class="line">    <span class="comment">//姓名</span></span><br><span class="line">    item = <span class="keyword">new</span> QTableWidgetItem(Name,MainWindow::ctName);</span><br><span class="line">    item-&gt;setTextAlignment(Qt::AlignHCenter | Qt::AlignVCenter);</span><br><span class="line">    StudID += rowNo;</span><br><span class="line">    item-&gt;setData(Qt::UserRole,QVariant(StudID));</span><br><span class="line">    ui-&gt;tableInfo-&gt;setItem(rowNo,MainWindow::colName,item);</span><br><span class="line">    <span class="comment">//性别</span></span><br><span class="line">    QIcon icon;</span><br><span class="line">    <span class="keyword">if</span>(Sex == <span class="string">&quot;男&quot;</span>)&#123;</span><br><span class="line">        icon.addFile(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        icon.addFile(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    item = <span class="keyword">new</span> QTableWidgetItem(Sex,MainWindow::ctSex);</span><br><span class="line">    item-&gt;setIcon(icon);</span><br><span class="line">    item-&gt;setTextAlignment(Qt::AlignHCenter | Qt::AlignVCenter);</span><br><span class="line">    ui-&gt;tableInfo-&gt;setItem(rowNo,MainWindow::colSex,item);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//出生日期</span></span><br><span class="line">    str = birth.toString(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">    item = <span class="keyword">new</span> QTableWidgetItem(str,MainWindow::ctBirth);</span><br><span class="line">    item-&gt;setTextAlignment(Qt::AlignLeft | Qt::AlignVCenter);</span><br><span class="line">    ui-&gt;tableInfo-&gt;setItem(rowNo,MainWindow::colBirth,item);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//民族</span></span><br><span class="line">    item = <span class="keyword">new</span> QTableWidgetItem(Nation,MainWindow::ctNation);</span><br><span class="line">    item-&gt;setTextAlignment(Qt::AlignHCenter | Qt::AlignVCenter);</span><br><span class="line">    ui-&gt;tableInfo-&gt;setItem(rowNo,MainWindow::colNation,item);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否是党员</span></span><br><span class="line">    item = <span class="keyword">new</span> QTableWidgetItem(<span class="string">&quot;党员&quot;</span>,MainWindow::ctPartyM);</span><br><span class="line">    item-&gt;setTextAlignment(Qt::AlignHCenter | Qt::AlignVCenter);</span><br><span class="line">    <span class="keyword">if</span>(isPM)&#123;</span><br><span class="line">        item-&gt;setCheckState(Qt::Checked);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        item-&gt;setCheckState(Qt::Unchecked);</span><br><span class="line">    &#125;</span><br><span class="line">    item-&gt;setBackground(Qt::yellow);</span><br><span class="line">    ui-&gt;tableInfo-&gt;setItem(rowNo,MainWindow::colPartyM,item);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分数</span></span><br><span class="line">    str.setNum(score);</span><br><span class="line">    item = <span class="keyword">new</span> QTableWidgetItem(str,MainWindow::ctScore);</span><br><span class="line">    item-&gt;setTextAlignment(Qt::AlignHCenter | Qt::AlignVCenter);</span><br><span class="line">    ui-&gt;tableInfo-&gt;setItem(rowNo,MainWindow::colScore,item);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/06/155427Vlg29m.png" alt=""></p>
</li>
<li><p>获得当前单元格数据</p>
<p><img data-src="https://files.catbox.moe/j6h3sk.png" alt=""></p>
</li>
</ul>
<p><img data-src="https://files.catbox.moe/3q8up5.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::on_tableInfo_currentCellChanged</span><span class="params">(<span class="keyword">int</span> currentRow, <span class="keyword">int</span> currentColumn, <span class="keyword">int</span> previousRow, <span class="keyword">int</span> previousColumn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   QTableWidgetItem *item = ui-&gt;tableInfo-&gt;item(currentRow,currentColumn);</span><br><span class="line">   <span class="keyword">if</span>(item == <span class="literal">NULL</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   labCellIndex-&gt;setText(QString::asprintf(<span class="string">&quot;当前单元格坐标：%d行，%d列&quot;</span>,currentRow,currentColumn));</span><br><span class="line">   <span class="keyword">int</span> cellType = item-&gt;type();</span><br><span class="line">   labCellType-&gt;setText(QString::asprintf(<span class="string">&quot;当前单元格类型：%d&quot;</span>,cellType));</span><br><span class="line">   item = ui-&gt;tableInfo-&gt;item(currentRow,MainWindow::colName);</span><br><span class="line">   <span class="keyword">int</span> ID = item-&gt;data(Qt::UserRole).toInt();</span><br><span class="line">   labStudID-&gt;setText(QString::asprintf(<span class="string">&quot;学生ID：%d&quot;</span>,ID));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://files.catbox.moe/ys8bps.png" alt=""></p>
<ul>
<li><p>插入、添加、删除行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::on_btnInsertRow_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> curRow = ui-&gt;tableInfo-&gt;currentRow();</span><br><span class="line">    ui-&gt;tableInfo-&gt;insertRow(curRow);</span><br><span class="line">    createItemsARow(curRow,<span class="string">&quot;新生&quot;</span>,<span class="string">&quot;男&quot;</span>,QDate::fromString(<span class="string">&quot;1992-2-2&quot;</span>,<span class="string">&quot;yyyy-M-d&quot;</span>),<span class="string">&quot;苗族&quot;</span>,<span class="literal">true</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::on_btnAppendRow_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> curRow = ui-&gt;tableInfo-&gt;rowCount();</span><br><span class="line">    ui-&gt;tableInfo-&gt;insertRow(curRow);</span><br><span class="line">    createItemsARow(curRow,<span class="string">&quot;新生&quot;</span>,<span class="string">&quot;女&quot;</span>,QDate::fromString(<span class="string">&quot;1994-2-3&quot;</span>,<span class="string">&quot;yyyy-M-d&quot;</span>),<span class="string">&quot;满族&quot;</span>,<span class="literal">true</span>,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除当前行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::on_btnDelCurRow_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> curRow = ui-&gt;tableInfo-&gt;currentRow();</span><br><span class="line">    ui-&gt;tableInfo-&gt;removeRow(curRow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自动调整行高和列宽</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::on_autoAdRowH_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = ui-&gt;tableInfo-&gt;currentRow();</span><br><span class="line">    qDebug() &lt;&lt; row;</span><br><span class="line">    <span class="keyword">if</span>(row == <span class="number">-1</span>)&#123;</span><br><span class="line">        ui-&gt;tableInfo-&gt;resizeRowsToContents();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (row &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">        ui-&gt;tableInfo-&gt;resizeRowToContents(row);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::on_autoAdColH_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = ui-&gt;tableInfo-&gt;currentRow();</span><br><span class="line">    <span class="keyword">if</span>(row == <span class="number">-1</span>)&#123;</span><br><span class="line">        ui-&gt;tableInfo-&gt;resizeColumnsToContents();</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (row &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">        ui-&gt;tableInfo-&gt;resizeColumnToContents(row);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/06/165854ahJWW2.png" alt=""></p>
</li>
<li><p>其他属性</p>
<ul>
<li><p>设置表格内容是否可编辑</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/06/170057e4aLh4.png" alt=""></p>
</li>
<li><p>设置行表头、列表头是否显示</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/06/170201islhNr.png" alt=""></p>
</li>
<li><p>间隔行底色</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/06/170239m5aLVn.png" alt=""></p>
</li>
<li><p>选择模式</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/06/1703151wctFZ.png" alt=""></p>
</li>
</ul>
</li>
<li><p>遍历表格读取数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::on_btnReadToEdit_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString str;</span><br><span class="line">    QTableWidgetItem *cellItem;</span><br><span class="line">    ui-&gt;textEdit-&gt;clear();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; ui-&gt;tableInfo-&gt;rowCount();i++) &#123;</span><br><span class="line">        str = QString::asprintf(<span class="string">&quot;第 %d 行&quot;</span>,i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; ui-&gt;tableInfo-&gt;columnCount() <span class="number">-1</span>; j++) &#123;</span><br><span class="line">            cellItem = ui-&gt;tableInfo-&gt;item(i,j);</span><br><span class="line">            str = str + cellItem-&gt;text() + <span class="string">&quot;  &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cellItem = ui-&gt;tableInfo-&gt;item(i,colPartyM);</span><br><span class="line">        <span class="keyword">if</span>(cellItem-&gt;checkState() == Qt::Checked)&#123;</span><br><span class="line">            str = str + <span class="string">&quot;党员&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            str = str + <span class="string">&quot;群众&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ui-&gt;textEdit-&gt;appendPlainText(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>bug</tag>
        <tag>const</tag>
        <tag>函数</tag>
        <tag>C++</tag>
        <tag>变量</tag>
        <tag>Qt</tag>
        <tag>Widget</tag>
        <tag>QTableWidget</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt基础学习笔记03</title>
    <url>/posts/C8CVJR.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p><strong>转载标注来源</strong></p>
</blockquote>
<h1 id="Model-View结构"><a href="#Model-View结构" class="headerlink" title="Model/View结构"></a>Model/View结构</h1><p>GUI应用程序的一个很重要的功能是由用户在界面上编辑和修改数据，典型的如数据库应用程序。数据库应用程序中，用户在界面上执行各种操作，实际上是修改了界面组件所关联的数据库内的数据。</p>
<p>将界面组件与所编辑的数据分离开来，又通过数据源的方式连接起来，是处理界面与数据的一种较好的方式。Qt使用Model/View结构来处理这种关系，Model/View的基本结构如下图：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/07/082402wojM1B.png" alt=""></p>
<ul>
<li>数据(Data)是实际的数据，如数据库的一个数据表或SQL查询结果，内存中的一个StringList,或磁盘文件结构等。</li>
<li>视图或视图组件(View)是屏幕上的界面组件，视图从数据模型获得每个数据项的模型索引(model index),通过模型索引获取数据，然后为界面组件提供显示数据。Qt提供一些现成的数据视图组件，如QListView、QTree View和QTable View等。</li>
<li>模型或数据模型(Modl)与实际数据通信，并为视图组件提供数据接口。它从原始数据提取需要的内容，用于视图组件进行显示和编辑。Q中有一些预定义的数据模型，如<br>QStringListModel可作为StringList的数据模型，QSqlTableModel可以作为数据库中一个数据表的数据模型。</li>
</ul>
<p>由于数据源与显示界面通过Mode/View结构分离开来，因此可以将一个数据模型在不同的视<br>图中显示，也可以在不修改数据模型的情况下，设计特殊的视图组件。</p>
<p>在Model/View结构中，还提供了代理(Delegate)功能，代理功能可以让用户定制数据的界面显示和编辑方式。在标准的视图组件中，代理功能显示一个数据，当数据被编辑时，代理通过模型索引与数据模型通信，并为编辑数据提供一个编辑器，一般是一个QLineEdit组件。</p>
<p>模型、视图和代理之间使用信号和槽通信。当源数据发生变化时，数据模型发射信号通知视<br>图组件：当用户在界面上操作数据时，视图组件发射信号表示这些操作信息：当编辑数据时，代理发射信号告知数据模型和视图组件编辑器的状态。</p>
<h2 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h2><p>所有的基于项数据(item data)的数据模型(Model)都是基于QAbstractItemModel类的，这个类定义了视图组件和代理存取数据的接口。数据无需存储在数据模型里，数据可以是其他类、文件、数据库或任何数据源。Qt中与数据模型相关的几个主要的类的层次结构如下图：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/07/0835352cqGoy.png" alt=""></p>
<p>抽象类是不能直接使用的，需要由子类继承来实现一些纯虚函数。Qt提供了一些模型类用于项数据处理</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/07/083834yEqMCj.png" alt=""></p>
<h2 id="视图组件"><a href="#视图组件" class="headerlink" title="视图组件"></a>视图组件</h2><p>视图组件(Viw)就是显示数据模型的数据的界面组件，Qt提供的视图组件如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/07/085954mU2zht.png" alt=""></p>
<p>视图组件在显示数据时，只需调用视图类的setModelO)函数，为视图组件设置一个数据模型就可以实现视图组件与数据模型之间的关联，在视图组件上的修改将自动保存到关联的数据模型    里，一个数据模型可以同时在多个视图组件里显示数据。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/07/093401rPeKsF.png" alt=""></p>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p><img data-src="https://xuemingde.com/pages/image/2022/12/07/095156feona9.png" alt=""></p>
<h2 id="Model-View结构的一些概念"><a href="#Model-View结构的一些概念" class="headerlink" title="Model/View结构的一些概念"></a>Model/View结构的一些概念</h2><ul>
<li><p>Model/View的基本结构</p>
<p>在Model/View结构中，数据模型为视图组件和代理提供存取数据的标准接口。在Qt中，所有的数据模型类都从QAbstractItemModel继承而来，不管底层的数据结构是如何组织数据的，QAbstractItemModel的子类都以表格的层次结构表示数据，视图组件通过这种规则来存取模型中的数据，但是表现给用户的形式不一样。</p>
<p>不管数据模型的表现形式是怎么样的，数据模型中存储数据的基本单元都是项(item),每个项有一个行号、一个列号，还有一个父项(parent item)。在列表和表格模式下，所有的项都有一个相同的顶层项(root item):在树状结构中，行号、列号、父项稍微复杂一点，但是由这3个参数完全可以定义一个项的位置，从而存取项的数据。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/07/102147PnzkHH.png" alt="数据模型的几种表现形式"></p>
</li>
</ul>
<ul>
<li><p>模型索引</p>
<p>为了保证数据的表示与数据存取方式隔离，数据模型中引入了模型索引(model index)的概念。通过数据模型存取的每个数据都有一个模型索引，视图组件和代理都通过模型索引来获<br>取数据。<br>QModelIndex表示模型索引的类。模型索引提供数据存取的一个临时指针，用于通过数据模型提取或修改数据。因为模型内部组织数据的结构随时可能改变，所以模型索引是临时的。如果需要使用持久性的模型索引，则要使用QPersistentModelIndex类。</p>
</li>
<li><p>行号和列号</p>
<p>数据模型的基本形式是用行和列定义的表格数据，但这并不意味着底层的数据是用二维数组存储的，使用行和列只是为了组件之间交互方便的一种规定。通过模型索引的行号和列号就可以存取数据。<br>要获得一个模型索引，必须提供3个参数：行号、列号、父项的模型索引。例如，对于如上图中的表格数据模型中的3个数据项A、B、C,获取其模型索引的代码是：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/07/102729JGl4Sy.png" alt=""></p>
<p>在创建模型索引的函数中需要传递行号、列号和父项的模型索引。对于列表和表格模式的数据模型，顶层节点总是用QModelIndex()表示。</p>
</li>
<li><p>父项</p>
<p>当数据模型是列表或表格时，使用行号、列号存储数据比较直观，所有数据项的父项(parent itm)就是顶层项：当数据模型是树状结构时，情况比较复杂（树状结构中，项一般习惯于称为节点)，一个节点可以有父节点，也可以是其他节点的父节点，在构造数据项的模型索引时，必须指定正确的行号、列号和父节点。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/07/102908jnDyQG.png" alt=""></p>
</li>
<li><p>项的角色</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/07/1031319WqTac.png" alt=""></p>
</li>
</ul>
<h1 id="QFileSystemModel"><a href="#QFileSystemModel" class="headerlink" title="QFileSystemModel"></a>QFileSystemModel</h1><h2 id="QFileSystemModel类的基本功能"><a href="#QFileSystemModel类的基本功能" class="headerlink" title="QFileSystemModel类的基本功能"></a>QFileSystemModel类的基本功能</h2><p><img data-src="https://xuemingde.com/pages/image/2022/12/09/100420SVKram.png" alt=""></p>
<p>这里还有另一种写法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">connect(ui-&gt;treeView,&amp;QTreeView::clicked,[=]()&#123;</span><br><span class="line">        ui-&gt;listView-&gt;setRootIndex(ui-&gt;treeView-&gt;currentIndex());</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/09/101417A0rxzX.png" alt=""></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::on_treeView_clicked</span><span class="params">(<span class="keyword">const</span> QModelIndex &amp;index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ui-&gt;chkIsDir-&gt;setChecked(model-&gt;isDir(index));</span><br><span class="line">    ui-&gt;LabPath-&gt;setText(model-&gt;filePath(index));</span><br><span class="line">    ui-&gt;LabType-&gt;setText(model-&gt;type(index));</span><br><span class="line">    ui-&gt;LabFileName-&gt;setText(model-&gt;fileName(index));</span><br><span class="line">    <span class="keyword">int</span> sz = model-&gt;size(index) / <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">if</span>(sz &lt; <span class="number">1024</span>)&#123;</span><br><span class="line">        ui-&gt;LabFileSize-&gt;setText(QString(<span class="string">&quot;%1 KB&quot;</span>).arg(sz));</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        ui-&gt;LabFileSize-&gt;setText(QString::asprintf(<span class="string">&quot;%.1f MB&quot;</span>,sz / <span class="number">1024.0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/09/103249D16Bsq.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/09/105740C8J2Dy.png" alt=""></p>
<h1 id="QStringListModel"><a href="#QStringListModel" class="headerlink" title="QStringListModel"></a>QStringListModel</h1><p><img data-src="https://xuemingde.com/pages/image/2022/12/09/183521tBWnRT.png" alt=""></p>
<p>效果：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/09/183545q9rSK8.png" alt=""></p>
<ul>
<li><p>编辑、添加、删除项的操作</p>
<ul>
<li><p>编辑</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ui-&gt;listView-&gt;setEditTriggers(QAbstractItemView::DoubleClicked | QAbstractItemView::SelectedClicked);<span class="comment">// 表示在双击，或选择并单击列表项后，就进入编辑状态。</span></span><br><span class="line"><span class="comment">//setEditTrigger函数设置QListView是否可编辑，以及进入编辑状态。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//若要设置为不可编辑，则可以设置为：</span></span><br><span class="line">ui-&gt;listView-&gt;setEditTriggers(QAbstractItemView::NoEditTriggers);</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>添加项</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Widget::on_btnListAppend_clicked</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    theModel-&gt;insertRow(theModel-&gt;rowCount());</span><br><span class="line">    QModelIndex index = theModel-&gt;index(theModel-&gt;rowCount() - <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    theModel-&gt;setData(index,<span class="string">&quot;new item&quot;</span>,Qt::DisplayRole);</span><br><span class="line">    ui-&gt;listView-&gt;setCurrentIndex(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/12/110212zDyJkZ.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/12/110242eck0hT.png" alt=""></p>
</li>
<li><p>插入项</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/12/110648qdrVQ0.png" alt=""></p>
</li>
<li><p>删除当前项</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/12/111038azaY5z.png" alt="3"></p>
</li>
<li><p>删除列表</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/12/1110540PKO6q.png" alt=""></p>
</li>
</ul>
</li>
</ul>
<h1 id="QStandardItemModel"><a href="#QStandardItemModel" class="headerlink" title="QStandardItemModel"></a>QStandardItemModel</h1><p><img data-src="https://xuemingde.com/pages/image/2022/12/12/112938j6j7Og.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/12/113039bAKVg1.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/12/113054sNjWey.png" alt=""></p>
<h2 id="界面设计与主窗口类定义"><a href="#界面设计与主窗口类定义" class="headerlink" title="界面设计与主窗口类定义"></a>界面设计与主窗口类定义</h2><p><img data-src="https://xuemingde.com/pages/image/2022/12/12/142405JugDU5.png" alt=""></p>
<h2 id="QStandardItemModel的使用"><a href="#QStandardItemModel的使用" class="headerlink" title="QStandardItemModel的使用"></a>QStandardItemModel的使用</h2><ul>
<li><p>从文本文件导入数据</p>
<p>QStandardltemModel 是标准的基于项数据的数据模型，以类似于二维数组的形式管理内部数据，适合于处理表格型数据，其显示一般采用QTableView。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MainWindow::MainWindow(QWidget *parent)</span><br><span class="line">    : QMainWindow(parent)</span><br><span class="line">    , ui(<span class="keyword">new</span> Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(<span class="keyword">this</span>);</span><br><span class="line">    setCentralWidget(ui-&gt;splitter);</span><br><span class="line">    theModel = <span class="keyword">new</span> QStandardItemModel(<span class="number">1</span>,FixedColumuCount,<span class="keyword">this</span>); <span class="comment">// 数据模型</span></span><br><span class="line">    theSelection = <span class="keyword">new</span> QItemSelectionModel(theModel);</span><br><span class="line">    connect(ui-&gt;tableView,&amp;QTableView::clicked,[=]()&#123;</span><br><span class="line">       QModelIndex curindex = theSelection-&gt;currentIndex();</span><br><span class="line">       on_currentChanged(curindex);</span><br><span class="line">    &#125;);</span><br><span class="line">    ui-&gt;tableView-&gt;setModel(theModel);</span><br><span class="line">    ui-&gt;tableView-&gt;setSelectionModel(theSelection);</span><br><span class="line">    ui-&gt;tableView-&gt;setSelectionMode(QAbstractItemView::ExtendedSelection);</span><br><span class="line">    ui-&gt;tableView-&gt;setSelectionBehavior(QAbstractItemView::SelectItems);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~MainWindow()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ui;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::on_currentChanged</span><span class="params">(<span class="keyword">const</span> QModelIndex &amp;current)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(current.isValid())&#123;</span><br><span class="line">        ui-&gt;labCellPos-&gt;setText(QString::asprintf(<span class="string">&quot;当前单元格：%d行，%d列&quot;</span>,current.row() + <span class="number">1</span>,current.column()+ <span class="number">1</span>));</span><br><span class="line">        QStandardItem *aItem = theModel-&gt;itemFromIndex(current);</span><br><span class="line">        ui-&gt;labCellText-&gt;setText(<span class="string">&quot;单元格内容：&quot;</span> + aItem-&gt;text());</span><br><span class="line">        QFont font = aItem-&gt;font();</span><br><span class="line">        ui-&gt;actFontBold-&gt;setChecked(font.bold());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::on_actOpen_triggered</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString curPath = QCoreApplication::applicationDirPath();</span><br><span class="line">    QString aFileName = QFileDialog::getOpenFileName(<span class="keyword">this</span>,<span class="string">&quot;打开一个文件&quot;</span>,curPath,<span class="string">&quot;井数据文件(*.txt);;所有文件(*.*)&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(aFileName.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QStringList fFileCoentent;</span><br><span class="line">    <span class="function">QFile <span class="title">aFile</span><span class="params">(aFileName)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(aFile.open(QIODevice::ReadOnly | QIODevice::Text))&#123;</span><br><span class="line">        <span class="function">QTextStream <span class="title">aStream</span><span class="params">(&amp;aFile)</span></span>;</span><br><span class="line">        ui-&gt;plainTextEdit-&gt;clear();</span><br><span class="line">        <span class="keyword">while</span> (!aStream.atEnd()) &#123;</span><br><span class="line">            QString str = aStream.readLine();</span><br><span class="line">            ui-&gt;plainTextEdit-&gt;appendPlainText(str);</span><br><span class="line">            fFileCoentent.append(str);</span><br><span class="line">        &#125;</span><br><span class="line">        aFile.close();</span><br><span class="line">        ui-&gt;labCurFile-&gt;setText(<span class="string">&quot;当前文件：&quot;</span> + aFileName);</span><br><span class="line">        iniModelFormStringList(fFileCoentent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::iniModelFormStringList</span><span class="params">(QStringList &amp; aFileCoentent)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rowCnt = aFileCoentent.count();</span><br><span class="line">    theModel-&gt;setRowCount(rowCnt - <span class="number">1</span>);</span><br><span class="line">    QString header = aFileCoentent.at(<span class="number">0</span>);</span><br><span class="line">    QStringList headerList = header.split(QRegExp(<span class="string">&quot;\\s+&quot;</span>),QString::SkipEmptyParts);</span><br><span class="line">    theModel-&gt;setHorizontalHeaderLabels(headerList);</span><br><span class="line"></span><br><span class="line">    QStandardItem *aItem;</span><br><span class="line">    QStringList tmpList;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; rowCnt; i++) &#123;</span><br><span class="line">        QString aLineText = aFileCoentent.at(i);</span><br><span class="line">        tmpList = aLineText.split(QRegExp(<span class="string">&quot;\\s+&quot;</span>),QString::SkipEmptyParts);</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>;j &lt; FixedColumuCount - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            aItem = <span class="keyword">new</span> QStandardItem(tmpList.at(j));</span><br><span class="line">            theModel-&gt;setItem(i - <span class="number">1</span>,j,aItem);</span><br><span class="line">        &#125;</span><br><span class="line">        aItem = <span class="keyword">new</span> QStandardItem(tmpList.at(j));</span><br><span class="line">        aItem-&gt;setCheckable(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span>(tmpList.at(j) == <span class="string">&quot;0&quot;</span>)&#123;</span><br><span class="line">            aItem-&gt;setCheckState(Qt::Unchecked);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            aItem-&gt;setCheckState(Qt::Checked);</span><br><span class="line">        &#125;</span><br><span class="line">        theModel-&gt;setItem(i - <span class="number">1</span>,j,aItem);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/13/103502Uu5L5a.png" alt=""></p>
<p><code>theModel-&gt;setHorizontalHeaderLabels(headerList);</code>函数：设置表头标题。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/13/110953kGYwSa.png" alt=""></p>
<ul>
<li><p>添加行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::on_actAppend_triggered</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QList&lt;QStandardItem*&gt; aItemList;</span><br><span class="line">    QStandardItem *aItem;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; FixedColumuCount - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        aItem = <span class="keyword">new</span> QStandardItem(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        aItemList &lt;&lt; aItem;</span><br><span class="line">    &#125;</span><br><span class="line">    QString str = theModel-&gt;headerData(theModel-&gt;columnCount() - <span class="number">1</span>,Qt::Horizontal,Qt::DisplayRole).toString();</span><br><span class="line">    aItem = <span class="keyword">new</span> QStandardItem(str);</span><br><span class="line">    aItem-&gt;setCheckable(<span class="literal">true</span>);</span><br><span class="line">    aItemList &lt;&lt; aItem;</span><br><span class="line"></span><br><span class="line">    theModel-&gt;insertRow(theModel-&gt;rowCount(), aItemList);</span><br><span class="line">    QModelIndex curindex = theModel-&gt;index(theModel-&gt;rowCount() - <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    theSelection-&gt;clearSelection();</span><br><span class="line">    theSelection-&gt;setCurrentIndex(curindex,QItemSelectionModel::Select);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/13/163228hEV094.png" alt=""></p>
</li>
<li><p>插入行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::on_actInsert_triggered</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QList&lt;QStandardItem*&gt; aItemList;</span><br><span class="line">    QStandardItem *aItem;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; FixedColumuCount - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        aItem = <span class="keyword">new</span> QStandardItem(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">        aItemList &lt;&lt; aItem;</span><br><span class="line">    &#125;</span><br><span class="line">    QString str = theModel-&gt;headerData(theModel-&gt;columnCount() - <span class="number">1</span>,Qt::Horizontal,Qt::DisplayRole).toString();</span><br><span class="line">    aItem = <span class="keyword">new</span> QStandardItem(str);</span><br><span class="line">    aItem-&gt;setCheckable(<span class="literal">true</span>);</span><br><span class="line">    aItemList &lt;&lt; aItem;</span><br><span class="line"></span><br><span class="line">    QModelIndex index = theSelection-&gt;currentIndex();</span><br><span class="line">    theModel-&gt;insertRow(index.row(), aItemList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>删除行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::on_actDelete_triggered</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QModelIndex curIndex = theSelection-&gt;currentIndex();</span><br><span class="line">    <span class="keyword">if</span>(curIndex.row() == theModel-&gt;rowCount() - <span class="number">1</span>)&#123;</span><br><span class="line">        theModel-&gt;removeRow(curIndex.row());<span class="comment">//删除最后一行</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        theModel-&gt;removeRow(curIndex.row());</span><br><span class="line">        <span class="comment">//当前选择行</span></span><br><span class="line">        theSelection-&gt;setCurrentIndex(curIndex,QItemSelectionModel::Select);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>单元格格式设置</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//左对齐</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::on_actAlignLeft_triggered</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!theSelection-&gt;hasSelection())&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QModelIndexList selectIndex = theSelection-&gt;selectedIndexes();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; selectIndex.count();i++) &#123;</span><br><span class="line">        QModelIndex aIndex = selectIndex.at(i);</span><br><span class="line">        QStandardItem *aItem = theModel-&gt;itemFromIndex(aIndex);</span><br><span class="line">        aItem-&gt;setTextAlignment(Qt::AlignLeft);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//加粗</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MainWindow::on_actFontBold_triggered</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!theSelection-&gt;hasSelection())&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    QModelIndexList selectIndex = theSelection-&gt;selectedIndexes();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; selectIndex.count();i++) &#123;</span><br><span class="line">        QModelIndex aIndex = selectIndex.at(i);</span><br><span class="line">        QStandardItem *aItem = theModel-&gt;itemFromIndex(aIndex);</span><br><span class="line">        QFont font = aItem-&gt;font();</span><br><span class="line">        font.setBold(<span class="literal">true</span>);</span><br><span class="line">        aItem-&gt;setFont(font);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据另存为文件</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">void MainWindow::on_actSave_triggered()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//保存为文件</span></span><br><span class="line">    QString curPath = QCoreApplication::applicationDirPath();</span><br><span class="line">    QString aFileName = QFileDialog::getSaveFileName(this,<span class="string">&quot;选择一个文件&quot;</span>,curPath,<span class="string">&quot;冰鞋数据文件(*.txt);;所有文件(*.*)&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(aFileName.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    QFile aFile(aFileName);</span><br><span class="line">    <span class="keyword">if</span>(!(aFile.open(QIODevice::ReadWrite | QIODevice::Text | QIODevice::Truncate)))&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    QTextStream aStream(&amp;aFile);</span><br><span class="line">    QStandardItem *aItem;</span><br><span class="line">    int i,j;</span><br><span class="line">    QString  <span class="built_in">str</span>;</span><br><span class="line">    ui-&gt;plainTextEdit-&gt;clear();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; theModel-&gt;columnCount();i++) &#123;</span><br><span class="line">        aItem = theModel-&gt;horizontalHeaderItem(i);</span><br><span class="line">        <span class="built_in">str</span> = <span class="built_in">str</span> + aItem-&gt;text() + <span class="string">&quot;\t\t&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    aStream &lt;&lt; <span class="built_in">str</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    ui-&gt;plainTextEdit-&gt;appendPlainText(<span class="built_in">str</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; theModel-&gt;rowCount();i++) &#123;</span><br><span class="line">        <span class="built_in">str</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>;j &lt; theModel-&gt;columnCount() - <span class="number">1</span>;j++) &#123;</span><br><span class="line">            aItem = theModel-&gt;item(i,j);</span><br><span class="line">            <span class="built_in">str</span> = <span class="built_in">str</span> + aItem-&gt;text() + QString::asprintf(<span class="string">&quot;\t\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        aItem = theModel-&gt;item(i,j);</span><br><span class="line">        <span class="keyword">if</span>(aItem-&gt;checkState() == Qt::Checked)&#123;</span><br><span class="line">            <span class="built_in">str</span> = <span class="built_in">str</span> + <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">str</span> = <span class="built_in">str</span> + <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ui-&gt;plainTextEdit-&gt;appendPlainText(<span class="built_in">str</span>);</span><br><span class="line">        aStream &lt;&lt; <span class="built_in">str</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="自定义代理"><a href="#自定义代理" class="headerlink" title="自定义代理"></a>自定义代理</h1><p><img data-src="https://xuemingde.com/pages/image/2022/12/14/104007KqpcoX.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/14/104626Yr83DR.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/14/112452vHeaH7.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/14/112532Z5XE0K.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/14/112547GUReEO.png" alt=""></p>
<h2 id="自定义代理类的使用"><a href="#自定义代理类的使用" class="headerlink" title="自定义代理类的使用"></a>自定义代理类的使用</h2><p><img data-src="https://xuemingde.com/pages/image/2022/12/14/112733txJk7V.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/14/112753FU4yNR.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/12/14/112824xZCIWr.png" alt=""></p>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>内存</tag>
        <tag>sql</tag>
        <tag>const</tag>
        <tag>数据库</tag>
        <tag>函数</tag>
        <tag>数组</tag>
        <tag>C++</tag>
        <tag>指针</tag>
        <tag>Qt</tag>
        <tag>索引</tag>
        <tag>Widget</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt基础学习笔记04</title>
    <url>/posts/23E5YZV.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li><p>qt中将Frame框设置成有颜色的边框</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">QFrame&#123;</span><br><span class="line"><span class="attribute">border-radius</span>:<span class="number">10px</span>;</span><br><span class="line"><span class="attribute">border</span>:<span class="number">1px</span> solid <span class="built_in">rgb</span>(<span class="number">100</span>, <span class="number">100</span>,<span class="number">189</span>)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
<li><p>Qt的LineEdit设置无边框</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">QLineEdit&#123;<span class="attribute">border</span>: none &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>​</p>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">QFrame&#123;<span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>);</span><br><span class="line">		<span class="attribute">border-image</span>:None;	</span><br><span class="line">		<span class="attribute">border-radius</span>:<span class="number">22px</span>;</span><br><span class="line">&#125;</span><br><span class="line">QPushButton&#123;</span><br><span class="line"><span class="attribute">border-image</span>:None;	</span><br><span class="line"> <span class="attribute">background-color</span>: white;</span><br><span class="line"> <span class="attribute">color</span>:black;</span><br><span class="line"> <span class="attribute">border-radius</span>:<span class="number">21px</span>;</span><br><span class="line"> <span class="attribute">font</span>: <span class="number">16px</span> <span class="string">&quot;阿里巴巴普惠体 R&quot;</span>;</span><br><span class="line"> <span class="attribute">text-align</span>: center; </span><br><span class="line"><span class="attribute">margin-top</span>:<span class="number">0px</span>;</span><br><span class="line"><span class="attribute">margin-left</span>: <span class="number">0px</span>;</span><br><span class="line">marigin-<span class="attribute">right</span>:<span class="number">0px</span>;</span><br><span class="line">&#125;</span><br><span class="line">QPushButton<span class="selector-pseudo">:checked</span>&#123;</span><br><span class="line"> <span class="attribute">background-color</span>: <span class="built_in">rgb</span>(<span class="number">102</span>, <span class="number">179</span>, <span class="number">225</span>);</span><br><span class="line"> <span class="attribute">color</span>:white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><p>Qt::FocusPolicy</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>  1、Qt::TabFocus：通过按下Tab键获取焦点（这时候鼠标点击获取不到焦点的）。</p>
<p>  2、Qt::ClickFocus：鼠标点击获取焦点。</p>
<p>  3、Qt::StrongFocus：通过Tab键和鼠标点击获取焦点。</p>
<p>  4、Qt::WheelFocus：通过Tab键、鼠标点击、鼠标滚轮按下获取焦点。</p>
<p>  5、Qt::NoFocus：不接受焦点。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* acceptDrops</span><br><span class="line"></span><br><span class="line">&gt; acceptDrops属性表示当前部件是否接受鼠标拖放事件，鼠标拖放应该是与鼠标拖拽结合在一起的，在Qt Designer中可以通过属性acceptDrops设置部件是否接受鼠标拖放事件。如果部件接受拖放，则在鼠标拖放时，拖放事件会发送给鼠标当前光标下接受拖放的第一个部件。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 如果一个部件设置了acceptDrops属性为True，则就是通知系统该部件可能接受鼠标拖放事件。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 注意：</span><br><span class="line">&gt; 1、如果当前部件是一个桌面(windowType() &#x3D;&#x3D; Qt.Desktop), 如果此时另一应用正在使用桌面则这个属性设置可能失败；</span><br><span class="line">&gt; 2、不要在拖、放事件的处理方法中修改该属性。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 使用acceptDrops(）获取当前部件是否支持拖放；</span><br><span class="line">&gt; 使用setAcceptDrops(bool on)设置当前部件是否支持拖放。</span><br><span class="line">&gt; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* QPushButton</span><br><span class="line"></span><br><span class="line">  flat属性用于确认按钮边框是否凸起，如果为False则凸起，如果为True则边框与背景是平坦的。</span><br><span class="line"></span><br><span class="line">  (1) default属性表示当在对话框中时有“Enter”键按下时执行此按键的click()事件。它的默认值是false；</span><br><span class="line"></span><br><span class="line">  (2)autoDefault属性设置为true时会影响按键的外观（略微突出显大），它的默认值是true。</span><br><span class="line"></span><br><span class="line">  ​</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QFrame&#123;</span><br><span class="line"></span><br><span class="line">border-radius:10px;</span><br><span class="line"></span><br><span class="line">border:1px solid rgb(119, 119,119)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>QSqlTableModel</p>
<p><img data-src="https://xuemingde.com/pages/image/2023/02/07/150127NvND4X.png" alt="150127NvND4X"></p>
<p>​</p>
</li>
</ul>
]]></content>
      <categories>
        <category>嵌入式</category>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>sql</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的事务隔离级别有哪些</title>
    <url>/posts/Y4WPCX.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><div style="text-align: center;"></div><br><span id="more"></span></p>
<p>MYSQL有四大隔离级别，分别是：读未提交，读已提交，可重复读，串行化。</p>
<p>读未提交，就是在并发情况下，A事务读到了B事务未提交的数据，如果B事务最终回滚操作，事务A读取的数据就是错乱的，而且很难追踪，则会产生脏读的现象。读未提交是限制性最弱的隔离级别，带来的问题也最多，也有可能产生不可重复读和幻读的问题，所以很少实际应用。</p>
<p>读已提交，就是一个事务读取到的数据是其他事务已经提交的数据，此隔离级别虽然解决了脏读的问题，但是有不可重复的问题存在。</p>
<p>不可重复读，就是在并发情况下，A事务首次读取到的数据为1，未提交，接着B事务把数据1改为了2，并提交了事务，接着A事务再次读取数据，数据就变成了2，这种想象就是不可重复读问题。</p>
<p>可重复读，根据名字就能知道，他的出现解决了不可重复读的问题，是mysql的InnoDB存储引擎下的默认隔离级别。他虽然解决了脏读和不可重复读的问题，但还是会有幻读的问题存在。</p>
<p>可重复读是如何解决不可重复读的问题呢？是通过MVCC解决的。</p>
<p>MVCC主要是通过undo log和read view来实现。在MySQL中，在表的每一条数据后面都隐藏着几个字段：一个是事务ID，记录最近操作这条数据的事务ID；一个是回滚指针，指向这条数据的上一个版本，如果是新插入的数据，此记录为空；还一个是隐含的自增ID，当数据表没有设置主键和没有字段的值是唯一记录时，mysql会采用这个隐含的自增ID作为主键。</p>
<p>undo log，也被称为回滚日志，用于记录数据被修改前的信息。作用是记录回滚信息和快照读。如果一个事务是插入新记录，产生的undo log只在事务回滚时需要，在事务提交后可以被立即丢弃；如果一个事务是修改或者删除，产生的undo log不仅会在回滚时需要，在快照读的时候也需要，所以不能轻易被删除，只有在快照读和回滚时不涉及该日志时，就会被purge线程清理。在undo 日志中，会将一条数据不同的版本根据回滚指针串联起来，形成一个链表。</p>
<p>read view，就是事务进行快照读操作时产生的读视图。RC级别下，同一事务里，每次查询都会产生一个新的视图，这样很有可能造成在同一个事务里前后读取到的数据不一致的问题，RR级别下，同一事务下，只会获取一次视图，之后的同样查询会沿用此视图，从而保证了数据都是一样的。read view 遵循一个可见性算法来做判断，判断当前事务可见哪些版本的数据。可以先来了解read view的几个属性：一个是m_ids，是一个List数据结构，用来存放当前系统中所有活跃的读写事务ID；一个是min_limit_id，指的是当前系统中所有活跃的读写事务ID中最小的事务ID；一个是max_limit_id，指的是当前系统中所有活跃的读写事务ID中最大的事务ID；一个是creator_trx_id，指的是创建当前视图的事务ID。</p>
<p>readview大概的算法流程：</p>
<p>如果数据的事务ID &lt; 最小的活跃事务ID，说明该版本数据是在生成视图前生成的，并已经提交，该版本数据会被当前事务访问（对当前事务不可见）。</p>
<p>如果数据的事务ID &gt; 会等于最大的活跃事务ID，说明该版本数据是在生成视图后生成的，该版本数据不会被当前事务访问（对当前事务不可见）。</p>
<p>如果    最小的活跃事务ID &lt;=  数据的事务ID  &lt;= 最大的活跃事务ID，这种情况下，有三种情况：</p>
<ol>
<li><p>如果所有的活跃事务ID中包含这个数据的事务ID，说明读视图生产的时候，这个数据事务还没有提交，但是如果这个数据的事务ID等于创建这个读视图的事务ID，说明这个数据时自己生产的，因此可见。</p>
</li>
<li><p>如果所有的活跃事务ID中包含这个数据的事务ID，但这个数据的事务ID不等于创建视图事务的ID，视图生产时这个数据的事务还没有提交，不是自己生产的，所以这个数据对于当前的事务是不可见的。</p>
</li>
<li><p>如果所有的活跃事务ID中不包含这个数据的事务ID，说明这个数据的事务是在视图生产前就已经提交了，此数据是对当前事务可见的。</p>
</li>
</ol>
<p>根据这个算法获取到快照读的可见数据。</p>
<p>这里借鉴<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NuYWlsTWFubi9hcnRpY2xlL2RldGFpbHMvOTQ3MjQxOTc=">@SnailMann <i class="fa fa-external-link-alt"></i></span> 的一张流程图：</p>
<p><img data-src="https://xuemingde.com/pages/image/others/MnGVLF.jpg" alt="MnGVLF"></p>
<p>幻读，就是A事务读取表中某字段小于5的数据为3条，该事务没有提交，此时，B事务插入了一条符合A事务的查询条件的数据，并且提交了事务，A事务再次查询时会得到4条。这种情况在没有使用MVCC时会发生，如果使用了MVCC就不会发生。如果B事务提交后，A事务更新了该字段所有小于5的数据操作，之后再去获取该字段小于5的数据，还是会得到4条，所以，幻读问题又发生了。</p>
<p>MVCC没有彻底解决掉脏读的问题，只有当前操作都是快照读时，才不会产生幻读的问题，如果既有快照读又有当前读，就会有幻读的问题。</p>
<p>MVCC解决了快照读情况下的幻读问题，却没有解决当前读情况下的幻读问题。</p>
<p>RR级别下的当前读情况下如何解幻读？加锁！</p>
<p>next-key 锁由两部分：行锁和间隙锁。例如行锁要锁住id=5的行，前一个值是id=1的行，name该行对应的间隙锁就是(1,5]，在RR级别下，默认的加锁类型就是next-key，以此来防止当前读情况下导致幻读的问题。但是也带来了性能上的问题。</p>
<p>可串行化是最高的隔离级别，同时代价也是最大的，性能会很低，一般很少用。在该级别下事务是按照顺序执行的，所以避免的脏读、不可重复读和幻读的问题。因为该级别锁定的是整个范围的键，并一直持有本锁，知道事务完成。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>sql</tag>
        <tag>事务</tag>
        <tag>指针</tag>
        <tag>Mysql</tag>
        <tag>锁</tag>
        <tag>并发</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql复制插入数据</title>
    <url>/posts/1H0J6ZZ.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><div style="text-align: center;"></div><br><span id="more"></span></p>
<h2 id="新建表"><a href="#新建表" class="headerlink" title="新建表"></a>新建表</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `age` <span class="type">int</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>主键设为自增</p>
<h2 id="创建两条数据"><a href="#创建两条数据" class="headerlink" title="创建两条数据"></a>创建两条数据</h2></blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t <span class="keyword">VALUES</span> (<span class="keyword">null</span>,<span class="number">30</span>, <span class="string">&#x27;c&#x27;</span>),(<span class="keyword">null</span>,<span class="number">22</span>, <span class="string">&#x27;d&#x27;</span>); </span><br></pre></td></tr></table></figure>
<h2 id="复制插入"><a href="#复制插入" class="headerlink" title="复制插入"></a>复制插入</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t </span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">null</span>,age,name</span><br><span class="line"><span class="keyword">FROM</span> t</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	age <span class="operator">&gt;</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p> <img data-src="https://xuemingde.com/pages/image/others/pIBzxW.png" alt="pIBzxW"></p>
<h2 id="ID为UUID时。"><a href="#ID为UUID时。" class="headerlink" title="ID为UUID时。"></a>ID为UUID时。</h2><p>可用 REPLACE 函数将字符串中的某个字符替换即可。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t </span><br><span class="line"><span class="keyword">SELECT</span> REPLACE(id,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>),age,name</span><br><span class="line"><span class="keyword">FROM</span> t</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">	age <span class="operator">&gt;</span> <span class="number">1</span>;  </span><br></pre></td></tr></table></figure>
<p>将ID中的a替换成b  </p>
<h2 id="返回值时间加1个月"><a href="#返回值时间加1个月" class="headerlink" title="返回值时间加1个月"></a>返回值时间加1个月</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DATE_ADD( create_time, <span class="type">INTERVAL</span> <span class="number">1</span> <span class="keyword">MONTH</span> ) </span><br></pre></td></tr></table></figure>
<p>create_time 为返回值，在原来的时间上加一个月。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>sql</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>InnoDB与MYISAM的区别</title>
    <url>/posts/3R3HSKP.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误！！" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="9363798dab3c66c71e5798395efb6d25a5d2b76c14d9839821b62683460c0379">6e9d7ca9294f2dfe030bce02e69a0643aa65d5c451ad59517b0130ce8a6f5ba903bfc39331f555844c10e26a293a0a648d324a0176e6e820be727626320d087c7b78f84f9b8b449344b16779e2cb50a07d17f8355a665f2fbcc77bf2edacc7f6aa1bd00ad3f9e76ea4123d216d6e584b72aeeac12271a9293fe376b3a3b46ebe2e3b4d7338f7febe6ca2146cc87b9964719e56ec1faa988dd659b23adce3e015ac7313da3803528d9d070779731907d23b4c431d89ff5fc1088925f2ea34791864a9f818480c9dd79c5121572ade3167c91e360a703d45baf46751e2d94278b992689794518fdef919f9a4600d7876b0d14baa55de397f6f8a10655ddefe2a6127c2ed46397f575ff2122596b413fdd7ecea8a3627d62dca5964c2bf11445b8aef8e16815960ca532c9c632ae389a7c53326c130f42ff5fe07bd0fbe54952bc518948f68059277c32c30c3c92ac50c565f95b782b0917bd526944d135ef7adf0498e461cc8204ad80718f767d699ba927552edb028d84a1e49d99fcc8497752efd7769e89aa6ab703903d6bb58753242f11bc87112871a04a0e72a629840c8bb57768cf880154c672db52febc2805002833528cb858bd413b07f6a18bf256234df28adb73f687f800e70ed63e2dc5e38a4024096d4495d3c3d6d354504d0642ce464c57b0cb6126756c6c52391f7b45884278998cb1c7f6d60fad92b53262af9ad1be07afacddb73e28891ad41ddebf93998ab3177f449805965f7699b6a305b3698dadccbfcfdd6c5702044e72e41e88d6862f1abab40c5b15abb455f802a57395ee20d359335e29707dfad7d9880d39998b9e2b3b98985c1cc254af8c4693d0ab80e43db1c898bce5f0a4c450b19615dcf3b907e87aaea08353c660bc6705b9d7d44ff2fe69b2267c697f0da05568df17e43a163c4eddb0cea7dd08f51e0281605c4a2ad1ec8c476052df7aa5fd3d5bdcb970da31dc61926da4952374a546ccd0a131973791486143aa1a4cffabac1daceb43a76e1455ba88ffe3d100d3de36665f2163ffcc7f871a8bc805a4df9fea77a0d63ff2f3a9e4f39a5776ac7c6a5215c585183093f2a0b3ff1cdf363150ba667cf2dfa44aca8a894185bbdb290e44801d9cb939d7560b90bf6c89736ee3a07d88a114660271e61ac4dba4defde7a2925346aa71e0c233529fc1c70e4ff092e3d5a061701934bbbf4fdeb71f1bcfc8a3f81ae2be13e9b1559327d41fb4a74dec753053adb8f42f28dd82d0421be18e1f23b73bb9db6077b7199a08f7bdd2542b79f0ab8924647fdb9b44140b4d5e8f9be398fbe06c645584216a5ac702c7255d9dd6b263829724c72cdcd885450e40369e28e945062eb58c3a9c424532f2501960f76ba6681315381f7eafb19e5dc3c8ce57e77149ee2dfbc030aacdb5b91138f2d9e408629f95fbdcbc39c44cc76d5956815333999c5c904d4f81a852104b96b3fd1855c9e2fa38f942186ccfe4a62a344a9ee3e19994f6d3ab39998662562791f5854d2a3c62dfe5d6239ba478aaa494b005d1a9d91962eef892a55885ad15075a42f02f8ff8f888278793949efe78c016f767d4f6e37d4bc2c60d539d4ba238b9106cd6b310decec65706c28ef4f1346f7d302a6e935bbae9b22e8974b110c391be8069b0833c99870b9e9a85c64a9350cb7cd79b655fa89855451826e71ee4e57406ff0b94ce279cf4b81ffacdd0dfe482afb709812dcd63a27d851b7174e51980b2bb65c3b30cbf0df261bb7dcad6e00e97e27d4de78aa4e2b686eee062fac1b256f5d631eba4eb8be9ab99267f9596a6176a5af381beb6ef38281de430dedb4c2bd7e0ffda9151ae14576ab1748eca0fea4626bf22a61cea0f1dc5f579a9f934f40a21be02183338b3d1c55ecfced17be9270b729a7c12d3a2e0ce89effb27c78c57a4806a1b60d44695e666324dc3e61b988914bc31ebc571d3a6f951ad4e74b6e31aad770831e0e342625c3865d902f51e5fc2b8826c8b033a6c5a2bb2162acdacf66850c6bb332112d09cffc9e21c8a9d1d711f05746418c2f47f7134653495461fd365cc3b689fbba81aaf80e14a3cb8160f70b2a651f8b325058e6030d41d239b60bec8f02ed039c3d244b87416ee368fd54e8e2c93a9cfc9811010dfc65e452d10b2effc022a9cb5b6aa2cd4b8b1b90b6f00772b61875727b33cee589a52b139089959c289f7f8f208d2661b0b152d3b39324db7710e0101e72f17d3cb5fada9010c4ff092508b9b263b7045ab6ab3e3f5108927b9ba3879acfd2dcb9643469d823028912841dcb697bd009e0a5b581fa9b54fe8c45e72f0b6155233a9594413e7f9feb948bd97e73b40ea5ff914fec8aec7e5b2ac1e3fe7ebef4be8ce7513bf72dbca45290357d7becaf4413f29025d1c7b2953b70c1e457da11ce52d76a8021c64776bd6d133a75496347ed5c47af72f43b3805b2f5f3da2c37bc3b7f352d9c48d74a311268cbaa82f12884a907f20ceca6bfa75c9a94762981289fff95161824f75cae642ffe22a2f1a1b9eb92df8cd5a7752179a76457</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">未完结</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>数据库</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>sql</tag>
        <tag>事务</tag>
        <tag>数据库</tag>
        <tag>Mysql</tag>
        <tag>锁</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>MYSQL优化</title>
    <url>/posts/1HWEQYQ.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密码错误！！" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="8068aff3c2fd5ce8609a05e6e0c8c60528e16a39b7fe69d419778ec90f243025">5808c6cbf3ac08533f2dffaad5e129c11c64d264a6b884f80ed1fbf1dc1e35e7b32258040629b0a13924846a0e7073cea6e820c929af109415533534c1ecece8aa4b85537084f45109bc0913400863aa2b6cbfc01978ef41b9b53ab55c37743a369778d414aedfa5a0b2160adfa2dbb4a25d4934ff885f648b801fdb46665f119d9174f72cd8816c029e68e910ec8af01865066965e2cc9e4a455e7047255f7a8e5212c93a934849fecec1bfd4c350bb434266db822b6208e2fe9c58b283d2dc0e4067cdc9c53fe0b0c4beec63a9a789b6a63d075744615fca92c94d3e270cdec45495679a3c99957fecacc0b5e93c1bbc91ad3af40c953484abc0b2726fcfc335c5c650d935029e4bf9fab89daaf45adcb61df07c775ac270bb02babdf87ef061752cfc2dccf77d01a140253dad11733050868a5dfc2dd1c6d5a427f0a1cf87f3b6f6f832a7dd071544c138caf3f66a9cd00f6c9d3de96fc4f6f99166990d5ab6cfd7acde88a7a8684e448c88c644342012be8488d5de3be4de39e97563b49f70b6e32de143c4f94cf3d3c5398cb682148eb1f3ae117d2f183111807e14d9a2bcc785da61c8fc4f363e5b79e8f834a916dc0d17c0220c5685317fcd5f0403dd86cb4dd2c9a87e17f2a38055b2c76bc8b6893efa4569aba3d56c30f481ea5806ab16ae05e66ffb76108168fb7c97398493754b3431b6f0f3d0df93035657fbe69211b000e3cd14921edfb94f9311b25e204f3de241bfcf43ecfce5b4f834911df4f67e38753fb0991412d436415ada6bc9f0366abf26975b705341555ce15cfe96dbbe03e9200d18ca07fd9177a13a084bbd718b5e6aaccb37f0a674e0554d8e00d386b068c0aeee1ef7e4aaf931b57c00d5abb19e2497c3d92937d91fde2fbda5717bb5b01af6e18ce34673f679c90248903f9e41816e3507d3e30117f9a07ac4997ab5c40477053a40bace3e75ec1fa1968024796c5430e23fa0ba3fec62369987892216ea46db6c01120338206d2d34ac90cba3b48be266594c8af8f742bcb18dcf73381bbef4fcfeb74a767b97b0f8c924f67cd896f1c7ee199400b7f39ced975fa49921fe3b03d821b4291129907d58e5abbc574871a8e20308651c322061467de3e3f8098967c26016c235b2247172d0514a25a7f109b8b34e1f6ef23292678a825ea2abe5f9e7e384f579fc82abe738e144d2cac3e5bac5b6038f7fb7d56e5d759ea7e7d96c8f15cf460e0d1fe7bbff72fa40b14288b4f928f24453f1370cd2e70b2dfd23253dd324a817dc8f375b51d5fcd748c0025a9d4bf27ce583bf25a885e14d839364bdd58efcddf12b8caf5b55ed8b40149a4a9edb3a1e458a83145c53d766b23f0d06cb231b867ff69516ecf64a75aaafd05ac7c02962545f0d22de4d2e1cf036c159ac6ee07b415a3a0f173a846450341471af0cd2b3537199fc512f218b30889d337689e6313599cc01a2ba89c39386a51c2973530285b1fa2a29a800f2f7b098c9652df76e15ac19e9cd16009f16f06c576a22f809c18deef440ebd7c8f64326eec1b49aaa9fe01edc801e537f245a3016d3fc56fcb9048270ba32bbcbff92b1cba042ca6f4833f894db5978565ef4c69b456737f0aa69d82116f41a22017b263ab0e5fb3f6d52a58cb157f14487a31e9038773a9da2900d3778549bb2eb8929b5dd24af917cf616e6cdb9b90bab1ea4d9ca9ea301d68e6e7314a52c0db602acf657093dc097383e5f111b4facf149b66cc4f401e4b0f4ec09677b40db418cee384b729013b504330a7cc804ef52ccc55d8a6075ce3be3b2003fa4b897d5f2fb8a5d065716ff7909b823db94445183491074e7e722daa1db75ef27f1bafc0e6a365a9578c019470c1e5cc1f7568b690bc58e39b113b0b2a13177ab58d34363464f518147e5d3b01e7fea0c07e90f2207ed39d5ff8846d524459e27b2d985eb0405b5d449f6f73616ff35a5e354a301c93f58be979724365ca82a08734921c63230a4ee1a42fe9b9a01c1ad2fb1c9629ff7da3c5501d6f69b8b1d1aaeb5ff66ff419a19ecc8e3567c867b0c96c68c85c5149d74854ab2daacb13dd5b6055a4e9ad90b54751528e435c508a22e1ded90104fd022d6a8f7298a997fa8c3e03d5610a6db9a4dc57bebe65288b7fc7b186546ec0b21ea0e6bf5182cd516c43b02afa27502d7a5bf7b6308ef42be62f6388dea38953aecabaf7d9afc3fb2b4d1aeea615db1db4edf67eca8737836f6f47f50195e3a129b790dc66eba8e7bb392b05753b38b24aacbf5e64468c4ca2606589c2603e5f8479c380897a4ebec9e8680cda2b94d0768e5ee20bd4ed621b2b5fed0baaf5b8ad7899256dc92f350a5146b9260bf7bd77aa7c0d26c4d523043062fe6121b13891d311908e85b45627ae92de422a19a169656d20f0f45e79aaf2a45ab1a1c1191f8fff152d3d645b783708d6195f6b70269c391d18e76afcfdd5f8f193f1afe81cc81b542627f9324204831825d167599b1b459c933942a7d2cab32076677e79c6368d69d3019999f25b5d2dd83eb275f87ad49fb248a44122a6819d7b96a86ed2831d0f35a97d5095c29dd252698df4a2b296abb2ad4fa36fdfff74f2b5b1c29cedaccedd6a6d9a5ee10233b567be35484dd025eb13b8debab07db6855e9c92f9c33a9b195e762c34c024209ca83dd4aa8c4d402d3c9bfccbcf2650a1f82f3daa175c73ad28d5078e7a464786b6b3fd45be3031d0b26f0368c33851d43ab702dc495e73b6c33cffdea91d79f372fa9ed4ce4ed3f9e1e3f69111406af2579831527eb28ea05f1413aa956bc8c6a9641dc69d87de949a1bc50046686d5d1ad8c26a3886548c042bcfd23cd991264b32e486f676c8c8f143ed3cba985c34933b395621f1dbd0bb1cf47907946c182b2c942a0a491953af9f285feda72c809e4a70cf174e457ad42b969980e12b80495bee0a23444f4856022eb1255b7a29431facf2acc4b33a4c5c14ac0e0e7eb5d35b7fb404af668a1f422e6b91ebd0e41eea65db245e1a2ca032aabb5c6d5cd74906e2326c78253d2b473b8116323c3abe8d1f6146a803b26b43d829049bd64fa82652c516b1631b81755108faf6b60b1b399ae605e858281774bcedb0042b95b607232517a8f30a7e30ac7439d3c30c7f7ca195964a29f195dc20eabc796cfd4d13d26f0db245cde36ff6e4876a26d5632f155f2b57037957d273c44508b6e51787308bdda909e79e1edc3bae4847a44a722f2709af907973dd5dfaa50c6fc8042b4b56792310bc1abf51097f30ed7b194b5f8bfe7bf257defa823c53de06db23bc8f03040da25b3e96ba3c53ce6590c29ed5483d198b92db34b4ec01d286db8d17f717aadc3ff22dc4024980cd1cc1d20beb671b80076c3f2789cffa8715d11eff587f71233b4e4f520818823a94ddca5ceb6f036a3da10908357e9996a50984dd58389aea77f1b3bdfbe2fe4ef28cf727ed6e61a5e91ea910ad6097009a71f0245e769af141da1de73ca58ff7e915917614218d8e6c84107fe1b050a72a83ace3df78a75bf52947aaa07de1e6bcd1ea0079e89d809ef1203608c388c65e428d5e3851f8fa5a4f61ee02c365bddd7cbf326b0e905135039c75df8ea5680c8c924922a0a76bb58e1c1e0ed3c3d4cc32b1bf9a34d163bcda34a26530814744c2e02778b90e27bed8e1a066c865f6e8aa0ce121fa876b154ca9bcc2fc90f93630718b44677335c240d30ca57f2645845bb3be1058408da50ef565bc7abe2827866e792d2285cc0de625b0ecc72c44f3ad2db160be56ef50cf805054b50c9890420a42c54f5662a0121052015d5be8a9a56bbd9be6c8467d4549b063ae27894664c4af0e1434d487ce695397c7e4b4397e3f869c469e5f25724efe905fa11f1da29c05223936d1b22d4cd22542477d2538bf9461316f17201b3553b810639489ad655fcad629e539ede360079f151d93f4b85117998c11a1367f5bc1eb058af2ac7f13955268b618ff8d2be5fbd618db2ca3e55a009e91122d0c866614458148a6caf38b0df3cb246640094a932ec683429c66c2034e51cdcad12a42789e17ab96d9e5eb6ce6d685b3ad7b43b3a1193d814d5dfc9cfbffbaa2a092162cbe689f0d5d0b8174276af1149ca7828496a770859cd4ab7a4dc55bf2117251d618b11a378ed90a9afe9b4a53109931097ccb04a3d423587f4383ff6271628559c564cc1567649c20dc3f9c12d019b15217a9e3d14e6aca5ee916192d0a252cec6346e474c1e069284cbd9ba179ab267b8a5c41acdd19f7ee552019eb0cca92fcd4f42d3f09ae384a923a50fb59e307adf089ef21cd800b6ef2c65aa347ad09f6bc7a09fdcda9504cfaae9c2443d735dc9b43bb937aa06b4f8e046659154f599b844b5a81695bda6cb08b33dfe3ea031413d00970b639669dca6375f409058e1e69a9cf2043c3638dcda9464d0e718836b560bd3e749ddb01ecb5c771fcca6ce8346961c83198c7fa2fb1e278fbaaa769bb3482ef6b96c8f500185c549f6d5f501df2864dddddbe2987c60005868a5b9ea369ee235a61a6238d836fa116e85c1dc6b8533678ec83e7c50079d502f096633c24b3bd25abec6178f925c33378e4116f0b69f67a9bba9431c7d18d05953e55f5669c8c6c18b7dd4a414933fddbe3d41ade50d8736fecbfa9f33947ab027a464bf6f4e302ce61f5041c5aa8363377939affdf917a2a227235957c51540cc100753c51cb1888d7fdf81cafa39069456f16e35ffe2a98728ff7142ba438b89988c6777bb0f36b143f8d6a5ac3d174c913860436a244409736663e8576d986b18e4dbfaa524340b3e3d8a3035f59caba3d15bedd17cb01c768f49ad5db95723f6380cb3874e21c17efed036c441ff5e0a748f193865d8e1f0adf8bfad2466e238c03f39b4198e6ab4171bd8bb14af76106e6df7d50a25c34402092a4e32361f13e7f88ff599af4685fc1b50c387b5ef6616c2b4db272fae68c5a66298b14fbeb09e8e2a4e53c936f9c2fdf41aee44203144e2180e04323c2356f1adb52e501026b781fb63e3a2dcda9bbdee69eaa3fbc152f4e977ee9967611cd5586582f8df56cab2f4fcca31b93d5d95360ae7499f69fa5af15aa0dbae6d0310ff14083b49797b756e8db2bb74aa581ab265cd27c462a9a49a8bf86018037e915430598bb0d60389efbac8cbcf22dd698ed98de02bd9b8e7fe6edc213ef10223d87b8581612237b6a90ac1fda274e01f3ff0ce60777504fbe79898563a57268035d9eed0bad60fbcdac2defdddcf95f942eb0f32595e888f5c86696fb810a84cd7d5a6636253bc954fac977da2a96467a4dc4e54170f452455e6ee30ceb3dda4aff62190c7da8723502fd22240bb12beaa3235406ab0d0f14ce2f9ccb2a0dfc471fc41e2f66ca3de3a3a587c40a858b2f79f8238f6ed3b1f3b2779982c87a34609df025675908edc93faf6773277a4571001c12094b1bc36287cb6189785d9f1b311dab1417183d6885216f819815c20a6ac4d4b51b891c86c333900ffbe90914e381cafeff913138d5d5d3f567ff2c41f589df3c58a48d4af49be239420d3e3e1a34e13b49b8262dff3a166fe386a198bdfd9f81fdf9ad61ec85757201edc1719185b19caca8c6b56d277c50e1f0b80439a65904d39bda25d85a11dc406c6b6008f0959964701ac3410c05b5d5bd7aef4425a29e3e7b0751092535a547ee89396bbe4da73c96bff40e2d84066e7cf082d36be057e9754a131947dfe4f2834411c9ac006ec046b6e1166ae2cd3c7da3efa13f6efe033fc0552ff2d0f3530ee60ac40af04737c7d213ccd394149f04e8a279ba6baf7b862a2a45788c6edd1b4ce5b744592222ee70df6261007bc5748955e53be7881a7eb5dbc1781496966377fd06fdf5cd494f4884236255bb2467872aff2a064c76544a1cd7e5814cac8f209b2090a48fd7eec8007911d52b3b5a951fc5a1b198aa53ddf2bcf82dda0d482b854e10c485bb0d6e52ef5bc87b0c4851ab1362fa951460ecb0195a1642a55635b251c99a428e923c17ba69aa6e0207068ac665a6404ac3a5cd130d9c9665fe59e4619abc88a42e5a78e0f98e21c7955c25efec0af12c7274cf1811611af0e849c45073c72b08e6d8b73797215dd182eaf32a737d7e90a1bf0026f7587927429e761ef3bd1876904348ff5196b7d487a1c33551a0183910df54b82ac62ca5d281e8a626b8526405814503e5363cba36e51bcd545e3589e5fc229ec55a50423c2bbc9fc9658582f58f8c89eb08b42c5f8c197aaf65053e47585a269ef51a34774fccf3bd6a855a5e4060109b5500bb728eae565b5144941a2506632bab4f3d95ff7d835ba8f9df153e65c3ac1dfd35dbed865363a4a5ad88c57265af50af0558b44e4b67cd9b97f87644c1b701250bd24b8eab3980a4e288508a3ed5e0aa753b6327ab8f474b8c73e3da7da8db496435a373e95d46d2964a832fbfc855bc5bd76dd4ddd2def664a7e8d54b60e99f91374d632f50de82ecbde75b35c0d58bdff290cdfa75100e967804424b1243c6a8153559bae96e18f38c61794e9300423b606b786688531906c28f1943aa2aac846e2ba345b6097e6cf9c6f0c22e6b14a5df1428a7ef5ff9cdc677492e096b2ef84db07000f985baf43371029aa440482116f56c21eab20605602fae884324ec9b969cf682ede89bab229a3659e0f7f416118243bda5c059ac37c273b686fb9b8da06380fa78ad8e5bd7090a789b59a94fe484baf2f7aa5e376ba2f2435a8a7ba70db2094b5613be534626b566e8d7759100256373c97dd147287cef117a7e061d88f2e2a7e2115bd516c6df033ea48f0c079f3d7a667adb1ef03992917a54ca5f62b45a71064175c5de8dd958b82c1e628d449389ca84959c18d643755e0283247e2eb5843eba4c7083b8ab899488e145b24876cf99abefdbf4d7883e355826692d8e79ee814a0b74aa78f792652aec3b42f90248fdb215bd0c0835509f76c90622254ebbdfc40fa7e1d4c53a05675097aee36c093de4a38e6ab8373265649c746f5c02b9ea36ee2e4c59a48105f03f9cd0e59d81d33daed105f840c8ba5eeb0b6851f2e9494a434bbcb3d25f707abcf7853a7643bdd814e041adc848a9f781fa47a7359aac1e4dc3b580000f1d6f2f8eb955a2fda5f070f864ebf2b6da221386f1cd53e6add8659fe64d4a7000fb9cc2acb83ea2a1b7bb89f95369db6458c62afbdb625bd6a61ebc39c4aa2f4aa46c73aa65a019a9c038332b5b3085ef34154ef4975eac10113ae5a569f90ca0803cf09c5016e1519dba6ca9226e82d1897c89dbb3ded5a82253431164406a4a503510d38c243492b81c71fa09e4c5e992431d00c243557ac7910d1e79ada7faf535609fb41a3396c9cce774a8a64e9eb0fe32db81ad5e7405d0503ac728e129d306d475e5d2b2f64edcbdbc61d1461bb9de45bbd0d6f82eb81004c64c1ec20839ede3c17121759165ba40b34145982de8d2be1a255c58e0fcfc68dd573b284f80b976e7f8bc01190894d3e32becd00c8e260ac36a7f2f73a213a679798babde891ab4dd11fe7e425033d5b683adcfc56f742d44485dbeaf10d3144dd214fde456046cb822eb37e97b9d28ea67306fddb85a970ce7d56ad4bbf8198e78d4472e88c4e2546458f36a9ff20e4e3ec20040ace60aff89729fe63060061df7810dea39867793d54cfd3d3e40620320bfedf5a078e44956c6fff3e1c9677755f8b9cd922e7b2f489034737c0c7bcc8a551695a5ca2480e341e2f62bf25227cc1ca5b5e357d6a5f5201c709bd0e740416fc0fa887f66f122ba2172bd180a2ceadf18d51aa0577b233a3c14bc44e9f7842c68dd416402dfe8be86ec576070013028a5357149c8dc2f735ea4eabb32ff942f9872f5560b79b3fbf6c4be9e7ac9c01d8888ec08a90533a3c2598082f5a8e5b19fb35131fc94db38cab56e403b14b04df01ea0b3e82aa743c26162725a518d5158ede8fc605b4f2bc27ed126e5479fc16d015b0904d761116d9db490fd37b005342692f438b20103b613f14bc82d6cb9522ee97961ef5eabe748b14b7c49ec24bf53b559f722dbea2fa89b84056b7ac100ef599009650eb74afd2fa5857e22fdbbe7b4f8b9b3910493200d9edadbcca8ec3dc0e075a31e579832c6ae36f411eec411755feb07109aa644f037346e9db7ed1f10a7b976e4c33c1900eec3f0feefd50ff13e353610d0a437ac990a2d182955dd5e96b72f75d9e01121f5e75bb01ffdfc017e6c1f07092e4b7aa90735c339c01a33a56264a9099130c438790f72c08ed0f01b621de920a140aff2a875fab6ffe8b52ec49305452a1cdf01e67d5fedab0a5c65ddb10e56b0975e7e74f80832c5c0d8d3d91ee5b2397779d3f63827ed68ddfdb05c88d3998fb7aff622c5c821086265f936ce6cba233e6814009bc86c0afa746937b856c25b5703832fbac291bb13a4f05d9e874cb793a3f512f5b9bfe59a170994fae87d17637a1cbacebd780d5cbd46f3beeb6b540d92d747001bdde897c27212ce71ff4a1ec11f0d3191f66c65c2025e3837c5196748acbd3634f803bcbd1f39de029ce8b0429f7d4970b287e2669b056db2bfe765595c11a7eb298f882b848e74b253e2b5901933f854bc843645d0d6aa81742ffeb79fda4fc110101fa0b2f45b835ce6ad1684aee4a9544b3095a205d9bc019877d00e3578a2426a2d0b2d9ef8a3c32c4c0d17c83791def6417fddf825cd925d21cb025a57809f9b0a50849a8866c001e3add80b8e81ed6ef9a2824f55183fc7f88cb37e0be8e4a6d1b57ce0c81ffb03d3b1267022b63cddd8fcd6e142e950cac176ebd0b9faea7b2d5b7fe281342ee403923a2dff22b9566ef2ed6615181cdef4b4f1d634f06e196465c77a69bbc271ad9fb754162680c9022ce07895f235729a024462bf16d5c59c8f2e79c32b40bc4040879cef78f73be2ec13c32fbfe6830f232ee8c90b96d5fb46927cb8a221c0ecdd3157144e3208e8288ac70e82106f3049a7d220148c2084707b16593b63899c604a4b80f41e8c0f7069bbb8341bd9066c10528c31dd890d36dc7e306f4d197464bb5da73cbe7e750e5d087d37c03b7c1492b43437929201f0430409f9050650eb8acc1f5dc9e69adb124ebca466be4d15baeeb0030c209615104868b8fa5cfe8fdd3b038dd9bd4e2ba855755fcf58c8a3f6ed8f32be716a44c991e2e5d18fd1251972b7be081bf1ff7ce3921b5e52cd5539a85f61b30d53dc08168c1b3a16f8cd00168272cbf96e7f41b6bed796c41e54e360b246b35f2dd544ccaf3b35a15db564bb94f931326db7c96767741f69a80aa81ce00f7bdf2288da40a7c09d0e675b42aba04bd54255f54819a95faabda9198b013416c040b4e7f9f4e4e528da7f578016874571498af04e1582fc4a753795ce34e29e98f2642aef828b15224042c5d4fcd6b374c2a3e5065c866b8f4ac2b11dbad5b2b524246a32b34f1a3c8daadb16f8e740b4de725367c65bcd6822a5b36822d9f4837f7cdb0545a5e27dcfa62e91267e7ab232328969380aeeee7873b162ce76fc75d4649e372549a8f3ecc03de5cb4e02eb1dc9ab3480fd74f52d45080a4e5b28123b9a950f5751abf1ddcef4ead81e4360b358e8e489d9a7727802d4ee52932acb6e9e51ddaf241b6824e1a5744f116d4f30da827fcd1b467c77274402e07e62ac14a5c1acb9e9cbc5a9028327779879b411de1ea76f5be1c9dfed9f372653b991c1405b41987b1f09fd532f92345229cf4152290acb6d2a797701a6c0fbb0c8b6f4309e6304d20e8302fa05be91bba4eb55b44ec3b806a6022a42247c7eb9b937fd18307676139e7efd1c21a8df9bba5af887ef95cd919423d1fdb70ae5d77e2ace71d30ab7a43be375ce002cd4834c66c26457655353d29a0defcbd6c1b7d19fa52be28ab44ff0c4be78ef17d75257c1821fc87b51a3f77b89a04fd830e94dde970f5602a2fbe5357abab15c5f488aea80b0a3ebaba3bd8fd130d0113bcbba09c6b8e6ba306b66bfdc0ca0ab8b4387f17b843c7a1292e1ebb53e0517e6725428e3b1da32427f8c19bd845b45ce676e2daa2bb4f3692c5f9ce674c6ded5c9c28c02e6e41e76f439d61897c22f57e2607190b1b40a6ce1695c8fefff8fb829f305d013b2529794fccad5a1b9d70aafe00b329083c403893d711ee74419477f79035571b7ce6564631b6f0c79cf3b96561e5ba4f54f30d560c68dbc924dbcd86c8349ceac6912be34eabe19b40c68191bdc1d68fca3a951041d83325f22f99265f0695ecd9a1f43c51282e0315046edd84255ce2050de398c7ac4ec141eb91204d7888c05b4564d5754a9a07ed782add9b416ceab39c7584fd26a5d7dc9549084c07e920daacf437bed9e2e416c16f66f9d22dd1d1ee5841afb533302b4b5e2b273660a21527f605ae26c69010ccaad3a162132d795a3374c680786a93d9dfcbcd20d761ea663324d3ee1f67ff642523c895a70095bc0e54d861d674d656a0a4924e72e77fd096e2ec42d37d2502844b5d7f348fcb121aeb3a9e1a658e74f94464f9acc4b5a8729bbbe4559f706f7f7e05c70eb810aec2942cd611824a96f3fa4b86a700cad2b99edf19fa1fbaca3e375ebdb9fd3525577b6c8bd5eb531b78e9e7d6360065563a146fa6cd978b0d78a454c48fec0f737754206a84dab7841ce839cfa0521dc7d155f706d736a8a9eb413a273f5cd78b6f59bdb1fc7ea60eeaba9bb97c66f1b463c8034c5392bd8e2fe1401bf0f6dd99d388f55acb20c4080b9dcf0df5e883ca838edd0428c2779b603a181e2c31a7cf03f7c72db2b09a186d78ac9d5369396b64899ef2f278c511c1ea86389227d8a8b552936d9653783951a927edb87468881247e2b145661920f3637ad7ed034071de00f645281965b3dc2e4eabde30e449d8abb3b0933bb9984932a2a285880f372e5b6b23ba3ab1bd1eadbca3c339bb931d96375189fcf0628fbfdea9f2df7f54313a3303bf33a62a0a8789a3178f8cafefd54a2a4b4680f5efc133603c69c30f813fba72f8d9896e046612c735417132cb6a98eeb785fddc8563d8a30043484e446f9df36793554793c8d00ddc5a0753f2a276b829e72b4cb9a23d05a2c15b4d1fd917b26d7d44509afadec4ddc7d492211c9735b8644d295d16fd3c09ad55af4c2f0e3a1373afbd7f96f5d5bbe840e8ce0a0991bbc1daa5f39afa3e1f9ffe3371be47e57c4c3e7e3a66af8f2b2888c117f7ca8820f06f5370a0dae672b5af47df965af2702b110747c25724850380867e5311033d015ff5890d328d918d611f4a4c819ff5f856cee67a402aacf10dbe6aa6898e406f8a09da2671b00635a709f066e6005252239a4022d065e925972165c908e9b93425bab5858f79bf8c755d5f4268208ae93d8fa975bf5319b19f484ce21a6045ded0670d2a3dfacbedc728931a0fe20dcb0a6c0b0f21ffe15429450446fb40791cc4d5e8f20665d336222c455f33d15d0ab267818f55764265f5637b764519160574872ae55dcd110c41789dfd42fde6c7a5e73a6ff58cec10d857ed60241f6c749b1c19c748702316419b327f5b61bb7b7b096476e4fb875e50863c0186d741c87e1a387177ecbec08d1c3c18b49b69fbf660bde9b359572587361e0b77ec044730094ed902dcf51b6bdb9f35be46fa6d1ee20c7a5687e591182a86fd6b932ad81e4446f9d5280009f31697e80782e5a6fafe2e43fb5f999390751e6622176c876dcc0b50f89d423e5bd3529ba94ed4c7b187b476d18f668048793835b65963f64f09b385ccceadbfdf5b04bb9acec9c3d55f1f9827802a465e69011dee4aae98ed4cf6bec5e097fd71e6cbf8af26c454f4230c39fd80f4214439728a35a9e2dbd1631be3de6b7db32e5a9b2ef07ebf73512a354110a6ea6ba99f038db9e52cd96e958cd95dbab944eec42e46edcf5c2821b17778f32cb2dd17d25706b01ce969535e7b8da5c970fd4716f8272e0fbe61a5d4b4176745abcd892a8a01c6fb5acc2dfcade4f366d0c368ddd5aaa8a17e257e8d59c072804c50bd73e4b525043e683e587cedc5545d4a88bd624548debbd1a925ee00589e08280b83a2d4a0bc554e9b0e97b66da58bea37199313201322b59c5b6cc7a7d62c309dc117b36490d624879b11c09b34f0895f10f436872b73c43a0f930f4264f9a6e6ec5327eb76bddee6195d1d71be1d220d662b94e531cf624d0fa1867a0b1485699391dedc3e849c20d7e02b2d8ed5a3f48c3da047dfd10685cb0c253147640c9078de019a32a10308fae7847e761e69ff8e682da880e3bd3ded260ef4a4dd3a2c34d8186bf6fbb692b800c1fac89c1fdf84527c191b754ed1a6b8c2beaee30bbb4af3b4df61bc0e1f2c4bf2b02c436ebcd1f141722d46eafd83f2f167d6a07d0dd19fceaa37037735f06db9a0b1a9f4e4bdee31159b6f7c35c4feb58e6067a85a0f7b5523f1a0c581b1d9ed2b0a5c702a4bce04fb9ae202f887086f5703c54460bfcb9fddfc076b8f570b474ce19785f2a705d997771a638b090a671e002f6e1280c09113d3af6380d7a78ca2dfc79648677df3c98b7740b174bf6ffdf9b9f0f670e0e9e083683a401992d7af2f81d4d83c50105593d18ba617cefe59d70084617990f2f5df9948381dd16d1ef88c0727d2d02a505d2ec7d8df87c3f0a1b1838be5176c3c57d1e3ad16557c89c2bac0e9a9c5c348066cffdc792d8b62a5aed2427bb14445322323acaeb6fbd1540296db51c6373521c55580f22d451180cdddb5cf548891ee8f264c3fc90ac111fcc87fa20f2c5c6ba7dd64a87f9d57332f506871cc04087b7d3c97808997b7d569c8889518d9aed70284af4cf3caf05cd32ec881da4ef88e5b3ac6d8511596a04ab82053d7bffd8fe1de50e76222c4b6a8c5b7cfc073c8464f144cdb66cce5f5ac5db94a69cb3281e6a516c18dbbd36316720c7be6cf58e9c11bf0eb7cdfd8de43789caf9b6245ab9c3d9c553bbd852aef35362eb1207efae523d63ea6f951700a205c409f1cb5c88e90eba32c104bef77cf2f0ca75bdce6b9c907025d75ad91a446389a4530828ae1e40e4b5053f531273a4fd93576d6c564351bba8ed400b28613899e0fe10951edf79c67568bec763a88e59152b6e918bfc3d31fa4a7cbc3f8d4ff3ac9b66f14ad237de9f122a105a7466b4ce537c83d05b3239ac0f234ef6a44f64178d50f611f7c6c6221f104f42bb2de81041de2e52b691991cbcd0eb0b8844ebee1d76b9d95b1a98af7189fbceed9e950b26cbed1e7715d711c1b39d094a5c01632800a0310d462423ba77c23d2cf3bf7298c2e0a2fe8497c12b4b939139d58db627febbaa82c2f2cbcb624e989b9f665694aa8c9ae48984b32227443ea4e2710d26c0afe1df5ff87b2f51523c56fe99977a4002e415335d1ff7c0389f38b3134678ce718a58963d0bde0be2a109ccec11818bdeeee3551089d30cf225ebf8044f26343478659713c0e8b8abbaf66911b8b7dab808c389d69930baf72a3f8dd86f194c1c72fce8b2e105dca82b113bd7f7e065fcef2e68fc905e22dcf34ac4b006cc97b1d55cc612d82c82eed480ad8a03b83f5c3cc89140c87c2239ee68793e6e2cf65e7308f0ee92834e50d48a8606d6670fa818bdf16e8dfb68d26e521e2f3a90999ad088e8b9fe2cc2f9f8bbfe1cf9625e291093a27ddf84fa25aadac02a23606fcbae96a293934ba6d321f57933cb2582e07cdad204a01d07420203ff9f1541ef2f71bbed9464511a85619b50fdf3fe20b2e685d7264b63992b4bac1c7e19a8afe1619e12381c80efdfc0d535644975b04a7bda19cebd873ee032fd8d371ba1e33e3739200ff449910c06a1fa838c2f7eb76c816b378746f3a77ba4a46509fdbad2bf6dd311af879c4709960b7c7a33d4409af03eb3b0b12e053de8e3804944b87792eb460835c7561c2d14327e59583355e5ad828c3f82b0f450e616e312b536a7cf2b1021c1ff6db2cd7c27ed9bf6c368c34419b464492fc041eebb65d08bea3229af64f363e7e2afc1368744c4493bb7b419b0380a8d3da0c14cc9f6a5134d60e57245308ebe8787c50bd64729c3328157b54eefb457c71e6deb2582d7317b350a41620558326cb9b75c0acd6d0af0b464778341754cf8fa5dd1b0d00a6889423fc850664df9b2087b8aaafd64fa6418027854d553e6f9772b43372a7fd3f1f83e5fdb116076cdde9128ca3acc9152c95f0b50ba883b443ec9e28652896d73d6ac5cf4c3572f70a79f762047a4397107cc10dd959e6d648f25bef8f64be06c5448279658f073fbb48bf867aeb8ad7164fd06f521e361a4f87ddf376320777e86ec1ce4f10dc0e9b6fd7e3ed4f8c29ebcdb769cd8a7bdc65b3d5790c83cc701128ba23cb3ca2b41e022fdbe0261b1acb77d2bafe4cf1ccdaa41dfde82ca15f6a4237149324c85dc871b1be6ce16d7cab4085cd3ff89d88ac96ee88170d1358fee2be9dbcc7e6181a63937bfd7d445223cd4cb55c9db9aff2081e80c10ba9d74a06697cf777b92aa27d1067f7bff5ceda2c18cb89a8da3bf330f17d37962bc72463c3f45e3f82eaac98273e1290af59c97a793ca741027308c12eba97a1388a20ea086b00aca67ceb2d7bde70132ee07168dd5beaab76d8b3a21232e8fdb7049c3c06b331ea6e11d3d4ab5dc6a909c036cd266eb2965b88a69a90a893ae0956ae97f19bf81b580a2d327f1cf4bdd23d2c58248398bb0da4642c13ba6d7792d82ef4570f889e188ea8e19c16e20d120c92b6c8c1e7bee4e40b00e10fdb4091b265df197ab24c933fedd738df36c2ec4c89ba55c761f5b176bcffe4ed2a568f4ea25548c9b2b32f72a91affc7c4580b86dc1deb727d81102a83d47a5cd82e042bf127dda45cee1aaf358ddeb20d377973067b500ed711acdbe08bb95f3b67dcc0259486df57c5b4f8fdb4f7d01808dcf888cdbdf1be8c22a28ad27622e122c2cd13bc7a4760880bca8f0c6dacf85ceece183ada7bdf26503e61948e44c5aee82108304acb221e8fdfe865b4076b5bad89bf3b1ed2d983750dc5bfb0a09433bc2dc5f870837a82a0a5f4ea5ebe578a3cb3e01ef42e081f0a68325137e5b81f747959f2b4a66ed0c74a23659aa992cd1cb0dd7fe3c8fbd1cb28854dfbc3bcc965f6daec76bfa7bad29055604acb49d3cde0211d23e4c4b49e6d6eb788bda2aab804f2772f37a1fa8303bb43a037e9be8b888495128a2d380ef616fc9c816aca528632c0e460db8faeea7b25b878d126e5ef217bcac897b50e0be8c40ad8cf3ff24ba91138fdee6f0dd086ca5b496a20e97f6cdd9a37d6a0096c8b19dd41a6a6f05517077b7cab72f96a503d70175b6f9e0997da91f6b9bc3d7f29937d8037adda97acdd75854f48bc812287fc122af23b972be3030886fd59f1c3ca4f2bf814b903e113b102eeeccc4d9fddaa13933597fc84fad54ac42de27e188c595e3789d2b0206e10ea6cc78376d4814536ceb364a8d8d9906c8eddab3c1241ce393abc286507b9c698242b1dd8eb4d0f62be2b15d1cb6c74b313df893c0d3b96f1d0f6a2486871b177b7ab4d46da02d7acff4e92e8f539fc91c3836c60922d10ee3f7c38dc862edde66fd99b11585bbdb8d0aa4e243754f3de0bcde9dfacfac4eda80fe00d9fa2e5ee981e409e144909c6b9618c33d7767e031494855398ac0cbd849eb4487cd39b872b0e52f918a3efe5e88a5cea944506543afd385bd4f65172b9c2e2707a1ea346cdc166435104623f7a893794b35dfd373939f86b6d798a72b1194fc505546e02c30a47e968205ad6efa662ca3b3e91dc899238affaabe317e186f225edc57d9d38864dc6c2579119d457b9f2e72399212fe09fdcca2b71791bc32a83703f46c86a30f4d029a19f03a4b5499cbef2d23a7e0c11af55249daaaff100321eec95f2cb89fe4cbf99e1851631fd920a1d006bdeb0b38c95149d7d62d1df79fc180f849cfcaa966a264b5509b912ed1228ac011393312ec91628cfe7c91436d82bec575263b9296fe150af66640fff8ded61b1d9e94a79db42954e8b5e8c0aae3f22e4e4149dedcf688082a5dc09c2c4c55beacc4ac1770871b6bd795f7dba033d1a62d7cd3c633f425e5f9354aa20ead67d4c8e9a2cb5849659f401bcf9a4e79b49198d945a2e2cbc37529706049c2e347f5b6a0bae91560fd92f1ea443814fcd12ff63b373bbfa41309265e673f0b138ade5a6fa888d90f5912a11f5e8f0ff9cc430ebcafbe9eaedac93111e49c4b3e599b00efd4869968fb69d64c1922513081d3a4c1ae0bae1b7cd3fe0371f5690058f0c12e5840e4da89f7bc73812cc6ce5dc9eacb0a3f78d9af94809e31db1347f1736789bdf52526158e79cde2a0808c7495437e84bef61bd58e1ce652fd534d5f9d2fb90a7d348da3ac7b7b28fda40a05a1ac184866b90812d40dc2db641aeaa1da3bb538896f51a141d35563c31d011d01de5c3807acf6d0d83769a4d167e7655dd68b3ef65f14f3dacc37ff7d018c068fb4bf36c45a3172cc1bc337bc9f0030935fcc73b18c2f05a39367d940433a536a475d87f4f4632e679684ac54e623987b1100449c1dde14e36f75e9402e1bbece4f39263876619b088efb9e4fd4ec05ae185ea37ea66d5e0a17b510f970195e762d12bc6a085561f703270ea8b906b5548b8981c933885584d67a9ca2338ff59aff2f79d3b9978ac7faeeb80a8adfbf31d6d149ca7073fc40284fcbbdd9a43099d474f949cfd8c66fae28674eaf666d025fbac5e3622ba8b3970e04826555d65bc9151587b123bb8e0796656dab33613e269a5bcec66c0c7d3f6f53a1dd86d7e50b9279d391b119e4f9adbcfad3ff23fe70fd3ef2d46a14d5b7329f93fef06ba506a61476d1176b9e05f645db0dc31cf8b035877e09c3f71056b67319375d000474f5020f88a3462f9eadd266326f4dcb4335080acda2b8e940803bc5383701efff31284d5a1502605a7bce2bc348d54ba08aa91521e1441969e434399f355fd96a52d3b66e1799b9d63052a2d35088fef92518cf174670f3cc12d489f03b1a904797a0587c0783935bea41a60cb57ba086d45933bf931c8f0fa24291ecf4682c2e8a0fb6664f8c7711aaceac3ac879b11a2cc5c53f7f085666d5ace7f847c26a974c3ea22ec744fab64ed452c194e70fb1ade84e6be9783d3ad771fbe6c052f9a43313bb197a67a86190c19fb6b643c6c687ce07b009759495b2be1cecadb18173de11dc211870dccc4805644429ee8dee01a160b99b28696c4061d0bb58f4a09cce71cfc2c0293528dcc214ccfb266b2e6c5096989772bd737be3f5d2e3c2d4a6bf0f756db1148bbf9155f52d898a38c2c4fa52fd21291dc2083bd4f658dc83ffabf8ad406856b9f63dfe2c27dd1ab037dda42ff5fbf04a5625d95ad75516bfbd3b0e65cf8b5131675dfc6deb734ea8c8ceec8d23344380e3f21f34a6a12f58455d96f805c2c3cf0ab80ffa202ff615b8a9e6216fbe1820850f79c5c7f9a6a71f2d9a69f4704299095613aaf3ad35b0924df86f234169e06361f5f2e09ebb09812a27a0bbb08610ec4a2ffeae13189012fd7cdb9ca00d5c73e05109987495cb485a7a55e1956b24dcb6e77d6433971e5189f75635ae3f99f21aebfc74e03ca879e41d7abf0d70b93fc359590bab8242b499d407bd5b9222b7d475c16dd8cbe4e634fd15b0ec3a07d324dfa4da11d35199eb482abe378388eb0d6dd38bf5d62b504321c5a704e3eae1f612a147d1f9fbe2b6f01a205ed1540673c4faaa231ed9909dbe53ac68325b666362ab980306e4f02b57aa8f543d3554ca4422b17cb6074a568639e42cad0c249a02d18b784cb152c32694aab0cffb642427d58c6e7f103d24b2ce5d7f0c588fe647afef8392e65847e4b3f62255e194f98c63b2c7c9755a27465d440cec976b642ef67fa5c2edd07f5fa04acd8e49d03366abbc4de346a2fbd79d09d40b4cade535af3e79e2c2fb1f6c993f0a796b4391e0360d90f0bf616b85948815411708d1086a49a875c461fc22743e47eb0285c1670bc473fe2705fc0804df96821c3e642f6bf9b6a6f47fceb9d0b4c38e30cbe96db69776d29af6cb6bbc3375621610ade96cb37cdcb805cac0ac739ea17e9393628ca4fe4b43a0526bedb44428a8b4e12d4d6b8e1ae3ccd3f5ca2ded0c7e25438688939de93f39750c4c6b5a2c1f7359ad84fb7b8887c628710b5d726c7ba947bd28597a377dcb25dc22495f85386abb1744d583739263319eaf70e69bcbb98d0ac416738197d98845944293978640bb766367fc8c81ac37359c67e407678cbfa6e8ec4fe9c4e1199bde8e59e6c8c9e8cd09fc46f3c8135bccf9d39f4b3c9187a17f843689e812e068e9d22522cea86479698e5b8005d9164b12c3d1c6d7703c690d5e7b1cdfb5ec8f068996b26da02135e208cc7ef3af4e8120eae9836fcb7c7d66ef1c89926a387bc5e5f3b160d37185a73b38707002af6827cf5436ab3b4aa556a11520f7a9f40826f042c78c6ce841be92d31ffb2924fd3a3814960ade7b87755c50f8e988b206862104a5407619de3aecaea82a3d2b09d9b8b51ece4aefb53b6bfc1206ebd1492ae855fe7abaff5ee82b67bbd1bdf2b265b0131de906a5f51034b8f65b26d8c7255ca0ee748684a369d902729a7aa66cd55781c85300ef8d0b1b31e6223399d2eeb0f637372d6c40902df49f1c2acef1ddcc4356fba69e34df8befaa9bf51095502d3e0a85861f4120c7977adaf1e4f8c618b6428ddf7a838909801556046f2bff8571e750a4f5b7447b5e32c8a42250b33bc2f9a0ef2895826c5bd0cfdfdd0aa52be194c6e5eddcd9b185acaa9ff6c353875c384445041c42d146b68554c40960481947f1f935d89c6bfac430b2f8b6b1d7806bc7784a2e44b3937040dea3c374b7dce4f35a21d391c192cf67a1234bb9258b223f9609f70e538b42d7effe344a579052a0a581a95340ffcc14496add82b222d59f192b7b4d3c5ab35ad266deb4bf2d1b00185ccaf3b8f922be3f52ca6f223bf18bcffdd207c1c3cc3009eba4b75605f418e2e235357dd5fb5914da3f64bbc765742f586f5c18de90eebd0e2e7918b783b97c5c93de50e4aac0199a9a8c8b74bae1e8e036880c5a2071195333c7f9818eeb83c955d299f3aaa72602bb19147626b11dbc010e71035cb6f7bb4a5a13f627f97f93731bb201d4814dafa579fb1808d9da08d1045a494579ed85f3f1a4568ce7aad372b326a095118a97e549fcf9b5afe29df31e00450ae82e8f60a6a47575f44bbc07079f27d83579834d8d81c2f70a4cfc69d81d6ad04ce844b5519fd16d0f66956d150159c1ddc9b7d96e9a27d646525182cc00289159a8ba495c5d480b09b678c74200b6b3fe54a9a3e0421df510daf24eb29c26acf2e890c7edf9253453c99740e36e1ed74933438cd25c273d2f8a6536d81319267d735151e33453afc7e09ce72c2118a732999243bdaa1cc0bf4253a878c344b08a6f0aeae937f4ddb749eca398a8afb2df4fb25a1701f0dcaa313c9b664d5eb6ec155ead699088562c4d0cd49abbd0d446c59e7ad7258078858f287728392d56aa511252938671c3b03cfc4dae47eccdec1e6cfc84e2809b052a655d2d4b57721a3420a90b80df79b297b5b9dec94f194720325212b9903c5829f903798d4af8e66762073b741136486fc6ce06d5b8b3c06385daeb1a3a046d813a97a610c6e68491da2e5a359ff3e1486c9c3e49492e1142a9127ca0c09bf75226eddfd636547a3d24c9f0185576098547c15a33b69cb1a0c3da5263b6e18ddc6d7a6ddf8958503768d204c83acbfedcc1897d0de64936ce9df2285a7cfd506584fa5d54dd1686f7c5ae4210e0bd3f2ab2803f7b22b8118a2dce9551b506cef78a867dc760dee898b4ac4f0befe6facb570e023c7cd05278804ac8b570b165814e31d7597aabffc8b4a1bd065d97d0e4640e7c0205436c631b0767a819459391741b95c0d71ef5b7dca4bea74e9002c895313e3704ffd7115e861a4e4811704f9129f08456207f33645ffdd05011f552b6b52f6a0aacaa7a763032093af95b29d401d5dd05aba531b750244fafe9968a6ea3c3a5d82d34eda031345510264abd2332cfb91edd478b398dd1a734312a9063189e64a49a4a85a75a7ff27236b5d65c7ce41ff57eb886665e4613e695cbb13ab533d086f142768723e6887e102b1f26cece7d5034bfd10d968ff8c9b26bcfa3bccaec286c8e64251316c312ad451d5d4fd4acacac6a77ed4b2af8f4b0177523148eceb0d7d75860e8715b13a7fa947995020223926730fd15836f2dfd78bd87ecaf80532ccdeabf869bda2f6e7c0d287a5aad865af7f64751df0b9a62c33cbbd8bd078ab5e5cb5a59a918254992596c7dcb98d6ff3a8660eb1f716f191b93e1121560870ad02c957356a32b84d717fb109f01de8bef8b37b24e5b9f1af86f1e22f5e054d6ff85bff0892575eb135eb77ff449d1231f565177eb63f870bcb9249dfaf5d641bf93007441518e87ff0ad59a3ac076d4db3c2aeb5f773a8d7c82e7f4609aaa4a383f39cceb8f475409a3ef0534907039831e38e3c33c336faba53b7cf49d6dbc3acf838e4f96531f48692aaa22b4a27ae002411f6ef2a09b9aeefed1900739083ff21ba3d67253eea307971334e42860f6526173312ab1046f93f9874d2b264ba122eb7cde8ead49af1a78985b77555d2e9a45556440a1c05f1ac80704c4a8681016c0bc13ee5962bb09fd972e4fc76ce3d0288483cea3fa467d8ede6de6a2b1e94ea1462032e4a422f9239eeb1851adb3d52d4c92e966a13d64179e98db795a07a0f7d805a1e98a80b9004fd741fcdb17cf3c1a06347ae9e28d6c1e98db5f17114f8ba0836432249b62ef369dad4d93bb7b5143530ac4d7d250ee792ade8f0144e411d186374525044558c3a217cfc44b14e957fa148134e3c24525968b77b5f66b440f5b55ee99c167f94c031fd68172f8ab5354fec81091f8e1f7550e831dfa8eafdeb67849c5dff3ba6d42d3fb63ae5532bcc42718c3837886749ef3cff63c9d24984f8405336b02429299540879f35e5c94a93246c5a3fad6787a9519a27d9281c8e8a47aa6d6e695924066347b379ab40eaf527e3a543d4083a707f87107b46946b09ec6ffb0a7c6247332c479a3a26077a0b99c066e7d98ff02772bbba9c1f8aedf7f2a4c91d7da182834a3ad49ae4480f97c7b0707ac846ba5075d6b072bb5184836a49d7d0e97ca7619b25a438159611627422a6b76a86a677f89158a00c38e472d46a5eec6876c02a87ffd146d7da310c0e0eda84ce4652f578bf4319e30692a8887ea889c39dfe924d914519dceb72558335bad846694e8e89654ced0a7065dedc87fbb25cd716afecaab286b42782fbd754ea86e75013f3dfb146101e8a94aa0f83185f63d10d89f8d633f61b0120cf66368f939f5474324a871fe90254dbf5a0bb3562ca878486dfa32687d2185b774d54cb401c06e25b257ce01db48d43acda7c7dd8c91874ce5889a0e0c09b06c756f2201939e590882e855673522980173da60e1478e31f2dea888f2eca09cc4254662b63b5694416b66c517530e95a29b745b0fa30c277a460c6a4f8133cad39b784e0b79b3eaef3f5bdf2dfa9d2b118554160954f4c817f5bad4aaba4663da906ab5e7c83edf38b3df3e5b64bc3e9a53ff0244796d89c61cc5674a0d692c3db72f849794669b6e308e34868c71f54770ad9782bafd43249974acb8b998dc1934f5473be9a7ad99eec1cce16523595e7c3f473a91f160857f8463c088d1daf95a23f97f997b61fcfaf96d390e2ceac97dbe0afc2912e3757209665c0312d0552f433a86bdbf1584e829ed9822b9ced01cdb2d1e870b3d0e8223951ee86111ca5ec17fe459d0cc6322f92261aff1d85997133a7d1e2fe77c8e2a76f4f76eaf675760cff928a3f238773515a858809b299e3829da657f8b5638059b456553cda53cf4ec26fa3b841cba5da25aa3df983d82efadbe61155a17a5832256277f957097b3d953b79b6a94d8dce55430511a6b0d69b5b7485991cad3bc9f5b7efec31c023ac54cb19e865ceff512fadad3b3e7b3a9f59e46805b0a1c775e4128f4cb1655cef0640bdcc7a98497eb092440d85a291e29efd2a55bdc4bfb727b73249e349d9505639a86257f6da1c7f5e867c75fc71a6d25344b02614ee1b405f87ab9438e2d6213bed9b998db532f63d3b34efa2e533a424ee0745d759a40f9c66db271290e355b670f120bb5720919a431ac13d4265bb250478641161024e0e1d938e743ece2bac20606edb1ffcdefbfd8fb80d34185c078988241bdec6269e95f41cf76e8799eef2eda28612687dbebabff9d02094146e65a4d683f58acce88a3a99fb375d8a2af15352865363bdcc10edea638bf73ad9d770cea598c5130119f580d85c20aa14e524c4ec959500296187b91a95db69ca3aeb61c2f87d0ad7b30f3125623d8646763ab3ed989ef88ef91e246e9437d31cc613ca461a611c091a700bf6b18526b8bd16105efa95c819288c1ea94376d6428d056724de8e8a718f602e61517a45deaedd1b1895fec8c4f2c31ffadd9945bcf769af78ebacdf33512aba47f90dc53370b21ab9ff591befb1ac14eb09a944fa0ddd98f628da9542b328869780dd963b25c84e682759e654b00eaf63fac235481842df4474510eae454f6a4c212007e9830062561bf0e360f465870f9f8aafc049413ba308ca5a9b63e4288004f016519c7a07559f70e39cf816bbd8e03fda1517a13c6ab602a38cfd9ca93ac55d191cf6c51bcf17e12dd4b8a7e6d13411bf3aad8515b91d0a15991a058bec04634fbaa2499e6f0b4cb6d9d4993fc3205f5b7b235ff15ababd23a40fdd5be92bbba1e8d12fa15226d9b03dba0426e17a7cf9f829c77c673ee4ba97ff6eaecb2d99ce4df74b26acdce98af366c9747ffc5b923506428828a21446d53d271803b92ea0732839ee1baae2dec5a9e9eaf7f76388552cd6152143060096420785c6121b53f4e89160b242c0d56a352cbb484e07eea3f771a83562d701da6317f423f85433b27a2a0c6d2f8b7ecd2dbdd23ea82633bda959644eea334bc08c883f99efc15bb4257550f195445c355f72db1c2d531ef6b0ecb7412c7227b8e566446ebc716e48be88db04b5fca813d6a1be4511b8d0148ba383dd61edfeeb9b41a28ef51b59f067489072d1f609d61cef493881362f4f5216255a73d8de21fcbfe5bf84c7e09c5c86516d482a4c567d02a383cb785bc1bc8b31716503909fac8ea34011ffad4a7e99d55670b83ce2e547e8b35efccb735bcb769f9ebea96350406cb53e08bad5fee2bf636dab7335220f043606dfe6c0b2b5befb5d2e8cdbbb94bf4468162f1170f502c1df275057bd83463270004a97d19dce329d5cfb6d84d74d36dd522b3c8b2144aebd62b1935c662cbdd75f2b6153cd7b6b401e42dc0a24687415cf84e63dcc531f5fa7069c67bf8c952acb3cde2f9d32b33357eb583696bbd7cba9a68cfd979fb7bdea162e1bf819dc69f1fde934adf069cb9b600d00e0f0ae1bcc029fef8f170af70f07061cf74b4abdb483eee4b11bb4c3ffdb949355bb69c12748995d9eb667e43cb49b66d473c5ff2e3d5dc91bc1c41feb78dc96f8a8a7c8768bb83b2629c51eaf3e62af36f22a35a22d51128182bc9c6f7ab0139a87d0522e3202a6b2e84ea6d35d35bd2086dba04889836d827740b09657861819efa112ce7eb3a582ec781c1f931e0a2a115749dbdbc93cd7805be63f611ac8fad15c745c725a83fbd68e5fbf7dbb307c0b80b735834ccd803aa5f50351fbc4b06f9b0065755cf61e986000fdacce813ace316b1d7f35f7cf2a170cbbdbbbffcaa1b2278fef1986d7c2740409c96f7229376897fd8fd9815b482936a64ede30eac48d933c5da62c56f1fc463c20cfa32e1de0a9d18d12f78e28e474f911939305bae254779398c59ac8eb868d340095fc9a52a7c572fcd5bfeea83841799340d2d2aa389bf780c80d274cbb8adf6f5d06551d304ad90a3bab7fa6e0f9fb9ff0e79208f92951e6d9943b62cb08a02a3ba5d0870f36be72335572c275ea5276ad8dfb95ed8f29102efccd1bf113d338d134eb879790fcc56560b9745d1b220f9a0f7ce08bb238f609e05631715d4fe33b4feec77ca9c0b6f1635f0fdea51d6862791e485e79e3bb8b51612329b8fe8da682c83c137224d0ee0057fbf7f57ec2f78db6bf11372bd04c078f20f9d9ddb87d68a56aa4bf5ffe49ae097ab1b5f23f49646d1275c3e6edbb7fb252727c4cab741a68095fc91261ed882cbd50a47dede712d912cb34c6399b5ebd0a24ff647a346067d82cf849dbc3a6972699c9dca60e96b2953d23f865199b471815bc5cdca70b0d993c2f6ae446a275fe73dfef1357d78b3137d7cd37d7a0b37c99d280323a7891f48d03198fdc85a4ec54fba0122048ffd49ae42bc0699062ea431b6d46b08cfe62edee882ac8910cfd70997416d2896f2400f28e4fcf2ba7b55bf9b3db3f6025c313207bf19395870faa2081</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">未完结</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>数据库</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>内存</tag>
        <tag>sql</tag>
        <tag>CPU</tag>
        <tag>指针</tag>
        <tag>Mysql</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>ACID是靠什么保证的</title>
    <url>/posts/KZ41HP.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><div style="text-align: center;"></div><br><span id="more"></span></p>
<blockquote>
<p>ACID，事务的四大特性：原子性，一致性，隔离性，持久性</p>
</blockquote>
<ul>
<li><p>原子性<br>原子性是由undolog日志来保证的，它记录了需要回滚的日志信息，事务回滚时撤销已经执行成功的SQL。</p>
</li>
<li><p>一致性<br>一致性是由其他三个特性保证的，程序代码要保证业务上的一致性。</p>
</li>
<li><p>隔离性<br>隔离性是由MVCC来保证的。</p>
</li>
<li><p>持久性<br>持久性是由redo log来保证的，mysql修改数据的时候会在redolog中记录一条日志数据，就算数据没有保存成功，只要日志保存成功了，数据就不会丢失。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>sql</tag>
        <tag>事务</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>事务并发与事务隔离</title>
    <url>/posts/2EGA14J.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>什么是事务的隔离性？</strong></p>
<p>两个人同时在一个画本上画画，过程中你一笔我一笔，那么最后最后画出来的一定是一个四不像，多个事务同时操作一个数据也会和上面的情况类似，所以为了让不同的事务之间相互不存在干扰，就需要对事务的操作进行隔离，事务的隔离性也就是将操作同一个数据的事务相互分离，让操作之间分开有序的执行</p>
<p><strong>用什么方式实现事务的隔离性</strong></p>
<p>通常数据库里都是采用锁的机制，保证事务之间的隔离性，在一个事务对数据进行修改的时候，首先会对该数据进行加锁，在当前事务没有释放锁之前，后续的事务是无法对该数据再次进行加锁的，所以其它事务只能等待，只有前一个事务释放了锁之后，后面的事务才能进行加锁。通过加锁的方式来保证这种先来后到的顺序，以隔离多个事务对数据的操作，从而实现事务的隔离性。</p>
<h2 id="事务并发问题与事务隔离级别"><a href="#事务并发问题与事务隔离级别" class="headerlink" title="事务并发问题与事务隔离级别"></a><strong>事务并发问题与事务隔离级别</strong></h2><p>在事务并发执行的时候，如果不进行事务隔离，那么就会产生脏写、脏读、重复读、幻读的问题。  为了解决这些问题，数据库也针对不同的场景通过加锁的形式进行了不同程度的隔离，下面我们了解下产生这些问题的根源，然后不同的事务隔离级别是通过什么方式解决这些问题的。</p>
<h3 id="1、脏写问题"><a href="#1、脏写问题" class="headerlink" title="1、脏写问题"></a><strong>1、脏写问题</strong></h3><p>在事务并发的时候，一个事务可以修改另外一个正在进行中的事务的数据，这可能会导致一个写的事务会覆盖另外一个写的事务数据，这也就是脏写问题。</p>
<p><strong>案例：</strong>以存取款为例，假设A与B同用一张银行卡，银行卡内余额为1000，如果两个事务可以对同一个数据进行修改时，可能会产下面 事务B 把事务A的数据覆盖了，导致事务A写入的数据丢失了。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1107-Qd4URl.jpg" alt="img"></p>
<h3 id="如何解决脏写问题"><a href="#如何解决脏写问题" class="headerlink" title="如何解决脏写问题"></a><strong>如何解决脏写问题</strong></h3><p>在事务隔离级别<strong>READ_UNCOMMITTED</strong>  解决了脏写的问题，其原理是在READ_UNCOMMITTED事务隔离级别下，当事务对数据进行修改时，首先会对数据加写锁，加写锁成功后只有等事务提交或者回滚后才会释放，所以已经有一个事务对数据加了写锁，那么其他事务就会因为无法获取对应数据的锁而阻塞，所以在READ_UNCOMMITTED事务隔离级别下，多个事务是无法对同一个数据同时进行修改。</p>
<h3 id="2、脏读问题"><a href="#2、脏读问题" class="headerlink" title="2、脏读问题"></a><strong>2、脏读问题</strong></h3><p>在事务并发的时候，一个事务可以读取到另外一个正在进行中的事务数据，这产生了脏读问题。</p>
<p><strong>案例：</strong> 以存取款为例，假设A与B同用一张银行卡，银行卡内余额为1000，此时事务B进行取款，事务A进行存款，如果一个事务可以读取到另外一个正在进行中的事务数据，那么可能产生下面问题。</p>
<p><strong>操作：</strong> </p>
<p>1、事务B：进行取款1000，此时余额为0，但未提交事务。</p>
<p>2、事务A：此时事务A对银行卡余额进行查询，查询到账户余额为0。</p>
<p>3、事务B：撤销事务，余额恢复为1000.</p>
<p>4、事务A：进行存款500，余额=0+500。</p>
<p>5、事务A：提交事务，最后账户余额为500。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1108-wTOpco.jpg" alt="img"></p>
<h3 id="如何解决脏读问题"><a href="#如何解决脏读问题" class="headerlink" title="如何解决脏读问题"></a><strong>如何解决脏读问题</strong></h3><p>在事务隔离级别<strong>READ_COMMITTED</strong>（读提交）解决了脏读的问题，其原理是在READ_COMMITTED的事务隔离级别下，当事务对数据进行修改时，得先要对数据加写锁，当事务读取数据时，首先需要对数据加读锁。 因为写锁与读锁不能共存，所以在修改数据的时候，其它事务会因为无法成功加读锁而阻塞，所以READ_COMMITTED  的事务隔离级别下，一个事务就无法读取另外一个未完成的事务所修改的数据了。</p>
<h3 id="3、不可重复读问题"><a href="#3、不可重复读问题" class="headerlink" title="3、不可重复读问题"></a><strong>3、不可重复读问题</strong></h3><p>在事务并发的时候，一个事务里多次对同一个数据进行读取，但是读取到的结果是不一样的，这种问题称为不可重复读问题。</p>
<p><strong>案例：</strong>  以取款为例，假设A与B同用一张银行卡，银行卡内余额为1000。</p>
<p><strong>操作：</strong> 如下图所示，事务A在同一个事务里两次查询同一条数据，得到的却是不同的结果。</p>
<p>1、事务A：查询银行卡余额为1000.</p>
<p>3、事务B：取款1000。</p>
<p>4、事务B：提交事务（此时余额为0）。</p>
<p>5、事务A：查询余额，余额为0。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1108-xGDuCw.jpg" alt="img"></p>
<h3 id="如何解决不可重复读"><a href="#如何解决不可重复读" class="headerlink" title="如何解决不可重复读"></a><strong>如何解决不可重复读</strong></h3><p>不可重复读产生的核心问题是，在一个事务第1次读取和第2次读取数据的间隔过程中可以被另外一个事务修改，因为在READ_COMMITTED的事务隔离级别下，事务中每次读取数据结束后（事务未结束）就会释放读锁，而一旦读锁释放后另外一个事务就可以加写锁，最终导致事务中多次读取该数据的间隙中可以被其它事务修改。</p>
<p>而<strong>REPEATABLE_READ</strong> <strong>（可重复读）</strong>的事务隔离级别下，一个事务中的读取操作会对数据加读锁（并且在当前事务结束之前不会释放），此时另外一个事务对该数据修改之前会尝试加写锁（此时不会成功，因为读写锁冲突），所以就避免了一个事务多次读取的数据的间隔可以被另外一个事务修改。</p>
<p>不过实际实现的过程中，数据库解决不可重复读的方式会有所不同，在Mysql  innodb引擎中，解决不可重复读的问题并不是通过加锁实现，而是通过MVCC机制实现，使用MVCC后读取数据的时候不会加读锁，而是读取的历史版本数据，在RR事务隔离级别里，MVCC保证了在一个事务里多次读取的数据历史版本是一致的，所以就无法看到最新修改的数据，这样也就保证了一个事务里多次读取到的数据肯定是一致的。   具体MVCC实现原理参考：<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81Mjk3Nzg2Mg==">勤劳的小手：数据库基础（四）Innodb MVCC实现原理<i class="fa fa-external-link-alt"></i></span></p>
<h3 id="4、幻读问题"><a href="#4、幻读问题" class="headerlink" title="4、幻读问题"></a><strong>4、幻读问题</strong></h3><p>在事务并发的时候，一个事务可以往另外一个正在读取的事务查询范围内插入新数据，导致另外一个事务在第二次查询数据里，要比前一次查询的数据要多，同样的SQL后面一次查询凭空多出了数据，像幻觉一样所以称为幻读。</p>
<p><strong>案例：</strong> 以打印银行卡账单存款记录为例，假设A与B同用一张银行卡，银行卡内存款记录为两条。</p>
<p><strong>操作：</strong> 如下图所示，存款表有2条数据，A对存款表进行读取，  当A第一次读取到存款记录的时候只有2条数据； 但是与此同时B往银行卡进行了一笔存款然后提交了事务，在B提交了存款事务之后，A执行了打印操  作，最后发现打印存款表信息的时候却发现有3条数据，与之前查出的数据不一样，这种平白无故多出来 的数据就好象发生了幻觉一样所以称为幻读；</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1108-3p8bmU.png" alt="img"></p>
<h3 id="解决幻读的两种方式"><a href="#解决幻读的两种方式" class="headerlink" title="解决幻读的两种方式"></a><strong>解决幻读的两种方式</strong></h3><h3 id="1、设置事务隔离级别为SERIALIZABLE"><a href="#1、设置事务隔离级别为SERIALIZABLE" class="headerlink" title="1、设置事务隔离级别为SERIALIZABLE"></a><strong>1、设置事务隔离级别为SERIALIZABLE</strong></h3><p>在SERIALIZABLE事务隔离级别下，所有的事务都串行化执行，一个事务的执行必须等前面的事务结束，这样的话查询的时候就无法有其他事务查询新的数据，所以不会产生幻读问题。</p>
<h3 id="2、加间隙锁"><a href="#2、加间隙锁" class="headerlink" title="2、加间隙锁"></a><strong>2、加间隙锁</strong></h3><p>幻读问题的本质在于，没有对查询范围内的所有数据进  (包括不存在的数据）进行加锁，而导致改查询范围内可以被插入新的数据，所以使用间隙锁，对查询的范围进行加锁，此时新插入的数据的事务会因为无法加锁成功而阻塞，所以就避免了幻读。比如表数据如下图， 那么此时如果执行select * from user where id&gt;2 时  ，间隙锁会对id&gt;2的空间加锁，所以此时我们另外一个事务插入ID为3 、4、6、7……. 都会因为锁阻塞而无法成功。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1109-VOwtZ0.jpg" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>为解决不同场景的并发事务问题，事务定义了四种隔离级别，每个隔离级别都针对事务并发问题中的一种或几种进行解决，事务级别越高，解决的并发事务问题也就越多，同时也意味着加的锁就越多，所以性能也会越差。不同的隔离级别下它们加锁的情况如下：</p>
<h3 id="READ-UNCOMMITTED"><a href="#READ-UNCOMMITTED" class="headerlink" title="READ_UNCOMMITTED"></a><strong>READ_UNCOMMITTED</strong></h3><p>事务读取：不加锁</p>
<p>事务写入：加写锁</p>
<p>解决问题：脏写</p>
<p>存在问题：脏读，不可重复读、幻读。</p>
<h3 id="READ-COMMITTED"><a href="#READ-COMMITTED" class="headerlink" title="READ_COMMITTED"></a><strong>READ_COMMITTED</strong></h3><p>事务读取：加读锁（每次select完成都会释放读锁）</p>
<p>事务写入：加写锁</p>
<p>解决问题：脏写、脏读</p>
<p>存在问题：不可重复读、幻读。</p>
<h3 id="REPEATABLE-READ"><a href="#REPEATABLE-READ" class="headerlink" title="REPEATABLE_READ"></a><strong>REPEATABLE_READ</strong></h3><p>事务读取：加读锁（每次select完不会释放锁，而是事务结束后才释放）（如果是Mysql的innodb还会加间隙锁）。</p>
<p>事务写入：加写锁</p>
<p>解决问题：脏写、脏读、不可重复读，幻读（如果是Mysql的innodb则已解决）</p>
<p>存在问题：幻读 （如果是Mysql的innodb则不存在）。</p>
<h3 id="SERIALIZABLE"><a href="#SERIALIZABLE" class="headerlink" title="SERIALIZABLE"></a><strong>SERIALIZABLE</strong></h3><p>不管读取还是修改所有的事务串行化执行，一个事务的执行必须等其他事务结束。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>内存</tag>
        <tag>sql</tag>
        <tag>事务</tag>
        <tag>数据库</tag>
        <tag>Mysql</tag>
        <tag>锁</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql里的锁</title>
    <url>/posts/3K8NATX.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>加锁的目的是什么</strong></p>
<p>在了解数据库锁之前，首先我们必须要明白加锁的是为了解决什么问题，如果你还不清楚的话，那么从现在开始你就知道了，对数据加锁是为了解决事务的隔离性问题，让事务之间相互不影响，每个事务进行操作的时候都必须先对数据加上一把锁，防止其他事务同时操作数据。如果你想一个人静一静，不被别人打扰，那么请在你的房门上加上一把锁。</p>
<h2 id="锁实是基于什么实现的"><a href="#锁实是基于什么实现的" class="headerlink" title="锁实是基于什么实现的?"></a><strong>锁实是基于什么实现的?</strong></h2><p>为了后面大家后面对锁理解的更透彻，所以必须要先解决这个问题，现实生活中家里的锁是锁在门上的，那么数据库的锁又是加在了哪里呢？我在这里可以告诉你，数据库里面的锁是基于索引实现的，在Innodb中我们的锁都是作用在索引上面的，当我们的SQL命中索引时，那么锁住的就是命中条件内的索引节点(行锁)，如果没有命中索引的话，那我们锁的就是整个索引树（表锁），如下图一下锁住的是整棵树还是某几个节点，完全取决于你的条件是否有命中到对应的索引节点。</p>
<p><strong>innodb索引结构图(B+ tree):</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1029-UQSDtz.jpg" alt="img"></p>
<h2 id="锁的分类。"><a href="#锁的分类。" class="headerlink" title="锁的分类。"></a><strong>锁的分类。</strong></h2><p>数据库里有的锁有很多种，为了方面理解，所以我根据其相关性”人为”的对锁进行了一个分类，分别如下</p>
<p>基于锁的属性分类：共享锁、排他锁。</p>
<p>基于锁的粒度分类：表锁、行锁、记录锁、间隙锁、临键锁。</p>
<p>基于锁的状态分类：意向共享锁、意向排它锁。</p>
<h2 id="属性锁"><a href="#属性锁" class="headerlink" title="属性锁"></a><strong>属性锁</strong></h2><h3 id="共享锁-Share-Lock"><a href="#共享锁-Share-Lock" class="headerlink" title="共享锁(Share Lock)"></a><strong>共享锁(Share Lock)</strong></h3><p>共享锁又称读锁，简称S锁。当一个事务对数据加上读锁之后，其他事务只能对该数据加读锁，而无法对数据加写锁，直到所有的读锁释放之后其他事务才能对其进行加持写锁。  加了共享锁之后，无法再加排它锁，这也就可以避免读取数据的时候会被其它事务修改，从而导致重复读问题。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1029-C3JaXH.jpg" alt="img"></p>
<h3 id="排他锁（eXclusive-Lock）"><a href="#排他锁（eXclusive-Lock）" class="headerlink" title="排他锁（eXclusive Lock）"></a><strong>排他锁（eXclusive Lock）</strong></h3><p>排他锁又称写锁，简称X锁；当一个事务对数据加上写锁之后，其他事务将不能再为数据加任何锁，直到该锁释放之后，其他事务才能对数据进行加锁。加了排他锁之后，其它事务就无法再对数进行读取和修改，所以也就出现脏写和脏读的问题。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1030-7folzQ.jpg" alt="img"></p>
<h2 id="粒度锁"><a href="#粒度锁" class="headerlink" title="粒度锁"></a><strong>粒度锁</strong></h2><h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a><strong>表锁</strong></h2><p>表锁是指上锁的时候锁住的是整个表，当下一个事务访问该表的时候，必须等前一个事务释放了锁才能进行对表进行访问；</p>
<p>特点： 粒度大，加锁简单，容易冲突；</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1030-PJKzGs.jpg" alt="img"></p>
<h2 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a><strong>行锁</strong></h2><p>行锁是对所有行级别锁的一个统称，比如下面说的记录锁、间隙锁、临键锁都是属于行锁，  行锁是指加锁的时候锁住的是表的某一行或多行记录，多个事务访问同一张表时，只有被锁住的记录不能访问，其他的记录可正常访问；</p>
<p>特点：粒度小，加锁比表锁麻烦，不容易冲突，相比表锁支持的并发要高；</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1031-BPV25T.jpg" alt="img"></p>
<h2 id="记录锁-Record-Lock"><a href="#记录锁-Record-Lock" class="headerlink" title="记录锁(Record Lock)"></a><strong>记录锁(Record Lock)</strong></h2><p>记录锁属于行锁中的一种，记录锁的范围只是表中的某一条记录，记录锁是说事务在加锁后锁住的只是表的某一条记录。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1031-a3WNay.jpg" alt="img"></p>
<p><strong>触发条件：</strong>精准条件命中，并且命中索引；</p>
<p><strong>例如：</strong><code>update  user_info  set name=’张三’  where id=1</code> ,这里的id是索引。</p>
<p><strong>记录锁的作用：</strong>加了记录锁之后数据可以避免数据在查询的时候被修改的重复读问题，也避免了在修改的事务未提交前被其他事务读取的脏读问题。</p>
<h2 id="间隙锁-Gap-Lock"><a href="#间隙锁-Gap-Lock" class="headerlink" title="间隙锁(Gap Lock)"></a><strong>间隙锁(Gap Lock)</strong></h2><p>间隙锁属于行锁中的一种，间隙锁是在事务加锁后其锁住的是表记录的某一个区间，当表的相邻ID之间出现空隙则会形成一个区间，遵循左开右闭原则。</p>
<p>比如下面的表里面的数据ID 为 1,4,5,7,10 ,那么会形成以下几个间隙区间，-n-1区间，1-4区间，7-10区间，10-n区间 （-n代表负无穷大，n代表正无穷大）</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1032-pesciR.jpg" alt="img"></p>
<p><strong>触发条件：</strong>范围查询，查询条件必须命中索引、间隙锁只会出现在REPEATABLE_READ（重复读)的事务级别中。</p>
<p><strong>例如</strong>：对应上图的表执行<code>select * from  user_info   where id&gt;1 and id&lt;4</code>(这里的id是唯一索引) ，这个SQL查询不到对应的记录，那么此时会使用间隙锁。  </p>
<p><strong>间隙锁作用</strong>：防止幻读问题，事务并发的时候，如果没有间隙锁，就会发生如下图的问题，在同一个事务里，A事务的两次查询出的结果会不一样。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1032-RaUbEx.jpg" alt="img"></p>
<h2 id="临键锁-Next-Key-Lock"><a href="#临键锁-Next-Key-Lock" class="headerlink" title="临键锁(Next-Key Lock)"></a><strong>临键锁(Next-Key Lock)</strong></h2><p>临键锁也属于行锁的一种，并且它是INNODB的行锁默认算法，总结来说它就是记录锁和间隙锁的组合，临键锁会把查询出来的记录锁住，同时也会把该范围查询内的所有间隙空间也会锁住，再之它会把相邻的下一个区间也会锁住。</p>
<p><strong>例如：</strong>下面表的数据执行 <code>select * from user_info where id&gt;1 and id&lt;=13 for update ;</code></p>
<p>会锁住ID为5,10的记录；同时会锁住，1至5,5至10,10至15的区间。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1033-cQMHbj.jpg" alt="img"></p>
<p><strong>触发条件：</strong>范围查询，条件命中了索引。</p>
<p><strong>临键锁的作用：</strong>结合记录锁和间隙锁的特性，临键锁避免了在范围查询时出现脏读、重复读、幻读问题。加了临键锁之后，在范围区间内数据不允许被修改和插入。</p>
<h2 id="状态锁"><a href="#状态锁" class="headerlink" title="状态锁"></a><strong>状态锁</strong></h2><p>状态锁包括意向共享锁和意向排它锁，把他们区分为状态锁的一个核心逻辑，是因为这两个锁都是都是描述是否可以对某一个表进行加表锁的状态。</p>
<p><strong>意向锁的解释</strong>：当一个事务试图对<strong>整个表</strong>进行加锁（共享锁或排它锁）之前，首先需要获得对应类型的意向锁（意向共享锁或意向共享锁） </p>
<h3 id="意向共享锁"><a href="#意向共享锁" class="headerlink" title="意向共享锁"></a><strong>意向共享锁</strong></h3><p>当一个事务试图对<strong>整个表</strong>进行加共享锁之前，首先需要获得这个表的意向共享锁。</p>
<h3 id="意向排他锁"><a href="#意向排他锁" class="headerlink" title="意向排他锁"></a><strong>意向排他锁</strong></h3><p>当一个事务试图对<strong>整个表</strong>进行加排它锁之前，首先需要获得这个表的意向排它锁。</p>
<h3 id="为什么我们需要意向锁？"><a href="#为什么我们需要意向锁？" class="headerlink" title="为什么我们需要意向锁？"></a><strong>为什么我们需要意向锁？</strong></h3><p>意向锁光从概念上可能有点难理解，所以我们有必要从一个案例来分析其作用，这里首先我们先要有一个概念那就是innodb加锁的方式是基于索引，并且加锁粒度是行锁，然后我们来看下面的案例。</p>
<p><strong>第一步：</strong></p>
<p>事务A对user_info表执行一个SQL:update user_info set name =”张三” where id=6  加锁情况如下图;</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1034-ec6pp9.jpg" alt="img"></p>
<p><strong>第二步：</strong></p>
<p>与此同时数据库又接收到事务B修改数据的请求：SQL: update user_info set name =”李四”；</p>
<p>1、因为事务B是对整个表进行修改操作，那么此SQL是需要对整个表进行加排它锁的（update加锁类型为排他锁）；</p>
<p>2、我们首先做的第一件事是先检查这个表有没有被别的事务锁住，只要有事务对表里的任何一行数据加了共享锁或排他锁我们就无法对整个表加锁（<strong>排他锁不能与任何属性的锁兼容</strong>）<strong>。</strong></p>
<p>3、因为INNODB锁的机制是基于行锁，那么这个时候我们会对整个索引每个节点一个个检查，我们需要检查每个节点是否被别的事务加了共享锁或排它锁。</p>
<p>4、最后检查到索引ID为6的节点被事务A锁住了，最后导致事务B只能等待事务A锁的释放才能进行加锁操作。</p>
<p><strong>思考：</strong></p>
<p>在A事务的操作过程中，后面的每个需要对user_info加持表锁的事务都需要遍历整个索引树才能知道自己是否能够进行加锁，这种方式是不是太浪费时间和损耗数据库性能了？ </p>
<p><strong>所以就有了意向锁的概念：</strong>如果当事务A加锁成功之后就设置一个状态告诉后面的人，已经有人对表里的行加了一个排他锁了，你们不能对整个表加共享锁或排它锁了，那么后面需要对整个表加锁的人只需要获取这个状态就知道自己是不是可以对表加锁，避免了对整个索引树的每个节点扫描是否加锁，而这个状态就是我们的意向锁。</p>
<p><strong>在测试锁的实操过程中需要注意的问题。</strong></p>
<p>看了这么多理论，相信很多人都会去实际操作一下，一是验证逻辑，而是加深自己的理解，为了避免大家少踩坑，在这里提醒几个需要注意的地方。</p>
<p>1、关闭自动提交事务功能，自己手动begin   commit  rollback。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;autocommit&#x27;</span></span><br><span class="line"><span class="keyword">Set</span> autocommit <span class="operator">=</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span></span><br></pre></td></tr></table></figure>
<p>2、查看当前会话隔离级别是否为REPEATABLE-READ（一般默认都是此级别）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@tx</span>_isolation</span><br></pre></td></tr></table></figure>
<p>3、最重要的一点，查询数据的时候要使用当前读（因为Mysql 有MVCC的机制所以很多情况下都不会进行加锁，使用当前读就不会使用MVCC） 比如使用下面这个 for update 就是使用当前读。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_user <span class="keyword">where</span> id<span class="operator">&gt;</span><span class="number">3</span> <span class="keyword">and</span> id<span class="operator">&lt;</span><span class="number">10</span> <span class="keyword">for</span> update</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>原文：<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81MjMxMjM3Ng==">数据库基础（三）Mysql里的锁 - 知乎<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>sql</tag>
        <tag>事务</tag>
        <tag>数据库</tag>
        <tag>Mysql</tag>
        <tag>锁</tag>
        <tag>索引</tag>
        <tag>并发</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Innodb的MVCC实现原理</title>
    <url>/posts/VQ077V.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>理解MVCC之前，我们需要回顾了解一下数据库的一些其他相关知识点</p>
<p>（1）数据库为什么要有事务？</p>
<p>为了保证数据最终的一致性。</p>
<p>（2）事务包括哪几个特性？</p>
<p>原子性、隔离性、一致性、持久性。</p>
<p>（3）事务的并发引起了哪些问题？</p>
<p>事务并发会引起脏读、重复读、幻读问题。</p>
<p>（4）怎么解决事务并发出现的问题？</p>
<p>设置事务隔离级别，读未提交，读提交，重复读，序列化</p>
<p>（5）数据库通过什么方式保证了事务的隔离性？</p>
<p>通过加锁来实现事务的隔离性。 </p>
<p>（6）频繁的加锁会带来什么问题？</p>
<p>读数据的时候没办法修改。修改数据的时候没办法读取，极大的降低了数据库性能。</p>
<p>（7）数据库是如何解决加锁后的性能问题的？</p>
<p>MVCC 多版本控制实现读取数据不用加锁， 可以让读取数据同时修改。修改数据时同时可读取。</p>
<h2 id="一、什么是MVCC？"><a href="#一、什么是MVCC？" class="headerlink" title="一、什么是MVCC？"></a>一、什么是MVCC？</h2><p>MVCC是在并发访问数据库时，通过对数据做多版本管理，避免因为写锁的阻塞而造成读数据的并发阻塞问题。</p>
<p>通俗的讲就是MVCC通过保存数据的历史版本，根据比较版本号来处理数据的是否显示，从而达到读取数据的时候不需要加锁就可以保证事务隔离性的效果</p>
<h2 id="二、Innodb-MVCC实现的核心知识点"><a href="#二、Innodb-MVCC实现的核心知识点" class="headerlink" title="二、Innodb MVCC实现的核心知识点"></a>二、Innodb MVCC实现的核心知识点</h2><p>1、事务版本号</p>
<p>2、表的隐藏列。</p>
<p>3、undo log</p>
<p>4、 read view</p>
<h3 id="2-1、事务版本号"><a href="#2-1、事务版本号" class="headerlink" title="2-1、事务版本号"></a>2-1、事务版本号</h3><p>每次事务开启前都会从数据库获得一个自增长的事务ID，可以从事务ID判断事务的执行先后顺序。</p>
<h3 id="2-2、表格的隐藏列"><a href="#2-2、表格的隐藏列" class="headerlink" title="2-2、表格的隐藏列"></a>2-2、表格的隐藏列</h3><p><strong>DB_TRX_ID:</strong>        记录操作该数据事务的事务ID；</p>
<p><strong>DB_ROLL_PTR：</strong>指向上一个版本数据在undo log 里的位置指针；</p>
<p><strong>DB_ROW_ID:</strong>      隐藏ID ，当创建表没有合适的索引作为聚集索引时，会用该隐藏ID创建聚集索引;</p>
<h3 id="2-3、Undo-log"><a href="#2-3、Undo-log" class="headerlink" title="2-3、Undo log"></a>2-3、Undo log</h3><p>Undo log 主要用于记录数据被修改之前的日志，在表信息修改之前先会把数据拷贝到undo log 里，当事务进行回滚时可以通过undo log 里的日志进行数据还原。</p>
<p><strong>Undo log 的用途</strong></p>
<p>（1）保证事务进行rollback时的原子性和一致性，当事务进行回滚的时候可以用undo log的数据进行恢复。</p>
<p> （2）用于MVCC快照读的数据，在MVCC多版本控制中，通过读取undo log的历史版本数据可以实现不同事务版本号都拥有自己独立的快照数据版本。</p>
<h3 id="2-4、事务版本号、表格的隐藏列、undo-log的关系"><a href="#2-4、事务版本号、表格的隐藏列、undo-log的关系" class="headerlink" title="2-4、事务版本号、表格的隐藏列、undo log的关系"></a>2-4、事务版本号、表格的隐藏列、undo log的关系</h3><p>我们模拟一次数据修改的过程来让我们了解下事务版本号、表格隐藏的列和undo log他们之间的使用关系。</p>
<p><strong>（1）首先准备一张原始原始数据表</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1014-pZjl2q.jpg" alt="1014-F3zJiu"></p>
<p>（2）开启一个事务A： 对user_info表执行 update  user_info set name =“李四”where id=1 会进行如下流程操作</p>
<p>1、首先获得一个事务编号 104</p>
<p>2、把user_info表修改前的数据拷贝到undo log</p>
<p>3、修改user_info表 id=1的数据</p>
<p>4、把修改后的数据事务版本号改成 当前事务版本号，并把DB_ROLL_PTR 地址指向undo log数据地址。</p>
<p>（3）最后执行完结果如图：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1017-gKgh48.jpg" alt="img"></p>
<h3 id="2-5、Read-view"><a href="#2-5、Read-view" class="headerlink" title="2-5、Read view"></a>2-5、Read view</h3><p>在innodb 中每个事务开启后都会得到一个read_view。副本主要保存了当前数据库系统中正处于活跃（没有commit）的事务的ID号，其实简单的说这个副本中保存的是系统中当前不应该被本事务看到的其他事务id列表。</p>
<h3 id="Read-view-的几个重要属性"><a href="#Read-view-的几个重要属性" class="headerlink" title="Read view 的几个重要属性"></a>Read view 的几个重要属性</h3><p><strong>trx_ids:</strong>       当前系统活跃(未提交)事务版本号集合。</p>
<p><strong>low_limit_id:</strong>   创建当前read view 时“当前系统最大<strong>事务版本号</strong>+1”。</p>
<p><strong>up_limit_id:</strong>    创建当前read view 时“系统正处于<strong>活跃事务</strong>最小版本号”</p>
<p><strong>creator_trx_id:</strong>  创建当前read view的事务版本号；</p>
<h3 id="Read-view-匹配条件"><a href="#Read-view-匹配条件" class="headerlink" title="Read view 匹配条件"></a>Read view 匹配条件</h3><p>（1）数据事务ID &lt;up_limit_id 则显示</p>
<p>如果数据事务ID小于read view中的最小活跃事务ID，则可以肯定该数据是在当前事务启之前就已经存在了的,所以可以显示。</p>
<p>（2）数据事务ID&gt;=low_limit_id 则不显示</p>
<p>如果数据事务ID大于read view 中的当前系统的最大事务ID，则说明该数据是在当前read view 创建之后才产生的，所以数据不予显示。</p>
<p>（3） up_limit_id &lt;=<strong>数据事务ID&lt;</strong>low_limit_id  则与活跃事务集合<strong>trx_ids</strong>里匹配</p>
<p>如果数据的事务ID大于最小的活跃事务ID,同时又小于等于系统最大的事务ID，这种情况就说明这个数据有可能是在当前事务开始的时候还没有提交的。</p>
<p>所以这时候我们需要把数据的事务ID与当前read view 中的活跃事务集合trx_ids 匹配:</p>
<p><strong>情况1:</strong>    如果事务ID不存在于trx_ids 集合（则说明read view产生的时候事务已经commit了），这种情况数据则可以显示。</p>
<p><strong>情况2：</strong>  如果事务ID存在trx_ids则说明read view产生的时候数据还没有提交，但是如果数据的事务ID等于creator_trx_id ，那么说明这个数据就是当前事务自己生成的，自己生成的数据自己当然能看见，所以这种情况下此数据也是可以显示的。</p>
<p><strong>情况3：</strong>  如果事务ID既存在trx_ids而且又不等于creator_trx_id那就说明read view产生的时候数据还没有提交，又不是自己生成的，所以这种情况下此数据不能显示。</p>
<p>（4）不满足read view条件时候，从undo log里面获取数据</p>
<p>当数据的事务ID不满足read view条件时候，从undo log里面获取数据的历史版本，然后数据历史版本事务号回头再来和read view 条件匹配 ，直到找到一条满足条件的历史数据，或者找不到则返回空结果；</p>
<h2 id="三、Innodb实现MCC的原理"><a href="#三、Innodb实现MCC的原理" class="headerlink" title="三、Innodb实现MCC的原理"></a>三、Innodb实现MCC的原理</h2><p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1017-C85dvp.jpg" alt="img"></p>
<h3 id="3-1、模拟MVCC实现流程"><a href="#3-1、模拟MVCC实现流程" class="headerlink" title="3-1、模拟MVCC实现流程"></a>3-1、模拟MVCC实现流程</h3><p>下面我们通过开启两个同时进行的事务来模拟MVCC的工作流程。</p>
<p><strong>（1）创建user_info表，插入一条初始化数据</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1017-S1wPS3.jpg" alt="img"></p>
<p><strong>（2）事务A和事务B同时对user_info进行修改和查询操作</strong></p>
<p>事务A：update user_info set name =”李四”</p>
<p>事务B：select * fom user_info where id=1</p>
<p><strong>问题：</strong></p>
<p>先开启事务A ，在事务A修改数据后但未进行commit，此时执行事B。最后返回结果如何。</p>
<p><strong>执行流程如下图：</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1018-WDgWpW.jpg" alt="img"></p>
<p><strong>执行流程说明：</strong></p>
<p><strong>（1）事务A：开启事务，首先得到一个事务编号102；</strong></p>
<p><strong>（2）事务B：开启事务，得到事务编号103；</strong></p>
<p><strong>（3）事务A：进行修改操作，首先把原数据拷贝到undolog,然后对数据进行修改，标记事务编号和上一个数据版本在undo log的地址。</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1018-1vklPX.jpg" alt="img"></p>
<p><strong>（4）事务B： 此时事务B获得一个read view ，read view对应的值如下</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1018-O8GlSP.jpg" alt="1018-OSba8r"></p>
<p><strong>（5）事务B： 执行查询语句，此时得到的是事务A修改后的数据</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1019-GRx57G.jpg" alt="img"></p>
<p><strong>（6）事务B： 把数据与read view进行匹配，</strong></p>
<p>数据事务ID为102 等于up_limit_id （这里不小于up_limit_id）</p>
<p>数据事务ID为102  小于low_limit_id</p>
<p>数据事务ID为102存在于  trx_ids，</p>
<p>数据事务ID为102不等于creator_trx_id</p>
<p>发现不满足read view显示条件，所以从undo lo获取历史版本的数据再和read view进行匹配，最后返回数据如下。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1019-YvOauz.jpg" alt="img"></p>
<h2 id="四、补充"><a href="#四、补充" class="headerlink" title="四、补充"></a>四、补充</h2><h3 id="各种事务隔离级别下的Read-view-工作方式"><a href="#各种事务隔离级别下的Read-view-工作方式" class="headerlink" title="各种事务隔离级别下的Read view 工作方式"></a>各种事务隔离级别下的Read view 工作方式</h3><p>RC(read commit) 级别下同一个事务里面的每一次查询都会获得一个新的read view副本。这样就可能造成同一个事务里前后读取数据可能不一致的问题（重复读）</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1019-x1NF8M.jpg" alt="img"></p>
<p>RR(重复读)级别下的一个事务里只会获取一次read view副本，从而保证每次查询的数据都是一样的。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1019-EwbKQo.jpg" alt="img"></p>
<p>READ_UNCOMMITTED 级别的事务不会获取read view 副本。</p>
<h3 id="快照读和当前读"><a href="#快照读和当前读" class="headerlink" title="快照读和当前读"></a>快照读和当前读</h3><p><strong>快照读</strong></p>
<p>快照读是指读取数据时不是读取最新版本的数据，而是基于历史版本读取的一个快照信息（mysql读取undo log历史版本) ，快照读可以使普通的SELECT 读取数据时不用对表数据进行加锁，从而解决了因为对数据库表的加锁而导致的两个如下问题</p>
<p>1、解决了因加锁导致的修改数据时无法对数据读取问题;</p>
<p>2、解决了因加锁导致读取数据时无法对数据进行修改的问题;</p>
<p><strong>当前读</strong></p>
<p>当前读是读取的数据库最新的数据，当前读和快照读不同，因为要读取最新的数据而且要保证事务的隔离性，所以当前读是需要对数据进行加锁的（Update    delete    insert   select ….lock in share mode   select for update 为当前读）</p>
<h2 id="五、讨论"><a href="#五、讨论" class="headerlink" title="五、讨论"></a>五、讨论</h2><h3 id="MVCC是否有解决幻读问题？"><a href="#MVCC是否有解决幻读问题？" class="headerlink" title="MVCC是否有解决幻读问题？"></a>MVCC是否有解决幻读问题？</h3><p>看到有很多网友对这个话题有讨论，这里补充一下和大家理一理这个问题，首先我通过验证得出来的结论是MVCC不存在幻读问题的，但也并不是说MVCC解决了幻读的问题，经过理论的推断和验证得到的结论是在<strong>快照读的情况下可以避免幻读问题，在当前读的情况下则需要使用间隙锁来解决幻读问题的</strong>。</p>
<h3 id="MVCC不存在幻读问题（RR级别的情况下）"><a href="#MVCC不存在幻读问题（RR级别的情况下）" class="headerlink" title="MVCC不存在幻读问题（RR级别的情况下）"></a>MVCC不存在幻读问题（RR级别的情况下）</h3><p>首先确认一点MVCC属于快照读的，在进行快照读的情况下是不会对数据进行加锁，而是基于事务版本号和undo历史版本读取数据，其实上面的文章已经说得很清楚了，我们根据上面的MVCC流程来推导，无论如何在MVCC的情况下都是不会出现幻读的问题的，如下图。</p>
<p>1、开启事务1，获得事务ID为1。</p>
<p>2、事务1执行查询，得到readview。</p>
<p>3、开始事务2。</p>
<p>4、执行insert。</p>
<p>5、提交事务2。</p>
<p>6、执行事务1的第二次查询 (因为这里是RR级别，所以不会再去获得readview,还是使用第一次获得的readview)</p>
<p>7、最后得到的结果是，插入的数据不会显示，因为插入的数据事务ID大于等于 readview里的最大活跃事务ID。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1020-iIrKAA.jpg" alt="img"></p>
<p><strong>实际案例：</strong></p>
<p>首先关闭数据库的自动提交事务功能。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1020-8492ES.jpg" alt="img"></p>
<p> 然后使用手动提交事务的方式，进行一次快照读，但是不提交事务，然后启动插入数据的事务，进行数据插入 commit，结果我发现在使用快照读的时候，数据是可以插入成功的，那这也就说明了一个问题，<strong>快照读的时候就根本没加锁，否则的话数据是不可能插入成功的，而且在插入数据提交成功后，我们执行第二条查询 语句是读取不到中间插入的这条数据的，这也就说明在没有加锁的情况下，基于历史版本的MVCC快照读是可以避免幻读问题的</strong>。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1020-iUMz8J.jpg" alt="1020-gEDxYX"></p>
<h3 id="当前读存的幻读问题解决方案"><a href="#当前读存的幻读问题解决方案" class="headerlink" title="当前读存的幻读问题解决方案"></a>当前读存的幻读问题解决方案</h3><p>上面我们已经论证了在RR级别快照读的情况下，是不存在幻读问题的。  因为会基于历史版本读取数据，但是当前读的话就不同了，当前读每次都会读取最新的数据。所以两次读取中间如果可以插入数据，那么就肯定会造成幻读问题，所以在当前读的情况下就必须通过一种方式来解决幻读问题，而这种方式就是采用加锁来解决。</p>
<p><strong>实际案例：</strong></p>
<p>首先关闭数据库的自动提交事务功能，  使用当前读的方式演示和上面一样的流程，结果发现在当前读的时候没有提交事务之前是根本无法进行数据插入的，所以这也就说明了，使用当前读的时候会对这个范围内的数据进行加锁，所以无法在查询的范围内进行数据插入，这无疑也证明了在当前读的情况下mysql是使用锁的机制来避免出现重复读和幻读问题的。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1021-hFAdty.jpg" alt="img"></p>
<blockquote>
<p>原文： <span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC81Mjk3Nzg2Mg==">数据库基础（四）Innodb MVCC实现原理 - 知乎<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>sql</tag>
        <tag>集合</tag>
        <tag>事务</tag>
        <tag>数据库</tag>
        <tag>指针</tag>
        <tag>Mysql</tag>
        <tag>锁</tag>
        <tag>索引</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql索引原理</title>
    <url>/posts/VB6XWR.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>什么是索引<br>索引是一种利用某种规则的数据结构与实际数据的关系加快数据查找的功能；索引数据节点中有着实际文件的位置，因为索引是根据特定的规则和算法构建的,在查找的时候遵循索引的规则可以快速查找到对应数据的节点，从而达到快速查找数据的效果；其实宏观来说索引其实是一种概念而不是具体的某项技术，只是我们在某个技术中运用得比较广泛和鲜明（比如说数据库）渐渐的有了特定领域的标签，其实在生活中索引的使用无处不在，比如说：书本里的目录；读书时的座位号，考试编号都有类似索引的功能;</p>
<p>总结来所有通过某规则数据结构和实际目标关联，根据特定规则算法快速寻址的功能都可以称之为索引；</p>
<h2 id="二、为什么要用索引"><a href="#二、为什么要用索引" class="headerlink" title="二、为什么要用索引"></a>二、为什么要用索引</h2><p>首先我们看下在没有索引的情况下是怎么查找数据的：</p>
<p>我们用一个例子来解释比较直观</p>
<p>（1）没有索引的情况下访问数据：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1300-vn2lXu.jpg" alt="1300-9A9kOW"></p>
<p>（2）使用平衡二叉树结构作为索引的情况下访问数据：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1300-0sjTWg.jpg" alt="1300-EQ6HD3">  </p>
<p>第一张图没有使用索引我们会进行顺序查找，依照数据顺序逐个进行匹配，进行了5次寻址才查询出所需数据，第二张图用了一个简单的平衡二叉树索引之后我们只用了3次，这还是数据量小的情况下，数据量大了效果更明显，所以总结来说创建索引就是为了加快数据查找速度；</p>
<h2 id="三、Innodb-的索引选择"><a href="#三、Innodb-的索引选择" class="headerlink" title="三、Innodb 的索引选择"></a>三、Innodb 的索引选择</h2><p>Mysql 的默认存储引擎innodb使用B+树作为索引的存储结构，为了让我们能更深入理解B+树，所以我们会对B+树的衍生过程做一些了解。</p>
<h3 id="1、数组和链表的选择"><a href="#1、数组和链表的选择" class="headerlink" title="1、数组和链表的选择"></a><strong>1、数组和链表的选择</strong></h3><p>作为最基础的数据存储结构数组和链表，是选用数组还是选择链表来作为索引存储的基本结构呢？首先我们需要从索引和两种数据结构的特性来分析。</p>
<p><strong>数组的特性：</strong> 查找快、但是插入、修改数据慢。</p>
<p><strong>链表的特性：</strong> 查找慢、插入、修改快。</p>
<p>在数据库的业务场景里插入、修改、查询都是比较频繁的操作，选链表还是数组好像都不完美。既然都不完美，那么我们只能退而求其次，看谁比较容易去完善。从完善的角度来看，那么我们就会从数组里发现一个致命的问题，数组的修改和移动都会导致数组大量的元素迁移，而且在迁移的过程中是不能查找数据的，数组元素迁移没有完成查询出来的数据就可能是错的，这样就导致数组在频繁插入和修改的过程中不仅仅是修改和插入本身慢，而且因为这个而导致查询也用不了，显然这个问题对于修改和插入频繁的数据库来说是无法忍受的。所以我们只能把链表作为索引的基础结构了，那么剩下的就是如何解决链表查询小笼包慢的问题了。</p>
<h3 id="2、从链表到二叉树"><a href="#2、从链表到二叉树" class="headerlink" title="2、从链表到二叉树"></a><strong>2、从链表到二叉树</strong></h3><p>如果使用链表来存储数据，那么必须要解决的一个问题就是要解决链表的查询效率问题，我们必须通过一种算法来解决链表查找数据慢的问题，而这里这里就用到了二分查找法，利用二分法思维把链表拆成N个对半分的节点，然后形成了一个数据结构叫二叉查找树，使用了二分法思维衍生出来的树大大提升了查找的性能。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1301-cjA5NX.jpg" alt="1301-Bnp6DL"></p>
<h3 id="3、从二叉查树到平衡二叉树"><a href="#3、从二叉查树到平衡二叉树" class="headerlink" title="3、从二叉查树到平衡二叉树"></a><strong>3、从二叉查树到平衡二叉树</strong></h3><p>二叉查找树极大的提升了链表查找数据的效率，不过我们又发现了一个问题，就是二叉查找树的“高度”不可控，一旦树的节点插入变成向下图一样的结构。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1301-vTHEoc.jpg" alt="1301-4hsdTc">  </p>
<p>如果树的节点不可控编程变成线性结构，那么就会极大的降低我们的查询效率，所以我们就又需要一种算法来保证二叉树节点的平衡，让树的节点高度差不会太大，这个时候就衍生了一些平衡算法，最终我们的二叉树就有像AVL树和红黑树这些新产品，我们也称这些新产品为平衡二叉树，，平衡二叉树通常会保证树的左右两边的节点层级相差不会大于2。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1301-2pzIIa.jpg" alt="1301-I8F42Y"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1302-j9YcaM.jpg" alt=""></p>
<h3 id="4、从平衡二叉树到B树"><a href="#4、从平衡二叉树到B树" class="headerlink" title="4、从平衡二叉树到B树"></a><strong>4、从平衡二叉树到B树</strong></h3><p>平衡二叉树的出现好像很接近于我们的理想状态了，但好像还有什么优化的空间，我们通过上面两个树的演化过程发现，影响这棵树的查询效率的决定性因素就是树的高度，只要树的层级越少，那么树的查询效率就越高，本着这个原则我们就思考每个节点能不能多存点 数据，只要每个数节点的数据保存的越多，那么我们树的层级就会越少，</p>
<p>B树相对平衡二叉树最大的一个改变，就是B树的每个节点可存储的关键字增多了，特别是在B树应用到数据库中的时候，节点存储关键字的数量充分利用了磁盘块IO的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来），B树只要把节点大小限制在磁盘快大小范围，这样就可以只需要一次IO就读取到节点所有数据，节点存储了更多的关键字，但是并不会影响IO的次数。B树树相对于之前节点可以存储更多的关键字，所以树的层级会比原来少很多，树的层级减少了，那么检索的效率就会大大提升。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1302-U1Ng5z.jpg" alt="1302-0YutJJ"></p>
<h3 id="5、从B树到B-树"><a href="#5、从B树到B-树" class="headerlink" title="5、从B树到B+树"></a><strong>5、从B树到B+树</strong></h3><p><strong>其实B树已经接近我们的理想预期了，但是还是能从B树的上面找到可以优化的地方，比如以下几个方面：</strong></p>
<p>1、B树的节点同时保存了索引的key和数据值（如果节点只保存索引key不保存值，那么是不是会把索引树的层层级更进一步的减少）。</p>
<p>2、因为每个节点保存了数据值，这样的话查询不同的数据效率就会显得不稳定，有些在树的第一层匹配成功就返回，有些则可能需要匹配到树的最后一层才返回。</p>
<p>3、如果要查询所有数据，那么就必须遍历整个B树的每个节点。</p>
<p><strong>B+树在B树的基础上 又做了一些优化，B+树主要做了下面几点的优化。</strong></p>
<p>1、B+跟B树不同，B+树的非叶子节点不保存实际的数据，只保存索引key，所有的数据都会保存到叶子节点。</p>
<p><strong>树层级变少：</strong>如果非叶子节点不保存实际的数据值，而只保存索引key，那么相对于B树来说B+树的每个<strong>非叶子</strong>节点存储的索引key会更多，所以树的层级也会更少，那么查询效率也会更快。</p>
<p><strong>查询更稳定：</strong>因为B+所有数据值都是存在<strong>叶子</strong>节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定；</p>
<p><strong>遍历整个树更快：</strong>B+树遍历整棵树只需要遍历所有的<strong>叶子</strong>节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</p>
<p>2、B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针。</p>
<p><strong>排序和范围查询更方便</strong>：B+树所有的叶子节点数据构成了一个有序链表，这样在进行数据排序和询范围大小查询数据的时候更方便，数据紧密性也更高。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1302-rYU3bq.jpg" alt="1302-WFyIHT">  </p>
<p><strong>（百度百科算法结构示意图）</strong></p>
<p>总结来说，从平衡二叉树、B树、B+树，总体来看它们的贯彻的思想是相同的，在链表的基础上，如何采用二分法和数据平衡策略来提升查找数据的速度。不同点是他们一个一个在演变的过程中通过IO从磁盘读取数据的原理进行一步步的演变，每一次演变都是为了让节点的空间更合理的运用起来，从而使树的层级减少达到快速查找数据的目的，在这个基础上，B+树的查找速度快、性能稳定、排序快、扫表快等诸多特点也就让Mysql选择了B+树来作为索引的存储结构。</p>
<h2 id="四、补充"><a href="#四、补充" class="headerlink" title="四、补充"></a>四、补充</h2><h3 id="为什么说Mysql的索引树一般都在1-3层的结构？"><a href="#为什么说Mysql的索引树一般都在1-3层的结构？" class="headerlink" title="为什么说Mysql的索引树一般都在1-3层的结构？"></a><strong>为什么说Mysql的索引树一般都在1-3层的结构？</strong></h3><p>经常听到别人说Mysql的索引树一般会在3层，这个是有什么依据？ 其实这个的确是有数据计算支撑的，我们可以根据B+树的原理进行一下数据推算，因为磁盘每页数据为4K，而Mysql的B+树对此又进行了一次调整，在Mysql也有自己的页概念，Mysql里的每一页数据等于磁盘4个页的大小，所以在Mysql里面的一页数据其实是16K，那么也就意味着Mysql里B+树的非叶子节点可存储16K的数据。</p>
<p>然后我们按照一个索引大小，如果字段类型为varchar，长度为10，字符类型为utf8mb4，在不考虑其他因素的影响下，一个索引的大小等于 10 _3+2=32字节，我们按照每个非叶子节点的16K来计算，Mysql索引树每个节点能容纳(16_1024)/32=512个索引key。</p>
<p><strong>索引树的第一层：</strong>第一层是树的根节点，所以索引树的第一层保存索引Key的数量为512个；</p>
<p><strong>索引树的第二层：</strong>B+树根节点可保存512个索引key，也就是当前B+树有512个分叉，那么第二层索引树节点个数为512个，保存索引Key的数量=512*512=262144。</p>
<p><strong>索引树的第三层：</strong>第二层key数量为262144，那么第三层的树节点数量也就是262144，那么第三层索引树节点个数为512个，保存索引Key的数量=262144*512=134217728。</p>
<p>根据一个计算我们可以基本得出，类型varchar，长度为10，字符类型为utf8mb4的索引字段，数据在512条之内树结构只有一层。数据在262144之内树只有两层，数据在134217728之内，索引树都会保持在3层之内，而我们的表数据一般而言都保持在千万级以内，所以说Mysql的索引树一般都在1-3层。</p>
<blockquote>
<p><a href="https://xuemingde.com/JavaNotes/数据库/20220407-Mysql索引原理">20220407-Mysql索引原理</a><br>本文转自 <span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yMTM3NzIwNDI=">https://zhuanlan.zhihu.com/p/213772042<i class="fa fa-external-link-alt"></i></span>，如有侵权，请联系删除。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>sql</tag>
        <tag>数据库</tag>
        <tag>数组</tag>
        <tag>指针</tag>
        <tag>Mysql</tag>
        <tag>索引</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>事务持久性与原子性的保障</title>
    <url>/posts/2DEMJ1C.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>持久性的意义</strong></p>
<p>所谓持久性就是说在事务成功提交了之后，数据的最终变更操作都会持久化到磁盘上去,不会因为故障导致数据丢失。而在计算机系统里，只有数据保存到了磁盘才能保证数据不会丢失，持久化的问题是所有数据库系统都需要面临的，无法保证持久性的数据库就意味着在数据库、系统、服务器发生故障时无法进行数据恢复。</p>
<p><strong>持久性的难题</strong></p>
<p>保证持久性的意义在于，就算遇到数据库、系统、服务器崩溃，我们依然能对已经损坏的数据进行恢复，用习惯了ACID的数据库，我们潜意识里就以为持久化是自然而然的事情，然而并非这样，我们经典的MyIsam 就不支持这个特性，至于为什么，因为保证持久化的操作本身是有难题需要攻克的，这个难题在于把数据写入磁盘的操作过程并不是原子性的。</p>
<p>因为一次事务会牵扯到多次调用磁盘写数据的操作，而多次磁盘操作相互是独立的，所以一个事务是无法保障多次磁盘读写的原子操作的。这也就意味着，如果事务提交的时候如果发生故障、崩溃，就有可能部分写磁盘操作调用成功，部分写操作调用失败的情况，从而导致产生了脏数据。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1114-VY1lSA.jpg" alt="img"></p>
<p>除了原子性问题之外，为了提升IO的效率， 数据库是允许异步写入数据到磁盘的，数据写入通常会先写内存、再写磁盘。 为了优化写入数据的性能，通常应用也会在内存中加入各种缓冲区，  所以数据最终什么时候写入到磁盘   这个时间是根据具体的策略来决定，简单来说就是应用程序写入数据成功了，但是并不一定代表数据已经持久化到磁盘了。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1115-jg7jSN.jpg" alt="img"></p>
<p><strong>所以综合来看持久化的关键问题在于两方面，：</strong></p>
<p>一方面，应用程序的一次业务操作会牵扯到多次调用磁盘写，而多次写入磁盘的操作并不具备原子性，所以就也会存在部分数据写入成功，部分数据写入失败的情况。</p>
<p>另一方面，数据从内存写入到磁盘的整个过程可以异步进行的，所以导致从程序上来看数据写入成功了，但是数据并不一定已经持久化到磁盘了。 </p>
<h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a><strong>redo log</strong></h3><p>上面我们已经了解到 如果提交事务的过程中发生崩溃、宕机，就有可能会导致数据丢失和损坏，那么如何解决这个问题就在于，在数据丢失和损坏之后我们能通过什么方式对数据进行恢复。</p>
<p>回想到现实世界里，有时候我们在做某件事情的时候，偶尔会遇到脑子突然断片或失忆的情况（好比应用崩溃、服务器宕机），然后断片了之后，回想不起来断片之前自己在做什么，也不知道事情做到了哪一步，而这个时候我们往往会想着要是在做事情之前把这些记录在笔记本里面就好了，按着记事本里面的记录就知道自己应该做什么事情，还有哪些事情没有做了，然后把没做的事情继续做完就行了。</p>
<p>在现实世界我们用记事本的方式解决脑子失忆、断片的问题，在计算机里我们用记日志的方式来解决数据崩溃恢复问题，而Mysql里这个日志就是redo log。 redo  log的功能就是事务提交之前首先会把本次事务需要变更的数据，包括修改磁盘那块扇区、修改哪些数据等，通通都记录下来。所以只要保证成功记录了redo log  ，那么就算事务提交之后发生了崩溃、宕机，此时内存的数据即便没有即时写入磁盘，又或则只写入了一部分数据到磁盘，我们只需要通过找到事务对应的redo log，再对数据进行对比恢复即可。</p>
<p><strong>加入redo log后，事务执行过程如下：</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1115-40zR4M.jpg" alt="img"></p>
<h3 id="原子性保障"><a href="#原子性保障" class="headerlink" title="原子性保障"></a><strong>原子性保障</strong></h3><p>所谓原子性就是说，在事务中进行的一系列操作，要么全部执行成功，要么全部执行失败，不存在部分执行部分不执行的情况。</p>
<p>首先事务的操作<strong>“要么全部成功”</strong>，这个是指事务提交后必须保证数据全部修改成功，在正常情况下事务提交后数据是肯定能修改成功的，所以这里需要考虑的是异常情况下能否保证数据全部修改成功 (比如在数据库崩溃、宕机等故障的情况)，所以保证原子性操作全部成功的前提就得必须保证持久性，这这部分的功能在上面我们已经知道是通过redo  log 来解决了。</p>
<p>然后原子性中还有一个特性<strong>“要么全部失败”，</strong>，这个是指事务可以在任何阶段进行回滚了，并且在执行回滚操作后，必须保证事务所变更的数据恢复到修改之前的样子。  比如上面的流程中，在修改数据后业务不具备事务提交的条件，那么此时就需要对事务进行回滚，可是需要注意的是，此时已经变更的数据有可能已经写入到磁盘了，所以如果需要进行事务回滚，那么就必然需要对已经修改的数据进行还原，所以此时我们就需要有一个记录的历史数据快照的日志，这个日志的作用在于如果事务需要进行回滚，那么通过该日志考记录的历史快照可以还原已经变更的数据信息，在Mysql 里这个快照日志就是undo log。</p>
<h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a><strong>undo log</strong></h3><p>在Mysql里每次修改数据前，首先会把修改之前的数据作为历史保存一份到undo log里面的，数据里面会记录操作该数据的事务ID，在事务需要进行回滚的时候，通过对比undo log日志把已经修改的数据进行还原。</p>
<p><strong>加入redo log后，事务执行过程如下：</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/07/1115-BoH8vP.jpg" alt="img"></p>
<p><strong>总结：</strong></p>
<p>事务持久性的难题在于，一个事务会牵扯到多次磁盘IO操作，多次IO之间操作相互独立，所以在发生故障和意外情况会出现部分数据写入成功，部分数据写入失败的情况，为了保障数据最终都能成功写入到磁盘，所以在修改数据之前，通过redo log提前记录一份最终需要完成修改的数据记录，如果在事务提交的的过程中发生故障、宕机的意外导致数据写入不成功，从而在意外发生后通过redo  log来将未成功写入的数据重新写入，最终把需要修改的数据全部写入磁盘，从而保障了事务的持久性。</p>
<p>原子性的难题在于，当修改数据后如果需要对事务进行回滚，这个过程中内存中修改的数据可能持久化到磁盘，导致脏数据，所以必须通过undo  log提前记录一份历史数据的快照，在事务需要进行回滚的时候，通过历史数据的快照来将已经变更的数据恢复如初，从而保障事务回滚后就像什么都没发生过一样，配合redo log 保障了事务原子性要么全部成功，要么全部失败的原子特性。</p>
<blockquote>
<p>原文：<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80MjA2MjI0NzI=">数据库基础（五）事务持久性与原子性的保障 - 知乎<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>内存</tag>
        <tag>sql</tag>
        <tag>事务</tag>
        <tag>数据库</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>基于代价的慢查询优化建议</title>
    <url>/posts/2HNBAGV.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>原文：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvTWFRVEk0YWZJaDJaZWhjLUYtaWlzUQ==">基于代价的慢查询优化建议<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>对于数据库来说，慢查询往往意味着风险。SQL执行得越慢，消耗的CPU资源或IO资源也会越大。大量的慢查询可直接引发业务故障，关注慢查询即是关注故障本身。本文主要介绍了美团如何利用数据库的代价优化器来优化慢查询，并给出索引建议，评估跟踪建议质量，运营治理慢查询。</p>
<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景</h2><p>慢查询是指数据库中查询时间超过指定阈值（美团设置为100ms）的SQL，它是数据库的性能杀手，也是业务优化数据库访问的重要抓手。随着美团业务的高速增长，日均慢查询量已经过亿条，此前因慢查询导致的故障约占数据库故障总数的10%以上，而且高级别的故障呈日益增长趋势。因此，对慢查询的优化已经变得刻不容缓。</p>
<p>那么如何优化慢查询呢？最直接有效的方法就是选用一个查询效率高的索引。关于高效率的索引推荐，主要有基于经验规则和代价的两种算法。在日常工作中，基于经验规则的推荐随处可见，对于简单的SQL，如<code>select * from sync_test1 where name like &#39;Bobby%&#39;</code>，直接添加索引IX(name) 就可以取得不错的效果；但对于稍微复杂点的SQL，如<code>select * from sync_test1 where name like &#39;Bobby%&#39; and dt &gt; &#39;2021-07-06&#39;</code>，到底选择IX(name)、IX(dt)、IX(dt,name) 还是IX(name,dt)，该方法也无法给出准确的回答。更别说像多表Join、子查询这样复杂的场景了。所以采用基于代价的推荐来解决该问题会更加普适，因为基于代价的方法使用了和数据库优化器相同的方式，去量化评估所有的可能性，选出的是执行SQL耗费代价最小的索引。</p>
<h2 id="2-基于代价的优化器介绍"><a href="#2-基于代价的优化器介绍" class="headerlink" title="2 基于代价的优化器介绍"></a>2 基于代价的优化器介绍</h2><h3 id="2-1-SQL执行与优化器"><a href="#2-1-SQL执行与优化器" class="headerlink" title="2.1 SQL执行与优化器"></a>2.1 SQL执行与优化器</h3><p>一条SQL在MySQL服务器中执行流程主要包含：SQL解析、基于语法树的准备工作、优化器的逻辑变化、优化器的代价准备工作、基于代价模型的优化、进行额外的优化和运行执行计划等部分。具体如下图所示：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/26/0929-9DkzN6.jpeg" alt=""></p>
<p>SQL执行与优化器</p>
<h3 id="2-2-代价模型介绍"><a href="#2-2-代价模型介绍" class="headerlink" title="2.2 代价模型介绍"></a>2.2 代价模型介绍</h3><p>而对于优化器来说，执行一条SQL有各种各样的方案可供选择，如表是否用索引、选择哪个索引、是否使用范围扫描、多表Join的连接顺序和子查询的执行方式等。如何从这些可选方案中选出耗时最短的方案呢？这就需要定义一个量化数值指标，这个指标就是代价(Cost)，我们分别计算出可选方案的操作耗时，从中选出最小值。</p>
<p>代价模型将操作分为Server层和Engine（存储引擎）层两类，Server层主要是CPU代价，Engine层主要是IO代价，比如MySQL从磁盘读取一个数据页的代价io_block_read_cost为1，计算符合条件的行代价为row_evaluate_cost为0.2。除此之外还有：</p>
<ol>
<li>memory_temptable_create_cost (default 2.0) 内存临时表的创建代价。</li>
<li>memory_temptable_row_cost (default 0.2) 内存临时表的行代价。</li>
<li>key_compare_cost (default 0.1) 键比较的代价，例如排序。</li>
<li>disk_temptable_create_cost (default 40.0) 内部myisam或innodb临时表的创建代价。</li>
<li>disk_temptable_row_cost (default 1.0) 内部myisam或innodb临时表的行代价。</li>
</ol>
<p>在MySQL 5.7中，这些操作代价的默认值都可以进行配置。为了计算出方案的总代价，还需要参考一些统计数据，如表数据量大小、元数据和索引信息等。MySQL的代价优化器模型整体如下图所示：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/26/0929-08hEUU.jpeg" alt="图片">代价模型</p>
<h3 id="2-3-基于代价的索引选择"><a href="#2-3-基于代价的索引选择" class="headerlink" title="2.3 基于代价的索引选择"></a>2.3 基于代价的索引选择</h3><p>还是继续拿上述的<code>SQL select * from sync_test1 where name like &#39;Bobby%&#39; and dt &gt; &#39;2021-07-06&#39;</code>为例，我们看看MySQL优化器是如何根据代价模型选择索引的。首先，我们直接在建表时加入四个候选索引。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">Table</span>: <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `sync_test1` (</span><br><span class="line">    `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    `cid` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `phone` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `name` <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `address` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `dt` datetime <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">    KEY `IX_name` (`name`),</span><br><span class="line">    KEY `IX_dt` (`dt`),</span><br><span class="line">    KEY `IX_dt_name` (`dt`,`name`),</span><br><span class="line">    KEY `IX_name_dt` (`name`,`dt`)</span><br><span class="line">    ) ENGINE<span class="operator">=</span>InnoDB</span><br></pre></td></tr></table></figure>
<p>通过执行explain看出MySQL最终选择了IX_name索引。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> explain  select * from sync_test1 <span class="built_in">where</span> name like <span class="string">&#x27;Bobby%&#x27;</span> and dt &gt; <span class="string">&#x27;2021-07-06&#x27;</span>;</span></span><br><span class="line">+----+-------------+------------+------------+-------+-------------------------------------+---------+---------+------+------+----------+------------------------------------+</span><br><span class="line">| id | select_type | table      | partitions | type  | possible_keys                       | key     | key_len | ref  | rows | filtered | Extra                              |</span><br><span class="line">+----+-------------+------------+------------+-------+-------------------------------------+---------+---------+------+------+----------+------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | sync_test1 | NULL       | range | IX_name,IX_dt,IX_dt_name,IX_name_dt | IX_name | 12      | NULL |  572 |    36.83 | Using index condition; Using where |</span><br><span class="line">+----+-------------+------------+------------+-------+-------------------------------------+---------+---------+------+------+----------+------------------------------------+</span><br></pre></td></tr></table></figure>
<p>然后再打开MySQL追踪优化器Trace功能。可以看出，没有选择其他三个索引的原因均是因为在其他三个索引上使用range scan的代价均&gt;= IX_name。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from INFORMATION_SCHEMA.OPTIMIZER_TRACE\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line"></span><br><span class="line">TRACE: &#123;</span><br><span class="line">...</span><br><span class="line"><span class="string">&quot;rows_estimation&quot;</span>: [</span><br><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;table&quot;</span>: <span class="string">&quot;`sync_test1`&quot;</span>,</span><br><span class="line"><span class="string">&quot;range_analysis&quot;</span>: &#123;</span><br><span class="line"><span class="string">&quot;table_scan&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;rows&quot;</span>: 105084,</span><br><span class="line">  <span class="string">&quot;cost&quot;</span>: 21628</span><br><span class="line">&#125;,</span><br><span class="line">...</span><br><span class="line"><span class="string">&quot;analyzing_range_alternatives&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;range_scan_alternatives&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;index&quot;</span>: <span class="string">&quot;IX_name&quot;</span>,</span><br><span class="line">      <span class="string">&quot;ranges&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;Bobby\u0000\u0000\u0000\u0000\u0000 &lt;= name &lt;= Bobbyÿÿÿÿÿ&quot;</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="string">&quot;index_dives_for_eq_ranges&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">&quot;rowid_ordered&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;using_mrr&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;index_only&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;rows&quot;</span>: 572,</span><br><span class="line">      <span class="string">&quot;cost&quot;</span>: 687.41,</span><br><span class="line">      <span class="string">&quot;chosen&quot;</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;index&quot;</span>: <span class="string">&quot;IX_dt&quot;</span>,</span><br><span class="line">      <span class="string">&quot;ranges&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;0x99aa0c0000 &lt; dt&quot;</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="string">&quot;index_dives_for_eq_ranges&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">&quot;rowid_ordered&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;using_mrr&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;index_only&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;rows&quot;</span>: 38698,</span><br><span class="line">      <span class="string">&quot;cost&quot;</span>: 46439,</span><br><span class="line">      <span class="string">&quot;chosen&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;cause&quot;</span>: <span class="string">&quot;cost&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;index&quot;</span>: <span class="string">&quot;IX_dt_name&quot;</span>,</span><br><span class="line">      <span class="string">&quot;ranges&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;0x99aa0c0000 &lt; dt&quot;</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="string">&quot;index_dives_for_eq_ranges&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">&quot;rowid_ordered&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;using_mrr&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;index_only&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;rows&quot;</span>: 38292,</span><br><span class="line">      <span class="string">&quot;cost&quot;</span>: 45951,</span><br><span class="line">      <span class="string">&quot;chosen&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;cause&quot;</span>: <span class="string">&quot;cost&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;index&quot;</span>: <span class="string">&quot;IX_name_dt&quot;</span>,</span><br><span class="line">      <span class="string">&quot;ranges&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;Bobby\u0000\u0000\u0000\u0000\u0000 &lt;= name &lt;= Bobbyÿÿÿÿÿ&quot;</span></span><br><span class="line">      ],</span><br><span class="line">      <span class="string">&quot;index_dives_for_eq_ranges&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">&quot;rowid_ordered&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;using_mrr&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;index_only&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;rows&quot;</span>: 572,</span><br><span class="line">      <span class="string">&quot;cost&quot;</span>: 687.41,</span><br><span class="line">      <span class="string">&quot;chosen&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="string">&quot;cause&quot;</span>: <span class="string">&quot;cost&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;analyzing_roworder_intersect&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;usable&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="string">&quot;cause&quot;</span>: <span class="string">&quot;too_few_roworder_scans&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">&quot;chosen_range_access_summary&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;range_access_plan&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;range_scan&quot;</span>,</span><br><span class="line">    <span class="string">&quot;index&quot;</span>: <span class="string">&quot;IX_name&quot;</span>,</span><br><span class="line">    <span class="string">&quot;rows&quot;</span>: 572,</span><br><span class="line">    <span class="string">&quot;ranges&quot;</span>: [</span><br><span class="line">      <span class="string">&quot;Bobby\u0000\u0000\u0000\u0000\u0000 &lt;= name &lt;= Bobbyÿÿÿÿÿ&quot;</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;rows_for_plan&quot;</span>: 572,</span><br><span class="line">  <span class="string">&quot;cost_for_plan&quot;</span>: 687.41,</span><br><span class="line">  <span class="string">&quot;chosen&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们根据代价模型来推演一下代价的计算过程：</p>
<ol>
<li>走全表扫描的代价：io_cost + cpu_cost = （数据页个数 <em> io_block_read_cost）+ (数据行数 </em> row_evaluate_cost +  1.1)  = （data_length / block_size + 1）+ (rows <em> 0.2 + 1.1) =  (9977856 / 16384 + 1) + (105084 </em> 0.2 + 1.1) =  21627.9。</li>
<li>走二级索引IX_name的代价：io_cost + cpu_cost = (预估范围行数 <em> io_block_read_cost + 1) + (数据行数 </em>  row_evaluate_cost + 0.01) =  (572 <em> 1 +  1) + (572</em>0.2 + 0.01) = 687.41。</li>
<li>走二级索引IX_dt的代价：io_cost + cpu_cost = (预估范围行数 <em> io_block_read_cost + 1) + (数据行数 </em>  row_evaluate_cost + 0.01)  = (38698 <em> 1 + 1) + (38698</em>0.2 + 0.01) =  46438.61。</li>
<li>走二级索引IX_dt_name的代价: io_cost + cpu_cost = (预估范围行数 <em> io_block_read_cost + 1) + (数据行数 </em>  row_evaluate_cost + 0.01)  = (38292 <em> 1 + 1) + (38292 </em> 0.2 + 0.01) =  45951.41。</li>
<li>走二级索引IX_name_dt的代价：io_cost + cpu_cost = (预估范围行数 <em> io_block_read_cost + 1) + (数据行数 </em>  row_evaluate_cost + 0.01)  = (572 <em> 1 +  1) + (572</em>0.2 + 0.01) = 687.41。</li>
</ol>
<p><strong>补充说明</strong></p>
<ol>
<li>计算结果在小数上有偏差，因为MySQL使用%g打印浮点数，小数会以最短的方式输出。 </li>
<li>除“+1.1 +1”这种调节值外，Cost计算还会出现+0.01, 它是为了避免index scan和range scan出现Cost的竞争。</li>
<li>Cost计算是基于MySQL的默认参数配置，如果Cost Model参数改变，optimizer_switch的选项不同，数据分布不同都会导致最终Cost的计算结果不同。 </li>
<li>data_length可查询information_schema.tables，block_size默认16K。</li>
</ol>
<h3 id="2-4-基于代价的索引推荐思路"><a href="#2-4-基于代价的索引推荐思路" class="headerlink" title="2.4 基于代价的索引推荐思路"></a>2.4 基于代价的索引推荐思路</h3><p>如果想借助MySQL优化器给慢查询计算出最佳索引，那么需要真实地在业务表上添加所有候选索引。对于线上业务来说，直接添加索引的时间空间成本太高，是不可接受的。MySQL优化器选最佳索引用到的数据是索引元数据和统计数据，所以我们想是否可以通过给它提供候选索引的这些数据，而非真实添加索引的这种方式来实现。</p>
<p>通过深入调研MySQL的代码结构和优化器流程，我们发现是可行的：一部分存在于Server层的frm文件中，比如索引定义；另一部分存在于Engine层中，或者通过调用Engine层的接口函数来获取，比如索引中某个列的不同值个数、索引占据的页面大小等。索引相关的信息，如下图所示：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/26/0940-EBi6rx.jpeg" alt="图片"></p>
<p>基于代价的索引推荐思路</p>
<p>因为MySQL本身就支持自定义存储引擎，所以索引推荐思路是构建一个支持虚假索引的存储引擎，在它上面建立包含候选索引的空表，再采集样本数据，计算出统计数据提供给优化器，让优化器选出最优索引，整个调用关系如下图所示：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/26/0940-iEOrlx.jpeg" alt="图片"></p>
<p>基于代价的索引推荐思路</p>
<h2 id="3-索引推荐实现"><a href="#3-索引推荐实现" class="headerlink" title="3 索引推荐实现"></a>3 索引推荐实现</h2><p>因为存储引擎本身并不具备对外提供服务的能力，直接在MySQL Server层修改也难以维护，所以我们将整个索引推荐系统拆分成支持虚假索引的Fakeindex存储引擎和对外提供服务的Go-Server两部分，整体架构图如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/26/0941-xWC1xA.jpeg" alt="图片"></p>
<p>架构图</p>
<p>首先简要介绍一下Fakeindex存储引擎，这是一个轻量级的存储引擎，负责将索引的相关接口透传到Go-Server部分。因为它必须采用C++实现，与Go-Server间存在跨语言调用的问题，我们使用了Go原生的轻量级RPC技术+cgo来避免引入重量级的RPC框架，也不必引入第三方依赖包。函数调用链路如下所示，MySQL优化器调用Fakeindex的C++函数，参数转换成C语言，然后通过cgo调用到Go语言的方法，再通过Go自带的RPC客户端向服务端发起调用。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/26/0941-ypqRfL.jpeg" alt="图片"></p>
<p>调用链路</p>
<p>下面将重点阐述核心逻辑Go-Server部分，主要流程步骤如下。</p>
<h3 id="3-1-前置校验"><a href="#3-1-前置校验" class="headerlink" title="3.1 前置校验"></a>3.1 前置校验</h3><p>首先根据经验规则，排除一些不支持通过添加索引来提高查询效率的场景，如查系统库的SQL，非select、update、delete SQL等。</p>
<h3 id="3-2-提取关键列名"><a href="#3-2-提取关键列名" class="headerlink" title="3.2 提取关键列名"></a>3.2 提取关键列名</h3><p>这一步提取SQL可用来添加索引的候选列名，除了选择给出现在where中的列添加索引，MySQL对排序、聚合、表连接、聚合函数（如max）也支持使用索引来提高查询效率。我们对SQL进行语法树解析，在树节点的where、join、order by、group by、聚合函数中提取列名，作为索引的候选列。值得注意的是，对于某些SQL，还需结合表结构才能准确地提取，比如：</p>
<ol>
<li>select * from tb1, tb2 where a = 1，列a归属tb1还是tb2取决于谁唯一包含列a。</li>
<li>select * from  tb1 natural join tb2 where tb1.a = 1，在自然连接中，tb1和tb2默认使用了相同列名进行连接，但SQL中并没有暴露出这些可用于添加索引的列。</li>
</ol>
<h3 id="3-3-生成候选索引"><a href="#3-3-生成候选索引" class="headerlink" title="3.3 生成候选索引"></a>3.3 生成候选索引</h3><p>将提取出的关键列名进行全排列即包含所有的索引组合，如列A、B、C的所有索引组合是[‘A’, ‘B’, ‘C’, ‘AB’, ‘AC’, ‘BA’, ‘BC’, ‘CA’, ‘CB’, ‘ABC’, ‘ACB’, ‘BAC’,  ‘BCA’, ‘CAB’, ‘CBA’]，但还需排除一些索引才能得到所有的候选索引，比如：</p>
<ol>
<li>已经存在的索引，如存在AB，需排除AB、A，因为MySQL支持使用前缀索引。</li>
<li>超过最大索引长度3072字节限制的索引。</li>
<li>一些暂时不支持的索引，如带地理数据类型列的空间索引。</li>
</ol>
<h3 id="3-4-数据采集"><a href="#3-4-数据采集" class="headerlink" title="3.4 数据采集"></a>3.4 数据采集</h3><p>直接从业务数据库采集，数据分成元数据、统计数据、样本数据三部分：</p>
<ol>
<li><strong>元数据</strong>：即表的定义数据，包括列定义、索引定义，可通过show create table获取。</li>
<li><strong>统计数据</strong>：如表的行数、表数据大小、索引大小，可以通过查询infromation_schema.tables获取；已存在索引的cardinality（关键值：即索引列的不同值个数，值越大，索引优化效果越明显），可以通过查询mysql.innodb_index_stats表获取。</li>
<li><strong>样本数据</strong>：候选索引为假索引，采集的统计数据并不包含假索引的数据，这里我们通过采集原表的样本数据来计算出假索引的统计数据。</li>
</ol>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/26/0942-ek9Vti.jpeg" alt="图片"></p>
<p>数据采集</p>
<p>下面介绍样本数据的采样算法，好的采样算法应该尽最大可能采集到符合原表数据分布的样本。比如基于均匀随机采样的方式<code>select * from table where rand() &lt; rate</code>，然而它会给线上数据库造成大量I/O的问题，严重时可引发数据库故障。所以我们采用了基于块的采样方式：它参考了MySQL  8.0的直方图采样算法，如对于一张100万的表，采集10万行数，根据主键的最小值最大值将表数据均分成100个区间，每个区间取一块1000行数据，采集数据的SQL，最后将采集到的数据塞入采样表中。代码如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> A,B,C,id <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> id <span class="operator">&gt;=</span> <span class="number">1000</span> <span class="keyword">and</span> id <span class="operator">&lt;=</span> <span class="number">10000</span> limit <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">select</span> A,B,C,id <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> id <span class="operator">&gt;=</span> <span class="number">10000</span> <span class="keyword">and</span> id <span class="operator">&lt;=</span> <span class="number">20000</span> limit <span class="number">1000</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="3-5-统计数据计算"><a href="#3-5-统计数据计算" class="headerlink" title="3.5 统计数据计算"></a>3.5 统计数据计算</h3><p>下面举例说明两个核心统计数据的计算方式。首先是records_in_range，优化器在处理范围查询时，如果可以用索引，就会调用该函数估算走该索引可过滤出的行数，以此决定最终选用的索引。</p>
<p>比如，对于SQL<code>select * from table1 where A &gt; 100 and B &lt; 1000</code>，候选索引A、B来说，优化器会调用此函数在索引页A上估算A &gt;  100有多少行数，在索引页B上估计B&lt;1000的行数，例如满足条件的A有200行，B有50行，那么优化器会优先选择使用索引B。对于假索引来说，我们按照该公式：样本满足条件的范围行数 * (原表行数 / 样本表行数)，直接样本数据中查找，然后按照采样比例放大即可估算出原表中满足条件的范围行数。</p>
<p>其次是用于计算索引区分度的cardinality。如果直接套用上述公式：样本列上不同值个数 <em> (原表行数 / 样本表行数)，  如上述的候选索引A，根据样本统计出共有100个不同值，那么在原表中，该列有多少不同值？一般以为是10,000 =100  </em>（1,000,000/100,000）。但这样计算不适用某些场景，比如状态码字段，可能最多100个不同值。针对该问题，我们引入斜率和两趟计算来规避，流程如下：</p>
<ul>
<li><strong>第一趟计算</strong>：取样本数据一半来统计A的不同值个数R1，区间[min_id, min_id+(max_id - min_id) / 2]。</li>
<li><strong>第二趟计算</strong>：取所有样本据统计A的不同值个数R2，区间[min_id, max_id] 计算斜率：R2/R1。</li>
<li><strong>判断斜率</strong>：如果斜率小于1.1，为固定值100，否则根据采样比例放大，为10,000。</li>
</ul>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/26/0942-XnDqx4.jpeg" alt="图片"></p>
<p>统计数据计算</p>
<h3 id="3-6-候选索引代价评估"><a href="#3-6-候选索引代价评估" class="headerlink" title="3.6 候选索引代价评估"></a>3.6 候选索引代价评估</h3><p>这一步让优化器帮助我们从候选索引中选出最佳索引，主要步骤如下：</p>
<ol>
<li>建包含候选索引的表：将候选索引塞入原表定义，并把存储引擎改为Fakeindex，在推荐引擎的mysqld上创建表。</li>
<li>通过在推荐引擎mysqld上explain format=json SQL，获取优化器选择的索引。</li>
</ol>
<p>值得注意的是，MySQL表最多建64个索引（二级索引），计算所有候选索引的可能时，使用的是增幅比指数还恐怖的全排列算法。如下图所示，随着列数的增加，候选索引数量急剧上升，在5个候选列时的索引组合数量就超过了MySQL最大值，显然不能满足一些复杂SQL的需求。统计美团线上索引列数分布后，我们发现，95%以上的索引列数都&lt;=3个。同时基于经验考虑，3列索引也可满足绝大部分场景，剩余场景会通过其他方式，如库表拆分来提高查询性能，而不是增加索引列个数。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/26/0938-ePWI3q.png" alt="image-20220426093827271"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/26/0938-MBGYlr.png" alt="image-20220426093856097"></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/26/0931-1SHKgs.jpeg" alt="图片"></p>
<p><u>候选索引代价评估</u></p>
<h2 id="4-推荐质量保证"><a href="#4-推荐质量保证" class="headerlink" title="4 推荐质量保证"></a>4 推荐质量保证</h2><p>为了得到索引推荐质量大致的整体数据，我们使用美团数据库最近一周的线下慢查询数据，共246G、约3万个SQL模板用例做了一个初步测试。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/26/0934-IHLvji.png" alt="图片"></p>
<p>建议质量保证</p>
<p>从结果可以看出，系统基本能覆盖到大部分的慢查询。但还是会出现无效的推荐，大致原因如下：</p>
<ol>
<li>索引推荐计算出的Cost严重依赖样本数据的质量，在当表数据分布不均或数据倾斜时会导致统计数据出现误差，导致推荐出错误索引。</li>
<li>索引推荐系统本身存在缺陷，从而导致推荐出错误索引。</li>
<li>MySQL优化器自身存在的缺陷，导致推荐出错误索引。</li>
</ol>
<p>因此，我们在业务添加索引前后增加了索引的有效性验证和效果追踪两个步骤，整个流程如下所示：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/26/0933-jX2Pdw.jpeg" alt="图片"></p>
<p>全链路</p>
<h3 id="4-1-有效性验证"><a href="#4-1-有效性验证" class="headerlink" title="4.1 有效性验证"></a>4.1 有效性验证</h3><p>因为目前还不具备大规模数据库备份快速还原的能力，所以无法使用完整的备份数据做验证。我们近似地认为，如果推荐索引在业务库上取得较好的效果，那么在样本库也会取得不错效果。通过真正地在样本库上真实执行SQL，并添加索引来验证其有效性，验证结果展示如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/26/0933-fR5pMD.png" alt="图片"></p>
<p>有效性验证</p>
<h3 id="4-2-效果追踪"><a href="#4-2-效果追踪" class="headerlink" title="4.2 效果追踪"></a>4.2 效果追踪</h3><p>考虑到使用采样数据验证的局限性，所以当在生产环境索引添加完毕之后，会立即对添加的索引进行效果追踪。一方面通过explain验证索引是否被真正用到，以及Cost是否减小；另一方面用Flink实时跟踪该数据库的全量SQL访问数据，通过对比索引添加前后，该SQL的真实执行时间来判断索引是否有效。如果发现有性能方面的回退，则立即发出告警，周知到DBA和研发人员。生成的报告如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/26/0933-yGgfgy.jpeg" alt="图片"></p>
<p>效果追踪</p>
<h3 id="4-3-仿真环境"><a href="#4-3-仿真环境" class="headerlink" title="4.3 仿真环境"></a>4.3 仿真环境</h3><p>当推荐链路出现问题时，直接在线上排查验证问题的话，很容易给业务带来安全隐患，同时也降低了系统的稳定性。对此我们搭建了离线仿真环境，利用数据库备份构建了和生产环境一样的数据源，并完整复刻了线上推荐链路的各个步骤，在仿真环境回放异常案例，复现问题、排查根因，反复验证改进方案后再上线到生产系统，进而不断优化现有系统，提升推荐质量。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/26/0933-5cxtK1.jpeg" alt="图片"></p>
<p>仿真环境</p>
<h3 id="4-4-测试案例库"><a href="#4-4-测试案例库" class="headerlink" title="4.4 测试案例库"></a>4.4 测试案例库</h3><p>在上线过程中，往往会出现改进方案修复了一个Bug，带来了更多Bug的情况。能否做好索引推荐能力的回归测试，直接决定了推荐质量的稳定性。于是，我们参考了阿里云的技术方案，计划构建一个尽可能完备的测试案例库用于衡量索引推荐服务能力强弱。但考虑影响MySQL索引选择的因素众多，各因素间的组合，SQL的复杂性，如果人为去设计测试用例是是不切实际的，我们通过下列方法自动化收集测试用例：</p>
<ol>
<li>利用美团线上的丰富数据，以影响MySQL索引选择的因素特征为抓手，直接从全量SQL和慢SQL中抽取最真实的案例，不断更新现有测试案例库。</li>
<li>在生产的推荐系统链路上埋点，自动收集异常案例，回流到现有的测试案例库。</li>
<li>对于现有数据没有覆盖到的极端场景，采用人为构造的方案，补充测试用例。</li>
</ol>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/26/0932-WMXptR.jpeg" alt="图片"></p>
<p>测试案例库</p>
<h2 id="5-慢查询治理运营"><a href="#5-慢查询治理运营" class="headerlink" title="5 慢查询治理运营"></a>5 慢查询治理运营</h2><p>我们主要从时间维度的三个方向将慢查询接入索引推荐，推广治理：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/26/0932-NrXR65.jpeg" alt="图片">慢查询治理运营</p>
<h3 id="5-1-过去-历史慢查询"><a href="#5-1-过去-历史慢查询" class="headerlink" title="5.1 过去-历史慢查询"></a>5.1 过去-历史慢查询</h3><p>这类慢查询属于过去产生的，并且一直存在，数量较多，治理推动力不足，可通过收集历史慢查询日志发现，分成两类接入：</p>
<ol>
<li><strong>核心数据库</strong>：该类慢查询通常会被周期性地关注，如慢查询周报、月报，可直接将优化建议提前生成出来，接入它们，一并运营治理。</li>
<li><strong>普通数据库</strong>：可将优化建议直接接入数据库平台的慢查询模块，让研发自助地选择治理哪些慢查询。</li>
</ol>
<h3 id="5-2-现在-新增慢查询"><a href="#5-2-现在-新增慢查询" class="headerlink" title="5.2 现在-新增慢查询"></a>5.2 现在-新增慢查询</h3><p>这类慢查询属于当前产生的，数量较少，属于治理的重点，也可通过实时收集慢查询日志发现，分成两类接入：</p>
<ol>
<li><strong>影响程度一般的慢查询</strong>：可通过实时分析慢查询日志，对比历史慢查询，识别出新增慢查询，并生成优化建议，为用户创建数据库风险项，跟进治理。</li>
<li><strong>影响程度较大的慢查询</strong>：该类通常会引发数据库告警，如慢查询导致数据库Load过高，可通过故障诊断根因系统，识别出具体的慢查询SQL，并生成优化建议，及时推送到故障处理群，降低故障处理时长。</li>
</ol>
<h3 id="5-3-未来-潜在慢查询"><a href="#5-3-未来-潜在慢查询" class="headerlink" title="5.3 未来-潜在慢查询"></a>5.3 未来-潜在慢查询</h3><p>这类查询属于当前还没被定义成慢查询，随着时间推进可能变成演变成慢查询，对于一些核心业务来说，往往会引发故障，属于他们治理的重点，分成两类接入：</p>
<ol>
<li><strong>未上线的准慢查询</strong>：项目准备上线而引入的新的准慢查询，可接入发布前的集成测试流水线，Java项目可通过 agentmain的代理方式拦截被测试用例覆盖到的SQL，再通过经验+explain识别出慢查询，并生成优化建议，给用户在需求管理系统上创建缺陷任务，解决后才能发布上线。</li>
<li><strong>已上线的准慢查询</strong>：该类属于当前执行时间较快的SQL，随着表数据量的增加，会演变成慢查询，最常见的就是全表扫描，这类可通过增加慢查询配置参数log_queries_not_using_indexes记录到慢日志，并生成优化建议，为用户创建数据库风险项，跟进治理。</li>
</ol>
<h2 id="6-项目运行情况"><a href="#6-项目运行情况" class="headerlink" title="6 项目运行情况"></a>6 项目运行情况</h2><p>当前，主要以新增慢查询为突破点，重点为全表扫描推荐优化建议。目前我们已经灰度接入了一小部分业务，共分析了六千多条慢查询，推荐了一千多条高效索引建议。另外，美团内部的研发同学也可通过数据库平台自助发起SQL优化建议工单，如下图所示：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/26/0932-x8khX5.jpeg" alt=""></p>
<p>RDS平台发起</p>
<p>另外在美团内部，我们已经和数据库告警打通，实现了故障发现、根因分析、解决方案的自动化处理，极大地提高了故障处理效率。下面是一个展示案例，当数据库集群发生告警，我们会拉一个故障群，先通过根因定位系统，如果识别出慢查询造成的，会马上调用SQL优化建议系统，推荐出索引，整个处理流程是分钟级别，都会在群里面推送最新消息。如下图所示：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/26/0931-ONekMc.jpeg" alt="图片"></p>
<p>告警诊断</p>
<h2 id="7-未来规划"><a href="#7-未来规划" class="headerlink" title="7 未来规划"></a>7 未来规划</h2><p>考虑到美团日均产生近亿级别的慢查询数据，为了实现对它们的诊断分析，我们还需要提高系统大规模的数据并发处理的能力。另外，当前该系统还是针对单SQL的优化，没有考虑维护新索引带来的代价，如占用额外的磁盘空间，使写操作变慢，也没有考虑到MySQL选错索引引发其他SQL的性能回退。对于业务或者DBA来说，我们更多关心的是整个数据库或者集群层面的优化。</p>
<p>业界如阿里云的DAS则是站在全局的角度考量，综合考虑各个因素，输出需要创建的新索引、需要改写的索引、需要删除的索引，实现数据库性能最大化提升，同时最大化降低磁盘空间消耗。未来我们也将不断优化和改进，实现类似基于Workload的全局优化。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>内存</tag>
        <tag>bug</tag>
        <tag>sql</tag>
        <tag>数据库</tag>
        <tag>函数</tag>
        <tag>C++</tag>
        <tag>CPU</tag>
        <tag>全局</tag>
        <tag>Mysql</tag>
        <tag>Qt</tag>
        <tag>索引</tag>
        <tag>并发</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>spring boot 中Spring data jpa命名策略</title>
    <url>/posts/2J0546C.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>数据库，表字段命名是驼峰命名法（UserID）,Spring data jpa 自动更新之后是 user_id, 表字段不对照</p>
<p>Spring data jpa基于Hibernate5.0</p>
<p>application.yml 写法</p>
<p>1、无修改命名 </p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">hibernate:</span></span><br><span class="line">      <span class="attr">naming:</span>                     </span><br><span class="line">        <span class="attr">physical-strategy:</span> <span class="string">org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl</span></span><br></pre></td></tr></table></figure>
<p>2、遇到大写字母 加”_”的命名</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">hibernate:</span></span><br><span class="line">      <span class="attr">naming:</span>                     </span><br><span class="line">        <span class="attr">physical-strategy:</span> <span class="string">org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://cdn.jsdelivr.net/gh/wuwenyishi/shared@image/2022/04/27/1253-eL250t.png" alt="image-20220427125309634"></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>InnoDB锁专题</title>
    <url>/posts/2NPWEZZ.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>原文：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvRnd0TVdCVF9HQkgyY1Nnb2Qyb1V6QQ==">两万字详解！InnoDB锁专题！<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>本文将跟大家聊聊InnoDB的锁。本文比较长，包括一条SQL是如何加锁的，一些加锁规则、如何分析和解决死锁问题等内容，建议耐心读完，肯定对大家有帮助的。</p>
<ol>
<li>为什么需要加锁呢？</li>
<li>InnoDB的七种锁介绍</li>
<li>一条SQL是如何加锁的</li>
<li>RR隔离级别下的加锁规则</li>
<li>如何查看事务加锁情况</li>
<li>死锁案例分析</li>
</ol>
<h2 id="为什么需要加锁？"><a href="#为什么需要加锁？" class="headerlink" title="为什么需要加锁？"></a>为什么需要加锁？</h2><p>数据库为什么需要加锁呢？</p>
<blockquote>
<p>在日常生活中，如果你心情不好。想要一个人静静，<strong>不想被比别人打扰</strong>，你就可以把自己关进房间里，并且<strong>反锁</strong>。</p>
</blockquote>
<p>同理，对于MySQL数据库来说的话，一般的对象都是一个事务一个事务来说的。所以，如果一个事务内，正在写某个SQL，我们肯定<strong>不想它被别的事务影响</strong>到嘛？因此，数据库设计大叔，就给被操作的<strong>SQL加上锁</strong>。</p>
<blockquote>
<p>专业一点的说法: 如果有多个并发请求存取数据，在数据就可能会产生多个事务同时操作同一行数据。如果并发操作不加控制，不加锁的话，就可能写入了不正确的数据，或者导致读取了不正确的数据，破坏了数据的一致性。因此需要考虑加锁。</p>
</blockquote>
<h3 id="事务并发存在的问题"><a href="#事务并发存在的问题" class="headerlink" title="事务并发存在的问题"></a>事务并发存在的问题</h3><ul>
<li><strong>脏读</strong>:一个事务A读取到事务B未提交的数据，就是<strong>脏读</strong>。</li>
<li><strong>不可重复读</strong>：事务A被事务B干扰到了！在事务A范围内，两个相同的查询，读取同一条记录，却返回了不同的数据，这就是<strong>不可重复读</strong>。</li>
<li><strong>幻读</strong>：事务A查询一个范围的结果集，另一个并发事务B往这个范围中<strong>插入/删除</strong>了数据，并静悄悄地提交，然后事务A再次查询相同的范围，两次读取得到的结果集不一样了，这就是幻读。</li>
</ul>
<h3 id="一个加锁和不加锁对比的例子"><a href="#一个加锁和不加锁对比的例子" class="headerlink" title="一个加锁和不加锁对比的例子"></a>一个加锁和不加锁对比的例子</h3><p>我们知道MySQL数据库有四大隔离级别<strong>读已提交（RC）、可重复读（RR）、串行化、读未提交</strong>。如果是<strong>读未提交隔离</strong>级别，并发情况下，它是不加锁的，因此就会存在<strong>脏读、不可重复读、幻读</strong>的问题。</p>
<p>为了更通俗易懂一点，还是给大家举个例子吧，虽然东西挺简单的。假设现在有表结构和数据如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `account` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `balance` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `un_name_idx` (`name`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> account(id,name,balance)<span class="keyword">values</span> (<span class="number">1</span>,<span class="string">&#x27;Jay&#x27;</span>,<span class="number">100</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> account(id,name,balance)<span class="keyword">values</span> (<span class="number">2</span>,<span class="string">&#x27;Eason&#x27;</span>,<span class="number">100</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> account(id,name,balance)<span class="keyword">values</span> (<span class="number">3</span>,<span class="string">&#x27;Lin&#x27;</span>,<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>在<strong>READ-UNCOMMITTED（读未提交）</strong> 隔离级别下，假设现在有两个事务A、B：</p>
<ul>
<li>假设现在Jay的余额是100，事务A正在准备查询Jay的余额</li>
<li>这时候，事务B先扣减Jay的余额，扣了10</li>
<li>最后A 读到的是扣减后的余额</li>
</ul>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0840-zjCmem.png" alt=""></p>
<p>手动验证了一把，流程如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0841-9C4X0u.png" alt=""></p>
<p>由上图可以发现，事务A、B交替执行，事务A被事务B干扰到了，因为事务A读取到事务B未提交的数据,这就是脏读。为什么存在脏读问题呢？这是因为在<strong>读未提交的隔离级别</strong>下执行写操作，并<strong>没有对SQL加锁</strong>，因此产生了<strong>脏读</strong>这个问题。</p>
<p>我们再来看下，在<strong>串行化隔离级别</strong>下，同样的SQL执行流程，又是怎样的呢？</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0841-Rzo6ff.png" alt=""></p>
<p>为啥会阻塞等待超时呢？这是因为<strong>串行化隔离级别</strong>下，对写的SQL<strong>加锁</strong>啦。我们可以再看下加了什么锁，命令如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> innodb_status_output<span class="operator">=</span><span class="keyword">ON</span>;  开启输出</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> innodb_status_output_locks<span class="operator">=</span><span class="keyword">ON</span>;  开启锁信息输出</span><br><span class="line"><span class="keyword">SHOW</span> ENGINE INNODB STATUS</span><br></pre></td></tr></table></figure>
<p>锁相关的输出内容如下：<img data-src="https://xuemingde.com/pages/image/2022/05/06/0843-jljDOq.png" alt=""></p>
<p>我们可以看到了这么一把锁：<code>lock_mode X locks rec but not gap</code>，它到底是一种什么锁呢？来来来，我们一起来学习下<strong>InnoDB的七种锁</strong>。</p>
<h2 id="InnoDB的七种锁介绍"><a href="#InnoDB的七种锁介绍" class="headerlink" title="InnoDB的七种锁介绍"></a>InnoDB的七种锁介绍</h2><p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0844-6u96Tm.png" alt=""></p>
<h3 id="共享-排他锁"><a href="#共享-排他锁" class="headerlink" title="共享/排他锁"></a>共享/排他锁</h3><p>InnoDB呢实现了两种标准的<strong>行级锁</strong>：共享锁（简称S锁）、排他锁（简称X锁）。</p>
<ul>
<li>共享锁：简称为S锁，<strong>在事务要读取一条记录时，需要先获取该记录的S锁。</strong></li>
<li>排他锁：简称X锁，<strong>在事务需要改动一条记录时，需要先获取该记录的X锁。</strong></li>
</ul>
<p>如果事务<code>T1</code>持有行R的<code>S</code>锁，那么另一个事务<code>T2</code>请求访问这条记录时，会做如下处理：</p>
<ul>
<li>T2 请求<code>S</code>锁立即被允许，结果<code>T1和T2</code>都持有R行的<code>S</code>锁</li>
<li>T2 请求<code>X</code>锁不能被立即允许,此操作会阻塞</li>
</ul>
<p>如果<code>T1</code>持有行R的<code>X</code>锁，那么<code>T2</code>请求R的<code>X、S</code>锁都不能被立即允许，<code>T2</code>必须等待<code>T1</code>释放<code>X</code>锁才可以，因为<code>X</code>锁与任何的锁都不兼容。</p>
<p><code>S锁和X锁</code>的兼容关系如下图表格：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0844-1PNaq9.png" alt="图片"></p>
<p><code>X</code>锁和<code>S</code>锁是对于行记录来说的话，因此可以称它们为<strong>行级锁或者行锁</strong>。我们认为行锁的粒度就比较细，其实一个事务也可以在<strong>表级别下加锁</strong>，对应的，我们称之为<strong>表锁</strong>。给表加的锁，也是可以分为<code>X</code>锁和<code>S</code>锁的哈。</p>
<p>如果一个事务给表已经加了<code>S</code>锁，则：</p>
<ul>
<li>别的事务可以继续获得该表的<code>S</code>锁，也可以获得该表中某些记录的<code>S</code>锁。</li>
<li>别的事务不可以继续获得该表的<code>X</code>锁，也不可以获得该表中某些记录的<code>X</code>锁。</li>
</ul>
<p>如果一个事务给表加了<code>X</code>锁，那么</p>
<ul>
<li>别的事务不可以获得该表的<code>S</code>锁，也不可以获得该表某些记录的<code>S</code>锁。</li>
<li>别的事务不可以获得该表的<code>X</code>锁，也不可以继续获得该表某些记录的<code>X</code>锁。</li>
</ul>
<h3 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h3><p>什么是意向锁呢？意向锁是<strong>一种不与行级锁冲突的表级锁</strong>。未来的某个时刻，事务可能要加共享或者排它锁时，先提前声明一个意向。注意一下，意向锁，是一个<strong>表级别的锁哈</strong>。</p>
<p><strong>为什么需要意向锁呢？</strong> 或者换个通俗的说法，为什么要加共享锁或排他锁时的时候，需要提前声明个意向锁呢呢？</p>
<blockquote>
<p>因为InnoDB是支持表锁和行锁共存的，如果一个事务A获取到某一行的排他锁，并未提交，这时候事务B请求获取同一个表的表共享锁。因为<strong>共享锁和排他锁是互斥的</strong>，因此事务B想对这个表加共享锁时，需要保证没有其他事务持有这个表的表排他锁，同时还要保<strong>证没有其他事务持有表中任意一行的排他锁</strong>。</p>
<p>然后问题来了，你要保证没有其他事务持有表中任意一行的排他锁的话，去遍历每一行？这样显然是一个效率很差的做法。<strong>为了解决这个问题，InnoDB的设计大叔提出了意向锁。</strong></p>
</blockquote>
<p><strong>意向锁是如何解决这个问题的呢？</strong>  我们来看下</p>
<p>意向锁分为两类：</p>
<ul>
<li>意向共享锁：简称<code>IS</code>锁，当事务准备在某些记录上加S锁时，需要现在表级别加一个<code>IS</code>锁。</li>
<li>意向排他锁：简称<code>IX</code>锁，当事务准备在某条记录上加上X锁时，需要现在表级别加一个<code>IX</code>锁。</li>
</ul>
<p>比如：</p>
<ul>
<li><code>select ... lock in share mode</code>，要给表设置<code>IS</code>锁;</li>
<li><code>select ... for update</code>，要给表设置<code>IX</code>锁;</li>
</ul>
<p>意向锁又是如何解决这个效率低的问题呢：</p>
<blockquote>
<p>如果一个事务A获取到某一行的排他锁，并未提交,这时候表上就有<code>意向排他锁</code>和这一行的<code>排他锁</code>。这时候事务B想要获取这个表的共享锁，此时因为检测到事务A持有了表的<code>意向排他锁</code>，因此事务A必然持有某些行的排他锁，也就是说事务B对表的加锁请求需要阻塞等待，不再需要去检测表的每一行数据是否存在排他锁啦。这样效率就高很多啦。</p>
</blockquote>
<p>意向锁仅仅表明意向的锁，意向锁之间<strong>并不会互斥，是可以并行的</strong>，整体兼容性如下图所示：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0844-eSVbOP.png" alt=""></p>
<h3 id="记录锁（Record-Lock）"><a href="#记录锁（Record-Lock）" class="headerlink" title="记录锁（Record Lock）"></a>记录锁（Record Lock）</h3><p>记录锁是最简单的行锁，仅仅锁住一行。如：<code>SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE</code>，如果c1字段是主键或者是唯一索引的话，这个SQL会加一个记录锁（Record Lock）</p>
<p>记录锁永远都是加在索引上的，即使一个表没有索引，InnoDB也会隐式的创建一个索引，并使用这个索引实施记录锁。它会阻塞其他事务对这行记录的插入、更新、删除。</p>
<p>一般我们看死锁日志时，都是找关键词，比如<code>lock_mode X locks rec but not gap</code>），就表示一个X型的记录锁。记录锁的关键词就是<strong>rec but not gap</strong>。以下就是一个记录锁的日志：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">RECORD LOCKS space id <span class="number">58</span> page <span class="keyword">no</span> <span class="number">3</span> n bits <span class="number">72</span> index `<span class="keyword">PRIMARY</span>` <span class="keyword">of</span> <span class="keyword">table</span> `test`.`t` </span><br><span class="line">trx id <span class="number">10078</span> lock_mode X locks rec but <span class="keyword">not</span> gap</span><br><span class="line">Record lock, heap <span class="keyword">no</span> <span class="number">2</span> PHYSICAL RECORD: n_fields <span class="number">3</span>; compact format; info bits <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>: len <span class="number">4</span>; hex <span class="number">8000000</span>a; <span class="keyword">asc</span>     ;;</span><br><span class="line"> <span class="number">1</span>: len <span class="number">6</span>; hex <span class="number">00000000274</span>f; <span class="keyword">asc</span>     <span class="string">&#x27;O;;</span></span><br><span class="line"><span class="string"> 2: len 7; hex b60000019d0110; asc        ;;</span></span><br></pre></td></tr></table></figure>
<h3 id="间隙锁（Gap-Lock）"><a href="#间隙锁（Gap-Lock）" class="headerlink" title="间隙锁（Gap Lock）"></a>间隙锁（Gap Lock）</h3><p>为了解决幻读问题，InnoDB引入了间隙锁<code>(Gap Lock)</code>。间隙锁是一种加在两个索引之间的锁，或者加在第一个索引之前，或最后一个索引之后的间隙。它锁住的是<strong>一个区间</strong>，而不仅仅是这个区间中的每一条数据。</p>
<p>比如<code>lock_mode X locks gap before rec</code>表示X型gap锁。以下就是一个间隙锁的日志：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">RECORD LOCKS space id <span class="number">177</span> page <span class="keyword">no</span> <span class="number">4</span> n bits <span class="number">80</span> index idx_name <span class="keyword">of</span> <span class="keyword">table</span> `test2`.`account` </span><br><span class="line">trx id <span class="number">38049</span> lock_mode X locks gap before rec</span><br><span class="line">Record lock, heap <span class="keyword">no</span> <span class="number">6</span> PHYSICAL RECORD: n_fields <span class="number">2</span>; compact format; info bits <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>: len <span class="number">3</span>; hex <span class="number">576569</span>; <span class="keyword">asc</span> Wei;;</span><br><span class="line"> <span class="number">1</span>: len <span class="number">4</span>; hex <span class="number">80000002</span>; <span class="keyword">asc</span>     ;;</span><br></pre></td></tr></table></figure>
<h3 id="临键锁-Next-Key-Lock"><a href="#临键锁-Next-Key-Lock" class="headerlink" title="临键锁(Next-Key Lock)"></a>临键锁(Next-Key Lock)</h3><p>Next-key锁是<strong>记录锁和间隙锁的组合</strong>，它指的是加在某条记录以及这条记录前面间隙上的锁。说得更具体一点就是:临键锁会封锁索引记录本身，以及索引记录之前的区间，即它的锁区间是前开后闭，比如<code>(5,10]</code>。</p>
<p>如果一个会话占有了索引记录R的共享/排他锁，其他会话不能立刻在R之前的区间插入新的索引记录。官网是这么描述的：</p>
<blockquote>
<p>If one session has a shared or exclusive lock on record R in an index,  another session cannot insert a new index record in the gap immediately  before R in the index order.</p>
</blockquote>
<h3 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h3><p>插入意向锁,是插入一行记录操作之前设置的<strong>一种间隙锁。</strong>这个锁释放了一种插入方式的信号。它解决的问题是：多个事务，在同一个索引，同一个范围区间插入记录时，如果插入的位置不冲突，就不会阻塞彼此。</p>
<p>假设有索引值4、7，几个不同的事务准备插入5、6，每个锁都在获得插入行的独占锁之前用插入意向锁各自锁住了4、7之间的间隙，但是不阻塞对方因为插入行不冲突。以下就是一个插入意向锁的日志：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="type">RECORD</span> LOCKS space id <span class="number">31</span> page <span class="keyword">no</span> <span class="number">3</span> n bits <span class="number">72</span> <span class="keyword">index</span> `<span class="keyword">PRIMARY</span>` <span class="keyword">of</span> <span class="keyword">table</span> `test`.`child`</span><br><span class="line">trx id <span class="number">8731</span> lock_mode X locks gap <span class="keyword">before</span> rec <span class="keyword">insert</span> intention waiting</span><br><span class="line"><span class="type">Record</span> <span class="keyword">lock</span>, heap <span class="keyword">no</span> <span class="number">3</span> PHYSICAL <span class="type">RECORD</span>: n_fields <span class="number">3</span>; compact <span class="keyword">format</span>; <span class="keyword">info</span> bits <span class="number">0</span></span><br><span class="line"> <span class="number">0</span>: len <span class="number">4</span>; hex <span class="number">80000066</span>; <span class="keyword">asc</span>    f;;</span><br><span class="line"> <span class="number">1</span>: len <span class="number">6</span>; hex <span class="number">000000002215</span>; <span class="keyword">asc</span>     &quot; ;;</span><br><span class="line"> 2: len 7; hex 9000000172011c; asc     r  ;;...</span><br></pre></td></tr></table></figure>
<p>锁模式兼容矩阵（横向是已持有锁，纵向是正在请求的锁）如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0845-cIOfdv.png" alt=""></p>
<h3 id="自增锁"><a href="#自增锁" class="headerlink" title="自增锁"></a>自增锁</h3><p><strong>自增锁是一种特殊的表级别锁</strong>。它是专门针对<code>AUTO_INCREMENT</code>类型的列，对于这种列，如果表中新增数据时就会去持有自增锁。简言之，如果一个事务正在往表中插入记录，所有其他事务的插入必须等待，以便第一个事务插入的行，是连续的主键值。</p>
<p>官方文档是这么描述的：</p>
<blockquote>
<p>An AUTO-INC lock is a special table-level lock taken by transactions  inserting into tables with AUTO_INCREMENT columns. In the simplest case, if one transaction is inserting values into the table, any other  transactions must wait to do their own inserts into that table, so that  rows inserted by the first transaction receive consecutive primary key  values.</p>
</blockquote>
<p>假设有表结构以及自增模式是1，如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">create</span> <span class="keyword">table</span> t0 (id <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,name <span class="type">varchar</span>(<span class="number">16</span>),<span class="keyword">primary</span> key ( id));</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%innodb_autoinc_lock_mode%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">|</span> Variable_name            <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"><span class="operator">|</span> innodb_autoinc_lock_mode <span class="operator">|</span> <span class="number">1</span>     <span class="operator">|</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
<p>设置事务A和B交替执行流程如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0846-PQAgHX.png" alt=""></p>
<p>通过上图我们可以看到，当我们在事务A中进行自增列的插入操作时，另外会话事务B也进行插入操作，这种情况下会发生2个奇怪的现象：</p>
<ul>
<li>事务A会话中的自增列好像直接增加了2个值。（如上图中步骤7、8）</li>
<li>事务B会话中的自增列直接从2开始增加的。（如上图步骤5、6）</li>
</ul>
<p>自增锁是一个表级别锁，那为什么会话A事务还没结束，事务会话B可以执行插入成功呢？不是应该锁表嘛？</p>
<p>这是因为在参数<code>innodb_autoinc_lock_mode</code>上，这个参数设置为<code>1</code>的时候，相当于将这种<code>auto_inc lock</code>弱化为了一个更轻量级的互斥自增长机制去实现，官方称之为<code>mutex</code>。</p>
<p><code>innodb_autoinc_lock_mode</code>还可以设置为0或者2，</p>
<ul>
<li><strong>0</strong>：表示传统锁模式，使用<code>表级AUTO_INC</code>锁。一个事务的<code>INSERT-LIKE</code>语句在语句执行结束后释放AUTO_INC表级锁，而不是在事务结束后释放。</li>
<li><strong>1</strong>: 连续锁模式,连续锁模式对于<code>Simple inserts</code>不会使用表级锁，而是使用一个轻量级锁来生成自增值，因为InnoDB可以提前直到插入多少行数据。自增值生成阶段使用轻量级互斥锁来生成所有的值，而不是一直加锁直到插入完成。对于<code>bulk inserts</code>类语句使用AUTO_INC表级锁直到语句完成。</li>
<li><strong>2</strong>:交错锁模式,所有的<code>INSERT-LIKE</code>语句都不使用表级锁，而是使用轻量级互斥锁。</li>
</ul>
<blockquote>
<ul>
<li><strong>INSERT-LIKE</strong>:指所有的插入语句，包括：INSERT、REPLACE、INSERT…SELECT、REPLACE…SELECT,LOAD DATA等。</li>
<li><strong>Simple inserts</strong>:指在插入前就能确定插入行数的语句，包括：INSERT、REPLACE，不包含INSERT…ON DUPLICATE KEY UPDATE这类语句。</li>
<li><strong>Bulk inserts</strong>: 指在插入钱不能确定行数的语句，包括：INSERT … SELECT/REPLACE … SELECT/LOAD DATA。</li>
</ul>
</blockquote>
<h2 id="一条SQL是如何加锁的呢？"><a href="#一条SQL是如何加锁的呢？" class="headerlink" title="一条SQL是如何加锁的呢？"></a>一条SQL是如何加锁的呢？</h2><p>介绍完InnoDB的七种锁后，我们来看下一条SQL是如何加锁的哈，现在可以分9种情况进行：</p>
<ul>
<li>组合一：查询条件是主键，RC隔离级别</li>
<li>组合二：查询条件是唯一索引，RC隔离级别</li>
<li>组合三：查询条件是普通索引，RC隔离级别</li>
<li>组合四：查询条件上没有索引，RC隔离级别</li>
<li>组合五：查询条件是主键，RR隔离级别</li>
<li>组合六：查询条件是唯一索引，RR隔离级别</li>
<li>组合七：查询条件是普通索引，RR隔离级别</li>
<li>组合八：查询条件上没有索引，RR隔离级别</li>
<li>组合九：Serializable隔离级别</li>
</ul>
<h3 id="查询条件是主键-RC隔离级别"><a href="#查询条件是主键-RC隔离级别" class="headerlink" title="查询条件是主键 + RC隔离级别"></a>查询条件是主键 + RC隔离级别</h3><p>在<strong>RC（读已提交）</strong> 的隔离级别下，对查询条件列是主键id的话，会加什么锁呢？</p>
<p>我们搞个简单的表，初始化几条数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1 (id <span class="type">int</span>,name <span class="type">varchar</span>(<span class="number">16</span>),<span class="keyword">primary</span> key ( id));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>),(<span class="number">3</span>,<span class="string">&#x27;c&#x27;</span>),(<span class="number">6</span>,<span class="string">&#x27;b&#x27;</span>),(<span class="number">9</span>,<span class="string">&#x27;a&#x27;</span>),(<span class="number">10</span>,<span class="string">&#x27;d&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>假设给定SQL：<code>delete from t1 where id = 6;</code>，id是主键。在RC隔离级别下，只需要将主键上<code>id = 6</code>的记录，加上<code>X锁</code>即可。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0847-KXzs9k.png" alt=""></p>
<p>我们来验证一下吧，先开启事务会话A，先执行以下操作：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>删除id<span class="operator">=</span><span class="number">6</span>的这条记录</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> t1 <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">6</span>;</span><br></pre></td></tr></table></figure>
<p>接着开启事务会话B</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line">update t1 <span class="keyword">set</span> name<span class="operator">=</span><span class="string">&#x27;b1&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span><span class="number">6</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>发现这个阻塞等待，最后超时释放锁了</span><br></pre></td></tr></table></figure>
<p>验证流程图如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0847-kG1emh.png" alt=""></p>
<p>事务会话B对<code>id=6</code>的记录执行更新时，发现阻塞了，打开看下加了什么锁。发现是因为<code>id=6</code>这一行加了一个X型的记录锁</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0848-tcfUmz.png" alt=""></p>
<p>如果我们事务B不是对<code>id=6</code>执行更新，而是其他记录的话，是可以顺利执行的，如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0848-iVSpw0.png" alt=""></p>
<p><strong>结论就是</strong>，在<strong>RC（读已提交）</strong> 的隔离级别下，对查询条件是主键id的场景，会加一个排他锁（X锁），或者说加一个X型的记录锁。</p>
<h3 id="查询条件是唯一索引-RC隔离级别"><a href="#查询条件是唯一索引-RC隔离级别" class="headerlink" title="查询条件是唯一索引+RC隔离级别"></a>查询条件是唯一索引+RC隔离级别</h3><p>如果查询条件id，只是一个唯一索引呢？那在RC（读提交隔离级别下），又加了什么锁呢？我们搞个新的表，初始化几条数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t2 (name <span class="type">varchar</span>(<span class="number">16</span>),id <span class="type">int</span>,<span class="keyword">primary</span> key (name),<span class="keyword">unique</span> key(id));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t2 <span class="keyword">values</span>(<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>),(<span class="string">&#x27;c&#x27;</span>,<span class="number">3</span>),(<span class="string">&#x27;b&#x27;</span>,<span class="number">6</span>),(<span class="string">&#x27;d&#x27;</span>,<span class="number">9</span>);</span><br></pre></td></tr></table></figure>
<p>id是唯一索引，name是主键的场景下，我们给定SQL：<code>delete from t2 where id = 6;</code>。</p>
<p>在RC隔离级别下，该SQL需要加两个<code>X</code>锁，一个对应于id 唯一索引上的<code>id = 6</code>的记录，另一把锁对应于聚簇索引上的<code>[name=’b’,id=6]</code>的记录。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0848-ZWno4R.png" alt=""></p>
<p><strong>为什么主键索引上的记录也要加锁呢？</strong></p>
<blockquote>
<p>如果并发的一个SQL，是通过主键索引来更新：<code>update t2 set id = 666 where name = &#39;b&#39;;</code>此时，如果delete语句没有将主键索引上的记录加锁，那么并发的update就会感知不到delete语句的存在，违背了同一记录上的更新/删除需要串行执行的约束。</p>
</blockquote>
<h3 id="查询条件是普通索引-RC隔离级别"><a href="#查询条件是普通索引-RC隔离级别" class="headerlink" title="查询条件是普通索引 + RC隔离级别"></a>查询条件是普通索引 + RC隔离级别</h3><p>如果查询条件是普通的二级索引，在RC（读提交隔离级别下），又加了什么锁呢？</p>
<blockquote>
<p>若id列是普通索引，那么对应的所有满足SQL查询条件的记录，都会加上锁。同时，这些记录对应主键索引，也会上锁。</p>
</blockquote>
<p>我们初始化下表结构和数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t3 (name <span class="type">varchar</span>(<span class="number">16</span>),id <span class="type">int</span>,<span class="keyword">primary</span> key (name),key(id));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t3 <span class="keyword">values</span>(<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>),(<span class="string">&#x27;c&#x27;</span>,<span class="number">3</span>),(<span class="string">&#x27;b&#x27;</span>,<span class="number">6</span>),(<span class="string">&#x27;e&#x27;</span>,<span class="number">6</span>),(<span class="string">&#x27;d&#x27;</span>,<span class="number">9</span>);</span><br></pre></td></tr></table></figure>
<p>加锁示意图如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0848-2QRBai.png" alt=""></p>
<p>我们来验证一下，先开启事务会话A，先执行以下操作：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>删除id<span class="operator">=</span><span class="number">6</span>的这条记录</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> t3 <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">6</span>;</span><br></pre></td></tr></table></figure>
<p>接着开启事务会话B</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line">update t3 <span class="keyword">set</span> id<span class="operator">=</span><span class="number">7</span> <span class="keyword">where</span> name <span class="operator">=</span><span class="string">&#x27;e&#x27;</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>发现这个阻塞等待，最后超时释放锁了</span><br></pre></td></tr></table></figure>
<p>实践流程如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0847-MVh31G.png" alt=""></p>
<p>事务会话B为什么会阻塞等待超时，是因为事务会话A的<code>delete语句</code>确实有加<strong>主键索引的X锁</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0850-5TmKEB.png" alt=""></p>
<h3 id="查询条件列无索引-RC隔离级别"><a href="#查询条件列无索引-RC隔离级别" class="headerlink" title="查询条件列无索引+RC隔离级别"></a>查询条件列无索引+RC隔离级别</h3><p>如果id没有加索引，只是一个常规的列，在RC（读提交隔离级别下），又加了什么锁呢？</p>
<blockquote>
<p>若id列上没有索引，MySQL会走聚簇索引进行全表扫描过滤。每条记录都会加上X锁。但是，<strong>为了效率考虑，MySQL在这方面进行了改进</strong>，在扫描过程中，<strong>若记录不满足过滤条件，会进行解锁操作</strong>。同时优化违背了2PL原则。</p>
</blockquote>
<p>初始化下表结构和数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t4 (name <span class="type">varchar</span>(<span class="number">16</span>),id <span class="type">int</span>,<span class="keyword">primary</span> key (name));</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t4 <span class="keyword">values</span>(<span class="string">&#x27;a&#x27;</span>,<span class="number">1</span>),(<span class="string">&#x27;c&#x27;</span>,<span class="number">3</span>),(<span class="string">&#x27;b&#x27;</span>,<span class="number">6</span>),(<span class="string">&#x27;e&#x27;</span>,<span class="number">6</span>),(<span class="string">&#x27;d&#x27;</span>,<span class="number">9</span>);</span><br></pre></td></tr></table></figure>
<p>加锁示意图图下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0850-XHe3A7.png" alt=""></p>
<p>验证流程如下，先开启事务会话A，先执行以下操作：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>删除id<span class="operator">=</span><span class="number">6</span>的这条记录</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> t4 <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">6</span>;</span><br></pre></td></tr></table></figure>
<p>接着开启事务会话B</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>可以执行，MySQL因为效率问题，解锁了</span><br><span class="line">update t4 <span class="keyword">set</span> name<span class="operator">=</span><span class="string">&#x27;f&#x27;</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">3</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>阻塞等待</span><br><span class="line">update t4 <span class="keyword">set</span> name<span class="operator">=</span><span class="string">&#x27;f&#x27;</span> <span class="keyword">where</span> id<span class="operator">=</span><span class="number">6</span>;</span><br></pre></td></tr></table></figure>
<p>验证结果如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0850-CdXVfD.png" alt=""></p>
<h3 id="查询条件是主键-RR隔离级别"><a href="#查询条件是主键-RR隔离级别" class="headerlink" title="查询条件是主键+RR隔离级别"></a>查询条件是主键+RR隔离级别</h3><p>给定SQL：<code>delete from t1 where id = 6;</code>，如果id是<strong>主键</strong>的话，在RR隔离级别下，跟RC隔离级别，加锁是一样的，也都是在<code>id = 6</code>这条记录上加上<code>X</code>锁。大家感兴趣可以照着3.1小节例子，自己验证一下哈。</p>
<h3 id="查询条件是唯一索引-RR隔离级别"><a href="#查询条件是唯一索引-RR隔离级别" class="headerlink" title="查询条件是唯一索引+RR隔离级别"></a>查询条件是唯一索引+RR隔离级别</h3><p>给定SQL：<code>delete from t1 where id = 6;</code>，如果id是<strong>唯一索引</strong>的话，在RR隔离级别下，跟RC隔离级别，加锁也是一样的哈，加了两个<code>X</code>锁，id唯一索引满足条件的记录上一个，对应的主键索引上的记录一个。</p>
<h3 id="查询条件是普通索引-RR隔离级别"><a href="#查询条件是普通索引-RR隔离级别" class="headerlink" title="查询条件是普通索引+RR隔离级别"></a>查询条件是普通索引+RR隔离级别</h3><p>如果查询条件是普通的二级索引，在RR（可重复读的隔离级别下），除了会加<code>X</code>锁，<strong>还会加<code>间隙Gap</code>锁</strong>。Gap锁的提出，是为了解决幻读问题引入的，它是一种加在两个索引之间的锁。</p>
<p>假设有表结构和初始化数据如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t5 ( id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, c <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, d <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, <span class="keyword">PRIMARY</span> KEY (id), KEY c (c)) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t5 <span class="keyword">values</span>(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure>
<p>如果一条更新语句<code>update t5 set d=d+1 where c = 10</code>，加锁示意图如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0902-qfPKDu.png" alt=""></p>
<p>我们来验证一下吧，先开启事务会话A，先执行以下操作：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line">update t5 <span class="keyword">set</span> d<span class="operator">=</span>d<span class="operator">+</span><span class="number">1</span> <span class="keyword">where</span> c <span class="operator">=</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>接着开启事务会话B</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t5 <span class="keyword">values</span>(<span class="number">12</span>,<span class="number">12</span>,<span class="number">12</span>);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>阻塞等待，最后超时释放锁了</span><br></pre></td></tr></table></figure>
<p>验证流程图如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0902-39Kfd7.png" alt=""></p>
<p>为什么会阻塞呢？因此<code>c=10</code>这个记录更新时，不仅会有两把<code>X</code>锁，还会把区间<code>（10,15）</code>加间隙锁，因此要插入<code>（12,12,12）</code>记录时，会阻塞。</p>
<h3 id="查询条件列无索引-RR隔离级别"><a href="#查询条件列无索引-RR隔离级别" class="headerlink" title="查询条件列无索引+RR隔离级别"></a>查询条件列无索引+RR隔离级别</h3><p>如果查询条件列没有索引呢？又是如何加的锁呢？</p>
<p>假设有表结构和数据如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t5 ( id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, c <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, d <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, <span class="keyword">PRIMARY</span> KEY (id)) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t5 <span class="keyword">values</span>(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure>
<p>给定一条更新语句<code>update t5 set d=d+1 where c = 10</code>，因为<code>c</code>列没有索引，加锁示意图如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0902-WeELho.png" alt=""></p>
<p>如果查询条件列没有索引，主键索引的所有记录，都将加上<code>X锁</code>，每条记录间也都加上<code>间隙Gap锁</code>。大家可以想象一下，任何加锁并发的SQL，都是不能执行的，全表都是锁死的状态。如果表的数据量大，那效率就更低。</p>
<blockquote>
<p>在这种情况下，MySQL做了一些优化，即<code>semi-consistent read</code>，对于不满足条件的记录，MySQL提前释放锁，同时Gap锁也会释放。而<code>semi-consistent read</code>是如何触发的呢：要么在<code>Read Committed</code>隔离级别下；要么在<code>Repeatable Read</code>隔离级别下，设置了<code>innodb_locks_unsafe_for_binlog</code>参数。但是<code>semi-consistent read</code>本身也会带来其他的问题，不建议使用。</p>
</blockquote>
<p>我们来验证一下哈，先开启事务会话A，先执行以下操作：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line">update t5 <span class="keyword">set</span> d<span class="operator">=</span>d<span class="operator">+</span><span class="number">1</span> <span class="keyword">where</span> c <span class="operator">=</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure>
<p>接着开启事务会话B</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t5 <span class="keyword">values</span>(<span class="number">16</span>,<span class="number">16</span>,<span class="number">16</span>);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>插入阻塞等待</span><br><span class="line">update t5 <span class="keyword">set</span> d<span class="operator">=</span>d<span class="operator">+</span><span class="number">1</span> <span class="keyword">where</span> c <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>更新阻塞等待</span><br></pre></td></tr></table></figure>
<p>我们去更新一条不存在的<code>c=16</code>的记录，也会被X锁阻塞的。验证如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0902-9Yheuk.png" alt=""></p>
<h3 id="Serializable串行化"><a href="#Serializable串行化" class="headerlink" title="Serializable串行化"></a>Serializable串行化</h3><p>在<strong>Serializable串行化的隔离级别</strong>下，对于写的语句，比如<code>update account set balance= balance-10 where name=‘Jay’;</code>，跟RC和RR隔离级别是一样的。不一样的地方是，在查询语句，如<code>select balance from account where name = ‘Jay’;</code>，在<strong>RC和RR</strong>是不会加锁的，但是在Serializable串行化的隔离级别，即会加锁。</p>
<p>如文章开始第一小节的那个例子，就是类似的：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0903-hHscAN.png" alt=""></p>
<h2 id="RR隔离级别下，加锁规则到底是怎样的呢？"><a href="#RR隔离级别下，加锁规则到底是怎样的呢？" class="headerlink" title="RR隔离级别下，加锁规则到底是怎样的呢？"></a>RR隔离级别下，加锁规则到底是怎样的呢？</h2><p>对于RC隔离级别，加的排他锁（X锁），是比较好理解的，哪里更新就锁哪里嘛。但是<strong>RR隔离级别</strong>，间隙锁是怎么加的呢？我们一起来学习一下。</p>
<p>对<strong>InnoDb</strong>的锁来说，面试的时候问的比较多，就是<code>Record lock、Gap lock、Next-key lock</code>。接下来我们来学习，RR隔离级别，到底一个锁是怎么加上去的。<strong>丁奇的MySQL45讲有讲到，RR隔离级别，是如何加锁的。大家有兴趣可以去订购看下哈，非常不错的课程。</strong></p>
<p>首先MySQL的版本，是<code>5.x 系列 &lt;=5.7.24，8.0 系列 &lt;=8.0.13</code>。加锁规则一共包括：两个<code>原则</code>、<code>两个优化</code>和一个<code>bug</code>。</p>
<ul>
<li><strong>原则1</strong>：加锁的基本单位都是<code>next-key lock</code>。<code>next-key lock（临键锁）</code>是前开后闭区间。</li>
<li><strong>原则2</strong>：查找过程中访问到的对象才会加锁。</li>
<li><strong>优化1</strong>：索引上的等值查询，给唯一索引加锁的时候，<code>next-key lock</code>退化为行锁<code>（Record lock）</code>。</li>
<li><strong>优化 2</strong>：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，<code>next-key lock</code>退化为间隙锁（Gap lock）。</li>
<li><strong>一个 bug</strong>：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li>
</ul>
<p>假设有表结构和数据如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t5 ( id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, c <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, d <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, <span class="keyword">PRIMARY</span> KEY (id), KEY c (c)) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t5 <span class="keyword">values</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>),(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>),(<span class="number">15</span>,<span class="number">15</span>,<span class="number">15</span>),(<span class="number">20</span>,<span class="number">20</span>,<span class="number">20</span>),(<span class="number">25</span>,<span class="number">25</span>,<span class="number">25</span>);</span><br></pre></td></tr></table></figure>
<p>分7个案例去分析哈：</p>
<ol>
<li>等值查询间隙锁</li>
<li>非唯一索引等值锁</li>
<li>主键索引范围锁</li>
<li>非唯一索引范围锁</li>
<li>唯一索引范围锁 bug</li>
<li>普通索引上存在”等值”的例子</li>
<li>limit 语句减少加锁范围</li>
</ol>
<h3 id="案例一：等值查询间隙锁"><a href="#案例一：等值查询间隙锁" class="headerlink" title="案例一：等值查询间隙锁"></a>案例一：等值查询间隙锁</h3><p>我们同时开启A、B、C三个会话事务，如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0903-I4wc17.png" alt=""></p>
<p>发现事务B会阻塞等待，而C可以执行成功。如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0903-ciVgJv.png" alt=""></p>
<p><strong>为什么事务B会阻塞呢？</strong></p>
<ul>
<li>这是因为根据<strong>加锁原则1</strong>：加锁基本单位是<code>next-key lock</code>，因此事务会话 A的加锁范围是（5,10]，这里为什么是区间（5,10]，这是因为更新的记录，所在的表已有数据的区间就是5-10哈，又因为<code>next-key lock</code>是左开右闭的，所以加锁范围是<code>（5,10]</code>。</li>
<li>同时<strong>根据优化 2</strong>，这是一个等值查询 (id=6)，而id=10不满足查询条件。所以<code>next-key lock</code>退化成间隙<code>Gap锁</code>，因此最终加锁的范围是<code>(5,10)</code>。</li>
<li>然后<code>事务Session B</code>中，你要插入的是9,9在区间(5,10)内，而区间(5,10)都被锁了。因此事务B会阻塞等到。</li>
</ul>
<p><strong>为什么事务C可以正常执行呢？</strong></p>
<p>这是因为锁住的区间是<code>(5,10)</code>，没有包括10，<strong>所以事务C可以正常执行</strong>。</p>
<h3 id="案例二：非唯一索引等值锁"><a href="#案例二：非唯一索引等值锁" class="headerlink" title="案例二：非唯一索引等值锁"></a>案例二：非唯一索引等值锁</h3><p>按顺序执行事务会话A、B、C，如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0903-K9ZEdt.png" alt=""></p>
<p>发现事务B可以执行成功，而C阻塞等待。如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0904-qKvDbd.png" alt=""></p>
<p><strong>为什么事务会话B没有阻塞，事务会话C却阻塞了？</strong></p>
<p>事务会话A执行时，会给索引树<code>c=5</code>的这一行加上读<code>共享</code>锁。</p>
<ol>
<li>根据<strong>加锁原则1</strong>，加锁单位是<code>next-key lock</code>，因此会加上<code>next-key lock(0,5]</code>。</li>
<li>因为c 只是普通索引，所以仅访问<code>c=5</code>这一条记录时不会马上停下来，需要继续向右遍历，查到<code>c=10</code>才结束。根据<strong>加锁原则2</strong>，访问到的都要加锁，因此要给<code>(5,10]</code>加<code>next-key lock</code>。</li>
<li>由<strong>加锁优化2</strong>：等值判断，向右遍历，最后一个值10<code>不满足c=5</code> 这个等值条件，因此退化成间隙锁 <code>(5,10)</code>。</li>
<li>根据<strong>加锁原则 2</strong> ：<strong>只有访问到的对象才会加锁</strong>，事务A的这个查询使用了<strong>覆盖索引</strong>，没有回表，并不需要访问主键索引，因此主键索引上没有加任何锁，事务会话B是对主键id的更新，因此事务会话B的<code>update</code>语句不会阻塞。</li>
<li>但是事务会话C，要插入一个（6,6,6) 的记录时，会被事务会话A的<code>间隙锁(5,10)</code>锁住，因此事务会话C阻塞了。</li>
</ol>
<h3 id="案例三：主键索引范围锁"><a href="#案例三：主键索引范围锁" class="headerlink" title="案例三：主键索引范围锁"></a>案例三：主键索引范围锁</h3><p>主键范围查询又是怎么加锁的呢？比如给定SQL:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t5 <span class="keyword">where</span> id<span class="operator">&gt;=</span><span class="number">10</span> <span class="keyword">and</span> id<span class="operator">&lt;</span><span class="number">11</span> <span class="keyword">for</span> update;</span><br></pre></td></tr></table></figure>
<p>按顺序执行事务会话A、B、C，如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0905-6KeA3e.png" alt=""></p>
<p>执行结果如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0904-he5Pzo.png" alt=""></p>
<p>发现事务会话B中，插入12，即<code>insert into t5 values(12,12,12);</code>时，阻塞了，而插入6，<code>insert into t5 values(6,6,6);</code>却可以顺利执行。同时事务C中，<code>Update t5 set d=d+1 where id =15;</code>也会阻塞，为什么呢？</p>
<p>事务会话A执行时，要找到第一个<code>id=10</code>的行：</p>
<ul>
<li>根据<strong>加锁原则1</strong>：加锁单位是<code>next-key lock</code>，因此会加上<code>next-key lock(5,10]</code>。</li>
<li>又因为id是主键，也就是唯一值，因此根据<strong>优化1</strong>：索引上的等值查询，给唯一索引加锁时，<code>next-key lock</code>退化为<code>行锁（Record lock）</code>。所以只加了<code>id=10</code>这个行锁。</li>
<li>范围查找就往后继续找，找到<code>id=15</code>这一行停下来，因此还需要加<code>next-key lock(10,15]</code>。</li>
</ul>
<p>事务会话A执行完后，加的锁是<code>id=10</code>这个行锁，以及临键锁<code>next-key lock(10,15]</code>。这就是为什么事务B插入6那个记录可以顺利执行，插入12就不行啦。同理，事务C那个更新id=15的记录，也是会被阻塞的。</p>
<h3 id="案例四：非唯一索引范围锁"><a href="#案例四：非唯一索引范围锁" class="headerlink" title="案例四：非唯一索引范围锁"></a>案例四：非唯一索引范围锁</h3><p>如果是普通索引，范围查询又加什么锁呢？按顺序执行事务会话A、B、C，如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0847-q6kmuK.png" alt=""></p>
<p>执行结果如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0905-uPcab7.png" alt=""></p>
<p>发现事务会话B和事务会话C的执行SQL都被阻塞了。</p>
<p>这是因为，事务会话A执行时，要找到第一个<code>c=10</code>的行：</p>
<ol>
<li>根据加锁原则1：加锁单位是next-key lock，因此会加上<code>next-key lock(5,10]</code>。又因为c不是唯一索引，所以它不会退化为行锁。因此加的锁还是<code>next-key lock(5,10]</code>。</li>
<li>范围查找就往后继续找，找到<code>id=15</code>这一行停下来，因此还需要加<code>next-key lock(10,15]</code>。</li>
</ol>
<p>因此事务B和事务C插入的<code>insert into t5 values(6,6,6);</code>和<code>Update t5 set d=d+1 where c =15;</code> 都会阻塞。</p>
<h3 id="案例五：唯一索引范围锁-bug"><a href="#案例五：唯一索引范围锁-bug" class="headerlink" title="案例五：唯一索引范围锁 bug"></a>案例五：唯一索引范围锁 bug</h3><p>前面四种方案中，加锁的两个原则和两个优化都已经用上啦，那个唯一索引范围bug是如何触发的呢？</p>
<p>按顺序执行事务会话A、B、C，如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0905-caM9Bu.png" alt=""></p>
<p>执行结果如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0905-ARS7ah.png" alt=""></p>
<p>发现事务B的更新语句<code>Update t5 set d=d+1 where id =20;</code>和事务C<code>insert into t5 values(18,18,18);</code>的插入语句均已阻塞了。</p>
<p>这是因为，事务会话A执行时，要找到第一个<code>id=15</code>的行，根据加锁原则1：加锁单位是<code>next-key lock</code>，因此会加上<code>next-key lock(10,15]</code>。因为id是主键，即唯一的，因此循环判断到 id=15 这一行就应该停止了。但是实现上，InnoDB 会往前扫描到第一个不满足条件的行为止，直到扫描到<code>id=20</code>。而且由于这是个范围扫描，因此索引id上的<code>(15,20]</code>这个 next-key lock 也会被锁上。</p>
<p>所以，事务B要更新 id=20 这一行时，会阻塞锁住。同样地事务会话C要插入<code>id=16</code>的一行，也会被锁住。</p>
<h3 id="案例六：普通索引上存在”等值”的例子"><a href="#案例六：普通索引上存在”等值”的例子" class="headerlink" title="案例六：普通索引上存在”等值”的例子"></a>案例六：普通索引上存在”等值”的例子</h3><p>如果查询条件列是普通索引，且存在相等的值，加锁又是怎样的呢？</p>
<p>在原来t5表的数据基础上，插入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t5 <span class="keyword">values</span>(<span class="number">28</span>,<span class="number">10</span>,<span class="number">66</span>);</span><br></pre></td></tr></table></figure>
<p>则<code>c索引</code>树如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0906-TmNMbH.png" alt=""></p>
<p>c索引值有相等的，但是它们对应的主键是有间隙的。比如<code>（c=10，id=10）和（c=10，id=28）</code>之间。</p>
<p>我们来看个例子，按顺序执行事务会话A、B、C，如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0906-56dH1p.png" alt=""></p>
<p>执行结果如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0906-qHyOtb.png" alt=""></p>
<p>为什么事务B插入语句会阻塞，事务C的更新语句不会呢？</p>
<ul>
<li>这是因为事务会话A在遍历的时候，先访问第一个<code>c=10</code>的记录。它根据<strong>原则 1</strong>，加一个(c=5,id=5) 到 (c=10,id=10)的next-key lock。</li>
<li>然后，事务会话A向右查找，直到碰到 (c=15,id=15) 这一行，循环才结束。根据优化 2，这是一个等值查询，向右查找到了不满足条件的行，所以会退化成<code>(c=10,id=10) 到 (c=15,id=15)</code>的间隙Gap锁。即事务会话A这个<code>select...for update</code>语句在索引 c 上的加锁范围，就是下图灰色阴影部分的：</li>
</ul>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0906-iQzyAT.png" alt=""></p>
<p>因为c=13是这个区间内的，所以事务B插入<code>insert into t5 values(13,13,13);</code>会阻塞。因为根据优化2，已经退化成 (c=10,id=10) 到 (c=15,id=15) 的间隙Gap锁,即不包括c=15，所以事务C，<code>Update t5 set d=d+1 where c=15</code>不会阻塞</p>
<h3 id="案例七：limit-语句减少加锁范围"><a href="#案例七：limit-语句减少加锁范围" class="headerlink" title="案例七：limit 语句减少加锁范围"></a>案例七：limit 语句减少加锁范围</h3><p>如果一个SQL有limit，会不会对加锁有什么影响呢？我们用4.6的例子，然后给查询语句加个limit：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="operator">*</span> <span class="keyword">from</span> t5 <span class="keyword">where</span> c<span class="operator">=</span><span class="number">10</span> limit <span class="number">2</span> <span class="keyword">for</span> update;</span><br></pre></td></tr></table></figure>
<p>事务A、B执行如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0906-e5VvVv.png" alt=""></p>
<p>发现事务B并没有阻塞，而是可以顺利执行</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0907-lvIaxm.png" alt=""></p>
<p>这是为什么呢？跟上个例子，怎么事务会话B的SQL却不会阻塞了，事务会话A的<code>select</code>只是加多了一个<code>limit 2</code>。</p>
<p>这是因为明确加了<code>limit 2</code>的限制后，因此在遍历到 (c=10, id=30) 这一行之后，满足条件的语句已经有两条，循环就结束了。因此，索引 c上的加锁范围就变成了从（c=5,id=5) 到（c=10,id=30) 这个前开后闭区间，如下图所示：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0907-KZVQB0.png" alt=""></p>
<p>索引平时我们写SQL的时候，比如<code>查询select或者delete语句</code>时，尽量加一下<code>limit</code>哈，你看着这个例子不就减少了锁范围了嘛，哈哈。</p>
<h2 id="如何查看事务加锁情况"><a href="#如何查看事务加锁情况" class="headerlink" title="如何查看事务加锁情况"></a>如何查看事务加锁情况</h2><p>我门怎么查看执行中的SQL加了什么锁呢？或者换个说法，如何查看事务的加锁情况呢？有这两种方法：</p>
<ul>
<li>使用<code>infomation_schema</code>数据库中的表获取锁信息</li>
<li>使用show engine innodb status 命令</li>
</ul>
<h3 id="使用infomation-schema数据库中的表获取锁信息"><a href="#使用infomation-schema数据库中的表获取锁信息" class="headerlink" title="使用infomation_schema数据库中的表获取锁信息"></a>使用infomation_schema数据库中的表获取锁信息</h3><p><code>infomation_schema</code>数据库中，有几个表跟锁紧密关联的。</p>
<ul>
<li><strong>INNODB_TRX</strong>：该表存储了InnoDB当前正在执行的事务信息，包括事务id、事务状态（比如事务是在运行还是在等待获取某个所）等。</li>
<li><strong>INNODB_LOCKS</strong>：该表记录了一些锁信息，包括两个方面：1.如果一个事务想要获取某个锁，但未获取到，则记录该锁信息。2. 如果一个事务获取到了某个锁，但是这个锁阻塞了别的事务，则记录该锁信息。</li>
<li><strong>INNODB_LOCK_WAITS</strong>:表明每个阻塞的事务是因为获取不到哪个事务持有的锁而阻塞。</li>
</ul>
<h4 id="INNODB-TRX"><a href="#INNODB-TRX" class="headerlink" title="INNODB_TRX"></a>INNODB_TRX</h4><p>我们在一个会话中执行加锁的语句，在另外一个会话窗口，即可查看<code>INNODB_TRX</code>的信息啦，如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0847-Zgg6SA.png" alt=""></p>
<p>表中可以看到一个事务id为<code>1644837</code>正在运行汇中，它的隔离级别为<code>REPEATABLE READ</code>。我们一般关注这几个参数：</p>
<ul>
<li>trx_tables_locked：该事务当前加了多少个表级锁。</li>
<li>trx_rows_locked：表示当前加了多少个行级锁。</li>
<li>trx_lock_structs：表示该事务生成了多少个内存中的锁结构。</li>
</ul>
<h4 id="INNODB-LOCKS"><a href="#INNODB-LOCKS" class="headerlink" title="INNODB_LOCKS"></a>INNODB_LOCKS</h4><p>一般系统中，发生某个事务<strong>因为获取不到锁而被阻塞时</strong>，该表才会有记录。</p>
<p>事务A、B执行如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0909-NTEzcV.png" alt=""></p>
<p>使用<code>select * from information_schema.INNODB_LOCKS;</code>查看</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0909-lWBKAm.png" alt=""></p>
<p>可以看到两个事务Id <code>1644842</code>和<code>1644843</code>都持有什么锁，就是看那个<code>lock_mode和lock_type</code>哈。但是并看不出是哪个锁在等待那个锁导致的阻塞，这时候就可以看<code>INNODB_LOCK_WAITS</code>表啦。</p>
<h4 id="INNODB-LOCK-WAITS"><a href="#INNODB-LOCK-WAITS" class="headerlink" title="INNODB_LOCK_WAITS"></a>INNODB_LOCK_WAITS</h4><p>INNODB_LOCK_WAITS 表明每个事务是因为获取不到哪个事务持有的锁而阻塞。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0909-GnpSfx.png" alt=""></p>
<ul>
<li>requesting_trx_id：表示因为获取不到锁而被阻塞的事务的事务id</li>
<li>blocking_trx_id：表示因为获取到别的事务需要的锁而导致其被阻塞的事务的事务Id。</li>
</ul>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0910-K0s0xk.png" alt=""></p>
<p>即<code>requesting_trx_id</code>表示事务B的事务Id，<code>blocking_trx_id</code>表示事务A的事务Id。</p>
<h3 id="show-engine-innodb-status"><a href="#show-engine-innodb-status" class="headerlink" title="show engine innodb status"></a>show engine innodb status</h3><p><strong>INNODB_LOCKS</strong> 和 <strong>INNODB_LOCK_WAITS</strong> 在MySQL 8.0已被移除，其实就是不鼓励我们用这两个表来获取表信息。而我们还可以用<code>show engine innodb status</code>获取当前系统各个事务的加锁信息。</p>
<p>在看死锁日志的时候，我们一般先把这个变量<code>innodb_status_output_locks</code>打开哈，它是MySQL 5.6.16 引入的</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span>  innodb_status_output_locks <span class="operator">=</span><span class="keyword">on</span>;</span><br></pre></td></tr></table></figure>
<p>在RR隔离级别下，我们交替执行事务A和B：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0910-fvUHhE.png" alt=""></p>
<p>show engine innodb status查看日志，如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">TRANSACTIONS</span><br><span class="line"></span><br><span class="line">Trx id counter 1644854</span><br><span class="line">Purge done for trx&#x27;s n:o &lt; 1644847 undo n:o &lt; 0 state: running but idle</span><br><span class="line">History list length 32</span><br><span class="line">LIST OF TRANSACTIONS FOR EACH SESSION:</span><br><span class="line">TRANSACTION 283263895935640, not started</span><br><span class="line">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="line">TRANSACTION 1644853, ACTIVE 7 sec inserting</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">LOCK WAIT 2 lock struct(s), heap size 1136, 1 row lock(s), undo log entries 1</span><br><span class="line">MySQL thread id 7, OS thread handle 11956, query id 563 localhost ::1 root update</span><br><span class="line">insert into t5 values(6,6,6)</span><br><span class="line">TRX HAS BEEN WAITING 7 SEC FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 267 page no 4 n bits 80 index c of table `test2`.`t5` trx id 1644853 lock_mode X locks gap before rec insert intention waiting</span><br><span class="line">Record lock, heap no 3 PHYSICAL RECORD: n_fields 2; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 8000000a; asc     ;;</span><br><span class="line"> 1: len 4; hex 8000000a; asc     ;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TABLE LOCK table `test2`.`t5` trx id 1644853 lock mode IX</span><br><span class="line">RECORD LOCKS space id 267 page no 4 n bits 80 index c of table `test2`.`t5` trx id 1644853 lock_mode X locks gap before rec insert intention waiting</span><br><span class="line">Record lock, heap no 3 PHYSICAL RECORD: n_fields 2; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 8000000a; asc     ;;</span><br><span class="line"> 1: len 4; hex 8000000a; asc     ;;</span><br></pre></td></tr></table></figure>
<p>这结构锁的关键词需要记住一下哈：</p>
<ul>
<li><code>lock_mode X locks gap before rec</code>表示X型的gap锁</li>
<li><code>lock_mode X locks rec but not gap</code>表示 X型的记录锁（Record Lock）</li>
<li><code>lock mode X</code> 一般表示 X型临键锁（next-key 锁）</li>
</ul>
<p>以上的锁日志，我们一般关注点，是一下这几个地方：</p>
<ul>
<li><code>TRX HAS BEEN WAITING 7 SEC FOR THIS LOCK TO BE GRANTED</code>表示它在等这个锁</li>
<li><code>RECORD LOCKS space id 267 page no 4 n bits 80 index c of table</code>test2<code>.</code>t5<code>trx id 1644853 lock_mode X locks gap before rec insert intention waiting</code>表示一个锁结构，这个锁结构的Space ID是267，page number是4，n_bits属性为80，对应的索引是<code>c</code>，这个锁结构中存放的锁类型是X型的插入意向Gap锁。</li>
<li><code>0: len 4; hex 8000000a; asc     ;;</code>对应加锁记录的详细信息，8000000a代表的值就是10，a的16进制是10。</li>
<li><code>TABLE LOCK table</code>test2<code>.</code>t5<code>trx id 1644853 lock mode IX</code> 表示一个插入意向表锁</li>
</ul>
<p>这个日志例子，其实理解起来，就是事务A持有了索引c的间隙锁<code>（~，10）</code>，而事务B想获得这个gap锁，而获取不到，就一直在等待这个插入意向锁。</p>
<h2 id="手把手死锁案例分析"><a href="#手把手死锁案例分析" class="headerlink" title="手把手死锁案例分析"></a>手把手死锁案例分析</h2><p>如果发生死锁了，我们应该如何分析呢？一般分为四个步骤：</p>
<ol>
<li><code>show engine innodb status</code>，查看最近一次死锁日志。</li>
<li>分析死锁日志，找到关键词<code>TRANSACTION</code></li>
<li>分析死锁日志，查看正在执行的SQL</li>
<li>看SQL持有什么锁，又在等待什么锁。</li>
</ol>
<h3 id="一个死锁的简单例子"><a href="#一个死锁的简单例子" class="headerlink" title="一个死锁的简单例子"></a>一个死锁的简单例子</h3><p>表结构和数据如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t6 ( id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, c <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, d <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, <span class="keyword">PRIMARY</span> KEY (id), KEY c (c)) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t6 <span class="keyword">values</span>(<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>),(<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>我们开启A、B事务，执行流程如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0847-ln71aR.png" alt=""></p>
<h3 id="6-2-分析死锁日志"><a href="#6-2-分析死锁日志" class="headerlink" title="6.2 分析死锁日志"></a>6.2 分析死锁日志</h3><ol>
<li><code>show engine innodb status</code>，查看最近一次死锁日志。如下：</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">LATEST DETECTED DEADLOCK</span><br><span class="line"></span><br><span class="line">2022-05-03 22:53:22 0x2eb4</span><br><span class="line">*** (1) TRANSACTION:</span><br><span class="line">TRANSACTION 1644867, ACTIVE 31 sec starting index read</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">LOCK WAIT 3 lock struct(s), heap size 1136, 2 row lock(s)</span><br><span class="line">MySQL thread id 5, OS thread handle 7068, query id 607 localhost ::1 root statistics</span><br><span class="line">Select * from t6 where id=10 for update</span><br><span class="line">*** (1) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 268 page no 3 n bits 72 index PRIMARY of table `test2`.`t6` trx id 1644867 lock_mode X locks rec but not gap waiting</span><br><span class="line">Record lock, heap no 3 PHYSICAL RECORD: n_fields 5; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 8000000a; asc     ;;</span><br><span class="line"> 1: len 6; hex 00000019193c; asc      &lt;;;</span><br><span class="line"> 2: len 7; hex dd00000191011d; asc        ;;</span><br><span class="line"> 3: len 4; hex 8000000a; asc     ;;</span><br><span class="line"> 4: len 4; hex 8000000a; asc     ;;</span><br><span class="line"></span><br><span class="line">*** (2) TRANSACTION:</span><br><span class="line">TRANSACTION 1644868, ACTIVE 17 sec starting index read, thread declared inside InnoDB 5000</span><br><span class="line">mysql tables in use 1, locked 1</span><br><span class="line">3 lock struct(s), heap size 1136, 2 row lock(s)</span><br><span class="line">MySQL thread id 7, OS thread handle 11956, query id 608 localhost ::1 root statistics</span><br><span class="line">Select * from t6 where id=5 for update</span><br><span class="line">*** (2) HOLDS THE LOCK(S):</span><br><span class="line">RECORD LOCKS space id 268 page no 3 n bits 72 index PRIMARY of table `test2`.`t6` trx id 1644868 lock_mode X locks rec but not gap</span><br><span class="line">Record lock, heap no 3 PHYSICAL RECORD: n_fields 5; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 8000000a; asc     ;;</span><br><span class="line"> 1: len 6; hex 00000019193c; asc      &lt;;;</span><br><span class="line"> 2: len 7; hex dd00000191011d; asc        ;;</span><br><span class="line"> 3: len 4; hex 8000000a; asc     ;;</span><br><span class="line"> 4: len 4; hex 8000000a; asc     ;;</span><br><span class="line"></span><br><span class="line">*** (2) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line">RECORD LOCKS space id 268 page no 3 n bits 72 index PRIMARY of table `test2`.`t6` trx id 1644868 lock_mode X locks rec but not gap waiting</span><br><span class="line">Record lock, heap no 2 PHYSICAL RECORD: n_fields 5; compact format; info bits 0</span><br><span class="line"> 0: len 4; hex 80000005; asc     ;;</span><br><span class="line"> 1: len 6; hex 00000019193c; asc      &lt;;;</span><br><span class="line"> 2: len 7; hex dd000001910110; asc        ;;</span><br><span class="line"> 3: len 4; hex 80000005; asc     ;;</span><br><span class="line"> 4: len 4; hex 80000005; asc     ;;</span><br></pre></td></tr></table></figure>
<ol>
<li>先找到关键词<code>TRANSACTION</code>，可以发现两部分的事务日志，如下：</li>
</ol>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0911-PPGGm6.png" alt=""></p>
<ol>
<li>查看正在执行，产生死锁的对应的SQL，如下：</li>
</ol>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0847-Xg3rgj.png" alt=""></p>
<ol>
<li>查看分开两部分的TRANSACTION，分别持有什么锁，和等待什么锁。</li>
</ol>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/06/0912-IadvAW.png" alt=""></p>
<p>所谓的死锁，其实就是，我持有你的需要的锁，你持有我需要的锁，形成相互等待的闭环。所以排查死锁问题时，照着这个思维去思考就好啦。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>内存</tag>
        <tag>bug</tag>
        <tag>sql</tag>
        <tag>事务</tag>
        <tag>数据库</tag>
        <tag>变量</tag>
        <tag>面试</tag>
        <tag>Mysql</tag>
        <tag>锁</tag>
        <tag>索引</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>redis的删除过期key的策略</title>
    <url>/posts/SFARPJ.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在Redis内部，每当我们设置一个键的过期时间时，Redis就会将该键带上过期时间存放到一个<strong>过期字典</strong>中。当我们查询一个键时，Redis便首先检查该键是否存在过期字典中，如果存在，那就获取其过期时间。然后将过期时间和当前系统时间进行比对，比系统时间大，那就没有过期；反之判定该键过期。  </p>
<h1 id="过期删除策略"><a href="#过期删除策略" class="headerlink" title="过期删除策略"></a>过期删除策略</h1><h2 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h2><p>在设置key的过期时间的同时，创建一个定时器，让定时器在key的过期时间来临时，立即执行对key的删除操作；  </p>
<p>优点：定时删除对内存是最友好的，能够保存内存的key一旦过期就能立即从内存中删除。  </p>
<p>缺点：对CPU最不友好，在过期键比较多的时候，删除过期键会占用一部分 CPU 时间，对服务器的响应时间和吞吐量造成影响。  </p>
<h2 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h2><p>设置该key 过期时间后，我们不去管它，当需要该key时，我们在检查其是否过期，如果过期，我们就删掉它，反之返回该key。  </p>
<p>优点：对 CPU友好，我们只会在使用该键时才会进行过期检查，对于很多用不到的key不用浪费时间进行过期检查。</p>
<p>缺点：对内存不友好，如果一个键已经过期，但是一直没有使用，那么该键就会一直存在内存中，如果数据库中有很多这种使用不到的过期键，这些键便永远不会被删除，内存永远不会释放。从而造成内存泄漏。  </p>
<h2 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h2><p>每隔一段时间，我们就对一些key进行检查，删除里面过期的key。  </p>
<p>优点：可以通过限制删除操作执行的时长和频率来减少删除操作对 CPU 的影响。另外定期删除，也能有效释放过期键占用的内存。  </p>
<p>缺点：</p>
<ul>
<li>难以确定删除操作执行的时长和频率。</li>
<li>如果执行的太频繁，定期删除策略变得和定时删除策略一样，对CPU不友好。</li>
<li>如果执行的太少，那又和惰性删除一样了，过期键占用的内存不会及时得到释放。</li>
<li>另外最重要的是，在获取某个键时，如果某个键的过期时间已经到了，但是还没执行定期删除，那么就会返回这个键的值，这是业务不能忍受的错误。</li>
</ul>
<h1 id="Redis过期删除策略"><a href="#Redis过期删除策略" class="headerlink" title="Redis过期删除策略"></a>Redis过期删除策略</h1><p>单一使用某一策略都不能满足实际需求，可组合使用。</p>
<p>Redis的过期删除策略就是：惰性删除和定期删除两种策略配合使用。</p>
<ul>
<li><strong>惰性删除</strong>  </li>
</ul>
<p>Redis的惰性删除策略由 db.c/expireIfNeeded 函数实现，所有键读写命令执行之前都会调用 expireIfNeeded 函数对其进行检查，如果过期，则删除该键，然后执行键不存在的操作；未过期则不作操作，继续执行原有的命令。</p>
<ul>
<li><strong>定期删除</strong>  </li>
</ul>
<p>由redis.c/activeExpireCycle 函数实现，函数以一定的频率运行，每次运行时，都从一定数量的数据库中取出一定数量的随机键进行检查，并删除其中的过期键。</p>
<blockquote>
<p>注意：并不是一次运行就检查所有的库，所有的键，而是随机检查一定数量的键。  </p>
</blockquote>
<p>定期删除函数的运行频率，在Redis2.6版本中，规定每秒运行10次，大概100ms运行一次。在Redis2.8版本后，可以通过修改配置文件redis.conf 的 <strong>hz</strong> 选项来调整这个次数。  </p>
<p><strong>建议不要将这个值设置超过 100，否则会对CPU造成比较大的压力。</strong> </p>
<p>通过过期删除策略，对于某些永远使用不到的键，并且多次定期删除也没选定到并删除，那么这些键同样会一直驻留在内存中，又或者在Redis中存入了大量的键，这些操作可能会导致Redis内存不够用，这时候就需要<strong>Redis的内存淘汰策略</strong>了。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>内存</tag>
        <tag>数据库</tag>
        <tag>函数</tag>
        <tag>CPU</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis面试题</title>
    <url>/posts/2PVT91G.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="支持的数据结构"><a href="#支持的数据结构" class="headerlink" title="支持的数据结构"></a>支持的数据结构</h3><ol>
<li>String字符串  </li>
</ol>
<p>存储的String数据是二进制安全的，是最进本的数据类型，一个键最大存储512M。</p>
<p>应用场景：很常见的场景用于统计网站访问数量，当前在线人数等（incr命令自增。decr命令自减）</p>
<p><img data-src="https://xuemingde.com/pages/image/others/1605594981645-3560373a-80a8-4ed9-b098-bbd07f7a6daf.png" alt="image"></p>
<ol>
<li>Hash</li>
</ol>
<p>Redis中的散列可以看成具有String key和String value的map容器，可以将多个key-value存储到一个key中。每一个Hash可以存储4294967295个键值对。</p>
<p>应用场景：例如存储、读取、修改用户属性（name，age，pwd等）</p>
<p><img data-src="https://xuemingde.com/pages/image/others/1605594999435-52838f6c-a296-482f-bbe3-0458bc1d69dd.png" alt="image"></p>
<ol>
<li>List</li>
</ol>
<p>Redis的列表允许用户从序列的两端推入或者弹出元素，列表由多个字符串值组成的有序可重复的序列，是链表结构，所以向列表两端添加元素的时间复杂度为0(1)，获取越接近两端的元素速度就越快。List中可以包含的最大元素数量是4294967295。</p>
<p>应用场景：1.最新消息排行榜。2.消息队列，以完成多程序之间的消息交换。可以用push操作将任务存在list中（生产者），然后线程在用pop操作将任务取出进行执行。（消费者）</p>
<p><img data-src="https://xuemingde.com/pages/image/others/1605594989795-94de03ed-d934-447d-8503-0e9bea7b42f0.png" alt="image"></p>
<ol>
<li>集合Set</li>
</ol>
<p>Redis的集合是无序不可重复的，和列表一样，在执行插入和删除和判断是否存在某元素时，效率是很高的。集合最大的优势在于可以进行交集并集差集操作。Set可包含的最大元素数量是4294967295。</p>
<p>应用场景：1.利用交集求共同好友。2.利用唯一性，可以统计访问网站的所有独立IP。3.好友推荐的时候根据tag求交集，大于某个threshold（临界值的）就可以推荐。</p>
<p><img data-src="https://xuemingde.com/pages/image/others/1605595010088-ed456003-9a56-4631-9ccd-666d4527287b.png" alt="image"></p>
<ol>
<li>有序集合sorted set</li>
</ol>
<p>和set很像，都是字符串的集合，都不允许重复的成员出现在一个set中。他们之间差别在于有序集合中每一个成员都会有一个分数(score)与之关联，Redis正是通过分数来为集合中的成员进行从小到大的排序。尽管有序集合中的成员必须是卫衣的，但是分数(score)却可以重复。</p>
<p>应用场景：可以用于一个大型在线游戏的积分排行榜，每当玩家的分数发生变化时，可以执行zadd更新玩家分数(score)，此后在通过zrange获取几分top ten的用户信息。</p>
<p><img data-src="https://xuemingde.com/pages/image/others/1605595082580-7b4529d5-6260-4901-97cb-3542fc6c48a3.png" alt="image"></p>
<blockquote>
<p>最后，还有个对key的通用操作，所有的数据类型都可以使用的</p>
</blockquote>
<p><img data-src="https://xuemingde.com/pages/image/others/1605595240335-fef65e1b-6f04-432d-b59b-d3275920d741.png" alt="image"></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>集合</tag>
        <tag>Redis</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的缓存一致性 问题</title>
    <url>/posts/15KRDA4.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://xuemingde.com/pages/image/others/1616830617249-353047f5-904e-404b-baa3-0927fc5b4f77.png" alt="image.png"></p>
<h3 id="方式一：-先更新数据库，再更新缓存"><a href="#方式一：-先更新数据库，再更新缓存" class="headerlink" title="方式一： 先更新数据库，再更新缓存"></a>方式一： 先更新数据库，再更新缓存</h3><p><img data-src="https://xuemingde.com/pages/image/others/1616831172055-44a1ca85-3974-494d-aa8b-d4ebbc3405db.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1616831217400-3b84a864-5a2c-4bdf-9e74-3e56c066c30f.png" alt="image.png"></p>
<h3 id="方式二：先删缓存，再更新数据库"><a href="#方式二：先删缓存，再更新数据库" class="headerlink" title="方式二：先删缓存，再更新数据库"></a>方式二：先删缓存，再更新数据库</h3><p><img data-src="https://xuemingde.com/pages/image/others/1616831509175-c5f3169f-903d-4350-ba74-c2bd58286adc.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1616831579262-008fbb7b-e557-4304-b68d-9a7116a6b68a.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1616832118844-b6b49d56-7c2a-4ffe-90df-fec448cd9550.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1616832224837-2684fac9-4305-4e31-a89b-2c6323be1929.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1616832261751-69493367-cb6b-45d5-b39c-4e3cc3c0eaaf.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1616832301163-15e5857b-acfb-459b-b2fc-5977f5eeb378.png" alt="image.png"></p>
<h3 id="方式三：先更新数据库，再删缓存"><a href="#方式三：先更新数据库，再删缓存" class="headerlink" title="方式三：先更新数据库，再删缓存"></a>方式三：先更新数据库，再删缓存</h3><p><img data-src="https://xuemingde.com/pages/image/others/1616832821538-ec765b59-1b06-4150-a804-4be074240641.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1616833138358-58b31377-e7ea-4496-ab02-8e1ca146e25d.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1616833205589-da05da22-7e3f-491c-834d-dd3b07770714.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1616833256057-3fc89667-0735-44b6-982d-3f917b245c13.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1616833278950-6d618e3f-dc05-494b-bd2d-36c36316ecc5.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1616833293111-53a6c67e-ce63-48bd-9e67-b40970b13e24.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1616833332680-af709752-31ec-4793-b293-2b98b1936329.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1616833344867-42c32b3e-ecee-4139-8df7-7f79aa40f928.png" alt="image.png"></p>
<blockquote>
<p>相关文章：<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzcxMjI4NQ==">文章1<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vcmp6aGVuZy9wLzkwNDE2NTkuaHRtbA==">文章2<i class="fa fa-external-link-alt"></i></span>  <span class="exturl" data-url="aHR0cHM6Ly9ub3RlLmRvbHl3LmNvbS9jYWNoZS8wMC1EYXRhQmFzZUNvbnNpc3RlbmN5Lmh0bWw=">文章3<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>redis内存淘汰策略</title>
    <url>/posts/2FA73PT.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="查看Redis当前的内存淘汰策略（本地）"><a href="#查看Redis当前的内存淘汰策略（本地）" class="headerlink" title="查看Redis当前的内存淘汰策略（本地）"></a>查看Redis当前的内存淘汰策略（本地）</h2><p>进入redis安装目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//进入redis安装目录</span><br><span class="line">cd /Users/yons/Redis-service/redis-6.2.6</span><br><span class="line">//进入客户端</span><br><span class="line">redis-cli</span><br><span class="line">//获取当前内存淘汰策略</span><br><span class="line">config get maxmemory-policy</span><br><span class="line">//获取设置的Redis能使用的最大内存大小</span><br><span class="line">config get maxmemory</span><br><span class="line">//设置Redis最大占用内存大小为100M</span><br><span class="line">config set maxmemory 100mb</span><br></pre></td></tr></table></figure>
<blockquote>
<p>内存大小：如果不设置最大内存大小或者设置最大内存大小为0，在64位操作系统下不限制内存大小，在32位操作系统下最多使用3GB内存</p>
</blockquote>
<h2 id="Redis定义的内存淘汰策略"><a href="#Redis定义的内存淘汰策略" class="headerlink" title="Redis定义的内存淘汰策略"></a>Redis定义的内存淘汰策略</h2><ul>
<li><strong>noeviction(默认策略)</strong> ：对于写请求不再提供服务，直接返回错误（DEL请求和部分特殊请求除外）</li>
<li><strong>allkeys-lru</strong>：从所有key中使用LRU算法进行淘汰</li>
<li><strong>volatile-lru</strong>：从设置了过期时间的key中使用LRU算法进行淘汰</li>
<li><strong>allkeys-random</strong>：从所有key中随机淘汰数据</li>
<li><strong>volatile-random</strong>：从设置了过期时间的key中随机淘汰</li>
<li><strong>volatile-ttl</strong>：在设置了过期时间的key中，根据key的过期时间进行淘汰，越早过期的越优先被淘汰</li>
</ul>
<blockquote>
<p>当使用<strong>volatile-lru</strong>、<strong>volatile-random</strong>、<strong>volatile-ttl</strong>这三种策略时，如果没有key可以被淘汰，则和<strong>noeviction</strong>一样返回错误</p>
</blockquote>
<h2 id="修改淘汰策略"><a href="#修改淘汰策略" class="headerlink" title="修改淘汰策略"></a>修改淘汰策略</h2><h3 id="通过命令修改"><a href="#通过命令修改" class="headerlink" title="通过命令修改"></a>通过命令修改</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">config set maxmemory-policy allkeys-lru</span><br></pre></td></tr></table></figure>
<h3 id="通过配置文件修改"><a href="#通过配置文件修改" class="headerlink" title="通过配置文件修改"></a>通过配置文件修改</h3><p>修改redis.conf文件</p>
<p><code>maxmemory-policy allkeys-lru</code></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>内存</tag>
        <tag>Redis</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>一文搞懂redis</title>
    <url>/posts/1F4JVMQ.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p><strong>简介：</strong> NoSQL泛指非关系型数据库，随着web2.0互联网的诞生，传统的关系型数据库很难对付web2.0大数据时代！尤其是超大规模的高并发的社区，暴露出来很多难以克服的问题，NoSQL在当今大数据环境下发展的十分迅速，Redis是发展最快的。</p>
</blockquote>
<h3 id="一-什么是NoSQL？"><a href="#一-什么是NoSQL？" class="headerlink" title="一 什么是NoSQL？"></a>一 什么是NoSQL？</h3><p>Nosql = not only sql（不仅仅是SQL）</p>
<p>关系型数据库：列+行，同一个表下数据的结构是一样的。</p>
<p>非关系型数据库：数据存储没有固定的格式，并且可以进行横向扩展。</p>
<p>NoSQL泛指非关系型数据库，随着web2.0互联网的诞生，传统的关系型数据库很难对付web2.0大数据时代！尤其是超大规模的高并发的社区，暴露出来很多难以克服的问题，NoSQL在当今大数据环境下发展的十分迅速，Redis是发展最快的。</p>
<p>传统RDBMS和NoSQL</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">RDBMS</span><br><span class="line"><span class="bullet"> -</span> 组织化结构</span><br><span class="line"><span class="bullet"> -</span> 固定SQL</span><br><span class="line"><span class="bullet"> -</span> 数据和关系都存在单独的表中（行列）</span><br><span class="line"><span class="bullet"> -</span> DML（数据操作语言）、DDL（数据定义语言）等</span><br><span class="line"><span class="bullet"> -</span> 严格的一致性（ACID): 原子性、一致性、隔离性、持久性</span><br><span class="line"><span class="bullet"> -</span> 基础的事务</span><br><span class="line">NoSQL</span><br><span class="line"><span class="bullet"> -</span> 不仅仅是数据</span><br><span class="line"><span class="bullet"> -</span> 没有固定查询语言</span><br><span class="line"><span class="bullet"> -</span> 键值对存储（redis）、列存储（HBase）、文档存储（MongoDB）、图形数据库（不是存图形，放的是关系）（Neo4j）</span><br><span class="line"><span class="bullet"> -</span> 最终一致性（BASE）：基本可用、软状态/柔性事务、最终一致性</span><br></pre></td></tr></table></figure>
<h3 id="二-redis是什么？"><a href="#二-redis是什么？" class="headerlink" title="二 redis是什么？"></a>二 redis是什么？</h3><p>Redis = Remote Dictionary Server，即远程字典服务。</p>
<p>是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。</p>
<p>与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</p>
<h3 id="三-redis五大基本类型"><a href="#三-redis五大基本类型" class="headerlink" title="三 redis五大基本类型"></a>三 redis五大基本类型</h3><p>Redis是一个开源，内存存储的数据结构服务器，可用作数据库，高速缓存和消息队列代理。它支持字符串、哈希表、列表、集合、有序集合，位图，hyperloglogs等数据类型。内置复制、Lua脚本、LRU收回、事务以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分区。</p>
<p>由于redis类型大家很熟悉，且网上命令使用介绍很多，下面重点介绍五大基本类型的底层数据结构与应用场景，以便当开发时，可以熟练使用redis。</p>
<h4 id="1-String（字符串）"><a href="#1-String（字符串）" class="headerlink" title="1 String（字符串）"></a>1 String（字符串）</h4><figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span><span class="built_in">String</span>类型是redis的最基础的数据结构，也是最经常使用到的类型。</span><br><span class="line">  而且其他的四种类型多多少少都是在字符串类型的基础上构建的，所以<span class="built_in">String</span>类型是redis的基础。</span><br><span class="line"><span class="number">2.</span><span class="built_in">String</span> 类型的值最大能存储 <span class="number">512</span>MB，这里的<span class="built_in">String</span>类型可以是简单字符串、</span><br><span class="line">  复杂的<span class="built_in">xml</span>/json的字符串、二进制图像或者音频的字符串、以及可以是数字的字符串</span><br></pre></td></tr></table></figure>
<p><strong>应用场景</strong></p>
<p>1、缓存功能：String字符串是最常用的数据类型，不仅仅是redis，各个语言都是最基本类型，因此，利用redis作为缓存，配合其它数据库作为存储层，利用redis支持高并发的特点，可以大大加快系统的读写速度、以及降低后端数据库的压力。</p>
<p>2、计数器：许多系统都会使用redis作为系统的实时计数器，可以快速实现计数和查询的功能。而且最终的数据结果可以按照特定的时间落地到数据库或者其它存储介质当中进行永久保存。</p>
<p>3、统计多单位的数量：eg，uid：gongming count：0 根据不同的uid更新count数量。</p>
<p>4、共享用户session：用户重新刷新一次界面，可能需要访问一下数据进行重新登录，或者访问页面缓存cookie，这两种方式做有一定弊端，1）每次都重新登录效率低下 2）cookie保存在客户端，有安全隐患。这时可以利用redis将用户的session集中管理，在这种模式只需要保证redis的高可用，每次用户session的更新和获取都可以快速完成。大大提高效率。</p>
<h4 id="2-List（列表）"><a href="#2-List（列表）" class="headerlink" title="2 List（列表）"></a>2 List（列表）</h4><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span><span class="type">list</span>类型是用来存储多个有序的字符串的，列表当中的每一个字符看做一个元素</span><br><span class="line"><span class="number">2.</span>一个列表当中可以存储有一个或者多个元素，redis的<span class="type">list</span>支持存储<span class="number">2</span>^<span class="number">32</span>次方<span class="number">-1</span>个元素。</span><br><span class="line"><span class="number">3.</span>redis可以从列表的两端进行插入（pubsh）和弹出（pop）元素，支持读取指定范围的元素集，</span><br><span class="line">  或者读取指定下标的元素等操作。redis列表是一种比较灵活的链表数据结构，它可以充当队列或者栈的角色。</span><br><span class="line"><span class="number">4.</span>redis列表是链表型的数据结构，所以它的元素是有序的，而且列表内的元素是可以重复的。</span><br><span class="line">  意味着它可以根据链表的下标获取指定的元素和某个范围内的元素集。</span><br></pre></td></tr></table></figure>
<p><strong>应用场景</strong></p>
<p>1、消息队列：reids的链表结构，可以轻松实现阻塞队列，可以使用左进右出的命令组成来完成队列的设计。比如：数据的生产者可以通过Lpush命令从左边插入数据，多个数据消费者，可以使用BRpop命令阻塞的“抢”列表尾部的数据。</p>
<p>2、文章列表或者数据分页展示的应用。比如，我们常用的博客网站的文章列表，当用户量越来越多时，而且每一个用户都有自己的文章列表，而且当文章多时，都需要分页展示，这时可以考虑使用redis的列表，列表不但有序同时还支持按照范围内获取元素，可以完美解决分页查询功能。大大提高查询效率。</p>
<h4 id="3-Set（集合）"><a href="#3-Set（集合）" class="headerlink" title="3 Set（集合）"></a>3 Set（集合）</h4><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>redis集合（<span class="keyword">set</span>）类型和list列表类型类似，都可以用来存储多个字符串元素的集合。</span><br><span class="line"><span class="number">2.</span>但是和list不同的是<span class="keyword">set</span>集合当中不允许重复的元素。而且<span class="keyword">set</span>集合当中元素是没有顺序的，不存在元素下标。</span><br><span class="line"><span class="number">3.</span>redis的<span class="keyword">set</span>类型是使用哈希表构造的，因此复杂度是O(<span class="number">1</span>)，它支持集合内的增删改查，</span><br><span class="line">  并且支持多个集合间的交集、并集、差集操作。可以利用这些集合操作，解决程序开发过程当中很多数据集合间的问题。</span><br></pre></td></tr></table></figure>
<p><strong>应用场景</strong></p>
<p>1、标签：比如我们博客网站常常使用到的兴趣标签，把一个个有着相同爱好，关注类似内容的用户利用一个标签把他们进行归并。</p>
<p>2、共同好友功能，共同喜好，或者可以引申到二度好友之类的扩展应用。</p>
<p>3、统计网站的独立IP。利用set集合当中元素不唯一性，可以快速实时统计访问网站的独立IP。</p>
<p>数据结构</p>
<p>set的底层结构相对复杂写，使用了intset和hashtable两种数据结构存储，intset可以理解为数组。</p>
<h4 id="4-sorted-set（有序集合）"><a href="#4-sorted-set（有序集合）" class="headerlink" title="4 sorted set（有序集合）"></a>4 sorted set（有序集合）</h4><p>redis有序集合也是集合类型的一部分，所以它保留了集合中元素不能重复的特性，但是不同的是，有序集合给每个元素多设置了一个分数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis有序集合也是集合类型的一部分，所以它保留了集合中元素不能重复的特性，但是不同的是，</span><br><span class="line">有序集合给每个元素多设置了一个分数，利用该分数作为排序的依据。</span><br></pre></td></tr></table></figure>
<p><strong>应用场景</strong></p>
<p>1、 排行榜：有序集合经典使用场景。例如视频网站需要对用户上传的视频做排行榜，榜单维护可能是多方面：按照时间、按照播放量、按照获得的赞数等。</p>
<p>2、用Sorted Sets来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。</p>
<h4 id="5-hash（哈希）"><a href="#5-hash（哈希）" class="headerlink" title="5 hash（哈希）"></a>5 hash（哈希）</h4><figure class="highlight gauss"><table><tr><td class="code"><pre><span class="line">  Redis hash数据结构 是一个键值对（<span class="built_in">key</span>-value）集合,它是一个 <span class="keyword">string</span> 类型的 field 和 value 的映射表，</span><br><span class="line">redis本身就是一个<span class="built_in">key</span>-value型数据库，因此hash数据结构相当于在value中又套了一层<span class="built_in">key</span>-value型数据。</span><br><span class="line">所以redis中hash数据结构特别适合存储关系型对象</span><br></pre></td></tr></table></figure>
<p><strong>应用场景</strong></p>
<p>1、由于hash数据类型的key-value的特性，用来存储关系型数据库中表记录，是redis中哈希类型最常用的场景。一条记录作为一个key-value，把每列属性值对应成field-value存储在哈希表当中，然后通过key值来区分表当中的主键。</p>
<p>2、经常被用来存储用户相关信息。优化用户信息的获取，不需要重复从数据库当中读取，提高系统性能。</p>
<h3 id="四-五大基本类型底层数据存储结构"><a href="#四-五大基本类型底层数据存储结构" class="headerlink" title="四 五大基本类型底层数据存储结构"></a>四 五大基本类型底层数据存储结构</h3><p>在学习基本类型底层数据存储结构前，首先看下redis整体的存储结构。</p>
<p>redis内部整体的存储结构是一个大的hashmap，内部是数组实现的hash，key冲突通过挂链表去实现，每个dictEntry为一个key/value对象，value为定义的redisObject。</p>
<p>结构图如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/201938.png" alt="image.png"></p>
<p>dictEntry是存储key-&gt;value的地方，再让我们看一下dictEntry结构体</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 字典</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">typedef <span class="keyword">struct</span> dictEntry &#123;</span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    union &#123;</span><br><span class="line">        <span class="comment">// 指向具体redisObject</span></span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        uint64_t u64;</span><br><span class="line">        int64_t s64;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="keyword">struct</span> dictEntry *next;</span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>
<h4 id="1-redisObject"><a href="#1-redisObject" class="headerlink" title="1 redisObject"></a>1 redisObject</h4><p>我们接着再往下看redisObject究竟是什么结构的</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Redis 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">typedef <span class="keyword">struct</span> redisObject &#123;</span><br><span class="line">    <span class="comment">// 类型 4bits</span></span><br><span class="line">    unsigned type:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 编码方式 4bits</span></span><br><span class="line">    unsigned encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// LRU 时间（相对于 server.lruclock） 24bits</span></span><br><span class="line">    unsigned lru:<span class="number">22</span>;</span><br><span class="line">    <span class="comment">// 引用计数 Redis里面的数据可以通过引用计数进行共享 32bits</span></span><br><span class="line">    <span class="built_in">int</span> refcount;</span><br><span class="line">    <span class="comment">// 指向对象的值 64-bit</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>
<p>*ptr指向具体的数据结构的地址；type表示该对象的类型，即String,List,Hash,Set,Zset中的一个，但为了提高存储效率与程序执行效率，每种对象的底层数据结构实现都可能不止一种，encoding 表示对象底层所使用的编码。</p>
<p>redis对象底层的八种数据结构</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">REDIS_ENCODING_INT（<span class="keyword">long</span> 类型的整数）</span><br><span class="line">REDIS_ENCODING_EMBSTR embstr （编码的简单动态字符串）</span><br><span class="line">REDIS_ENCODING_RAW （简单动态字符串）</span><br><span class="line">REDIS_ENCODING_HT （字典）</span><br><span class="line">REDIS_ENCODING_LINKEDLIST （双端链表）</span><br><span class="line">REDIS_ENCODING_ZIPLIST （压缩列表）</span><br><span class="line">REDIS_ENCODING_INTSET （整数集合）</span><br><span class="line">REDIS_ENCODING_SKIPLIST （跳跃表和字典）</span><br></pre></td></tr></table></figure>
<p>好了，通过redisObject就可以具体指向redis数据类型了，总结一下每种数据类型都使用了哪些数据结构，如下图所示</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/202007.png" alt="image.png"></p>
<p>前期准备知识已准备完毕，下面分每种基本类型来讲。</p>
<h4 id="2-String数据结构"><a href="#2-String数据结构" class="headerlink" title="2 String数据结构"></a>2 String数据结构</h4><p>String类型的转换顺序</p>
<ul>
<li>当保存的值为整数且值的大小不超过long的范围，使用整数存储</li>
<li>当字符串长度不超过44字节时，使用EMBSTR 编码</li>
</ul>
<p>它只分配一次内存空间，redisObject和sds是连续的内存，查询效率会快很多，也正是因为redisObject和sds是连续在一起，伴随了一些缺点：当字符串增加的时候，它长度会增加，这个时候又需要重新分配内存，导致的结果就是整个redisObject和sds都需要重新分配空间，这样是会影响性能的，所以redis用embstr实现一次分配而后,只允许读，如果修改数据，那么它就会转成raw编码，不再用embstr编码了。</p>
<ul>
<li>大于44字符时，使用raw编码</li>
</ul>
<p><strong>SDS</strong></p>
<p>embstr和raw都为sds编码，看一下sds的结构体</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 针对不同长度整形做了相应的数据结构</span></span><br><span class="line"><span class="comment"> * Note: sdshdr5 is never used, we just access the flags byte directly.</span></span><br><span class="line"><span class="comment"> * However is here to document the layout of type 5 SDS strings. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">struct</span> __attribute__ ((__packed__)) sdshdr5 &#123;</span><br><span class="line">    unsigned <span class="built_in">char</span> flags; <span class="comment">/* 3 lsb of type, and 5 msb of string length */</span></span><br><span class="line">    <span class="built_in">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __attribute__ ((__packed__)) sdshdr8 &#123;</span><br><span class="line">    uint8_t len; <span class="comment">/* used */</span></span><br><span class="line">    uint8_t alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    unsigned <span class="built_in">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="built_in">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __attribute__ ((__packed__)) sdshdr16 &#123;</span><br><span class="line">    uint16_t len; <span class="comment">/* used */</span></span><br><span class="line">    uint16_t alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    unsigned <span class="built_in">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="built_in">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __attribute__ ((__packed__)) sdshdr32 &#123;</span><br><span class="line">    uint32_t len; <span class="comment">/* used */</span></span><br><span class="line">    uint32_t alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    unsigned <span class="built_in">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="built_in">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __attribute__ ((__packed__)) sdshdr64 &#123;</span><br><span class="line">    uint64_t len; <span class="comment">/* used */</span></span><br><span class="line">    uint64_t alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    unsigned <span class="built_in">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="built_in">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由于redis底层使用c语言实现，可能会有疑问为什么不用c语言的字符串呢，而是用sds结构体。</p>
<p>\1) 低复杂度获取字符串长度：由于len存在，可以直接查出字符串长度，复杂度O(1)；如果用c语言字符串，查询字符串长度需要遍历整个字符串，复杂度为O(n)；</p>
<p>\2) 避免缓冲区溢出：进行两个字符串拼接c语言可使用strcat函数，但如果没有足够的内存空间。就会造成缓冲区溢出；而用sds在进行合并时会先用len检查内存空间是否满足需求，如果不满足，进行空间扩展，不会造成缓冲区溢出；</p>
<p>3）减少修改字符串的内存重新分配次数：c语言字符串不记录字符串长度，如果要修改字符串要重新分配内存，如果不进行重新分配会造成内存缓冲区泄露；</p>
<p>redis sds实现了空间预分配和惰性空间释放两种策略</p>
<p>空间预分配：</p>
<p>1）如果sds修改后，sds长度（len的值）将于1mb，那么会分配与len相同大小的未使用空间，此时len与free值相同。例如，修改之后字符串长度为100字节，那么会给分配100字节的未使用空间。最终sds空间实际为 100 + 100 + 1(保存空字符’\0’)；</p>
<p>2）如果大于等于1mb，每次给分配1mb未使用空间<br>惰性空间释放：对字符串进行缩短操作时，程序不立即使用内存重新分配来回收缩短后多余的字节，而是使用 free 属性将这些字节的数量记录下来，等待后续使用（sds也提供api，我们可以手动触发字符串缩短）；</p>
<p>4）二进制安全：因为C字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此C字符串无法正确存取；而所有 SDS 的API 都是以处理二进制的方式来处理 buf 里面的元素，并且 SDS 不是以空字符串来判断是否结束，而是以 len 属性表示的长度来判断字符串是否结束；</p>
<p>5）遵从每个字符串都是以空字符串结尾的惯例，这样可以重用 C 语言库<string.h> 中的一部分函数。</p>
<p>学习完sds，我们回到上面讲到的，为什么小于44字节用embstr编码呢？</p>
<p>再看一下rejectObject和sds定义的结构（短字符串的embstr用最小的sdshdr8）</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">typedef <span class="keyword">struct</span> redisObject &#123;</span><br><span class="line">    <span class="comment">// 类型 4bits</span></span><br><span class="line">    unsigned type:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 编码方式 4bits</span></span><br><span class="line">    unsigned encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// LRU 时间（相对于 server.lruclock） 24bits</span></span><br><span class="line">    unsigned lru:<span class="number">22</span>;</span><br><span class="line">    <span class="comment">// 引用计数 Redis里面的数据可以通过引用计数进行共享 32bits</span></span><br><span class="line">    <span class="built_in">int</span> refcount;</span><br><span class="line">    <span class="comment">// 指向对象的值 64-bit</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br><span class="line"><span class="keyword">struct</span> __attribute__ ((__packed__)) sdshdr8 &#123;</span><br><span class="line">    uint8_t len; <span class="comment">/* used */</span></span><br><span class="line">    uint8_t alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    unsigned <span class="built_in">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="built_in">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>redisObject占用空间</p>
<p>4 + 4 + 24 + 32 + 64 = 128bits = 16字节</p>
<p>sdshdr8占用空间</p>
<p>1（uint8_t） + 1（uint8_t）+ 1 （unsigned char）+ 1（buf[]中结尾的’\0’字符）= 4字节</p>
<p>初始最小分配为64字节，所以只分配一次空间的embstr最大为 64 - 16- 4 = 44字节</p>
<h4 id="3-List存储结构"><a href="#3-List存储结构" class="headerlink" title="3 List存储结构"></a>3 List存储结构</h4><p>Redis3.2之前的底层实现方式：压缩列表ziplist 或者 双向循环链表linkedlist</p>
<p>当list存储的数据量比较少且同时满足下面两个条件时，list就使用ziplist存储数据：</p>
<ul>
<li>list中保存的每个元素的长度小于 64 字节；</li>
<li>列表中数据个数少于512个</li>
</ul>
<ol>
<li>Redis3.2及之后的底层实现方式：quicklist</li>
</ol>
<p>quicklist是一个双向链表，而且是一个基于ziplist的双向链表，quicklist的每个节点都是一个ziplist，结合了双向链表和ziplist的优点。</p>
<p><strong>ziplist</strong></p>
<p>ziplist是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。当列表对象元素不大，每个元素也不大的时候，就采用ziplist存储。但当数据量过大时就ziplist就不是那么好用了。因为为了保证他存储内容在内存中的连续性，插入的复杂度是O(N)，即每次插入都会重新进行realloc。如下图所示，redisObject对象结构中ptr所指向的就是一个ziplist。整个ziplist只需要malloc一次，它们在内存中是一块连续的区域。</p>
<p>ziplist结构如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/202035.png" alt="image.png"></p>
<p>1、zlbytes:用于记录整个压缩列表占用的内存字节数<br>　<br>2、zltail：记录要列表尾节点距离压缩列表的起始地址有多少字节<br>　<br>3、zllen：记录了压缩列表包含的节点数量。</p>
<p>4、entryX：要说列表包含的各个节点</p>
<p>5、zlend：用于标记压缩列表的末端</p>
<p>为什么数据量大时不用ziplist？</p>
<p>因为ziplist是一段连续的内存，插入的时间复杂化度为O(n)，而且每当插入新的元素需要realloc做内存扩展；而且如果超出ziplist内存大小，还会做重新分配的内存空间，并将内容复制到新的地址。如果数量大的话，重新分配内存和拷贝内存会消耗大量时间。所以不适合大型字符串，也不适合存储量多的元素。</p>
<p><strong>快速列表（quickList）</strong></p>
<p>快速列表是ziplist和linkedlist的混合体，是将linkedlist按段切分，每一段用ziplist来紧凑存储，多个ziplist之间使用双向指针链接。</p>
<p>为什么不直接使用linkedlist？</p>
<p>linkedlist的附加空间相对太高，prev和next指针就要占去16个字节，而且每一个结点都是单独分配，会加剧内存的碎片化，影响内存管理效率。</p>
<p>quicklist结构</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">typedef <span class="keyword">struct</span> quicklist &#123;</span><br><span class="line">    <span class="comment">// 指向quicklist的头部</span></span><br><span class="line">    quicklistNode *head;</span><br><span class="line">    <span class="comment">// 指向quicklist的尾部</span></span><br><span class="line">    quicklistNode *tail;</span><br><span class="line">    unsigned <span class="built_in">long</span> count;</span><br><span class="line">    unsigned <span class="built_in">int</span> len;</span><br><span class="line">    <span class="comment">// ziplist大小限定，由list-max-ziplist-size给定</span></span><br><span class="line">    <span class="built_in">int</span> fill : <span class="number">16</span>;</span><br><span class="line">    <span class="comment">// 节点压缩深度设置，由list-compress-depth给定</span></span><br><span class="line">    unsigned <span class="built_in">int</span> compress : <span class="number">16</span>;</span><br><span class="line">&#125; quicklist;</span><br><span class="line"></span><br><span class="line">typedef <span class="keyword">struct</span> quicklistNode &#123;</span><br><span class="line">    <span class="comment">// 指向上一个ziplist节点</span></span><br><span class="line">    <span class="keyword">struct</span> quicklistNode *prev;</span><br><span class="line">    <span class="comment">// 指向下一个ziplist节点</span></span><br><span class="line">    <span class="keyword">struct</span> quicklistNode *next;</span><br><span class="line">    <span class="comment">// 数据指针，如果没有被压缩，就指向ziplist结构，反之指向quicklistLZF结构</span></span><br><span class="line">    unsigned <span class="built_in">char</span> *zl;</span><br><span class="line">    <span class="comment">// 表示指向ziplist结构的总长度(内存占用长度)</span></span><br><span class="line">    unsigned <span class="built_in">int</span> sz;</span><br><span class="line">    <span class="comment">// ziplist数量</span></span><br><span class="line">    unsigned <span class="built_in">int</span> count : <span class="number">16</span>;     <span class="comment">/* count of items in ziplist */</span></span><br><span class="line">    unsigned <span class="built_in">int</span> encoding : <span class="number">2</span>;   <span class="comment">/* RAW==1 or LZF==2 */</span></span><br><span class="line">    <span class="comment">// 预留字段，存放数据的方式，1--NONE，2--ziplist</span></span><br><span class="line">    unsigned <span class="built_in">int</span> container : <span class="number">2</span>;  <span class="comment">/* NONE==1 or ZIPLIST==2 */</span></span><br><span class="line">    <span class="comment">// 解压标记，当查看一个被压缩的数据时，需要暂时解压，标记此参数为1，之后再重新进行压缩</span></span><br><span class="line">    unsigned <span class="built_in">int</span> recompress : <span class="number">1</span>; <span class="comment">/* was this node previous compressed? */</span></span><br><span class="line">    unsigned <span class="built_in">int</span> attempted_compress : <span class="number">1</span>; <span class="comment">/* node can&#x27;t compress; too small */</span></span><br><span class="line">    <span class="comment">// 扩展字段</span></span><br><span class="line">    unsigned <span class="built_in">int</span> extra : <span class="number">10</span>; <span class="comment">/* more bits to steal for future usage */</span></span><br><span class="line">&#125; quicklistNode;</span><br><span class="line"></span><br><span class="line">typedef <span class="keyword">struct</span> quicklistLZF &#123;</span><br><span class="line">    <span class="comment">// LZF压缩后占用的字节数</span></span><br><span class="line">    unsigned <span class="built_in">int</span> sz; <span class="comment">/* LZF size in bytes*/</span></span><br><span class="line">    <span class="comment">// 柔性数组，存放压缩后的ziplist字节数组</span></span><br><span class="line">    <span class="built_in">char</span> compressed[];</span><br><span class="line">&#125; quicklistLZF;</span><br></pre></td></tr></table></figure>
<p>结构图如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/202050.png" alt="image.png"></p>
<p>ziplist的长度</p>
<p>quicklist内部默认单个ziplist长度为8k字节，超出了这个字节数，就会新起一个ziplist。关于长度可以使用list-max-ziplist-size决定。</p>
<p>压缩深度</p>
<p>我们上面说到了quicklist下是用多个ziplist组成的，同时为了进一步节约空间，Redis还会对ziplist进行压缩存储，使用LZF算法压缩，可以选择压缩深度。quicklist默认的压缩深度是0，也就是不压缩。压缩的实际深度由配置参数list-compress-depth决定。为了支持快速push/pop操作，quicklist 的首尾两个 ziplist 不压缩，此时深度就是 1。如果深度为 2，就表示 quicklist 的首尾第一个 ziplist 以及首尾第二个 ziplist 都不压缩。</p>
<h4 id="4-Hash类型"><a href="#4-Hash类型" class="headerlink" title="4 Hash类型"></a>4 Hash类型</h4><p>当Hash中数据项比较少的情况下，Hash底层才用压缩列表ziplist进行存储数据，随着数据的增加，底层的ziplist就可能会转成dict，具体配置如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">hash-max-ziplist-entries 512</span><br><span class="line">hash-max-ziplist-value 64</span><br></pre></td></tr></table></figure>
<p>在List中已经介绍了ziplist，下面来介绍下dict。</p>
<p>看下数据结构</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">typedef <span class="keyword">struct</span> dict &#123;</span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="built_in">int</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br><span class="line">typedef <span class="keyword">struct</span> dictht &#123;</span><br><span class="line">    <span class="comment">//指针数组，这个hash的桶</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">//元素个数</span></span><br><span class="line">    unsigned <span class="built_in">long</span> size;</span><br><span class="line">    unsigned <span class="built_in">long</span> sizemask;</span><br><span class="line">    unsigned <span class="built_in">long</span> used;</span><br><span class="line">&#125; dictht;</span><br><span class="line"></span><br><span class="line">dictEntry大家应该熟悉，在上面有讲，使用来真正存储key-&gt;<span class="keyword">value</span>的地方</span><br><span class="line">typedef <span class="keyword">struct</span> dictEntry &#123;</span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    union &#123;</span><br><span class="line">        <span class="comment">// 指向具体redisObject</span></span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="comment">// </span></span><br><span class="line">        uint64_t u64;</span><br><span class="line">        int64_t s64;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="keyword">struct</span> dictEntry *next;</span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>
<p>我们可以看到每个dict中都有两个hashtable</p>
<p>结构图如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/202117.png" alt="image.png"></p>
<p>虽然dict结构有两个hashtable，但是通常情况下只有一个hashtable是有值的。但是在dict扩容缩容的时候，需要分配新的hashtable，然后进行渐近式搬迁，这时候两个hashtable存储的旧的hashtable和新的hashtable。搬迁结束后，旧hashtable删除，新的取而代之。</p>
<p>下面让我们学习下rehash全貌。</p>
<h4 id="5-渐进式rehash"><a href="#5-渐进式rehash" class="headerlink" title="5 渐进式rehash"></a>5 渐进式rehash</h4><p>所谓渐进式rehash是指我们的大字典的扩容是比较消耗时间的，需要重新申请新的数组，然后将旧字典所有链表的元素重新挂接到新的数组下面，是一个O(n)的操作。但是因为我们的redis是单线程的，无法承受这样的耗时过程，所以采用了渐进式rehash小步搬迁，虽然慢一点，但是可以搬迁完毕。</p>
<p>扩容条件</p>
<p>我们的扩容一般会在Hash表中的元素个数等于第一维数组的长度的时候，就会开始扩容。扩容的大小是原数组的两倍。不过在redis在做bgsave（RDB持久化操作的过程），为了减少内存页的过多分离（Copy On Write），redis不会去扩容。但是如果hash表的元素个数已经到达了第一维数组长度的5倍的时候，就会强制扩容，不管你是否在持久化。</p>
<p>不扩容主要是为了尽可能减少内存页过多分离，系统需要更多的开销去回收内存。</p>
<p>缩容条件</p>
<p>当我们的hash表元素逐渐删除的越来越少的时候。redis于是就会对hash表进行缩容来减少第一维数组长度的空间占用。缩容的条件是元素个数低于数组长度的10%，并且缩容不考虑是否在做redis持久化。</p>
<p>不用考虑bgsave主要是因为我们的缩容的内存都是已经使用过的，缩容的时候可以直接置空，而且由于申请的内存比较小，同时会释放掉一些已经使用的内存，不会增大系统的压力。</p>
<p>rehash步骤</p>
<p>1、为ht[1] 分配空间，让字典同时持有ht[0]和ht[1]两个哈希表；</p>
<p>2、定时维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash 开始；</p>
<p>3、在rehash进行期间，每次对字典执行CRUD操作时，程序除了执行指定的操作以外，还会将ht[0]中的数据rehash 到ht[1]表中，并且将rehashidx加一；</p>
<p>4、当ht[0]中所有数据转移到ht[1]中时，将rehashidx 设置成-1，表示rehash 结束；</p>
<p>（采用渐进式rehash 的好处在于它采取分而治之的方式，避免了集中式rehash 带来的庞大计算量。特别的在进行rehash时只能对h[0]元素减少的操作，如查询和删除；而查询是在两个哈希表中查找的，而插入只能在ht[1]中进行，ht[1]也可以查询和删除。）</p>
<p>5、将ht[0]释放，然后将ht[1]设置成ht[0]，最后为ht[1]分配一个空白哈希表。</p>
<p>过程如下图：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/202127.png" alt="image.png"></p>
<h4 id="6-set数据结构"><a href="#6-set数据结构" class="headerlink" title="6 set数据结构"></a>6 set数据结构</h4><p>Redis 的集合相当于Java中的 HashSet，它内部的键值对是无序、唯一的。它的内部实现相当于一个特殊的字典，字典中所有的 value 都是一个值 NULL。集合Set类型底层编码包括hashtable和inset。</p>
<p>当存储的数据同时满足下面这样两个条件的时候，Redis 就采用整数集合intset来实现set这种数据类型：</p>
<ul>
<li>存储的数据都是整数</li>
<li>存储的数据元素个数小于512个</li>
</ul>
<p>当不能同时满足这两个条件的时候，Redis 就使用dict来存储集合中的数据</p>
<p>hashtable在上面介绍过了，我们就只介绍inset。</p>
<p><strong>inset结构体</strong></p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">typedef <span class="keyword">struct</span> intset &#123;</span><br><span class="line">    uint32_t encoding;</span><br><span class="line">    <span class="comment">// length就是数组的实际长度</span></span><br><span class="line">    uint32_t length;</span><br><span class="line">    <span class="comment">// contents 数组是实际保存元素的地方，数组中的元素有以下两个特性：</span></span><br><span class="line">    <span class="comment">// 1.没有重复元素</span></span><br><span class="line">    <span class="comment">// 2.元素在数组中从小到大排列</span></span><br><span class="line">    int8_t contents[];</span><br><span class="line">&#125; intset;</span><br><span class="line"></span><br><span class="line"><span class="comment">// encoding 的值可以是以下三个常量的其中一个</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT32 (sizeof(int32_t))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t))</span></span><br></pre></td></tr></table></figure>
<p>inset的查询</p>
<p>intset是一个有序集合，查找元素的复杂度为O(logN)（采用二分法），但插入时不一定为O(logN)，因为有可能涉及到升级操作。比如当集合里全是int16_t型的整数，这时要插入一个int32_t，那么为了维持集合中数据类型的一致，那么所有的数据都会被转换成int32_t类型，涉及到内存的重新分配，这时插入的复杂度就为O(N)了。是intset不支持降级操作。</p>
<p><strong>inset是有序不要和我们zset搞混，zset是设置一个score来进行排序，而inset这里只是单纯的对整数进行升序而已</strong></p>
<h4 id="7-Zset数据结构"><a href="#7-Zset数据结构" class="headerlink" title="7 Zset数据结构"></a>7 Zset数据结构</h4><p>Zset有序集合和set集合有着必然的联系，他保留了集合不能有重复成员的特性，但不同的是，有序集合中的元素是可以排序的，但是它和列表的使用索引下标作为排序依据不同的是，它给每个元素设置一个分数，作为排序的依据。</p>
<p>zet的底层编码有两种数据结构，一个ziplist，一个是skiplist。</p>
<p>Zset也使用了ziplist做了排序，所以下面讲一下ziplist如何做排序。</p>
<p><strong>ziplist做排序</strong></p>
<p>每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员（member），而第二个元素则保存元素的分值（score）。</p>
<p>存储结构图如下一目了然：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/202141.png" alt="image.png"></p>
<p><strong>skiplist跳表</strong></p>
<p>结构体如下，skiplist是与dict结合来使用的，这个结构比较复杂。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 跳跃表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">typedef <span class="keyword">struct</span> zskiplist &#123;</span><br><span class="line">    <span class="comment">// 头节点，尾节点</span></span><br><span class="line">    <span class="keyword">struct</span> zskiplistNode *header, *tail;</span><br><span class="line">    <span class="comment">// 节点数量</span></span><br><span class="line">    unsigned <span class="built_in">long</span> length;</span><br><span class="line">    <span class="comment">// 目前表内节点的最大层数</span></span><br><span class="line">    <span class="built_in">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 跳跃表节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">typedef <span class="keyword">struct</span> zskiplistNode &#123;</span><br><span class="line">    <span class="comment">// member 对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="built_in">double</span> score;</span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="keyword">struct</span> zskiplistNode *backward;</span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="keyword">struct</span> zskiplistLevel &#123;</span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="keyword">struct</span> zskiplistNode *forward;</span><br><span class="line">        <span class="comment">// 这个层跨越的节点数量</span></span><br><span class="line">        unsigned <span class="built_in">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>
<p>跳表是什么？</p>
<p>我们先看下链表</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/202238.png" alt="image.png"></p>
<p>如果想查找到node5需要从node1查到node5，查询耗时</p>
<p>但如果在node上加上索引：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/202244.png" alt="image.png"></p>
<p>这样通过索引就能直接从node1查找到node5</p>
<p><strong>redis跳跃表</strong></p>
<p>让我们再看下redis的跳表结构（图太复杂，直接从网上找了张图说明）</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/202247.png" alt="image.png"></p>
<ul>
<li>header:指向跳跃表的表头节点，通过这个指针程序定位表头节点的时间复杂度就为O(1)；</li>
<li>tail:指向跳跃表的表尾节点,通过这个指针程序定位表尾节点的时间复杂度就为O(1)；</li>
<li>level:记录目前跳跃表内,层数最大的那个节点的层数(表头节点的层数不计算在内)，通过这个属性可以再O(1)的时间复杂度内获取层高最好的节点的层数；</li>
<li>length:记录跳跃表的长度,也即是,跳跃表目前包含节点的数量(表头节点不计算在内)，通过这个属性，程序可以再O(1)的时间复杂度内返回跳跃表的长度。</li>
</ul>
<p>结构右方的是四个 zskiplistNode结构,该结构包含以下属性</p>
<ul>
<li>层(level):</li>
</ul>
<p>节点中用L1、L2、L3等字样标记节点的各个层,L1代表第一层,L2代表第二层,以此类推。</p>
<p>每个层都带有两个属性:前进指针和跨度。前进指针用于访问位于表尾方向的其他节点,而跨度则记录了前进指针所指向节点和当前节点的距离(跨度越大、距离越远)。在上图中,连线上带有数字的箭头就代表前进指针,而那个数字就是跨度。当程序从表头向表尾进行遍历时,访问会沿着层的前进指针进行。</p>
<p>每次创建一个新跳跃表节点的时候,程序都根据幂次定律(powerlaw,越大的数出现的概率越小)随机生成一个介于1和32之间的值作为level数组的大小,这个大小就是层的“高度”。</p>
<ul>
<li>后退(backward)指针：</li>
</ul>
<p>节点中用BW字样标记节点的后退指针,它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。与前进指针所不同的是每个节点只有一个后退指针，因此每次只能后退一个节点。</p>
<ul>
<li>分值(score):</li>
</ul>
<p>各个节点中的1.0、2.0和3.0是节点所保存的分值。在跳跃表中,节点按各自所保存的分值从小到大排列。</p>
<ul>
<li>成员对象(oj):</li>
</ul>
<p>各个节点中的o1、o2和o3是节点所保存的成员对象。在同一个跳跃表中,各个节点保存的成员对象必须是唯一的,但是多个节点保存的分值却可以是相同的:分值相同的节点将按照成员对象在字典序中的大小来进行排序,成员对象较小的节点会排在前面(靠近表头的方向),而成员对象较大的节点则会排在后面(靠近表尾的方向)。</p>
<h3 id="五-三大特殊数据类型"><a href="#五-三大特殊数据类型" class="headerlink" title="五 三大特殊数据类型"></a>五 三大特殊数据类型</h3><h4 id="1-geospatial（地理位置）"><a href="#1-geospatial（地理位置）" class="headerlink" title="1 geospatial（地理位置）"></a>1 geospatial（地理位置）</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>geospatial将指定的地理空间位置（纬度、经度、名称）添加到指定的key中。</span><br><span class="line">  这些数据将会存储到<span class="built_in">sorted</span> <span class="built_in">set</span>这样的目的是为了方便使用GEORADIUS或者GEORADIUSBYMEMBER命令对数据进行半径查询等操作。</span><br><span class="line"><span class="number">2.</span><span class="built_in">sorted</span> <span class="built_in">set</span>使用一种称为Geohash的技术进行填充。经度和纬度的位是交错的，以形成一个独特的<span class="number">52</span>位整数。</span><br><span class="line">  <span class="built_in">sorted</span> <span class="built_in">set</span>的double score可以代表一个<span class="number">52</span>位的整数，而不会失去精度。（有兴趣的同学可以学习一下Geohash技术，使用二分法构建唯一的二进制串）</span><br><span class="line"><span class="number">3.</span>有效的经度是-<span class="number">180</span>度到<span class="number">180</span>度</span><br><span class="line">  有效的纬度是-<span class="number">85.05112878</span>度到<span class="number">85.05112878</span>度</span><br></pre></td></tr></table></figure>
<p><strong>应用场景</strong></p>
<ol>
<li>查看附近的人</li>
<li>微信位置共享</li>
<li>地图上直线距离的展示</li>
</ol>
<h4 id="2-Hyperloglog（基数）"><a href="#2-Hyperloglog（基数）" class="headerlink" title="2 Hyperloglog（基数）"></a>2 Hyperloglog（基数）</h4><p>什么是基数？ 不重复的元素</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hyperloglog</span> 是用来做基数统计的，其优点是：输入的提及无论多么大，hyperloglog使用的空间总是固定的<span class="number">12</span>KB ，利用<span class="number">12</span>KB，它可以计算<span class="number">2</span>^<span class="number">64</span>个不同元素的基数！非常节省空间！但缺点是估算的值，可能存在误差</span><br></pre></td></tr></table></figure>
<p><strong>应用场景</strong></p>
<p>网页统计UV （浏览用户数量，同一天同一个ip多次访问算一次访问，目的是计数，而不是保存用户）</p>
<p>传统的方式，set保存用户的id，可以统计set中元素数量作为标准判断。</p>
<p>但如果这种方式保存大量用户id，会占用大量内存，我们的目的是为了计数，而不是去保存id。</p>
<h4 id="3-Bitmaps（位存储）"><a href="#3-Bitmaps（位存储）" class="headerlink" title="3 Bitmaps（位存储）"></a>3 Bitmaps（位存储）</h4><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">Redis提供的<span class="keyword">Bitmaps这个“数据结构”可以实现对位的操作。Bitmaps本身不是一种数据结构，实际上就是字符串，但是它可以对字符串的位进行操作。</span></span><br><span class="line"><span class="keyword">可以把Bitmaps想象成一个以位为单位数组，数组中的每个单元只能存0或者1，数组的下标在bitmaps中叫做偏移量。单个bitmaps的最大长度是512MB，即2^32个比特位。</span></span><br></pre></td></tr></table></figure>
<p><strong>应用场景</strong></p>
<p>两种状态的统计都可以使用bitmaps，例如：统计用户活跃与非活跃数量、登录与非登录、上班打卡等等。</p>
<h3 id="六-Redis事务"><a href="#六-Redis事务" class="headerlink" title="六 Redis事务"></a>六 Redis事务</h3><p>事务本质：一组命令的集合</p>
<h4 id="1-数据库事务与redis事务"><a href="#1-数据库事务与redis事务" class="headerlink" title="1 数据库事务与redis事务"></a>1 数据库事务与redis事务</h4><p><strong>数据库的事务</strong></p>
<p>数据库事务通过ACID（原子性、一致性、隔离性、持久性）来保证。</p>
<p>数据库中除查询操作以外，插入(Insert)、删除(Delete)和更新(Update)这三种操作都会对数据造成影响，因为事务处理能够保证一系列操作可以完全地执行或者完全不执行，因此在一个事务被提交以后，该事务中的任何一条SQL语句在被执行的时候，都会生成一条撤销日志(Undo Log)。</p>
<p><strong>redis事务</strong></p>
<p>redis事务提供了一种“将多个命令打包， 然后一次性、按顺序地执行”的机制， 并且事务在执行的期间不会主动中断 —— 服务器在执行完事务中的所有命令之后， 才会继续处理其他客户端的其他命令。</p>
<p>Redis中一个事务从开始到执行会经历开始事务（muiti）、命令入队和执行事务(exec)三个阶段，事务中的命令在加入时都没有被执行，直到提交时才会开始执行(Exec)一次性完成。</p>
<p>一组命令中存在两种错误不同处理方式</p>
<p>1.代码语法错误（编译时异常）所有命令都不执行</p>
<p>2.代码逻辑错误（运行时错误），其他命令可以正常执行 （该点不保证事务的原子性）</p>
<p>为什么redis不支持回滚来保证原子性</p>
<p>这种做法的优点：</p>
<ul>
<li>Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。</li>
<li>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。</li>
</ul>
<p>鉴于没有任何机制能避免程序员自己造成的错误， 并且这类错误通常不会在生产环境中出现， 所以 Redis 选择了更简单、更快速的无回滚方式来处理事务。</p>
<p>事务监控</p>
<p>悲观锁：认为什么时候都会出现问题，无论做什么操作都会加锁。</p>
<p>乐观锁：认为什么时候都不会出现问题，所以不会上锁！更新数据的时候去判断一下，在此期间是否有人修改过这个数据。</p>
<p>使用cas实现乐观锁</p>
<p>redis使用watch key监控指定数据，相当于加乐观锁</p>
<p>watch保证事务只能在所有被监视键都没有被修改的前提下执行， 如果这个前提不能满足的话，事务就不会被执行。</p>
<p>watch执行流程</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/202323.png" alt="image.png"></p>
<h3 id="七-Redis持久化"><a href="#七-Redis持久化" class="headerlink" title="七 Redis持久化"></a>七 Redis持久化</h3><p>Redis是一种内存型数据库，一旦服务器进程退出，数据库的数据就会丢失，为了解决这个问题Redis供了两种持久化的方案，将内存中的数据保存到磁盘中，避免数据的丢失<br>两种持久化方式：快照（RDB文件）和追加式文件（AOF文件），下面分别为大家介绍两种方式的原理。</p>
<ul>
<li>RDB持久化方式会在一个特定的间隔保存那个时间点的数据快照。</li>
<li>AOF持久化方式则会记录每一个服务器收到的写操作。在服务启动时，这些记录的操作会逐条执行从而重建出原来的数据。写操作命令记录的格式跟Redis协议一致，以追加的方式进行保存。</li>
<li>Redis的持久化是可以禁用的，就是说你可以让数据的生命周期只存在于服务器的运行时间里。</li>
</ul>
<p>两种方式的持久化是可以同时存在的，但是当Redis重启时，AOF文件会被优先用于重建数据。</p>
<h4 id="1-RDB持久化"><a href="#1-RDB持久化" class="headerlink" title="1 RDB持久化"></a>1 RDB持久化</h4><p>RDB持久化产生的文件是一个经过压缩的二进制文件，这个文件可以被保存到硬盘中，可以通过这个文件还原数据库的状态，它可以手动执行，也可以在redis.conf配置文件中配置，定时执行。</p>
<p><strong>工作原理</strong></p>
<p>在进行RDB时，redis的主进程不会做io操作，会fork一个子进程来完成该操作：</p>
<ol>
<li>Redis 调用forks。同时拥有父进程和子进程。</li>
<li>子进程将数据集写入到一个临时 RDB 文件中。</li>
<li>当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。</li>
</ol>
<p>这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益(因为是使用子进程进行写操作，而父进程依然可以接收来自客户端的请求)</p>
<p><strong>触发机制</strong></p>
<p>在Redis中RDB持久化的触发分为两种：自己手动触发与自动触发。</p>
<p>主动触发</p>
<ol>
<li>save命令是同步的命令，会占用主进程，会造成阻塞，阻塞所有客户端的请求</li>
<li>bgsave</li>
</ol>
<p>bgsave是异步进行，进行持久化的时候，redis还可以将继续响应客户端请求</p>
<p>bgsave和save对比</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/202337.png" alt="image.png"></p>
<p>自动触发</p>
<p>1、save自动触发配置，见下面配置，满足m秒内修改n次key，触发rdb</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 时间策略   save m n m秒内修改n次key，触发rdb</span></span><br><span class="line"><span class="string">save</span> <span class="number">900</span> <span class="number">1</span></span><br><span class="line"><span class="string">save</span> <span class="number">300</span> <span class="number">10</span></span><br><span class="line"><span class="string">save</span> <span class="number">60</span> <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件名称</span></span><br><span class="line"><span class="string">dbfilename</span> <span class="string">dump.rdb</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件保存路径</span></span><br><span class="line"><span class="string">dir</span> <span class="string">/home/work/app/redis/data/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果持久化出错，主进程是否停止写入</span></span><br><span class="line"><span class="string">stop-writes-on-bgsave-error</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否压缩</span></span><br><span class="line"><span class="string">rdbcompression</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入时是否检查</span></span><br><span class="line"><span class="string">rdbchecksum</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure>
<p>2、从节点全量复制时，主节点发送rdb文件给从节点完成复制操作，主节点会触发bgsave命令；</p>
<p>3、执行flushall命令，会触发rdb</p>
<p>4、退出redis，且没有开启aof时</p>
<p>优点：</p>
<p>1、RDB 的内容为二进制的数据，占用内存更小，更紧凑，更适合做为备份文件；</p>
<p>2、RDB 对灾难恢复非常有用，它是一个紧凑的文件，可以更快的传输到远程服务器进行 Redis 服务恢复；</p>
<p>3、RDB 可以更大程度的提高 Redis 的运行速度，因为每次持久化时 Redis 主进程都会 fork() 一个子进程，进行数据持久化到磁盘，Redis 主进程并不会执行磁盘 I/O 等操作；</p>
<p>4、与 AOF 格式的文件相比，RDB 文件可以更快的重启。</p>
<p>缺点：</p>
<p>1、因为 RDB 只能保存某个时间间隔的数据，如果中途 Redis 服务被意外终止了，则会丢失一段时间内的 Redis 数据。</p>
<p>2、RDB 需要经常 fork() 才能使用子进程将其持久化在磁盘上。如果数据集很大，fork() 可能很耗时，并且如果数据集很大且 CPU 性能不佳，则可能导致 Redis 停止为客户端服务几毫秒甚至一秒钟。</p>
<h4 id="2-AOF（Append-Only-File）"><a href="#2-AOF（Append-Only-File）" class="headerlink" title="2 AOF（Append Only File）"></a>2 AOF（Append Only File）</h4><p>以日志的形式来记录每个写的操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换言之，redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p>
<p><strong>AOF配置项</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认不开启aof  而是使用rdb的方式</span></span><br><span class="line"><span class="string">appendonly</span> <span class="literal">no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认文件名</span></span><br><span class="line"><span class="string">appendfilename</span> <span class="string">&quot;appendonly.aof&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每次修改都会sync 消耗性能</span></span><br><span class="line"><span class="comment"># appendfsync always</span></span><br><span class="line"><span class="comment"># 每秒执行一次 sync 可能会丢失这一秒的数据</span></span><br><span class="line"><span class="string">appendfsync</span> <span class="string">everysec</span></span><br><span class="line"><span class="comment"># 不执行 sync ,这时候操作系统自己同步数据，速度最快</span></span><br><span class="line"><span class="comment"># appendfsync no </span></span><br></pre></td></tr></table></figure>
<p>AOF的整个流程大体来看可以分为两步，一步是命令的实时写入（如果是appendfsync everysec 配置，会有1s损耗），第二步是对aof文件的重写。</p>
<p><strong>AOF 重写机制</strong></p>
<p>随着Redis的运行，AOF的日志会越来越长，如果实例宕机重启，那么重放整个AOF将会变得十分耗时，而在日志记录中，又有很多无意义的记录，比如我现在将一个数据 incr一千次，那么就不需要去记录这1000次修改，只需要记录最后的值即可。所以就需要进行 AOF 重写。</p>
<p>Redis 提供了bgrewriteaof指令用于对AOF日志进行重写，该指令运行时会开辟一个子进程对内存进行遍历，然后将其转换为一系列的 Redis 的操作指令，再序列化到一个日志文件中。完成后再替换原有的AOF文件，至此完成。</p>
<p>同样的也可以在redis.config中对重写机制的触发进行配置：</p>
<p>通过将no-appendfsync-on-rewrite设置为yes，开启重写机制；auto-aof-rewrite-percentage 100意为比上次从写后文件大小增长了100%再次触发重写；</p>
<p>auto-aof-rewrite-min-size 64mb意为当文件至少要达到64mb才会触发制动重写。</p>
<p><strong>触发方式</strong></p>
<ol>
<li>手动触发：bgrewriteaof</li>
<li>自动触发 就是根据配置规则来触发，当然自动触发的整体时间还跟Redis的定时任务频率有关系。</li>
</ol>
<p>优点</p>
<p>1、数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。</p>
<p>2、通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。</p>
<p>3、AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）)</p>
<p>缺点</p>
<p>1、AOF 文件比 RDB 文件大，且恢复速度慢。<br>2、数据集大的时候，比 rdb 启动效率低。</p>
<h4 id="3-rdb与aof对比"><a href="#3-rdb与aof对比" class="headerlink" title="3 rdb与aof对比"></a>3 rdb与aof对比</h4><p><img data-src="https://xuemingde.com/pages/image/2022/03/202401.png" alt="image.png"></p>
<h3 id="八-发布与订阅"><a href="#八-发布与订阅" class="headerlink" title="八 发布与订阅"></a>八 发布与订阅</h3><p>redis发布与订阅是一种消息通信的模式：发送者（pub）发送消息，订阅者（sub）接收消息。</p>
<p>redis通过PUBLISH和SUBSCRIBE等命令实现了订阅与发布模式，这个功能提供两种信息机制，分别是订阅/发布到频道、订阅/发布到模式的客户端。</p>
<h4 id="1-频道（channel）"><a href="#1-频道（channel）" class="headerlink" title="1 频道（channel）"></a>1 频道（channel）</h4><p><strong>订阅</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/202406.png" alt="image.png"></p>
<p><strong>发布</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/202415.png" alt="image.png"></p>
<p><strong>完整流程</strong></p>
<p>发布者发布消息</p>
<p>发布者向频道channel:1发布消息hi</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; publish channel:1 hi</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
<p>订阅者订阅消息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; subscribe channel:1</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot; // 消息类型</span><br><span class="line">2) &quot;channel:1&quot; // 频道</span><br><span class="line">3) &quot;hi&quot; // 消息内容</span><br></pre></td></tr></table></figure>
<p>执行subscribe后客户端会进入订阅状态，仅可以使subscribe、unsubscribe、psubscribe和punsubscribe这四个属于”发布/订阅”之外的命令</p>
<p>订阅频道后的客户端可能会收到三种消息类型</p>
<ul>
<li>subscribe。表示订阅成功的反馈信息。第二个值是订阅成功的频道名称，第三个是当前客户端订阅的频道数量。</li>
<li>message。表示接收到的消息，第二个值表示产生消息的频道名称，第三个值是消息的内容。</li>
<li>unsubscribe。表示成功取消订阅某个频道。第二个值是对应的频道名称，第三个值是当前客户端订阅的频道数量，当此值为0时客户端会退出订阅状态，之后就可以执行其他非”发布/订阅”模式的命令了。</li>
</ul>
<p><strong>数据结构</strong></p>
<p>基于频道的发布订阅模式是通过字典数据类型实现的</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> redisServer &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    dict *pubsub_channels;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，字典的键为正在被订阅的频道， 而字典的值则是一个链表， 链表中保存了所有订阅这个频道的客户端。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/202437.png" alt="image.png"></p>
<p>订阅</p>
<p>当使用subscribe订阅时，在字典中找到频道key（如没有则创建），并将订阅的client关联在链表后面。</p>
<p>当client 10执行subscribe channel1 channel2 channel3时，会将client 10分别加到 channel1 channel2 channel3关联的链表尾部。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/202442.png" alt="image.png"></p>
<p>发布</p>
<p>发布时，根据key，找到字典汇总key的地址，然后将msg发送到关联的链表每一台机器。</p>
<p>退订</p>
<p>遍历关联的链表，将指定的地址删除即可。</p>
<h4 id="2-模式（pattern）"><a href="#2-模式（pattern）" class="headerlink" title="2 模式（pattern）"></a>2 模式（pattern）</h4><p>pattern使用了通配符的方式来订阅</p>
<p>通配符中?表示1个占位符，<em>表示任意个占位符(包括0)，?</em>表示1个以上占位符。</p>
<p>所以当使用 publish命令发送信息到某个频道时， 不仅所有订阅该频道的客户端会收到信息， 如果有某个/某些模式和这个频道匹配的话， 那么所有订阅这个/这些频道的客户端也同样会收到信息。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/202452.png" alt="image.png"></p>
<p>订阅发布完整流程</p>
<p>发布者发布消息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; publish b m1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; publish b1 m1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; publish b11 m1</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>
<p>订阅者订阅消息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; psubscribe b*</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;psubscribe&quot;</span><br><span class="line">2) &quot;b*&quot;</span><br><span class="line">3) (integer) 3</span><br><span class="line">1) &quot;pmessage&quot;</span><br><span class="line">2) &quot;b*&quot;</span><br><span class="line">3) &quot;b&quot;</span><br><span class="line">4) &quot;m1&quot;</span><br><span class="line">1) &quot;pmessage&quot;</span><br><span class="line">2) &quot;b*&quot;</span><br><span class="line">3) &quot;b1&quot;</span><br><span class="line">4) &quot;m1&quot;</span><br><span class="line">1) &quot;pmessage&quot;</span><br><span class="line">2) &quot;b*&quot;</span><br><span class="line">3) &quot;b11&quot;</span><br><span class="line">4) &quot;m1&quot;</span><br></pre></td></tr></table></figure>
<p><strong>数据结构</strong></p>
<p>pattern属性是一个链表，链表中保存着所有和模式相关的信息。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> redisServer &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    list *pubsub_patterns;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 链表中的每一个节点结构如下，保存着客户端与模式信息</span></span><br><span class="line">typedef <span class="keyword">struct</span> pubsubPattern &#123;</span><br><span class="line">    redisClient *client;</span><br><span class="line">    robj *pattern;</span><br><span class="line">&#125; pubsubPattern;</span><br></pre></td></tr></table></figure>
<p>数据结构图如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/202518.png" alt="image.png"></p>
<p>订阅</p>
<p>当有信的订阅时，会将订阅的客户端和模式信息添加到链表后面。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/202525.png" alt="image.png"></p>
<p>发布</p>
<p>当发布者发布消息时，首先会发送到对应的频道上，在遍历模式列表，根据key匹配模式，匹配成功将消息发给对应的订阅者。</p>
<p>完成的发布伪代码如下</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">PUBLISH</span>(<span class="params">channel, message</span>):</span></span><br><span class="line"><span class="function">    # 遍历所有订阅频道 channel 的客户端</span></span><br><span class="line"><span class="function">    <span class="keyword">for</span> client <span class="keyword">in</span> server.pubsub_channels[channel]:</span></span><br><span class="line"><span class="function">        # 将信息发送给它们</span></span><br><span class="line"><span class="function">        <span class="title">send_message</span>(<span class="params">client, message</span>)</span></span><br><span class="line"><span class="function">    # 取出所有模式，以及订阅模式的客户端</span></span><br><span class="line"><span class="function">    <span class="keyword">for</span> pattern, client <span class="keyword">in</span> server.pubsub_patterns:</span></span><br><span class="line"><span class="function">        # 如果 channel 和模式匹配</span></span><br><span class="line"><span class="function">        <span class="keyword">if</span> <span class="title">match</span>(<span class="params">channel, pattern</span>):</span></span><br><span class="line"><span class="function">            # 那么也将信息发给订阅这个模式的客户端</span></span><br><span class="line"><span class="function">            <span class="title">send_message</span>(<span class="params">client, message</span>)</span></span><br></pre></td></tr></table></figure>
<p>退订</p>
<p>使用punsubscribe，可以将订阅者退订，将改客户端移除出链表。</p>
<h3 id="九-主从复制"><a href="#九-主从复制" class="headerlink" title="九 主从复制"></a>九 主从复制</h3><p>什么是主从复制</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。</span><br><span class="line"><span class="number">2</span>.前者称为主节点(<span class="literal">master</span>)，后者称为从节点(<span class="literal">slave</span>)；数据的复制是单向的，只能由主节点到从节点</span><br><span class="line">默认情况下，每台redis服务器都是主节点；且一个主节点可以有多个从节点（或者没有），但一个从节点只有一个主</span><br></pre></td></tr></table></figure>
<p>主从复制的作用主要包括</p>
<ul>
<li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li>
<li>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复；实际上是一种服务的冗余。</li>
<li>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li>
<li>高可用基石：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li>
</ul>
<p>主从库采用的是读写分离的方式</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/202538.png" alt="image.png"></p>
<h4 id="1-原理"><a href="#1-原理" class="headerlink" title="1 原理"></a>1 原理</h4><p>分为全量复制与增量复制</p>
<p>全量复制：发生在第一次复制时</p>
<p>增量复制：只会把主从库网络断连期间主库收到的命令，同步给从库</p>
<h4 id="2-全量复制的三个阶段"><a href="#2-全量复制的三个阶段" class="headerlink" title="2 全量复制的三个阶段"></a>2 全量复制的三个阶段</h4><p>第一阶段是主从库间建立连接、协商同步的过程。</p>
<p>主要是为全量复制做准备。从库和主库建立起连接，并告诉主库即将进行同步，主库确认回复后，主从库间就可以开始同步了。</p>
<p>具体来说，从库给主库发送 psync 命令，表示要进行数据同步，主库根据这个命令的参数来启动复制。psync 命令包含了主库的 runID 和复制进度 offset 两个参数。runID，是每个 Redis 实例启动时都会自动生成的一个随机 ID，用来唯一标记这个实例。当从库和主库第一次复制时，因为不知道主库的 runID，所以将 runID 设为“？”。offset，此时设为 -1，表示第一次复制。主库收到 psync 命令后，会用 FULLRESYNC 响应命令带上两个参数：主库 runID 和主库目前的复制进度 offset，返回给从库。从库收到响应后，会记录下这两个参数。这里有个地方需要注意，FULLRESYNC 响应表示第一次复制采用的全量复制，也就是说，主库会把当前所有的数据都复制给从库。</p>
<p>第二阶段，主库将所有数据同步给从库。</p>
<p>从库收到数据后，在本地完成数据加载。这个过程依赖于内存快照生成的 RDB 文件。</p>
<p>具体来说，主库执行 bgsave 命令，生成 RDB 文件，接着将文件发给从库。从库接收到 RDB 文件后，会先清空当前数据库，然后加载 RDB 文件。这是因为从库在通过 replicaof 命令开始和主库同步前，可能保存了其他数据。为了避免之前数据的影响，从库需要先把当前数据库清空。在主库将数据同步给从库的过程中，主库不会被阻塞，仍然可以正常接收请求。否则，Redis 的服务就被中断了。但是，这些请求中的写操作并没有记录到刚刚生成的 RDB 文件中。为了保证主从库的数据一致性，主库会在内存中用专门的 replication buffer，记录 RDB 文件生成后收到的所有写操作。</p>
<p>第三个阶段，主库会把第二阶段执行过程中新收到的写命令，再发送给从库。</p>
<p>具体的操作是，当主库完成 RDB 文件发送后，就会把此时 replication buffer 中的修改操作发给从库，从库再重新执行这些操作。这样一来，主从库就实现同步了。</p>
<h3 id="十-哨兵机制"><a href="#十-哨兵机制" class="headerlink" title="十 哨兵机制"></a>十 哨兵机制</h3><p>哨兵的核心功能是主节点的自动故障转移</p>
<p>下图是一个典型的哨兵集群监控的逻辑图</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/202605.png" alt="image.png"></p>
<p>Redis Sentinel包含了若个Sentinel节点，这样做也带来了两个好处：</p>
<ol>
<li>对于节点的故障判断是由多个Sentinel节点共同完成，这样可以有效地防止误判</li>
<li>即使个别Sentinel节点不可用，整个Sentinel集群依然是可用的。</li>
</ol>
<p>哨兵实现了一下功能</p>
<ol>
<li>监控：每个Sentinel节点会对数据节点（Redis master/slave 节点）和其余Sentinel节点进行监控</li>
<li>通知：Sentinel节点会将故障转移的结果通知给应用方</li>
<li>故障转移：实现slave晋升为master，并维护后续正确的主从关系</li>
<li>配置中心：在Redis Sentinel模式中，客户端在初始化的时候连接的是Sentinel节点集合，从中获取主节点信息</li>
</ol>
<p>其中，监控和自动故障转移功能，使得哨兵可以及时发现主节点故障并完成转移；而配置中心和通知功能，则需要在与客户端的交互中才能体现。</p>
<h4 id="1-原理-1"><a href="#1-原理-1" class="headerlink" title="1 原理"></a>1 原理</h4><p><strong>监控</strong></p>
<p>Sentinel节点需要监控master、slave以及其它Sentinel节点的状态。这一过程是通过Redis的pub/sub系统实现的。Redis Sentinel一共有三个定时监控任务，完成对各个节点发现和监控：</p>
<ol>
<li>监控主从拓扑信息：每隔10秒，每个Sentinel节点，会向master和slave发送INFO命令获取最新的拓扑结构</li>
<li>Sentinel节点信息交换：每隔2秒，每个Sentinel节点，会向Redis数据节点的<strong>sentinel</strong>:hello频道上，发送自身的信息，以及对主节点的判断信息。这样，Sentinel节点之间就可以交换信息</li>
<li>节点状态监控：每隔1秒，每个Sentinel节点，会向master、slave、其余Sentinel节点发送PING命令做心跳检测，来确认这些节点当前是否可达</li>
</ol>
<p><strong>主观/客观下线</strong></p>
<p>主观下线</p>
<p>每个Sentinel节点，每隔1秒会对数据节点发送ping命令做心跳检测，当这些节点超过down-after-milliseconds没有进行有效回复时，Sentinel节点会对该节点做失败判定，这个行为叫做主观下线。</p>
<p>客观下线</p>
<p>客观下线，是指当大多数Sentinel节点，都认为master节点宕机了，那么这个判定就是客观的，叫做客观下线。</p>
<p>那么这个大多数是指多少呢？这其实就是分布式协调中的quorum判定了，大多数就是过半数，比如哨兵数量是5，那么大多数就是5/2+1=3个，哨兵数量是10大多数就是10/2+1=6个。</p>
<p>注：Sentinel节点的数量至少为3个，否则不满足quorum判定条件。</p>
<p><strong>哨兵选举</strong></p>
<p>如果发生了客观下线，那么哨兵节点会选举出一个Leader来进行实际的故障转移工作。Redis使用了Raft算法来实现哨兵领导者选举，大致思路如下：</p>
<ol>
<li>每个Sentinel节点都有资格成为领导者，当它主观认为某个数据节点宕机后，会向其他Sentinel节点发送sentinel is-master-down-by-addr命令，要求自己成为领导者；</li>
<li>收到命令的Sentinel节点，如果没有同意过其他Sentinel节点的sentinelis-master-down-by-addr命令，将同意该请求，否则拒绝（每个Sentinel节点只有1票）；</li>
<li>如果该Sentinel节点发现自己的票数已经大于等于MAX(quorum, num(sentinels)/2+1)，那么它将成为领导者；</li>
<li>如果此过程没有选举出领导者，将进入下一次选举。</li>
</ol>
<p><strong>故障转移</strong></p>
<p>选举出的Leader Sentinel节点将负责故障转移，也就是进行master/slave节点的主从切换。故障转移，首先要从slave节点中筛选出一个作为新的master，主要考虑以下slave信息：</p>
<ol>
<li>跟master断开连接的时长：如果一个slave跟master的断开连接时长已经超过了down-after-milliseconds的10倍，外加master宕机的时长，那么该slave就被认为不适合选举为master；</li>
<li>slave的优先级配置：slave priority参数值越小，优先级就越高；</li>
<li>复制offset：当优先级相同时，哪个slave复制了越多的数据（offset越靠后），优先级越高；</li>
<li>run id：如果offset和优先级都相同，则哪个slave的run id越小，优先级越高。</li>
</ol>
<p>接着，筛选完slave后， 会对它执行slaveof no one命令，让其成为主节点。</p>
<p>最后，Sentinel领导者节点会向剩余的slave节点发送命令，让它们成为新的master节点的从节点，复制规则与parallel-syncs参数有关。</p>
<p>Sentinel节点集合会将原来的master节点更新为slave节点，并保持着对其关注，当其恢复后命令它去复制新的主节点。</p>
<p>注：Leader Sentinel节点，会从新的master节点那里得到一个configuration epoch，本质是个version版本号，每次主从切换的version号都必须是唯一的。其他的哨兵都是根据version来更新自己的master配置。</p>
<h3 id="十一-缓存穿透、击穿、雪崩"><a href="#十一-缓存穿透、击穿、雪崩" class="headerlink" title="十一 缓存穿透、击穿、雪崩"></a>十一 缓存穿透、击穿、雪崩</h3><h4 id="1-缓存穿透"><a href="#1-缓存穿透" class="headerlink" title="1 缓存穿透"></a>1 缓存穿透</h4><ul>
<li>问题来源</li>
</ul>
<p>缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求。由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。</p>
<p>如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。</p>
<ul>
<li>解决方案</li>
</ul>
<ol>
<li>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；</li>
<li>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击。</li>
<li>布隆过滤器。类似于一个hash set，用于快速判某个元素是否存在于集合中，其典型的应用场景就是快速判断一个key是否存在于某容器，不存在就直接返回。布隆过滤器的关键就在于hash算法和容器大小。</li>
</ol>
<h4 id="2-缓存击穿"><a href="#2-缓存击穿" class="headerlink" title="2 缓存击穿"></a>2 缓存击穿</h4><ul>
<li>问题来源</li>
</ul>
<p>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。</p>
<ul>
<li>解决方案</li>
</ul>
<p>1、设置热点数据永远不过期。</p>
<p>2、接口限流与熔断，降级。重要的接口一定要做好限流策略，防止用户恶意刷接口，同时要降级准备，当接口中的某些服务不可用时候，进行熔断，失败快速返回机制。</p>
<p>3、加互斥锁</p>
<h4 id="3-缓存雪崩"><a href="#3-缓存雪崩" class="headerlink" title="3 缓存雪崩"></a>3 缓存雪崩</h4><ul>
<li>问题来源</li>
</ul>
<p>缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p>
<ul>
<li>解决方案</li>
</ul>
<ol>
<li>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。</li>
<li>如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中。</li>
<li>设置热点数据永远不过期</li>
</ol>
<p><strong>文章最后</strong></p>
<p>每一项技术深挖都是一个庞大的体系，学海无涯，共勉。</p>
<hr>
<blockquote>
<p>来自：<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzg3ODgwMj9zcG09YTJjNmguMTI4NzM1ODEuMC5kQXJ0aWNsZTg3ODgwMi40NDg2N2UwNEZEWGtNWQ==">阿里技术<i class="fa fa-external-link-alt"></i></span>   </p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>内存</tag>
        <tag>sql</tag>
        <tag>集合</tag>
        <tag>事务</tag>
        <tag>数据库</tag>
        <tag>栈</tag>
        <tag>函数</tag>
        <tag>数组</tag>
        <tag>CPU</tag>
        <tag>指针</tag>
        <tag>变量</tag>
        <tag>锁</tag>
        <tag>索引</tag>
        <tag>分布式</tag>
        <tag>Redis</tag>
        <tag>并发</tag>
        <tag>算法</tag>
        <tag>容器</tag>
        <tag>mongo</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis高可用集群原理和实践</title>
    <url>/posts/39ZYWX3.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>原文：<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MTAzNTUxNzE0ODc5MzQwNTgw">Redis 高可用集群原理和实践 - 掘金<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>Redis 集群是 Redis 提供的分布式数据库方案，集群痛殴分片（sharding）来进行数据共享，并提供复制和故障转移能力。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/31104759.jpg" alt="31104759"></p>
<h1 id="集群环境搭建"><a href="#集群环境搭建" class="headerlink" title="集群环境搭建"></a>集群环境搭建</h1><p>Redis 集群最少需要 3 个 master 节点，这里我们搭建 3 个master 节点，3 个 slave 及节点（由于我机器配置受限，直接通过端口的方式模拟集群搭建，本处只是实验方便，<strong>生产环境不可采取此方案</strong>）。<br>环境搭建步骤如下：</p>
<ol>
<li><p>简单说明，首先我们先要定义集群节点的端口 <code>7000-7005</code> 然后配置文件复制 redis.conf 到对应的配置文件名。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/31104954.png" alt="31104954"></p>
</li>
</ol>
<ol>
<li>编辑 redis.conf 文件，主要修改以下的几个配置（如果需要设置密码需要配置 <code>requirepass</code>和  <code>masterauth</code>）</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">daemonize yes</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这个端口和上面的配置清单一致即可</span></span><br><span class="line">port 7000 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动集群模式</span></span><br><span class="line">cluster-enabled yes</span><br><span class="line"><span class="meta">#</span><span class="bash"> 集群节点信息文件，这里700x最好和port对应上</span></span><br><span class="line">cluster-config-file nodes-7000.conf</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>
<ol>
<li><p>服务启动，注意我们需要启动所有的节点，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动所有的服务 7000-7005</span></span><br><span class="line">cd 7000</span><br><span class="line">redis-server ./redis-7000.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化集群，通过 <code>redis-cli --cluster create</code>命令初始化集群，命令如下(如果是生产环境，需要节点间 IP 以及端口是否可互相访问)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 \</span><br><span class="line">127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 \</span><br><span class="line">--cluster-replicas 1</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>集群状态查询  </p>
<ul>
<li>登录节点 <code>redis-cli -c -h 127.0.0.1 -p 7000</code>, 注意一定要加 <code>-c</code> 表示集群模式。</li>
<li>查询集群状态  <code>cluster info</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  etc redis-cli -c -h 127.0.0.1 -p 7000                         </span><br><span class="line">127.0.0.1:7000&gt; </span><br><span class="line">127.0.0.1:7000&gt; cluster info  </span><br><span class="line">cluster_state:ok</span><br><span class="line">cluster_slots_assigned:16384</span><br><span class="line">cluster_slots_ok:16384</span><br><span class="line">cluster_slots_pfail:0</span><br><span class="line">cluster_slots_fail:0</span><br><span class="line">cluster_known_nodes:6</span><br><span class="line">cluster_size:3</span><br><span class="line">cluster_current_epoch:6</span><br><span class="line">cluster_my_epoch:1</span><br><span class="line">cluster_stats_messages_ping_sent:263</span><br><span class="line">cluster_stats_messages_pong_sent:270</span><br><span class="line">cluster_stats_messages_sent:533</span><br><span class="line">cluster_stats_messages_ping_received:270</span><br><span class="line">cluster_stats_messages_pong_received:263</span><br><span class="line">cluster_stats_messages_received:533</span><br><span class="line">127.0.0.1:7000&gt; </span><br></pre></td></tr></table></figure>
<p>其他的集群创建方案 <code>utils/create-cluster</code>我们可以在参考资料中找到创建方式（参考文档：<span class="exturl" data-url="aHR0cHM6Ly9saW5rLmp1ZWppbi5jbj90YXJnZXQ9aHR0cHMlM0ElMkYlMkZyZWRpcy5pbyUyRmRvY3MlMkZtYW51YWwlMkZzY2FsaW5nJTJGJTIzcmVkaXMtY2x1c3Rlci0xMDE=">redis.io/docs/manual…<i class="fa fa-external-link-alt"></i></span>）</p>
</li>
</ol>
<h1 id="集群原理"><a href="#集群原理" class="headerlink" title="集群原理"></a>集群原理</h1><h2 id="槽指派机制"><a href="#槽指派机制" class="headerlink" title="槽指派机制"></a>槽指派机制</h2><p>Redis Cluster 将所有数据划分为 16384 个 slots(槽位)，每个节点负责其中一部分槽位。槽位的信息存储于每个节点中。<br>当 Redis Cluster 的客户端来连接集群时，它也会得到一份集群的槽位配置信息并将其缓存在客户端本地。这样当客户端要查找某个 key 时，可以直接定位到目标节点。同时因为槽位的信息可能会存在客户端与服务器不一致的情况，还需要纠正机制来实现槽位信息的校验调整。</p>
<h3 id="槽位定位算法"><a href="#槽位定位算法" class="headerlink" title="槽位定位算法"></a>槽位定位算法</h3><p>Cluster 默认会对 key 值使用 crc16 算法进行 hash 得到一个整数值，然后用这个整数值对 16384 进行与操作来得到具体槽位。<br>源码位置 <code>src/cluster.c</code> 中的 keyHashSlot 方法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">crc16(key,keylen) &amp; <span class="number">0x3FFF</span></span><br></pre></td></tr></table></figure>
<p>为什是 16384 可以看看这篇文章 ：<span class="exturl" data-url="aHR0cHM6Ly9saW5rLmp1ZWppbi5jbj90YXJnZXQ9aHR0cHMlM0ElMkYlMkZ3d3cuY3Nkbi5uZXQlMkZ0YWdzJTJGTXR6YWtnNXNORGczTnpjdFlteHZad08wTzBPTzBPME8uaHRtbA==">Redis 为什么是 16384 个槽 ？<i class="fa fa-external-link-alt"></i></span></p>
<p>查询某个 key 那个节点上，方法如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查询 key 所在的槽位</span></span><br><span class="line">127.0.0.1:7000&gt; cluster keyslot wahaha</span><br><span class="line">(integer) 12318</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查询所有的 槽分布信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以得出结论： wahaha 这个 key 在 7002 这个节点上</span></span><br><span class="line">127.0.0.1:7000&gt; cluster slots</span><br><span class="line">1) 1) (integer) 10923</span><br><span class="line">   2) (integer) 16383</span><br><span class="line">   3) 1) &quot;127.0.0.1&quot;</span><br><span class="line">      2) (integer) 7002</span><br><span class="line">      3) &quot;de631f8ac9649f5d9fb12013dc01407f953c3299&quot;</span><br><span class="line">   4) 1) &quot;127.0.0.1&quot;</span><br><span class="line">      2) (integer) 7004</span><br><span class="line">      3) &quot;6ac6065d07eb44b674a181da897401ec4cea9571&quot;</span><br><span class="line">2) 1) (integer) 5461</span><br><span class="line">   2) (integer) 10922</span><br><span class="line">   3) 1) &quot;127.0.0.1&quot;</span><br><span class="line">      2) (integer) 7001</span><br><span class="line">      3) &quot;e36fc81472afb04b9c88af1504a8e02647de1b13&quot;</span><br><span class="line">   4) 1) &quot;127.0.0.1&quot;</span><br><span class="line">      2) (integer) 7003</span><br><span class="line">      3) &quot;a89dcff90147f6cc9425ff0c6e4bead7017dc1e1&quot;</span><br><span class="line">3) 1) (integer) 0</span><br><span class="line">   2) (integer) 5460</span><br><span class="line">   3) 1) &quot;127.0.0.1&quot;</span><br><span class="line">      2) (integer) 7000</span><br><span class="line">      3) &quot;0acfc8b3dd2223333a03bbcf856dd2a839d2e072&quot;</span><br><span class="line">   4) 1) &quot;127.0.0.1&quot;</span><br><span class="line">      2) (integer) 7005</span><br><span class="line">      3) &quot;57ddd19f38d8b748386944d15d32671fb5cb1570&quot;</span><br><span class="line">127.0.0.1:7000&gt; </span><br></pre></td></tr></table></figure>
<p>其实没有这么麻烦，集群模式支持 <strong>跳转重定位</strong> 我们直接 get 就可以跳转过去。</p>
<h3 id="跳转重定位"><a href="#跳转重定位" class="headerlink" title="跳转重定位"></a>跳转重定位</h3><p>当客户端向一个错误的节点发出了指令，该节点会发现指令的 key 所在的槽位并不归自己管理，这时它会向客户端发送一个特殊的跳转指令携带目标操作的节点地址，告诉客户端去连这个节点去获取数据。客户端收到指令后除了跳转到正确的节点上去操作，还会同步更新纠正本地的槽位映射表缓存，后续所有 key 将使用新的槽位映射表。</p>
<blockquote>
<p>大白话说：就是如果当前 key 是自己的节点的槽位就自己处理，如果不是自己的槽位，就转向目标槽位的节点。</p>
</blockquote>
<p>演示一下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set abc sdl</span><br><span class="line">set sbc sdl</span><br></pre></td></tr></table></figure>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/31105832.jpg" alt="31105832"></p>
<h2 id="集群通讯机制"><a href="#集群通讯机制" class="headerlink" title="集群通讯机制"></a>集群通讯机制</h2><p>redis cluster 节点间采取 gossip 协议进行通信<br>维护集群的元数据(集群节点信息，主从角色，节点数量，各节点共享的数据等)有两种方式：</p>
<ul>
<li>集中式</li>
<li>gossip</li>
</ul>
<h3 id="集中式"><a href="#集中式" class="headerlink" title="集中式"></a>集中式</h3><p>优点在于元数据的更新和读取，时效性非常好，一旦元数据出现变更立即就会更新到集中式的存储中，其他节点读取的时候立即就可以立即感知到；不足在于所有的元数据的更新压力全部集中在一个地方，可能导致元数据的存储压力。 很多中间件都会借助 zookeeper 集中式存储元数据。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/31105938.jpg" alt="31105938"></p>
<h3 id="gossip"><a href="#gossip" class="headerlink" title="gossip"></a>gossip</h3><p><img data-src="https://xuemingde.com/pages/image/2022/05/31110007.jpg" alt="31110007"></p>
<p>gossip 协议包含多种消息，包括ping，pong，meet，fail等等。<br>meet：某个节点发送meet给新加入的节点，让新节点加入集群中，然后新节点就会开始与其他节点进行通信；<br>ping：每个节点都会频繁给其他节点发送ping，其中包含自己的状态还有自己维护的集群元数据，互相通过ping交换元数据(类似自己感知到的集群节点增加和移除，hash slot信息等)；<br>pong: 对ping和meet消息的返回，包含自己的状态和其他信息，也可以用于信息广播和更新；<br>fail: 某个节点判断另一个节点fail之后，就发送fail给其他节点，通知其他节点，指定的节点宕机了。</p>
<p><strong>gossip协议的优点在于元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续，打到所有节点上去更新，有一定的延时，降低了压力；缺点在于元数据更新有延时可能导致集群的一些操作会有一些滞后。</strong></p>
<h4 id="gossip-通信的-10000-端口"><a href="#gossip-通信的-10000-端口" class="headerlink" title="gossip 通信的 10000 端口"></a>gossip 通信的 10000 端口</h4><p>每个节点都有一个专门用于节点间gossip通信的端口，就是自己提供服务的端口号+10000，比如7001，那么用于节点间通信的就是17001端口。 每个节点每隔一段时间都会往另外几个节点发送ping消息，同时其他几点接收到ping消息之后返回pong消息。</p>
<h4 id="网络抖动"><a href="#网络抖动" class="headerlink" title="网络抖动"></a>网络抖动</h4><p>真实世界的机房网络往往并不是风平浪静的，它们经常会发生各种各样的小问题。比如网络抖动就是非常常见的一种现象，突然之间部分连接变得不可访问，然后很快又恢复正常。<br>为解决这种问题，Redis Cluster 提供了一种选项cluster-node-timeout，表示当某个节点持续 timeout 的时间失联时，才可以认定该节点出现故障，需要进行主从切换。如果没有这个选项，网络抖动会导致主从频繁切换 (数据的重新复制)。</p>
<h2 id="集群选举原理"><a href="#集群选举原理" class="headerlink" title="集群选举原理"></a>集群选举原理</h2><p>当slave发现自己的master变为FAIL状态时，便尝试进行Failover，以期成为新的master。由于挂掉的master可能会有多个slave，从而存在多个slave竞争成为master节点的过程， 其过程如下：</p>
<ol>
<li>slave发现自己的master变为FAIL</li>
<li>将自己记录的集群currentEpoch加1，并广播FAILOVER_AUTH_REQUEST 信息</li>
<li>其他节点收到该信息，只有master响应，判断请求者的合法性，并发送FAILOVER_AUTH_ACK，对每一个epoch只发送一次ack</li>
<li>尝试failover的slave收集master返回的FAILOVER_AUTH_ACK</li>
<li>slave收到超过半数master的ack后变成新Master(这里解释了集群为什么至少需要三个主节点，如果只有两个，当其中一个挂了，只剩一个主节点是不能选举成功的)</li>
<li>slave广播Pong消息通知其他集群节点。</li>
</ol>
<p>从节点并不是在主节点一进入 FAIL 状态就马上尝试发起选举，而是有一定延迟，一定的延迟确保我们等待FAIL状态在集群中传播，slave如果立即尝试选举，其它masters或许尚未意识到FAIL状态，可能会拒绝投票</p>
<p>延迟计算公式：</p>
<blockquote>
<p>DELAY = 500ms + random(0 ~ 500ms) + SLAVE_RANK * 1000ms</p>
</blockquote>
<p>SLAVE_RANK表示此slave已经从master复制数据的总量的rank。Rank越小代表已复制的数据越新。这种方式下，持有最新数据的slave将会首先发起选举（理论上）。</p>
<h3 id="集群脑裂数据丢失问题"><a href="#集群脑裂数据丢失问题" class="headerlink" title="集群脑裂数据丢失问题"></a>集群脑裂数据丢失问题</h3><p>Redis 集群没有过半机制会有脑裂问题，网络分区导致脑裂后多个主节点对外提供写服务，一旦网络分区恢复，会将其中一个主节点变为从节点，这时会有大量数据丢失。</p>
<p>规避方法可以在 redis 配置里加上参数(这种方法不可能百分百避免数据丢失，参考集群leader选举机制)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 写数据成功最少同步的slave数量，这个数量可以模仿大于半数机制配置，</span><br><span class="line">// 比如集群总共三个节点可以配置1，加上leader就是2，超过了半数</span><br><span class="line">min-replicas-to-write 1  </span><br></pre></td></tr></table></figure>
<p>注意：这个配置在一定程度上会影响集群的可用性，比如slave要是少于1个，这个集群就算leader正常也不能提供服务了，需要具体场景权衡选择。</p>
<h3 id="集群是否完整才能对外提供服务"><a href="#集群是否完整才能对外提供服务" class="headerlink" title="集群是否完整才能对外提供服务"></a>集群是否完整才能对外提供服务</h3><p>当redis.conf的配置cluster-require-full-coverage为no时，表示当负责一个插槽的主库下线<br>且没有相应的从库进行故障恢复时，集群仍然可用，如果为yes则集群不可用(默认为 yes)。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/31110357.jpg" alt="31110357"></p>
<h3 id="Redis-集群为什么至少需要三个master节点，并且推荐节点数为奇数？"><a href="#Redis-集群为什么至少需要三个master节点，并且推荐节点数为奇数？" class="headerlink" title="Redis 集群为什么至少需要三个master节点，并且推荐节点数为奇数？"></a>Redis 集群为什么至少需要三个master节点，并且推荐节点数为奇数？</h3><p>因为新master的选举需要大于半数的集群master节点同意才能选举成功，如果只有两个master节点，当其中一个挂了，是达不到选举新master的条件的。</p>
<p>奇数个master节点可以在满足选举该条件的基础上节省一个节点，比如三个master节点和四个master节点的集群相比，大家如果都挂了一个master节点都能选举新master节点，如果都挂了两个master节点都没法选举新master节点了，所以奇数的master节点更多的是<strong>从节省机器资源角度出发</strong>说的。</p>
<h3 id="Redis-集群对批量操作命令的支持"><a href="#Redis-集群对批量操作命令的支持" class="headerlink" title="Redis 集群对批量操作命令的支持"></a>Redis 集群对批量操作命令的支持</h3><p><img data-src="https://xuemingde.com/pages/image/2022/05/31110442.jpg" alt="31110442"></p>
<p>如何让多个 key 落到一个槽里面 ？<br>对于类似mset，mget这样的多个key的原生批量操作命令，redis集群只支持所有key落在同一slot的情况，如果有多个key<strong>一定要用mset命令在redis集群上操作，则可以在key的前面加上{XX}，这样参数数据分片hash计算的只会是大括号里的值，这样能确保不同的key能落到同一slot里去</strong>，示例如下：</p>
<blockquote>
<p>mset {user1}:1:name zhangsan {user1}:1:age 18</p>
</blockquote>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/31110518.jpg" alt="31110518"></p>
<p>假设name和age计算的hash slot值不一样，但是这条命令在集群下执行，redis只会用大括号里的 user1 做hash slot计算，所以算出来的slot值肯定相同，最后都能落在同一slot。</p>
<h3 id="对比-哨兵leader选举流程"><a href="#对比-哨兵leader选举流程" class="headerlink" title="对比: 哨兵leader选举流程"></a>对比: 哨兵leader选举流程</h3><p>当一个master服务器被某sentinel视为下线状态后，该sentinel会与其他sentinel协商选出sentinel的leader进行故障转移工作。每个发现master服务器进入下线的sentinel都可以要求其他sentinel选自己为sentinel的leader，选举是先到先得。同时每个sentinel每次选举都会自增配置纪元(选举周期)，每个纪元中只会选择一个sentinel的leader。如果所有超过一半的sentinel选举某sentinel作为leader。之后该sentinel进行故障转移操作，从存活的slave中选举出新的master，这个选举过程跟集群的master选举很类似。</p>
<p>哨兵集群只有一个哨兵节点，redis的主从也能正常运行以及选举master，如果master挂了，那唯一的那个哨兵节点就是哨兵leader了，可以正常选举新master。</p>
<p>不过为了高可用一般都推荐至少部署三个哨兵节点。为什么推荐奇数个哨兵节点原理跟集群奇数个master节点类似。</p>
<h1 id="集群故障转移"><a href="#集群故障转移" class="headerlink" title="集群故障转移"></a>集群故障转移</h1><p>Redis 集群中的节点分为主节点（master）和从节点（slave）,其中主节点用于处理槽，而从节点则用于复制某个主节点，并且在复制主节点下线时，代替主节点继续处理命令请求。</p>
<h2 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h2><p>集群中的每个节点都会<strong>定期</strong>地向集群中的其他节点发送PING消息，以此来检测对方是否在线，如果接收PING消息的节点没有在规定的时间内，向发送PING消息的节点返回PONG消息，那么发送PING消息的节点就会将接收PING消息的节点标记为<strong>疑似下线（probable fail，PFAIL）</strong>。</p>
<p>如果在一个集群里面，半数以上负责处理槽的主节点都将某个主节点x报告为疑似下线，那么这个主节点x将被标记为<strong>已下线（FAIL）</strong>，将主节点x标记为已下线的节点会向集群广播一条关于主节点x的FAIL消息，所有收到这条FAIL消息的节点都会立即将主节点x标记为已下线。</p>
<p>举个例子，主节点7002和主节点7003都认为主节点7000进入了下线状态，并且主节点7001也认为主节点7000进入了疑似下线状态，在集群四个负责处理槽的主节点里面，有三个都将主节点7000标记为下线，数量已经超过了半数，所以主节点7001会将主节点7000标记为已下线，并向集群广播一条关于主节点7000的FAIL消息，如图所示：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/31110629.jpg" alt="31110629"></p>
<h2 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h2><p>当一个从节点发现自己正在复制的主节点进入了已下线状态时，从节点将开始对下线主节点进行故障转移，以下是故障转移的执行步骤：</p>
<ol>
<li>复制下线主节点的所有从节点里面，会有一个从节点被选中。</li>
<li>被选中的从节点会执行<code>SLAVEOF no one</code>命令，成为新的主节点。</li>
<li>新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己。</li>
<li>新的主节点向集群广播一条PONG消息，这条PONG消息可以让集群中的其他节点立即知道这个节点已经由从节点变成了主节点，并且这个主节点已经接管了原本由已下线节点负责处理的槽。</li>
<li>新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成。</li>
</ol>
<h2 id="重新选择新节点"><a href="#重新选择新节点" class="headerlink" title="重新选择新节点"></a>重新选择新节点</h2><p>新的主节点是通过选举产生的。以下是集群选举新的主节点的方法：</p>
<ol>
<li>集群的配置纪元是一个自增计数器，它的初始值为0。</li>
<li>当集群里的某个节点开始一次故障转移操作时，集群配置纪元的值会被增一。</li>
<li>对于每个配置纪元，集群里每个负责处理槽的主节点都有一次投票的机会，而第一个向主节点要求投票的从节点将获得主节点的投票。</li>
<li>当从节点发现自己正在复制的主节点进入已下线状态时，从节点会向集群广播一条CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST消息，要求所有收到这条消息、并且具有投票权的主节点向这个从节点投票。</li>
<li>如果一个主节点具有投票权（它正在负责处理槽），并且这个主节点尚未投票给其他从节点，那么主节点将向要求投票的从节点返回一条CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息，表示这个主节点支持从节点成为新的主节点。</li>
<li>每个参与选举的从节点都会接收CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息，并根据自己收到了多少条这种消息来统计自己获得了多少主节点的支持。</li>
<li>如果集群里有N个具有投票权的主节点，那么当一个从节点收集到大于等于N/2+1张支持票时，这个从节点就会当选为新的主节点。</li>
<li>因为在每一个配置纪元里面，每个具有投票权的主节点只能投一次票，所以如果有N个主节点进行投票，那么具有大于等于N/2+1张支持票的从节点只会有一个，这确保了新的主节点只会有一个。</li>
<li>如果在一个配置纪元里面没有从节点能收集到足够多的支持票，那么集群进入一个新的配置纪元，并再次进行选举，直到选出新的主节点为止。</li>
</ol>
<p>Cluster 选举新主节点的方法和 Sentinel 的方法非常相似，因为两者都是基于 Raft 算法的领头选举（leader election）方法来实现的。</p>
<h1 id="水平拓展"><a href="#水平拓展" class="headerlink" title="水平拓展"></a>水平拓展</h1><h2 id="拓展主节点"><a href="#拓展主节点" class="headerlink" title="拓展主节点"></a>拓展主节点</h2><p>集群状态查询</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:7000&gt; cluster nodes </span><br><span class="line">6ac6065d07eb44b674a181da897401ec4cea9571 127.0.0.1:7004@17004 slave de631f8ac9649f5d9fb12013dc01407f953c3299 0 1653897401000 3 connected</span><br><span class="line">de631f8ac9649f5d9fb12013dc01407f953c3299 127.0.0.1:7002@17002 master - 0 1653897402475 3 connected 10923-16383</span><br><span class="line">a89dcff90147f6cc9425ff0c6e4bead7017dc1e1 127.0.0.1:7003@17003 slave e36fc81472afb04b9c88af1504a8e02647de1b13 0 1653897401956 2 connected</span><br><span class="line">e36fc81472afb04b9c88af1504a8e02647de1b13 127.0.0.1:7001@17001 master - 0 1653897401541 2 connected 5461-10922</span><br><span class="line">0acfc8b3dd2223333a03bbcf856dd2a839d2e072 127.0.0.1:7000@17000 myself,master - 0 1653897400000 1 connected 0-5460</span><br><span class="line">57ddd19f38d8b748386944d15d32671fb5cb1570 127.0.0.1:7005@17005 slave 0acfc8b3dd2223333a03bbcf856dd2a839d2e072 0 1653897401000 1 connected</span><br><span class="line">127.0.0.1:7000&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="拓展规划"><a href="#拓展规划" class="headerlink" title="拓展规划"></a>拓展规划</h3><p>我们在原始集群基础上再增加一主(7006)一从(7007)</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/31110722.png" alt="31110722"></p>
<p>启动节点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-server redis-7006.conf</span><br><span class="line">redis-server redis-7007.conf        </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="集群中加入节点"><a href="#集群中加入节点" class="headerlink" title="集群中加入节点"></a>集群中加入节点</h3><p>加入集群</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  etc redis-cli --cluster add-node 127.0.0.1:7006 127.0.0.1:7001</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Adding node 127.0.0.1:7006 to cluster 127.0.0.1:7001</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7001)</span></span><br><span class="line">M: e36fc81472afb04b9c88af1504a8e02647de1b13 127.0.0.1:7001</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: a89dcff90147f6cc9425ff0c6e4bead7017dc1e1 127.0.0.1:7003</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates e36fc81472afb04b9c88af1504a8e02647de1b13</span><br><span class="line">S: 6ac6065d07eb44b674a181da897401ec4cea9571 127.0.0.1:7004</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates de631f8ac9649f5d9fb12013dc01407f953c3299</span><br><span class="line">S: 57ddd19f38d8b748386944d15d32671fb5cb1570 127.0.0.1:7005</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 0acfc8b3dd2223333a03bbcf856dd2a839d2e072</span><br><span class="line">M: de631f8ac9649f5d9fb12013dc01407f953c3299 127.0.0.1:7002</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 0acfc8b3dd2223333a03bbcf856dd2a839d2e072 127.0.0.1:7000</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Check <span class="keyword">for</span> open slots...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Check slots coverage...</span></span><br><span class="line">[OK] All 16384 slots covered.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Send CLUSTER MEET to node 127.0.0.1:7006 to make it join the cluster.</span></span><br><span class="line">[OK] New node added correctly.</span><br><span class="line">➜  etc </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如下，7006加入了集群，并且默认是一个master节点：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  etc redis-cli -p 7001 cluster nodes</span><br><span class="line">2109c2832177e8514174c6ef8fefd681076e28df 127.0.0.1:7006@17006 master - 0 1653919429534 0 connected</span><br><span class="line">a89dcff90147f6cc9425ff0c6e4bead7017dc1e1 127.0.0.1:7003@17003 slave e36fc81472afb04b9c88af1504a8e02647de1b13 0 1653919430000 2 connected</span><br><span class="line">6ac6065d07eb44b674a181da897401ec4cea9571 127.0.0.1:7004@17004 slave de631f8ac9649f5d9fb12013dc01407f953c3299 0 1653919430549 3 connected</span><br><span class="line">57ddd19f38d8b748386944d15d32671fb5cb1570 127.0.0.1:7005@17005 slave 0acfc8b3dd2223333a03bbcf856dd2a839d2e072 0 1653919430549 1 connected</span><br><span class="line">de631f8ac9649f5d9fb12013dc01407f953c3299 127.0.0.1:7002@17002 master - 0 1653919429129 3 connected 10923-16383</span><br><span class="line">0acfc8b3dd2223333a03bbcf856dd2a839d2e072 127.0.0.1:7000@17000 master - 0 1653919430549 1 connected 0-5460</span><br><span class="line">e36fc81472afb04b9c88af1504a8e02647de1b13 127.0.0.1:7001@17001 myself,master - 0 1653919429000 2 connected 5461-10922</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="设置和迁移分片"><a href="#设置和迁移分片" class="headerlink" title="设置和迁移分片"></a>设置和迁移分片</h3><p>为集群分配分片</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster reshard 127.0.0.1:7001</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在执行过程中会询问，计划迁移槽数，迁移数据目标，以及迁移数据来源。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/31110818.jpg" alt="31110818"></p>
<p>重新分配后的结果查询 <code>redis-cli -p 7001 cluster nodes</code></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/31110858.jpg" alt="31110858"></p>
<p>配置从 7006 的从节点 7007,  同样也是先执行加入集群的命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster add-node 127.0.0.1:7007 127.0.0.1:7001</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="设置从节点"><a href="#设置从节点" class="headerlink" title="设置从节点"></a>设置从节点</h3><p>我们需要执行 replicate 命令来指定当前节点(从节点)的主节点id为哪个,首先需要连接新加的7007节点的客户端，然后使用集群命令进行操作，把当前的7007(slave)节点指定到一个主节点下(这里使用之前创建的7006主节点)</p>
<p>具体的命令如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查询集群节点</span></span><br><span class="line">➜  etc redis-cli -p 7001 cluster nodes                           </span><br><span class="line">2109c2832177e8514174c6ef8fefd681076e28df 127.0.0.1:7006@17006 master - 0 1653920562718 7 connected 0-1332 5461-6794 10923-12255</span><br><span class="line">a89dcff90147f6cc9425ff0c6e4bead7017dc1e1 127.0.0.1:7003@17003 slave e36fc81472afb04b9c88af1504a8e02647de1b13 0 1653920561710 2 connected</span><br><span class="line">6ac6065d07eb44b674a181da897401ec4cea9571 127.0.0.1:7004@17004 slave de631f8ac9649f5d9fb12013dc01407f953c3299 0 1653920562000 3 connected</span><br><span class="line">57ddd19f38d8b748386944d15d32671fb5cb1570 127.0.0.1:7005@17005 slave 0acfc8b3dd2223333a03bbcf856dd2a839d2e072 0 1653920562516 1 connected</span><br><span class="line">8d935918d877a63283e1f3a1b220cdc8cb73c414 127.0.0.1:7007@17007 master - 0 1653920563000 0 connected</span><br><span class="line">de631f8ac9649f5d9fb12013dc01407f953c3299 127.0.0.1:7002@17002 master - 0 1653920563000 3 connected 12256-16383</span><br><span class="line">0acfc8b3dd2223333a03bbcf856dd2a839d2e072 127.0.0.1:7000@17000 master - 0 1653920561506 1 connected 1333-5460</span><br><span class="line">e36fc81472afb04b9c88af1504a8e02647de1b13 127.0.0.1:7001@17001 myself,master - 0 1653920562000 2 connected 6795-10922</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 登录到新加节点</span></span><br><span class="line">➜  etc redis-cli -p 7007</span><br><span class="line">127.0.0.1:7007&gt; </span><br><span class="line"><span class="meta">#</span><span class="bash"> 制定当前当前节点的主节点 7006</span></span><br><span class="line">127.0.0.1:7007&gt; cluster replicate 2109c2832177e8514174c6ef8fefd681076e28df</span><br><span class="line">OK</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重新查询集群状态</span></span><br><span class="line">127.0.0.1:7007&gt; cluster nodes</span><br><span class="line">57ddd19f38d8b748386944d15d32671fb5cb1570 127.0.0.1:7005@17005 slave 0acfc8b3dd2223333a03bbcf856dd2a839d2e072 0 1653920688403 1 connected</span><br><span class="line">8d935918d877a63283e1f3a1b220cdc8cb73c414 127.0.0.1:7007@17007 myself,slave 2109c2832177e8514174c6ef8fefd681076e28df 0 1653920685000 7 connected</span><br><span class="line">2109c2832177e8514174c6ef8fefd681076e28df 127.0.0.1:7006@17006 master - 0 1653920688000 7 connected 0-1332 5461-6794 10923-12255</span><br><span class="line">de631f8ac9649f5d9fb12013dc01407f953c3299 127.0.0.1:7002@17002 master - 0 1653920687000 3 connected 12256-16383</span><br><span class="line">0acfc8b3dd2223333a03bbcf856dd2a839d2e072 127.0.0.1:7000@17000 master - 0 1653920687000 1 connected 1333-5460</span><br><span class="line">6ac6065d07eb44b674a181da897401ec4cea9571 127.0.0.1:7004@17004 slave de631f8ac9649f5d9fb12013dc01407f953c3299 0 1653920688099 3 connected</span><br><span class="line">a89dcff90147f6cc9425ff0c6e4bead7017dc1e1 127.0.0.1:7003@17003 slave e36fc81472afb04b9c88af1504a8e02647de1b13 0 1653920688504 2 connected</span><br><span class="line">e36fc81472afb04b9c88af1504a8e02647de1b13 127.0.0.1:7001@17001 master - 0 1653920687392 2 connected 6795-10922</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后我们再次查询，发现 7007 成功变成了 7008 的主节点</p>
<h2 id="主节点下线"><a href="#主节点下线" class="headerlink" title="主节点下线"></a>主节点下线</h2><p>彻底删除主节点，因为主节点中存在数据，所以我们可以分为两个步骤操作</p>
<ul>
<li>数据迁移</li>
<li>节点下线</li>
</ul>
<p>为了方便验证，我先设置一个数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:7001&gt; set sdl 123</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> Redirected to slot [11164] located at 127.0.0.1:7006</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7006&gt; get sdl</span><br><span class="line">&quot;123&quot;</span><br></pre></td></tr></table></figure>
<p>先下先从节点, 执行一下命令：<br><code>redis-cli --cluster del-node 127.0.0.1:7007 8d935918d877a63283e1f3a1b220cdc8cb73c414</code></p>
<h3 id="数据迁出"><a href="#数据迁出" class="headerlink" title="数据迁出"></a>数据迁出</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  etc redis-cli --cluster reshard 127.0.0.1:7001</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7001)</span></span><br><span class="line">M: e36fc81472afb04b9c88af1504a8e02647de1b13 127.0.0.1:7001</span><br><span class="line">   slots:[10212-10922] (711 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 2109c2832177e8514174c6ef8fefd681076e28df 127.0.0.1:7006</span><br><span class="line">   slots:[11471-12255] (785 slots) master</span><br><span class="line">S: a89dcff90147f6cc9425ff0c6e4bead7017dc1e1 127.0.0.1:7003</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates e36fc81472afb04b9c88af1504a8e02647de1b13</span><br><span class="line">S: 6ac6065d07eb44b674a181da897401ec4cea9571 127.0.0.1:7004</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates de631f8ac9649f5d9fb12013dc01407f953c3299</span><br><span class="line">S: 57ddd19f38d8b748386944d15d32671fb5cb1570 127.0.0.1:7005</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 0acfc8b3dd2223333a03bbcf856dd2a839d2e072</span><br><span class="line">M: de631f8ac9649f5d9fb12013dc01407f953c3299 127.0.0.1:7002</span><br><span class="line">   slots:[15624-16383] (760 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 0acfc8b3dd2223333a03bbcf856dd2a839d2e072 127.0.0.1:7000</span><br><span class="line">   slots:[0-10211],[10923-11470],[12256-15623] (14128 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Check <span class="keyword">for</span> open slots...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Check slots coverage...</span></span><br><span class="line">[OK] All 16384 slots covered.</span><br><span class="line">How many slots do you want to move (from 1 to 16384)? 785</span><br><span class="line">What is the receiving node ID? 0acfc8b3dd2223333a03bbcf856dd2a839d2e072</span><br><span class="line">Please enter all the source node IDs.</span><br><span class="line">  Type &#x27;all&#x27; to use all the nodes as source nodes for the hash slots.</span><br><span class="line">  Type &#x27;done&#x27; once you entered all the source nodes IDs.</span><br><span class="line">Source node #1: 2109c2832177e8514174c6ef8fefd681076e28df</span><br><span class="line">Source node #2: done</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查询节点槽信息<br><img data-src="https://xuemingde.com/pages/image/2022/05/31111010.jpg" alt="31111010"></p>
<p>节点下线</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster del-node 127.0.0.1:7006 2109c2832177e8514174c6ef8fefd681076e28df</span><br></pre></td></tr></table></figure>
<p>执行后结果如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/31111039.jpg" alt="31111039"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>《Redis 设计与实现》黄健宏</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9saW5rLmp1ZWppbi5jbj90YXJnZXQ9aHR0cHMlM0ElMkYlMkZ3d3cuY3Nkbi5uZXQlMkZ0YWdzJTJGTXR6YWtnNXNORGczTnpjdFlteHZad08wTzBPTzBPME8uaHRtbA==">Redis 为什么是 16384 个槽 ？<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9saW5rLmp1ZWppbi5jbj90YXJnZXQ9aHR0cHMlM0ElMkYlMkZibG9nLmNzZG4ubmV0JTJGd2FuZGVyc3RhcnJ5c2t5JTJGYXJ0aWNsZSUyRmRldGFpbHMlMkYxMTgxNTc3NTE=">blog.csdn.net/wanderstarr…<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9saW5rLmp1ZWppbi5jbj90YXJnZXQ9aHR0cHMlM0ElMkYlMkZzZWdtZW50ZmF1bHQuY29tJTJGYSUyRjExOTAwMDAwMzgzNzM1NDY=">segmentfault.com/a/119000003…<i class="fa fa-external-link-alt"></i></span></li>
<li>部分图片来源于网络，如有侵权请留言</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>数据库</tag>
        <tag>分布式</tag>
        <tag>Redis</tag>
        <tag>并发</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL优化和SQl注入问题</title>
    <url>/posts/1NTK6KJ.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><div style="text-align: center;"></div><br><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vbWVhZGVyL2hleG8tYmxvZy9ibG9iL2Jsb2cvc291cmNlL19wb3N0cy8lRTYlOTUlQjAlRTYlOEQlQUUlRTUlQkElOTMvU1FMLzIwMjEwMzI0LVNRTCVFNCVCQyU5OCVFNSU4QyU5NiVFNSU5MiU4Q1NRbCVFNiVCMyVBOCVFNSU4NSVBNSVFOSU5NyVBRSVFOSVBMiU5OC5tZA==">Gitee原文<i class="fa fa-external-link-alt"></i></span></p>
<span id="more"></span>
<h2 id="Mysq如何防止sql注入"><a href="#Mysq如何防止sql注入" class="headerlink" title="Mysq如何防止sql注入"></a>Mysq如何防止sql注入</h2><p><img data-src="https://xuemingde.com/pages/image/others/1616577043492-442c592a-804e-4088-b2c9-638a75b161e2.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1616577087040-e9f6cd55-6e3e-4222-b765-0a92dba38d06.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1616577122583-79d2acfc-d7f7-4621-a111-377d794dc8ed.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1616577268648-ffe8d2d7-47a1-4950-a640-13536b8995a2.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1616577373081-556a9755-06b5-468c-b408-6300bb732919.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1616577415889-ba502d4b-200a-4001-b248-74fb0a392ec4.png" alt="image.png"></p>
<h2 id="sql优化"><a href="#sql优化" class="headerlink" title="sql优化"></a>sql优化</h2><blockquote>
<p>参考文章：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4Nzg5OTQxL2FydGljbGUvZGV0YWlscy84Mzc0NDI3MQ==">文章一<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cDovL3d3dy4zNjBkb2MuY29tL2NvbnRlbnQvMTkvMDEzMS8xNS8xNjYxOTM0M184MTIzNjQ1MDkuc2h0bWw=">文章二<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9kYXRhYmFzZS41MWN0by5jb20vYXJ0LzIwMjAwOC82MjM1ODQuaHRt">文章三<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p><img data-src="https://xuemingde.com/pages/image/others/1616578389551-55a77709-b74e-4540-ae8f-04b5e4179322.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1616578441174-96b41421-3b20-40f0-9fd1-48eb450ea3df.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1616578463749-932b1d5a-0af6-4e0d-a631-821d61d0f2c1.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1616578525260-6a9732d6-9fa4-487a-bba3-988e62a88cc4.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1616578758297-eb44d2e5-a1d4-485d-8b2f-ad6f509113ab.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1616577654854-44419b96-5af4-44b2-b389-d00314469079.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1616577693679-2c2663b4-5efd-401f-aa98-57b5061806e1.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1616577751426-63b9766f-35d1-4687-bb88-c62324292220.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1616577825406-1ed6ee37-a0ed-43f8-9851-56531236c3ff.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1616577960384-46bfe1d5-528f-4431-8c29-960672e1511b.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1616578045790-15018eba-4314-482f-8eb7-a77058b40e82.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1616578168179-dbf58c50-3575-475f-a6d1-cef3fd469276.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1616578207948-033e7d81-2693-4b3e-8cd9-37203abf5a77.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1616578269256-50e74199-38ea-4d0b-9578-89a0fc62191e.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1616579091545-5c28d7c4-ecbe-43db-b31d-736843686929.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/image-20210324175324481.png" alt="image-20210324175324481"></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>OR与AND一起的用法</title>
    <url>/posts/1BED9D0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><div style="text-align: center;"></div><br><span id="more"></span>  </p>
<p>数据1<br><img data-src="https://xuemingde.com/pages/image/2022/23/150612.jpg" alt="150612"></p>
<p>查询<br><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询结果是id = 2且age = 20或者id=1</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span> <span class="keyword">or</span> id <span class="operator">=</span> <span class="number">2</span> <span class="keyword">AND</span> age <span class="operator">=</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure><br>返回结果<br><img data-src="https://xuemingde.com/pages/image/2022/23/150837.jpg" alt="150837"></p>
<p>查询  </p>
<pre><code class="lang-sql">-- 查询结果是 id=1或id=2 且age = 20
SELECT * from student WHERE (id = 1 or id = 2 ) AND age = 20;
</code></pre>
<p>返回结果<br><img data-src="https://xuemingde.com/pages/image/2022/23/151058.jpg" alt="151058">  </p>
<p>数据2。<br><img data-src="https://xuemingde.com/pages/image/2022/23/151502.jpg" alt="151502">  </p>
<p>查询返回结果<br><img data-src="https://xuemingde.com/pages/image/2022/23/151536.jpg" alt="151536">  </p>
<p>查询返回结果<br><img data-src="https://xuemingde.com/pages/image/2022/23/151700.jpg" alt="151700"></p>
<p>查询返回结果<br><img data-src="https://xuemingde.com/pages/image/2022/23/151721.jpg" alt="151721"></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>一文详解SQL关联子查询</title>
    <url>/posts/33P1FY8.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><div style="text-align: center;"></div><br><span id="more"></span></p>
<blockquote>
<p>Alibaba Java 技术图谱:  <span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9ncmFwaC9qYXZhP3NwbT1hMmM2aC4yMTExMDI1MC5KXzk3Njc5OTg0NTAuMy4yNDVhM2M2NzlEbGtWdA==">https://developer.aliyun.com/graph/java?spm=a2c6h.21110250.J_9767998450.3.245a3c679DlkVt<i class="fa fa-external-link-alt"></i></span></p>
<p>原文地址：<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9hcnRpY2xlLzc4MzEyND9zcG09YTJjNmguMjQ4NzQ2MzIuMC4wLjIxZTUzY2NkUHdYdTlT">https://developer.aliyun.com/article/783124?spm=a2c6h.24874632.0.0.21e53ccdPwXu9S<i class="fa fa-external-link-alt"></i></span></p>
<p> <strong>简介：</strong>本文主要介绍什么是关联子查询以及如何将关联子查询改写为普通语义的sql查询。                </p>
</blockquote>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/220112.png" alt="image.png"></p>
<p>作者 | 猫来<br>来源 | <span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvV2h4NTBLTlV1WE9STzA1Ymk3UEVDdw==">阿里技术公众号<i class="fa fa-external-link-alt"></i></span></p>
<p>本文主要介绍什么是关联子查询以及如何将关联子查询改写为普通语义的sql查询。</p>
<p>在背景介绍中我们将讲讲常见的关联子查询的语义，关联子查询语法的好处以及其执行时对数据库系统的挑战。第二章中我们将主要介绍如何将关联子查询改写为普通的查询的形式，也就是解关联。第三章中我们会介绍解关联中的优化方法。</p>
<h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><p>关联子查询是指和外部查询有关联的子查询，具体来说就是在这个子查询里使用了外部查询包含的列。</p>
<p>因为这种可以使用关联列的灵活性，将sql查询写成子查询的形式往往可以极大的简化sql以及使得sql查询的语义更加方便理解。下面我们通过使用tpch schema来举几个例子以说明这一点。tpch  schema是一个典型的订单系统的database，包含customer表，orders表，lineitem表等，如下图：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/220129.png" alt="image.png"></p>
<p>假如我们希望查询出“所有从来没有下过单的客户的信息”，那么我们可以将关联子查询作为过滤条件。使用关联子查询写出的sql如下。可以看到这里的not exists子查询使用列外部的列c_custkey。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 所有从来没有下过单的客户的信息</span></span><br><span class="line"><span class="keyword">select</span> c_custkey</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  customer</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">  <span class="keyword">not</span> <span class="keyword">exists</span> (</span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">      <span class="operator">*</span></span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">      orders</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">      o_custkey <span class="operator">=</span> c_custkey</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>如果不写成上面的形式，我们则需要考虑将customer和orders两个表先进行left join，然后再过滤掉没有join上的行，同时我们还需要markorder的每一行，使得本来就是null的那些。查询sql如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 所有从来没有下过单的客户的信息</span></span><br><span class="line"><span class="keyword">select</span> c_custkey</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  customer</span><br><span class="line">  <span class="keyword">left</span> <span class="keyword">join</span> (</span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">      <span class="keyword">distinct</span> o_custkey</span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">      orders</span><br><span class="line">  ) <span class="keyword">on</span> o_custkey <span class="operator">=</span> c_custkey</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">  o_custkey <span class="keyword">is</span> <span class="keyword">null</span></span><br></pre></td></tr></table></figure>
<p>从这个简单的例子中就可以看到使用关联子查询降低了sql编写的难度，同时提高了可读性。</p>
<p>除了在exists/in子查询中使用关联列，关联子查询还可以出现在where中作为过滤条件需要的值。比如tpch q17中使用子查询求出一个聚合值作为过滤条件。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- tpch q17</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">Sum</span>(l1.extendedprice) <span class="operator">/</span> <span class="number">7.0</span> <span class="keyword">AS</span> avg_yearly </span><br><span class="line"><span class="keyword">FROM</span>   lineitem l1, </span><br><span class="line">       part p</span><br><span class="line"><span class="keyword">WHERE</span>  p.partkey <span class="operator">=</span> l1.partkey </span><br><span class="line">       <span class="keyword">AND</span> p.brand <span class="operator">=</span> <span class="string">&#x27;Brand#44&#x27;</span> </span><br><span class="line">       <span class="keyword">AND</span> p.container <span class="operator">=</span> <span class="string">&#x27;WRAP PKG&#x27;</span> </span><br><span class="line">       <span class="keyword">AND</span> l1.quantity <span class="operator">&lt;</span> (<span class="keyword">SELECT</span> <span class="number">0.2</span> <span class="operator">*</span> <span class="built_in">Avg</span>(l2.quantity) </span><br><span class="line">                         <span class="keyword">FROM</span>   lineitem l2</span><br><span class="line">                         <span class="keyword">WHERE</span>  l2.partkey <span class="operator">=</span> p.partkey);</span><br></pre></td></tr></table></figure>
<p>除了出现在where里面，关联子查询可以出现在任何允许出现单行(scalar)的地方，比如select列表里。如果我们需要做报表汇总一些customer的信息，希望对每一个customer查询他们的订单总额，我们可以使用下面包含关联子查询的sql。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 客户以及对应的消费总额</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">  c_custkey,</span><br><span class="line">  (</span><br><span class="line">    <span class="keyword">select</span> <span class="built_in">sum</span>(o_totalprice)</span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">      orders</span><br><span class="line">    <span class="keyword">where</span> o_custkey <span class="operator">=</span> c_custkey </span><br><span class="line">    ）</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  customer</span><br></pre></td></tr></table></figure>
<p>更复杂一些的比如，我们希望查询每一个customer及其对应的在某个日期前已经签收的订单总额。利用关联子查询只需要做一些小的改变如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">  c_custkey,</span><br><span class="line">  (</span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">      <span class="built_in">sum</span>(o_totalprice)</span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">      orders</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">      o_custkey <span class="operator">=</span> c_custkey</span><br><span class="line">      <span class="keyword">and</span> <span class="string">&#x27;2020-05-27&#x27;</span> <span class="operator">&gt;</span> (</span><br><span class="line">        <span class="keyword">select</span></span><br><span class="line">          <span class="built_in">max</span>(l_receiptdate)</span><br><span class="line">        <span class="keyword">from</span></span><br><span class="line">          lineitem</span><br><span class="line">        <span class="keyword">where</span></span><br><span class="line">          l_orderkey <span class="operator">=</span> o_orderkey</span><br><span class="line">      ) </span><br><span class="line">    ）</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">   customer</span><br></pre></td></tr></table></figure>
<p>看了这些例子，相信大家都已经感受到使用关联子查询带来的便捷。但是同时关联子查询也带来了执行上的挑战。为了计算关联结果的值（子查询的输出），需要iterative的执行方式。</p>
<p>以之前讨论过的tpch 17为例子：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">Sum</span>(l1.extendedprice) <span class="operator">/</span> <span class="number">7.0</span> <span class="keyword">AS</span> avg_yearly </span><br><span class="line"><span class="keyword">FROM</span>   lineitem l1, </span><br><span class="line">       part p</span><br><span class="line"><span class="keyword">WHERE</span>  p.partkey <span class="operator">=</span> l1.partkey </span><br><span class="line">       <span class="keyword">AND</span> p.brand <span class="operator">=</span> <span class="string">&#x27;Brand#44&#x27;</span> </span><br><span class="line">       <span class="keyword">AND</span> p.container <span class="operator">=</span> <span class="string">&#x27;WRAP PKG&#x27;</span> </span><br><span class="line">       <span class="keyword">AND</span> l1.quantity <span class="operator">&lt;</span> (<span class="keyword">SELECT</span> <span class="number">0.2</span> <span class="operator">*</span> <span class="built_in">Avg</span>(l2.quantity) </span><br><span class="line">                         <span class="keyword">FROM</span>   lineitem l2</span><br><span class="line">                         <span class="keyword">WHERE</span>  l2.partkey <span class="operator">=</span> p.partkey);</span><br></pre></td></tr></table></figure>
<p>这里的子查询部分使用了外部查询的列 p.partkey。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="number">0.2</span> <span class="operator">*</span> <span class="built_in">Avg</span>(l2.quantity) </span><br><span class="line"><span class="keyword">FROM</span>   lineitem l2</span><br><span class="line"><span class="keyword">WHERE</span>  l2.partkey <span class="operator">=</span> p.partkey  <span class="comment">-- p.partkey是外部查询的列</span></span><br></pre></td></tr></table></figure>
<p>优化器将这个查询表示为如下图的逻辑树：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/220237.png" alt="image.png"></p>
<p>如果数据库系统不支持查看逻辑树，可以通过explain命令查看物理计划，一般输出如下图：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">---------------+</span></span><br><span class="line"><span class="operator">|</span> Plan Details  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+</span></span><br><span class="line"> <span class="number">1</span><span class="operator">-</span> Output[avg_yearly] avg_yearly :<span class="operator">=</span> expr</span><br><span class="line"> <span class="number">2</span>    <span class="operator">-</span><span class="operator">&gt;</span> Project[] expr :<span class="operator">=</span> (`sum` <span class="operator">/</span> <span class="keyword">DOUBLE</span> <span class="string">&#x27;7.0&#x27;</span>)</span><br><span class="line"> <span class="number">3</span>        <span class="operator">-</span> Aggregate sum :<span class="operator">=</span> `sum`(`extendedprice`)</span><br><span class="line"> <span class="number">4</span>            <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">Filter</span>[p.`partkey` <span class="operator">=</span> l1.`partkey` <span class="keyword">AND</span> `brand` <span class="operator">=</span> <span class="string">&#x27;Brand#51&#x27;</span> <span class="keyword">AND</span> `container` <span class="operator">=</span> <span class="string">&#x27;WRAP PACK&#x27;</span> <span class="keyword">AND</span> `quantity` <span class="operator">&lt;</span> `<span class="keyword">result</span>`]</span><br><span class="line"> <span class="number">5</span>                <span class="operator">-</span> CorrelatedJoin[[p.`partkey`]]</span><br><span class="line"> <span class="number">6</span>                    <span class="operator">-</span> CrossJoin</span><br><span class="line"> <span class="number">7</span>                        <span class="operator">-</span> TableScan[tpch:lineitem l1]</span><br><span class="line"> <span class="number">8</span>                        <span class="operator">-</span> TableScan[tpch:part p]</span><br><span class="line"> <span class="number">9</span>                    <span class="operator">-</span> Scalar</span><br><span class="line"><span class="number">10</span>                        <span class="operator">-</span><span class="operator">&gt;</span> Project[] <span class="keyword">result</span> :<span class="operator">=</span> (<span class="keyword">DOUBLE</span> <span class="string">&#x27;0.2&#x27;</span> <span class="operator">*</span> `avg`)</span><br><span class="line"><span class="number">11</span>                            <span class="operator">-</span> Aggregate avg :<span class="operator">=</span> `avg`(`quantity`)</span><br><span class="line"><span class="number">12</span>                                <span class="operator">-</span><span class="operator">&gt;</span> <span class="keyword">Filter</span>[(p.`partkey` <span class="operator">=</span> l2`partkey`)] </span><br><span class="line"><span class="number">13</span>                                    <span class="operator">-</span> TableScan[tpch:lineitem l2]</span><br></pre></td></tr></table></figure>
<p>我们将这个连接外部查询和子查询的算子叫做CorrelatedJoin(也被称之为lateral join, dependent  join等等。它的左子树我们称之为外部查询(input)，右子树称之为子查询(subquery)。子查询中出现的外部的列叫做关联列。在栗子中关联列为p.partkey。 </p>
<p>例子中对应的逻辑计划和相关定义如下图所示，explain返回结果中第6-8行为外部查询，9-13行为子查询，关联部位在子查询中第12行的filter。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/220305.png" alt="image.png"></p>
<p>这个算子的输出等价于一种iterative的执行的结果。也就将左子树的每一行关联列的值带入到右子树中进行计算并返回一行结果。有些类似将子查询看成一个user defined  function（udf），外部查询的关联列的值作为这个udf的输入参数。需要注意的是，我们需要子查询是确定的，也就是对同样值的关联列，每次运行子查询返回的结果应该是确定的。</p>
<p>在上图的栗子中，如果外部查询有一行的p.partkey的值为25，那么这一行对应的correlatedjoin的输出就是下面这个查询的结果：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- p.partkey = 25 时对应的子查询为</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">0.2</span> <span class="operator">*</span> <span class="built_in">Avg</span>(l2.quantity) </span><br><span class="line"><span class="keyword">FROM</span>   lineitem l2</span><br><span class="line"><span class="keyword">WHERE</span>  l2.partkey <span class="operator">=</span> <span class="number">25</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/220332.png" alt="image.png"><br><img data-src="https://xuemingde.com/pages/image/2022/03/220355.png" alt="image.png"></p>
<p>需要注意的是，如果计算结果为空集，则返回一行null。而如果运行中子查询返回了超过一行的结果，应该报运行时错误。在逻辑计划里，用enforcesinglerow这个node来约束。</p>
<p>从上面的介绍中可以发现，CorrelatedJoin这个算子打破了以往对逻辑树自上而下的执行模式。普通的逻辑树都是从叶子节点往根结点执行的，但是CorreltedJoin的右子树会被带入左子树的行的值反复的执行。</p>
<p>correlatedjoinnode的输出就是在外部查询的结果上增加了一列，但是可以看到这种iterative的执行方式的复杂度和将外部查询和子查询关联产生之前的那部分树进行cross join的复杂度相同。</p>
<p>同时，这样iterative的执行方式对分布式数据库系统来说是很大的挑战。因为需要修改执行时调度的逻辑。而且我们可以看到，这样的执行方式如果不进行结果的缓存，会进行很多重复结果的计算。</p>
<p>传统的优化器的优化规则没有特别的针对Correlatedjoin  node进行处理，为了支持关联子查询的这种iterative的形式，在优化器初始阶段就会把Correlatedjoin进行等价转换，转换过后的逻辑树用join，aggregation等普通算子来进行关联子查询结果的计算。这个过程被称为解关联（decorrelation/unnesting）。下面一章我们主要介绍常见的解关联的方式。</p>
<h3 id="二-常见的解关联方式"><a href="#二-常见的解关联方式" class="headerlink" title="二  常见的解关联方式"></a>二  常见的解关联方式</h3><p>为了方便起见，我们在这一章只讨论scalar关联子查询，就是会输出一列值的关联子查询。</p>
<p>在讨论如何解关联之前，我们总结一下关联子查询的输出有以下特点：</p>
<ul>
<li>correlated join算子的计算结果为在外部查询上增加一列。</li>
<li>增加的那一列的结果为将外部查询关联列的值带入子查询计算得出的。当计算结果超过一行则报错，计算结果为空则补充null。</li>
<li>不同于join算子，correlated join不改变外部查询的其他列（不少行也不膨胀）。</li>
</ul>
<p>解开关联的关键在于使得子查询获得对应的外部查询的行的值。</p>
<p>表现在计划上，就是将correleted join算子向右下推到产生关联的部位的下面。当correlated join算子的左右子树没有关联列的时候，correlated  join算子就可以转换成join算子。这样子查询就通过和外部查询join的方式获得了关联列的值，从而可以自上而下计算，回到原本的计算方式。如下图，下图中rest subquery为在关联产生部位之前的子查询部分。当correlated join 推到产生关联的部位之下，就可以转换为普通的join了。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/220408.png" alt="image.png"></p>
<p>correlated join推过的那些算子都是需要进行改写，以保持等价性（上图的栗子中subquery变为了subquery’）。</p>
<h4 id="1-下推规则"><a href="#1-下推规则" class="headerlink" title="1  下推规则"></a>1  下推规则</h4><p>论文Orthogonal Optimization of Subqueries and Aggregation[2]给出了将correlatedjoin<em>算子下推到其他算子（filter，project，aggregation，union 等）下面的的等价转换规则。但是文中的correlatedjoin</em>算子是会过滤外部查询的行数的，类似于inner join（论文中称为  ）。我们这里讨论更加general的类似于left join的 correlatedjoin (论文中称为  )，并讨论如果要保证外部查询行数不被过滤需要做哪些改写。</p>
<p>由于篇幅限制，下面我们只介绍下推到filter，project，aggregation算子下面的等价规则。</p>
<p>为了简单起见，我们在逻辑树中去掉了enforcesinglerow。</p>
<p><strong>转换1  无关联时转换为join</strong></p>
<p>回顾前文所说，correlated join算子的左子树为input，右子树为subquery。当correlated join的左右子树没有关联的时候，这个时候对外部查询的每一行，子查询的结果都是相同的。</p>
<p>我们就可以把correlated join转换成普通的没有join criteria的leftjoin算子。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/220414.png" alt="image.png"></p>
<blockquote>
<p>注：需要在subquery上添加enforcesinglerow来保证join语义和correlatedjoin相同（不会造成input的膨胀）。</p>
</blockquote>
<p><strong>转换2  简单关联条件时转换为join</strong></p>
<p>当correlated join右子树中最上面的节点为一个关联filter而他的下面无关联时，可以直接将这个filter放到left join的条件中，也可以理解为filter上提。如下图：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/220447.png" alt="image.png"></p>
<p><strong>转换3  下推穿过filter</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/220456.png" alt="image.png"></p>
<p>论文中correlatedjoin*可以直接推过filter。如果需要下推的为correlatedjoin，则需要对filter进行改写，改写成带有case when的project。当subquery的行不满足filter的条件时应输出null。</p>
<p><strong>转换4  下推穿过project</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/220503.png" alt="image.png"></p>
<p>correlated join下推过project，需要在project中添加input的输出列。</p>
<p><strong>转换5 下推穿过aggregation</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/220512.png" alt="image.png"></p>
<p>correlated join下推到带有group by的aggregation时，需要对aggregation进行改写。</p>
<p>改写为在aggregation的group by的列中增加外部查询的全部列。这里要求外部查询一定有key，如果没有则需要生成临时的key。生成可以的算子在图中为assignuniqueid算子。</p>
<p>如果aggregation为全局的，那么还需要进行额外的处理。如下图：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/220518.png" alt="image.png"></p>
<p>correlated join下推到全局aggregation的时候，需要对aggregation增加input的列(以及key)作为group  by的列。这个下推规则还需要一个前提，那就是aggregation函数需要满足满足特性 agg(Ø)=agg(null)  。这个的意思就是aggragtion函数需要对空集和对null的计算结果是相同的。</p>
<blockquote>
<p>注：在mysql和AnalyticDB for MySQL（阿里云自研的云原生数据仓库[1]，兼容mysql语法，下文简称ADB）的语法里，sum,  avg等都不满足这个特性。空集的平均值为0,  而对包含null值的任意集合取平均值结果为null不为0。所以需要mark子查询里的每一行，对空集进行特别的处理，在这里就不展开解释了。</p>
</blockquote>
<p>论文Orthogonal Optimization of Subqueries and Aggregation[2]反复运用上面这些规则进行correlatedjoin的下推，直到correlatedjoin可以转换为普通的join。</p>
<p>带入之前的tpch q17的栗子中，我们先使用将correlated join推到子查询中的project下面，查询变为：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/220546.png" alt="image.png"></p>
<p>然后下推穿过这个agg，并改写这个agg，如下图：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/220554.png" alt="image.png"></p>
<p>这里我们忽略 avg(Ø)!=avg(null) 。如果考虑这个情况，则需要mark子查询全部的行，在correlated  join之后根据子查询的结果结合mark的值对空集进行特别处理（将mark了的行的值从null变为0）。感兴趣的读者可以参考下一张中q17的最终计划。</p>
<p>接着直接调用之前的规则2，上提这个filter。这样这个查询就变为普通的没有关联的查询了。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/220602.png" alt="image.png"></p>
<h4 id="2-结果复用"><a href="#2-结果复用" class="headerlink" title="2  结果复用"></a>2  结果复用</h4><p>回顾上一节所说，子查询的查询结果是带入每一行关联列的值之后计算得出的，那么显而易见相同值的关联列带入子查询中计算出的结果是完全相同的。在上面的栗子中，对同样的p.partkey，correlatedjoin输出的子查询的结果是相等的。如下图中外部查询partkey为25的话产生的关联子查询时是完全相同的，那么结果也自然相同。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/220607.png" alt="image.png"></p>
<p>15年Newmann的论文Unnesting Arbitrary Queries[3]介绍了一种方法就是先对外部查询里关联列取distinct，再将correlated join返回的值和原本的外部查询根据关联列进行left join，如下图所示：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/220616.png" alt="image.png"></p>
<p>这里的not distinct join的条件对应mysql里面的&lt;=&gt;，null&lt;=&gt;null的结果为true，是可以join到一起的。</p>
<p>带入到之前的例子中如下图所示，对外部查询的关联列partkey先进行distinct，然后带入子查询计算结果，最后再通过join将对应的结果接到原本的外部查询上。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/220622.png" alt="image.png"></p>
<p>如果进行了上述转换，那么我们可以认为新的input的关联列永远是distinct的。而现在的correlatedjoin*算子可以允许input的列被过滤。这样做的好处除了对于相同的列不进行重复的子查询的计算之外，主要还有下面两个：</p>
<ul>
<li>新的外部查询是永远有key的，因为distinct过了。</li>
<li>correlatedjoin*算子由于过滤外部查询的列，所以它的下推更为简单（不需要assignuniqueid，不需要保留全部行）。</li>
</ul>
<p>进行上述的转换后，紧接着再套用之前的等价下推规则，我们又可以将correlatedjoin*下推到一个左右子树没有关联的地方，从而改写为inner join。</p>
<p>如果按照Unnesting Arbitrary  Queries[3]的方法进行解关联，需要将input的一部分结果进行复用，这个复用需要执行引擎的支持。需要注意的是，当系统不支持复用的时候，我们需要执行两次input的子树（如下图），这个时候就需要input这颗子树的结果是deterministic的，否则无法用这个方法进行解关联。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/220632.png" alt="image.png"></p>
<h3 id="三-关联子查询的优化"><a href="#三-关联子查询的优化" class="headerlink" title="三  关联子查询的优化"></a>三  关联子查询的优化</h3><p>在ADB的优化器中，逻辑计划会根据每一条转换规则进行匹配和转换，也就意味着在关联解开之后不需要关心解关联产生的计划的效率而将它直接交给后续的优化规则。但是现实并不是那么的美好，因为后续规则不够完备，以及解关联之后丢失了外部查询和子查询之间的关系，我们希望在解关联的时候就将计划尽可能优化。</p>
<h4 id="1-exists-in-filter关联子查询"><a href="#1-exists-in-filter关联子查询" class="headerlink" title="1  exists/in/filter关联子查询"></a>1  exists/in/filter关联子查询</h4><p>在之前的章节中为了简化，我们只讨论了scalar子查询。因为exists/in这些子查询都可以改写成scalar子查询。比如将exists改写为count(*) &gt; 0</p>
<p>但是可以看到，如果子查询的返回结果被用来过滤外部查询的行，实际上会简化整个解关联的过程。所以我们对exists/in这样的子查询进行特殊处理，在语法解析时就进行区分。在解关联的过程中，如果可以使用semijoin/antijoin算子进行解关联则直接解开关联，否则后续会转化成scalar子查询也就是correlatedjoin的形式。</p>
<h4 id="2-关联条件的上提"><a href="#2-关联条件的上提" class="headerlink" title="2  关联条件的上提"></a>2  关联条件的上提</h4><p>看到这里会发现，随着correlatedjoin的下推，这个逻辑树会变得更加复杂，所以我们在下推之前会在子查询内部进行关联算子的上提。当这个逻辑就是产生关联的算子越高，correlatedjoin就可以早点推到关联部位的下面。比如下面这个查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> t1.c2</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  t1</span><br><span class="line"><span class="keyword">WHERE</span> t1.c2 <span class="operator">&lt;</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="number">0.2</span> <span class="operator">*</span> <span class="built_in">max</span>(t2.x)</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">      t2</span><br><span class="line">    <span class="keyword">WHERE</span> t2.c1 <span class="operator">=</span> t2.c1</span><br><span class="line">    <span class="keyword">GROUP</span> <span class="keyword">BY</span> t2.c1</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>
<p>这里由于t2.c1 = t2.c1可以推到agg 上面(因为对于子查询这是一个在group  by列上的条件)，我们就可以进行下面的转换。先把关联的filter上提（有时需要改写），这样就只要把correlatedjoin推过filter，调用转换2就可以了。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/220655.png" alt="image.png"></p>
<p>更具体的例子就是前文提到的tpch q17。这里的scalar子查询作用在过滤条件中的情况也可以进行进一步改写。</p>
<p>下图为按照之前说的理论下推correlated join并改写为left join之后的逻辑计划。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/220701.png" alt="image.png"><br><img data-src="https://xuemingde.com/pages/image/2022/03/220710.png" alt="image.png"><br><img data-src="https://xuemingde.com/pages/image/2022/03/220717.png" alt="image.png"></p>
<p>而由于这个scalar子查询是作为filter条件的，这种情况下子查询没有结果返回为null对应的外部查询是一定会被过滤掉的。所以correlatedjoin可以直接转为 correlatedjoin*，再加上将filter进行上提，我们可以得到下面的计划。这样改写的好处是可以在join前先进行agg(early agg)。坏处就是如果不小心处理，很容易造成语义不等价造成count bug。</p>
<h4 id="3-代价相关的子查询优化"><a href="#3-代价相关的子查询优化" class="headerlink" title="3  代价相关的子查询优化"></a>3  代价相关的子查询优化</h4><p><strong>利用window算子解关联</strong></p>
<p>回顾到目前为止我们讲的这些，是不是印象最深刻的在于correlatedjoin算子是在外部查询上增加一列。而他的这个行为和window算子类似。window算子的语义就是不改变输入的行数，只是在每一行上增加一个在window的frame里计算出的值。所以我们可以利用window算子进行解关联，如果感兴趣可以参考这两篇论文Enhanced Subquery Optimizations in Oracle[4]和 WinMagic : Subquery Elimination  Using Window Aggregation[5]。</p>
<p>window解关联的改写就是在外部查询包含子查询中全部的表和条件时，可以直接使用window将子查询的结果拼接到外部查询上。他好处是节约了很多tablescan。比如说tpch q2。可以进行下面的改写：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/220722.png" alt="image.png"></p>
<p>这里之所能改写成window是因为外部查询包含了内部查询全部的表和条件。而且agg函数min也满足特性agg(Ø)=agg(null) （如果不满足，需要对行进行mark以及用case when 改写输出）。</p>
<p>可以看到改写后tablescan的数量大大减少。更进一步，优化器后面的优化规则会进行根据primarykey的信息以及agg函数的特性进行join 和 window的顺序交换从而进一步减少window算子输入的数据量（filter-join pushdown）。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/220729.png" alt="image.png"></p>
<p>这些好处很多文章里都说了。我们在这里讨论一下这样改写的不好的地方：</p>
<ul>
<li>比如在pk未能显示提供/agg的函数对duplicates敏感的情况下，window算子会阻挡filter-join的下推，从而打断了joingraph造成join的中间结果变大。</li>
<li>如果改写为两棵子树的join，filter-join可以下推到其中一颗子树上。而进行window改写后，filter-join无法下推。</li>
<li>在pipeline的执行模型下/&amp;使用cte的情况下，扫表获得的收益有限。</li>
<li>传统优化器对join&amp;agg的优化处理/优化规则比对window好/丰富很多。</li>
</ul>
<p>综上所述，什么时候使用window进行改写关联子查询需要进行收益和代价的估计。</p>
<p><strong>CorrelatedJoin在外部查询中的下推</strong></p>
<p>在将correlatedJoin往子查询方向下推之前，我们会将correlatedjoin先在外部查询中进行下推(比如推过cross join等)。</p>
<p>这样做是因为correlatedJoin永远不会造成数据的膨胀，所以理论上应该早点做。但实际上correlatejoin下推后也可能切割joingraph，从而造成和window改写差不多的问题。</p>
<h4 id="4-等价列的利用"><a href="#4-等价列的利用" class="headerlink" title="4  等价列的利用"></a>4  等价列的利用</h4><p>如果在子查询中存在和外部等价的列，那么可以先用这个列改写子查询中的关联列减少关联的地方从而简化查询。下面举一个简单的例子。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> t1.c2</span><br><span class="line"><span class="keyword">From</span></span><br><span class="line">  t1</span><br><span class="line"><span class="keyword">Where</span></span><br><span class="line">  t1.c3 <span class="operator">&lt;</span> (</span><br><span class="line">    <span class="keyword">Select</span> <span class="built_in">min</span>(t2.c3)</span><br><span class="line">    <span class="keyword">From</span> t2</span><br><span class="line">    <span class="keyword">Where</span> t1.c1 <span class="operator">=</span> t2.c1</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> t1.c1</span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line"><span class="comment">-- 在子查询中使用t2.c1 代替 t1.ct进行简化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Select</span> t1.c2</span><br><span class="line"><span class="keyword">From</span></span><br><span class="line">  t1</span><br><span class="line"><span class="keyword">Where</span></span><br><span class="line">  t1.c3 <span class="operator">&lt;</span> (</span><br><span class="line">    <span class="keyword">Select</span> <span class="built_in">min</span>(t2.c3)</span><br><span class="line">    <span class="keyword">From</span> t2</span><br><span class="line">    <span class="keyword">Where</span> t1.c1 <span class="operator">=</span> t2.c1</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> t2.c1</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<h4 id="5-子查询相关的优化规则"><a href="#5-子查询相关的优化规则" class="headerlink" title="5  子查询相关的优化规则"></a>5  子查询相关的优化规则</h4><p>一个方面correaltedjoin这个算子的特性给了我们一些进行优化的信息。下面举一些例子：</p>
<ol>
<li>经过correaltedjoin算子之后的行数与左子树的行数相同。</li>
<li>enforcesinglerow的输出为1行。</li>
<li>外部查询的关联列决定(function dependency)correaltedjoin的新增的输出列。</li>
<li>assignuniqueid产生的key具备unique的属性等，可用于之后化简aggregation和group by等。</li>
<li>子查询里的sort可以被裁剪。</li>
</ol>
<p>另一个方面，在子查询的改写中，可以通过属性推导进行子查询的化简。比如：</p>
<ol>
<li>如果原本外部查询就是unique的则没有别要增加uniqueid列。</li>
<li>enforcesinglerow的子节点的输出如果永远为1行则可以进行裁剪。</li>
<li>关联列在project上的子查询，如下图，在一些情况下改写为exists子查询。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> t1.orderkey,</span><br><span class="line">  (</span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">      <span class="built_in">min</span>(t1.orderkey)</span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">      orders t2</span><br><span class="line">    <span class="keyword">where</span></span><br><span class="line">      t2.orderkey <span class="operator">&gt;</span> t1.orderkey</span><br><span class="line">  )</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  orders t1</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">  <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h4 id="6-需要注意的地方"><a href="#6-需要注意的地方" class="headerlink" title="6  需要注意的地方"></a>6  需要注意的地方</h4><p>子查询解关联中最需要注意的地方就是两个地方，一个是确保仅对外部查询进行加一列的操作，一个是对null值的处理。</p>
<p><strong>计数错误</strong></p>
<p>文献中常提到的是一个经典的解关联容易出错的地方。比如下面的查询，我们有一个前提条件就是t1.c3全都是小于0的。在这个情况下子查询参与的关联条件应该是没有任何过滤度的。而改写成inner join则会过滤掉一些行。语义上是不等价的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> t1.c2</span><br><span class="line"><span class="keyword">From</span></span><br><span class="line">  t1</span><br><span class="line"><span class="keyword">Where</span></span><br><span class="line">  t1.c3 <span class="operator">&lt;</span> (</span><br><span class="line">    <span class="keyword">Select</span> <span class="built_in">COUNT</span> (<span class="operator">*</span>)</span><br><span class="line">    <span class="keyword">From</span> t2</span><br><span class="line">    <span class="keyword">Where</span> t1.c1 <span class="operator">=</span> t2.c1</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p><strong>分布式下的leftmarkjoin</strong></p>
<p>另一个容易出错的地方是论文Unnesting Arbitrary Queries[3]中的LeftMarkJoin，其输出的结果与in的语义相同。简单来说就是下面这个查询的结果。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> t1.c1 </span><br><span class="line">    <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">select</span></span><br><span class="line">      t2.c1</span><br><span class="line">    <span class="keyword">from</span></span><br><span class="line">      t2)</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">  t1</span><br></pre></td></tr></table></figure>
<p>这个查询对应的逻辑计划如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/220752.png" alt="image.png"></p>
<p>其输出结果为在左子树结果上加一列in的结果，in的结果有三种可能true,false和null。</p>
<p>在分布式环境下，对这个算子进行repartition和落盘很容易造成和null值相关的计算出错。</p>
<p>举一个简单的例子，当leftmarkjoin为repartition的执行方式时，会对左表和右表的数据根据c1的hash值进行重分布reshuffle。那么t1.c1中为null的行会被shuffle到同一台executor上。这个时候假如右表没有数据被shuffle到这台机器上，那么这一台executor并不知道对于null的这些行该输出null还是false。因为null in空集的结果为false，而null in 任何非空集合的结果为null。此时这台executor并不知道右表是否为空。</p>
<p><strong>解开关联后的效率</strong></p>
<p>在最开始的时候我们提到了iterative的执行方式，这里我们需要说明对有些关联子查询来说即使关联被解开为join/agg等算子，计算查询结果也需要一个cross join的代价。</p>
<p>比如下面这个两个查询， 第一个是我们常见的关联子查询的样子，可以转换成inner join + early agg的形式。而第二个解开关联后则会变成一个left join on非等值条件（代价同cross join）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- sql 1</span></span><br><span class="line"><span class="keyword">SELECT</span> t1.c1</span><br><span class="line">  <span class="keyword">FROM</span> t1</span><br><span class="line"> <span class="keyword">WHERE</span> t1.c2 <span class="operator">&gt;</span> ( </span><br><span class="line">   <span class="keyword">SELECT</span> <span class="built_in">min</span>(t2.c2) </span><br><span class="line">     <span class="keyword">FROM</span> t2 </span><br><span class="line">    <span class="keyword">WHERE</span> t2.c1 <span class="operator">=</span> t1.c1</span><br><span class="line">   );</span><br><span class="line"></span><br><span class="line"><span class="comment">-- sql 2</span></span><br><span class="line"><span class="keyword">SELECT</span> t1.c1</span><br><span class="line">  <span class="keyword">FROM</span> t1</span><br><span class="line"> <span class="keyword">WHERE</span> t1.c2 <span class="operator">&gt;</span> ( </span><br><span class="line">   <span class="keyword">SELECT</span> <span class="built_in">min</span>(t2.c2) </span><br><span class="line">     <span class="keyword">FROM</span> t2 </span><br><span class="line">    <span class="keyword">WHERE</span> t2.c1 <span class="operator">&gt;</span> t1.c1</span><br><span class="line">   );</span><br></pre></td></tr></table></figure>
<p>sq1解开关联后的计划如下：<br><img data-src="https://xuemingde.com/pages/image/2022/03/220813.png" alt="image.png"></p>
<p>sql2解开关联后的计划如下：<br><img data-src="https://xuemingde.com/pages/image/2022/03/220828.png" alt="image.png"></p>
<p>对于sql1来说，从语义上理解，外部查询的每一行带入子查询里扫过的行都是没有重叠的，所以代价和innerjoin on等值条件是一样的。再加上同样的外部行对应的子查询中min的结果相同可以应用early agg从而可以进一步优化。</p>
<p>对于sql2来说，从语义上理解，外部查询的每一行都必须要带入子查询中扫过所有的行才能判断在满足t2.c1 &gt;  t1.c1这个条件下的子查询的输出应该是什么。为了计算出结果这个代价是无法通过优化节约的。但是对同样的t1.c1输出始终是相同的，Unnesting Arbitrary Queries[3]中的结果复用仍然可以产生优化。</p>
<blockquote>
<p>参考文献<br>[1] <span class="exturl" data-url="aHR0cHM6Ly93d3cuYWxpeXVuLmNvbS9wcm9kdWN0L0Fwc2FyYURCL2Fkcw==">https://www.aliyun.com/product/ApsaraDB/ads<i class="fa fa-external-link-alt"></i></span><br>[2] Galindo-Legaria，César和Milind Joshi。“子查询和聚合的正交优化。” ACM SIGMOD记录30.2（2001）：571-581。<br>[3] Neumann，Thomas和Alfons Kemper。“取消嵌套任意查询。” 商业，技术和网络数据库系统（BTW 2015）（2015年）。<br>[4]贝拉姆康达（Bellamkonda），斯里坎特（Srikanth）等。“增强了Oracle中的子查询优化。” VLDB基金会论文集2.2（2009）：1366-1377<br>[5] Zuzarte，Calisto等人。“ Winmagic：使用窗口聚合消除子查询。” 2003 ACM SIGMOD国际数据管理国际会议论文集。2003。<br>[6] Neumann，Thomas，Viktor Leis和Alfons Kemper。“联接的完整故事（inHyPer）。” 商业，技术和网络数据库系统（BTW 2017）（2017）。<br>[7]加利福尼亚州加林多-莱加里亚（Galindo-Legaria），参数化查询和嵌套等效项。技术报告，Microsoft，2001年。MSR-TR-2000-31，2000年。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>bug</tag>
        <tag>sql</tag>
        <tag>集合</tag>
        <tag>数据库</tag>
        <tag>函数</tag>
        <tag>全局</tag>
        <tag>Mysql</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>MybatisPlus自动生成主键策略</title>
    <url>/posts/9P9EMN.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img data-src="https://xuemingde.com/pages/image/others/1617185015632-98ebebc3-0fc9-4502-aa98-2ba9ee508b26.png" alt="image.png"></p>
<p><img data-src="https://xuemingde.com/pages/image/others/1617185033768-20f85bfc-7299-4260-bbb4-b9978e341d78.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>框架</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring系列(上)</title>
    <url>/posts/DE2A8E.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在线查看：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYWxpeXVuZHJpdmUuY29tL3MvR1h6cURLQUV3Qm4=">阿里云盘<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring系列(下)</title>
    <url>/posts/1ZM62F.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在线查看：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYWxpeXVuZHJpdmUuY29tL3MvOHEyam1uMU1QcVk=">阿里云盘<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>spring是如何解决循环依赖的</title>
    <url>/posts/2SH00H4.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>原文：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvVE01VFhWSDZjUTQyTS1VaWt2bE5nZw==">spring：我是如何解决循环依赖的？<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>最近项目组的一个同事遇到了一个问题，问我的意见，一下子引起的我的兴趣，因为这个问题我也是第一次遇到。平时自认为对spring循环依赖问题还是比较了解的，直到遇到这个和后面的几个问题后，重新刷新了我的认识。</p>
<p>我们先看看当时出问题的代码片段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestService2 testService2;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestService1 testService1;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两段代码中定义了两个Service类：<code>TestService1</code>和<code>TestService2</code>，在TestService1中注入了TestService2的实例，同时在TestService2中注入了TestService1的实例，这里构成了<code>循环依赖</code>。</p>
<p>只不过，这不是普通的循环依赖，因为TestService1的test1方法上加了一个<code>@Async</code>注解。</p>
<p>大家猜猜程序启动后运行结果会怎样？</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean <span class="keyword">with</span> name <span class="string">&#x27;testService1&#x27;</span>: Bean <span class="keyword">with</span> name <span class="string">&#x27;testService1&#x27;</span> has been injected <span class="keyword">into</span> other beans [testService2] <span class="keyword">in</span> its raw <span class="built_in">version</span> <span class="keyword">as</span> part <span class="keyword">of</span> <span class="keyword">a</span> circular reference, but has eventually been wrapped. This means that said other beans <span class="built_in">do</span> <span class="keyword">not</span> use <span class="keyword">the</span> final <span class="built_in">version</span> <span class="keyword">of</span> <span class="keyword">the</span> bean. This is often <span class="keyword">the</span> <span class="built_in">result</span> <span class="keyword">of</span> over-eager type matching - consider <span class="keyword">using</span> <span class="string">&#x27;getBeanNamesOfType&#x27;</span> <span class="keyword">with</span> <span class="keyword">the</span> <span class="string">&#x27;allowEagerInit&#x27;</span> flag turned off, <span class="keyword">for</span> example.</span><br></pre></td></tr></table></figure>
<p>报错了。。。原因是出现了循环依赖。</p>
<p><strong>「不科学呀，spring不是号称能解决循环依赖问题吗，怎么还会出现？」</strong></p>
<p>如果把上面的代码稍微调整一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestService2 testService2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把TestService1的test1方法上的<code>@Async</code>注解去掉，<code>TestService1</code>和<code>TestService2</code>都需要注入对方的实例，同样构成了循环依赖。</p>
<p>但是重新启动项目，发现它能够正常运行。这又是为什么？</p>
<p>带着这两个问题，让我们一起开始spring循环依赖的探秘之旅。</p>
<h2 id="什么是循环依赖"><a href="#什么是循环依赖" class="headerlink" title="什么是循环依赖"></a>什么是循环依赖</h2><p>循环依赖：说白是一个或多个对象实例之间存在直接或间接的依赖关系，这种依赖关系构成了构成一个环形调用。</p>
<p>第一种情况：自己依赖自己的直接依赖</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/18/1018-nsvnDY.png" alt="图片"></p>
<p>第二种情况：两个对象之间的直接依赖</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/18/1018-P6klxc.png" alt="图片"></p>
<p>第三种情况：多个对象之间的间接依赖</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/18/1018-4pepnI.png" alt="图片"></p>
<p>前面两种情况的直接循环依赖比较直观，非常好识别，但是第三种间接循环依赖的情况有时候因为业务代码调用层级很深，不容易识别出来。</p>
<h2 id="循环依赖的N种场景"><a href="#循环依赖的N种场景" class="headerlink" title="循环依赖的N种场景"></a>循环依赖的N种场景</h2><p>spring中出现循环依赖主要有以下场景：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/18/1020-ABmjjy.png" alt="图片"></p>
<h3 id="单例的setter注入"><a href="#单例的setter注入" class="headerlink" title="单例的setter注入"></a>单例的setter注入</h3><p>这种注入方式应该是spring用的最多的，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestService2 testService2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestService1 testService1;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个经典的循环依赖，但是它能正常运行，得益于spring的内部机制，让我们根本无法感知它有问题，因为spring默默帮我们解决了。</p>
<p>spring内部有三级缓存：</p>
<ul>
<li>singletonObjects 一级缓存，用于保存实例化、注入、初始化完成的bean实例</li>
<li>earlySingletonObjects 二级缓存，用于保存实例化完成的bean实例</li>
<li>singletonFactories 三级缓存，用于保存bean创建工厂，以便于后面扩展有机会创建代理对象。</li>
</ul>
<p>下面用一张图告诉你，spring是如何解决循环依赖的：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/18/1021-HKc286.png" alt="图片"></p>
<p>​              图1</p>
<p>细心的朋友可能会发现在这种场景中第二级缓存作用不大。</p>
<p>那么问题来了，为什么要用第二级缓存呢？</p>
<p>试想一下，如果出现以下这种情况，我们要如何处理？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestService2 testService2;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestService3 testService3;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestService1 testService1;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestService1 testService1;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TestService1依赖于TestService2和TestService3，而TestService2依赖于TestService1，同时TestService3也依赖于TestService1。</p>
<p>按照上图的流程可以把TestService1注入到TestService2，并且TestService1的实例是从第三级缓存中获取的。</p>
<p>假设不用第二级缓存，TestService1注入到TestService3的流程如图：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/18/1103-WHZRkd.jpg" alt=""></p>
<p>​             </p>
<p>TestService1注入到TestService3又需要从第三级缓存中获取实例，而第三级缓存里保存的并非真正的实例对象，而是<code>ObjectFactory</code>对象。说白了，两次从三级缓存中获取都是<code>ObjectFactory</code>对象，而通过它创建的实例对象每次可能都不一样的。</p>
<p>这样不是有问题？</p>
<p>为了解决这个问题，spring引入的第二级缓存。上面图1其实TestService1对象的实例已经被添加到第二级缓存中了，而在TestService1注入到TestService3时，只用从第二级缓存中获取该对象即可。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/18/1022-gMDDPq.png" alt="图片"></p>
<p>​             </p>
<p>还有个问题，第三级缓存中为什么要添加<code>ObjectFactory</code>对象，直接保存实例对象不行吗？</p>
<p>答：不行，因为假如你想对添加到三级缓存中的实例对象进行增强，直接用实例对象是行不通的。</p>
<p>针对这种场景spring是怎么做的呢？</p>
<p>答案就在<code>AbstractAutowireCapableBeanFactory</code>类<code>doCreateBean</code>方法的这段代码中：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/18/1021-Bp2Wqp.png" alt="图片">它定义了一个匿名内部类，通过<code>getEarlyBeanReference</code>方法获取代理对象，其实底层是通过<code>AbstractAutoProxyCreator</code>类的<code>getEarlyBeanReference</code>生成代理对象。</p>
<h3 id="多例的setter注入"><a href="#多例的setter注入" class="headerlink" title="多例的setter注入"></a>多例的setter注入</h3><p>这种注入方法偶然会有，特别是在多线程的场景下，具体代码如下：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@Scope</span>(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line"><span class="variable">@Service</span></span><br><span class="line">public class TestService1 &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Autowired</span></span><br><span class="line">    private TestService2 testService2;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">test1</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">@Scope</span>(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line"><span class="variable">@Service</span></span><br><span class="line">public class TestService2 &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Autowired</span></span><br><span class="line">    private TestService1 testService1;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">test2</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很多人说这种情况spring容器启动会报错，其实是不对的，我非常负责任的告诉你程序能够正常启动。</p>
<p>为什么呢？</p>
<p>其实在<code>AbstractApplicationContext</code>类的<code>refresh</code>方法中告诉了我们答案，它会调用<code>finishBeanFactoryInitialization</code>方法，该方法的作用是为了spring容器启动的时候提前初始化一些bean。该方法的内部又调用了<code>preInstantiateSingletons</code>方法</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/18/1023-h6giqf.png" alt="图片">标红的地方明显能够看出：非抽象、单例 并且非懒加载的类才能被提前初始bean。</p>
<p>而多例即<code>SCOPE_PROTOTYPE</code>类型的类，非单例，不会被提前初始化bean，所以程序能够正常启动。</p>
<p>如何让他提前初始化bean呢？</p>
<p>只需要再定义一个单例的类，在它里面注入TestService1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestService1 testService1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新启动程序，执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Requested bean is currently in creation: Is there an unresolvable circular reference?</span><br></pre></td></tr></table></figure>
<p>果然出现了循环依赖。</p>
<p>注意：这种循环依赖问题是无法解决的，因为它没有用缓存，每次都会生成一个新对象。</p>
<h3 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h3><p>这种注入方式现在其实用的已经非常少了，但是我们还是有必要了解一下，看看如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestService1</span><span class="params">(TestService2 testService2)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestService2</span><span class="params">(TestService1 testService1)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><span class="line">Requested bean <span class="keyword">is</span> currently <span class="keyword">in</span> creation: <span class="keyword">Is</span> there an unresolvable circular <span class="keyword">reference</span>?</span><br></pre></td></tr></table></figure>
<p>出现了循环依赖，为什么呢？</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/18/1025-bR1zAK.png" alt="图片"></p>
<p>从图中的流程看出构造器注入没能添加到三级缓存，也没有使用缓存，所以也无法解决循环依赖问题。</p>
<h3 id="单例的代理对象setter注入"><a href="#单例的代理对象setter注入" class="headerlink" title="单例的代理对象setter注入"></a>单例的代理对象setter注入</h3><p>这种注入方式其实也比较常用，比如平时使用：<code>@Async</code>注解的场景，会通过<code>AOP</code>自动生成代理对象。</p>
<p>我那位同事的问题也是这种情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestService2 testService2;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestService1 testService1;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从前面得知程序启动会报错，出现了循环依赖：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean <span class="keyword">with</span> name <span class="string">&#x27;testService1&#x27;</span>: Bean <span class="keyword">with</span> name <span class="string">&#x27;testService1&#x27;</span> has been injected <span class="keyword">into</span> other beans [testService2] <span class="keyword">in</span> its raw <span class="built_in">version</span> <span class="keyword">as</span> part <span class="keyword">of</span> <span class="keyword">a</span> circular reference, but has eventually been wrapped. This means that said other beans <span class="built_in">do</span> <span class="keyword">not</span> use <span class="keyword">the</span> final <span class="built_in">version</span> <span class="keyword">of</span> <span class="keyword">the</span> bean. This is often <span class="keyword">the</span> <span class="built_in">result</span> <span class="keyword">of</span> over-eager type matching - consider <span class="keyword">using</span> <span class="string">&#x27;getBeanNamesOfType&#x27;</span> <span class="keyword">with</span> <span class="keyword">the</span> <span class="string">&#x27;allowEagerInit&#x27;</span> flag turned off, <span class="keyword">for</span> example.</span><br></pre></td></tr></table></figure>
<p>为什么会循环依赖呢？</p>
<p>答案就在下面这张图中：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/18/1026-5g0uLD.png" alt="图片"></p>
<p>说白了，bean初始化完成之后，后面还有一步去检查：第二级缓存 和 原始对象 是否相等。由于它对前面流程来说无关紧要，所以前面的流程图中省略了，但是在这里是关键点，我们重点说说：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/18/1026-7tKNpz.png" alt="图片"></p>
<p>那位同事的问题正好是走到这段代码，发现第二级缓存 和 原始对象不相等，所以抛出了循环依赖的异常。</p>
<p>如果这时候把TestService1改个名字，改成：TestService6，其他的都不变。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line">publicclass TestService6 &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TestService2 testService2;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再重新启动一下程序，神奇般的好了。</p>
<p>what？ 这又是为什么？</p>
<p>这就要从spring的bean加载顺序说起了，默认情况下，spring是按照文件完整路径递归查找的，按路径+文件名排序，排在前面的先加载。所以TestService1比TestService2先加载，而改了文件名称之后，TestService2比TestService6先加载。</p>
<p>为什么TestService2比TestService6先加载就没问题呢？</p>
<p>答案在下面这张图中：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/18/1026-jUaYl2.png" alt="图片"></p>
<p>这种情况testService6中其实第二级缓存是空的，不需要跟原始对象判断，所以不会抛出循环依赖。</p>
<h3 id="DependsOn循环依赖"><a href="#DependsOn循环依赖" class="headerlink" title="DependsOn循环依赖"></a>DependsOn循环依赖</h3><p>还有一种有些特殊的场景，比如我们需要在实例化Bean A之前，先实例化Bean B，这个时候就可以使用<code>@DependsOn</code>注解。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="variable">@DependsOn</span>(value = <span class="string">&quot;testService2&quot;</span>)</span><br><span class="line"><span class="variable">@Service</span></span><br><span class="line">public class TestService1 &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Autowired</span></span><br><span class="line">    private TestService2 testService2;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">test1</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">@DependsOn</span>(value = <span class="string">&quot;testService1&quot;</span>)</span><br><span class="line"><span class="variable">@Service</span></span><br><span class="line">public class TestService2 &#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">@Autowired</span></span><br><span class="line">    private TestService1 testService1;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">public</span> <span class="selector-tag">void</span> <span class="selector-tag">test2</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序启动之后，执行结果：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">Circular <span class="keyword">depends</span>-<span class="keyword">on</span> relationship <span class="keyword">between</span> <span class="string">&#x27;testService2&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;testService1&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这个例子中本来如果TestService1和TestService2都没有加<code>@DependsOn</code>注解是没问题的，反而加了这个注解会出现循环依赖问题。</p>
<p>这又是为什么？</p>
<p>答案在<code>AbstractBeanFactory</code>类的<code>doGetBean</code>方法的这段代码中：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/18/1027-K1l3xz.png" alt="图片">它会检查dependsOn的实例有没有循环依赖，如果有循环依赖则抛异常。</p>
<h2 id="出现循环依赖如何解决"><a href="#出现循环依赖如何解决" class="headerlink" title="出现循环依赖如何解决"></a>出现循环依赖如何解决</h2><p>项目中如果出现循环依赖问题，说明是spring默认无法解决的循环依赖，要看项目的打印日志，属于哪种循环依赖。目前包含下面几种情况：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/18/1027-k19B41.png" alt="图片"></p>
<h3 id="生成代理对象产生的循环依赖"><a href="#生成代理对象产生的循环依赖" class="headerlink" title="生成代理对象产生的循环依赖"></a>生成代理对象产生的循环依赖</h3><p>这类循环依赖问题解决方法很多，主要有：</p>
<ol>
<li>使用<code>@Lazy</code>注解，延迟加载</li>
<li>使用<code>@DependsOn</code>注解，指定加载先后关系</li>
<li>修改文件名称，改变循环依赖类的加载顺序</li>
</ol>
<h3 id="使用-DependsOn产生的循环依赖"><a href="#使用-DependsOn产生的循环依赖" class="headerlink" title="使用@DependsOn产生的循环依赖"></a>使用@DependsOn产生的循环依赖</h3><p>这类循环依赖问题要找到<code>@DependsOn</code>注解循环依赖的地方，迫使它不循环依赖就可以解决问题。</p>
<h3 id="多例循环依赖"><a href="#多例循环依赖" class="headerlink" title="多例循环依赖"></a>多例循环依赖</h3><p>这类循环依赖问题可以通过把bean改成单例的解决。</p>
<h3 id="构造器循环依赖"><a href="#构造器循环依赖" class="headerlink" title="构造器循环依赖"></a>构造器循环依赖</h3><p>这类循环依赖问题可以通过使用<code>@Lazy</code>注解解决。</p>
]]></content>
      <categories>
        <category>框架</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>Spring</tag>
        <tag>容器</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot 内置工具类</title>
    <url>/posts/N8AQ70.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h1><p>SpringBoot 中提供了 Assert 断言工具类，通常用于数据合法性检查</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 要求参数 object 必须为非空（Not Null），否则抛出异常，不予放行</span></span><br><span class="line"><span class="comment">// 参数 message 参数用于定制异常信息。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notNull</span><span class="params">(Object object, String message)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 要求参数必须空（Null），否则抛出异常，不予『放行』。</span></span></span><br><span class="line"><span class="function"><span class="comment">// 和 notNull() 方法断言规则相反</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isNull</span><span class="params">(Object object, String message)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 要求参数必须为真（True），否则抛出异常，不予『放行』。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isTrue</span><span class="params">(<span class="keyword">boolean</span> expression, String message)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 要求参数（List/Set）必须非空（Not Empty），否则抛出异常，不予放行</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notEmpty</span><span class="params">(Collection collection, String message)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 要求参数（String）必须有长度（即，Not Empty），否则抛出异常，不予放行</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hasLength</span><span class="params">(String text, String message)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 要求参数（String）必须有内容（即，Not Blank），否则抛出异常，不予放行</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hasText</span><span class="params">(String text, String message)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 要求参数是指定类型的实例，否则抛出异常，不予放行</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isInstanceOf</span><span class="params">(Class type, Object obj, String message)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 要求参数 `subType` 必须是参数 superType 的子类或实现类，否则抛出异常，不予放行</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">isAssignable</span><span class="params">(Class superType, Class subType, String message)</span></span></span><br></pre></td></tr></table></figure>
<h1 id="对象、数组、集合"><a href="#对象、数组、集合" class="headerlink" title="对象、数组、集合"></a>对象、数组、集合</h1><h2 id="ObjectUtils"><a href="#ObjectUtils" class="headerlink" title="ObjectUtils"></a>ObjectUtils</h2><p>获取对象的基本信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取对象的类名。参数为 null 时，返回字符串：&quot;null&quot; </span></span><br><span class="line"><span class="function">String <span class="title">nullSafeClassName</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 参数为 null 时，返回 0</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nullSafeHashCode</span><span class="params">(Object object)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 参数为 null 时，返回字符串：&quot;null&quot;</span></span></span><br><span class="line"><span class="function">String <span class="title">nullSafeToString</span><span class="params">(<span class="keyword">boolean</span>[] array)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取对象 HashCode（十六进制形式字符串）。参数为 null 时，返回 0 </span></span></span><br><span class="line"><span class="function">String <span class="title">getIdentityHexString</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取对象的类名和 HashCode。 参数为 null 时，返回字符串：&quot;&quot; </span></span></span><br><span class="line"><span class="function">String <span class="title">identityToString</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 相当于 toString()方法，但参数为 null 时，返回字符串：&quot;&quot;</span></span></span><br><span class="line"><span class="function">String <span class="title">getDisplayString</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>
<p>判断工具</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断数组是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">(Object[] array)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断参数对象是否是数组</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isArray</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断数组中是否包含指定元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsElement</span><span class="params">(Object[] array, Object element)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 相等，或同为 null时，返回 true</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">nullSafeEquals</span><span class="params">(Object o1, Object o2)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment">判断参数对象是否为空，判断标准为：</span></span></span><br><span class="line"><span class="function"><span class="comment">    Optional: Optional.empty()</span></span></span><br><span class="line"><span class="function"><span class="comment">       Array: length == 0</span></span></span><br><span class="line"><span class="function"><span class="comment">CharSequence: length == 0</span></span></span><br><span class="line"><span class="function"><span class="comment">  Collection: Collection.isEmpty()</span></span></span><br><span class="line"><span class="function"><span class="comment">         Map: Map.isEmpty()</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">(Object obj)</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>
<p>其他工具方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向参数数组的末尾追加新元素，并返回一个新数组</span></span><br><span class="line">&lt;A, O extends A&gt; A[] addObjectToArray(A[] array, O obj)</span><br><span class="line"><span class="comment">// 原生基础类型数组 --&gt; 包装类数组</span></span><br><span class="line">Object[] toObjectArray(Object source)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="StringUtils"><a href="#StringUtils" class="headerlink" title="StringUtils"></a>StringUtils</h2><p>字符串判断工具</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断字符串是否为 null，或 &quot;&quot;。注意，包含空白符的字符串为非空</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">(Object str)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断字符串是否是以指定内容结束。忽略大小写</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">endsWithIgnoreCase</span><span class="params">(String str, String suffix)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断字符串是否已指定内容开头。忽略大小写</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startsWithIgnoreCase</span><span class="params">(String str, String prefix)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 是否包含空白符</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsWhitespace</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断字符串非空且长度不为 0，即，Not Empty</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasLength</span><span class="params">(CharSequence str)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断字符串是否包含实际内容，即非仅包含空白符，也就是 Not Blank</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasText</span><span class="params">(CharSequence str)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断字符串指定索引处是否包含一个子串。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">substringMatch</span><span class="params">(CharSequence str, <span class="keyword">int</span> index, CharSequence substring)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 计算一个字符串中指定子串的出现次数</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countOccurrencesOf</span><span class="params">(String str, String sub)</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>
<p>字符串操作工具</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找并替换指定子串</span></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(String inString, String oldPattern, String newPattern)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 去除尾部的特定字符</span></span></span><br><span class="line"><span class="function">String <span class="title">trimTrailingCharacter</span><span class="params">(String str, <span class="keyword">char</span> trailingCharacter)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 去除头部的特定字符</span></span></span><br><span class="line"><span class="function">String <span class="title">trimLeadingCharacter</span><span class="params">(String str, <span class="keyword">char</span> leadingCharacter)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 去除头部的空白符</span></span></span><br><span class="line"><span class="function">String <span class="title">trimLeadingWhitespace</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 去除头部的空白符</span></span></span><br><span class="line"><span class="function">String <span class="title">trimTrailingWhitespace</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 去除头部和尾部的空白符</span></span></span><br><span class="line"><span class="function">String <span class="title">trimWhitespace</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 删除开头、结尾和中间的空白符</span></span></span><br><span class="line"><span class="function">String <span class="title">trimAllWhitespace</span><span class="params">(String str)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 删除指定子串</span></span></span><br><span class="line"><span class="function">String <span class="title">delete</span><span class="params">(String inString, String pattern)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 删除指定字符（可以是多个）</span></span></span><br><span class="line"><span class="function">String <span class="title">deleteAny</span><span class="params">(String inString, String charsToDelete)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 对数组的每一项执行 trim() 方法</span></span></span><br><span class="line"><span class="function">String[] <span class="title">trimArrayElements</span><span class="params">(String[] array)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 将 URL 字符串进行解码</span></span></span><br><span class="line"><span class="function">String <span class="title">uriDecode</span><span class="params">(String source, Charset charset)</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>
<p>路径相关工具方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解析路径字符串，优化其中的 “..” </span></span><br><span class="line"><span class="function">String <span class="title">cleanPath</span><span class="params">(String path)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 解析路径字符串，解析出文件名部分</span></span></span><br><span class="line"><span class="function">String <span class="title">getFilename</span><span class="params">(String path)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 解析路径字符串，解析出文件后缀名</span></span></span><br><span class="line"><span class="function">String <span class="title">getFilenameExtension</span><span class="params">(String path)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 比较两个两个字符串，判断是否是同一个路径。会自动处理路径中的 “..” </span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">pathEquals</span><span class="params">(String path1, String path2)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 删除文件路径名中的后缀部分</span></span></span><br><span class="line"><span class="function">String <span class="title">stripFilenameExtension</span><span class="params">(String path)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 以 “. 作为分隔符，获取其最后一部分</span></span></span><br><span class="line"><span class="function">String <span class="title">unqualify</span><span class="params">(String qualifiedName)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 以指定字符作为分隔符，获取其最后一部分</span></span></span><br><span class="line"><span class="function">String <span class="title">unqualify</span><span class="params">(String qualifiedName, <span class="keyword">char</span> separator)</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>
<h2 id="CollectionUtils"><a href="#CollectionUtils" class="headerlink" title="CollectionUtils"></a>CollectionUtils</h2><p>集合判断工具</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断 List/Set 是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">(Collection&lt;?&gt; collection)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断 Map 是否为空</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">(Map&lt;?,?&gt; map)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断 List/Set 中是否包含某个对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsInstance</span><span class="params">(Collection&lt;?&gt; collection, Object element)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 以迭代器的方式，判断 List/Set 中是否包含某个对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Iterator&lt;?&gt; iterator, Object element)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断 List/Set 是否包含某些对象中的任意一个</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsAny</span><span class="params">(Collection&lt;?&gt; source, Collection&lt;?&gt; candidates)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断 List/Set 中的每个元素是否唯一。即 List/Set 中不存在重复元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasUniqueObject</span><span class="params">(Collection&lt;?&gt; collection)</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>
<p>集合操作工具</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将 Array 中的元素都添加到 List/Set 中</span></span><br><span class="line">&lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">mergeArrayIntoCollection</span><span class="params">(Object array, Collection&lt;E&gt; collection)</span>  </span></span><br><span class="line"><span class="function"><span class="comment">// 将 Properties 中的键值对都添加到 Map 中</span></span></span><br><span class="line"><span class="function">&lt;K,V&gt; <span class="keyword">void</span> <span class="title">mergePropertiesIntoMap</span><span class="params">(Properties props, Map&lt;K,V&gt; map)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回 List 中最后一个元素</span></span></span><br><span class="line"><span class="function">&lt;T&gt; T <span class="title">lastElement</span><span class="params">(List&lt;T&gt; list)</span>  </span></span><br><span class="line"><span class="function"><span class="comment">// 返回 Set 中最后一个元素</span></span></span><br><span class="line"><span class="function">&lt;T&gt; T <span class="title">lastElement</span><span class="params">(Set&lt;T&gt; set)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 返回参数 candidates 中第一个存在于参数 source 中的元素</span></span></span><br><span class="line"><span class="function">&lt;E&gt; E <span class="title">findFirstMatch</span><span class="params">(Collection&lt;?&gt; source, Collection&lt;E&gt; candidates)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回 List/Set 中指定类型的元素。</span></span></span><br><span class="line"><span class="function">&lt;T&gt; T <span class="title">findValueOfType</span><span class="params">(Collection&lt;?&gt; collection, Class&lt;T&gt; type)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回 List/Set 中指定类型的元素。如果第一种类型未找到，则查找第二种类型，以此类推</span></span></span><br><span class="line"><span class="function">Object <span class="title">findValueOfType</span><span class="params">(Collection&lt;?&gt; collection, Class&lt;?&gt;[] types)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回 List/Set 中元素的类型</span></span></span><br><span class="line"><span class="function">Class&lt;?&gt; <span class="title">findCommonElementType</span><span class="params">(Collection&lt;?&gt; collection)</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>
<h1 id="文件、资源、IO-流"><a href="#文件、资源、IO-流" class="headerlink" title="文件、资源、IO 流"></a>文件、资源、IO 流</h1><h2 id="FileCopyUtils"><a href="#FileCopyUtils" class="headerlink" title="FileCopyUtils"></a>FileCopyUtils</h2><p>输入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从文件中读入到字节数组中</span></span><br><span class="line"><span class="keyword">byte</span>[] copyToByteArray(File in)</span><br><span class="line"><span class="comment">// 从输入流中读入到字节数组中</span></span><br><span class="line"><span class="keyword">byte</span>[] copyToByteArray(InputStream in)</span><br><span class="line"><span class="comment">// 从输入流中读入到字符串中</span></span><br><span class="line"><span class="function">String <span class="title">copyToString</span><span class="params">(Reader in)</span></span></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从字节数组到文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(<span class="keyword">byte</span>[] in, File out)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从文件到文件</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy</span><span class="params">(File in, File out)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从字节数组到输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(<span class="keyword">byte</span>[] in, OutputStream out)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 从输入流到输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy</span><span class="params">(InputStream in, OutputStream out)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 从输入流到输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy</span><span class="params">(Reader in, Writer out)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从字符串到输出流</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(String in, Writer out)</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>
<h2 id="ResourceUtils"><a href="#ResourceUtils" class="headerlink" title="ResourceUtils"></a>ResourceUtils</h2><p>从资源路径获取文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断字符串是否是一个合法的 URL 字符串。</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isUrl</span><span class="params">(String resourceLocation)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获取 URL</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> URL <span class="title">getURL</span><span class="params">(String resourceLocation)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 获取文件（在 JAR 包内无法正常使用，需要是一个独立的文件）</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> File	<span class="title">getFile</span><span class="params">(String resourceLocation)</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>
<p>Resource</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件系统资源 D:\...</span></span><br><span class="line">FileSystemResource</span><br><span class="line"><span class="comment">// URL 资源，如 file://... http://...</span></span><br><span class="line">UrlResource</span><br><span class="line"><span class="comment">// 类路径下的资源，classpth:...</span></span><br><span class="line">ClassPathResource</span><br><span class="line"><span class="comment">// Web 容器上下文中的资源（jar 包、war 包）</span></span><br><span class="line">ServletContextResource</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断资源是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从资源中获得 File 对象</span></span></span><br><span class="line"><span class="function">File <span class="title">getFile</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从资源中获得 URI 对象</span></span></span><br><span class="line"><span class="function">URI <span class="title">getURI</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 从资源中获得 URI 对象</span></span></span><br><span class="line"><span class="function">URL <span class="title">getURL</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获得资源的 InputStream</span></span></span><br><span class="line"><span class="function">InputStream <span class="title">getInputStream</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 获得资源的描述信息</span></span></span><br><span class="line"><span class="function">String <span class="title">getDescription</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>
<h2 id="StreamUtils"><a href="#StreamUtils" class="headerlink" title="StreamUtils"></a>StreamUtils</h2><p>输入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(<span class="keyword">byte</span>[] in, OutputStream out)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy</span><span class="params">(InputStream in, OutputStream out)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(String in, Charset charset, OutputStream out)</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">copyRange</span><span class="params">(InputStream in, OutputStream out, <span class="keyword">long</span> start, <span class="keyword">long</span> end)</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] copyToByteArray(InputStream in)</span><br><span class="line"><span class="function">String <span class="title">copyToString</span><span class="params">(InputStream in, Charset charset)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 舍弃输入流中的内容</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">drain</span><span class="params">(InputStream in)</span> </span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>
<h1 id="反射、AOP"><a href="#反射、AOP" class="headerlink" title="反射、AOP"></a>反射、AOP</h1><h2 id="ReflectionUtils"><a href="#ReflectionUtils" class="headerlink" title="ReflectionUtils"></a>ReflectionUtils</h2><p>获取方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在类中查找指定方法</span></span><br><span class="line"><span class="function">Method <span class="title">findMethod</span><span class="params">(Class&lt;?&gt; clazz, String name)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 同上，额外提供方法参数类型作查找条件</span></span></span><br><span class="line"><span class="function">Method <span class="title">findMethod</span><span class="params">(Class&lt;?&gt; clazz, String name, Class&lt;?&gt;... paramTypes)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 获得类中所有方法，包括继承而来的</span></span></span><br><span class="line"><span class="function">Method[] <span class="title">getAllDeclaredMethods</span><span class="params">(Class&lt;?&gt; leafClass)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 在类中查找指定构造方法</span></span></span><br><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">accessibleConstructor</span><span class="params">(Class&lt;T&gt; clazz, Class&lt;?&gt;... parameterTypes)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 是否是 equals() 方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEqualsMethod</span><span class="params">(Method method)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 是否是 hashCode() 方法 </span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isHashCodeMethod</span><span class="params">(Method method)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 是否是 toString() 方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isToStringMethod</span><span class="params">(Method method)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 是否是从 Object 类继承而来的方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isObjectMethod</span><span class="params">(Method method)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 检查一个方法是否声明抛出指定异常</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">declaresException</span><span class="params">(Method method, Class&lt;?&gt; exceptionType)</span> </span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>
<p>执行方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行方法</span></span><br><span class="line"><span class="function">Object <span class="title">invokeMethod</span><span class="params">(Method method, Object target)</span>  </span></span><br><span class="line"><span class="function"><span class="comment">// 同上，提供方法参数</span></span></span><br><span class="line"><span class="function">Object <span class="title">invokeMethod</span><span class="params">(Method method, Object target, Object... args)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 取消 Java 权限检查。以便后续执行该私有方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeAccessible</span><span class="params">(Method method)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 取消 Java 权限检查。以便后续执行私有构造方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeAccessible</span><span class="params">(Constructor&lt;?&gt; ctor)</span> </span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>
<p>获取字段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在类中查找指定属性</span></span><br><span class="line"><span class="function">Field <span class="title">findField</span><span class="params">(Class&lt;?&gt; clazz, String name)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 同上，多提供了属性的类型</span></span></span><br><span class="line"><span class="function">Field <span class="title">findField</span><span class="params">(Class&lt;?&gt; clazz, String name, Class&lt;?&gt; type)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 是否为一个 &quot;public static final&quot; 属性</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPublicStaticFinal</span><span class="params">(Field field)</span> </span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>
<p>设置字段</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 target 对象的 field 属性值</span></span><br><span class="line"><span class="function">Object <span class="title">getField</span><span class="params">(Field field, Object target)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 设置 target 对象的 field 属性值，值为 value</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setField</span><span class="params">(Field field, Object target, Object value)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 同类对象属性对等赋值</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shallowCopyFieldState</span><span class="params">(Object src, Object dest)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 取消 Java 的权限控制检查。以便后续读写该私有属性</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeAccessible</span><span class="params">(Field field)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 对类的每个属性执行 callback</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWithFields</span><span class="params">(Class&lt;?&gt; clazz, ReflectionUtils.FieldCallback fc)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 同上，多了个属性过滤功能。</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWithFields</span><span class="params">(Class&lt;?&gt; clazz, ReflectionUtils.FieldCallback fc, </span></span></span><br><span class="line"><span class="function"><span class="params">                  ReflectionUtils.FieldFilter ff)</span> </span></span><br><span class="line"><span class="function"><span class="comment">// 同上，但不包括继承而来的属性</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWithLocalFields</span><span class="params">(Class&lt;?&gt; clazz, ReflectionUtils.FieldCallback fc)</span> </span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>
<h2 id="AopUtils"><a href="#AopUtils" class="headerlink" title="AopUtils"></a>AopUtils</h2><p>判断代理类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断是不是 Spring 代理对象</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAopProxy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断是不是 jdk 动态代理对象</span></span></span><br><span class="line"><span class="function"><span class="title">isJdkDynamicProxy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 判断是不是 CGLIB 代理对象</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isCglibProxy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>
<p>获取被代理对象的 class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取被代理的目标 class</span></span><br><span class="line">Class&lt;?&gt; getTargetClass()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="AopContext"><a href="#AopContext" class="headerlink" title="AopContext"></a>AopContext</h2><p>获取当前对象的代理对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">currentProxy</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>来源：<a href="juejin.cn/post/7043403364020781064">掘金@CadeCode</a></p>
</blockquote>
]]></content>
      <categories>
        <category>框架</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>Spring</tag>
        <tag>SpringBoot</tag>
        <tag>集合</tag>
        <tag>GC</tag>
        <tag>const</tag>
        <tag>数组</tag>
        <tag>索引</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>springboot的启动原理</title>
    <url>/posts/318CB48.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="总流程图"><a href="#总流程图" class="headerlink" title="总流程图"></a>总流程图</h1><p><img data-src="https://xuemingde.com/pages/image/2022/03/09/ufeQLe.jpg" alt=""></p>
<h1 id="入口类"><a href="#入口类" class="headerlink" title="入口类"></a>入口类</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DevServiceApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DevServiceApplication.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SpringBootApplication注解"><a href="#SpringBootApplication注解" class="headerlink" title="SpringBootApplication注解"></a>SpringBootApplication注解</h2><blockquote>
<p>Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用</p>
</blockquote>
<p>SpringBootApplication注解是Spring Boot的核心注解，它其实是一个组合注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span> <span class="comment">//// 注解的适用范围，其中TYPE用于描述类、接口（包括包注解类型）或enum声明</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="comment">//// 注解的生命周期，保留到class文件中（三个生命周期）</span></span><br><span class="line"><span class="meta">@Documented</span> <span class="comment">//// 表明这个注解应该被javadoc记录</span></span><br><span class="line"><span class="meta">@Inherited</span> <span class="comment">//// 子类可以继承该注解</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span> <span class="comment">//// 继承了Configuration，表示当前是注解类</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span> <span class="comment">//// 开启springboot的注解功能，springboot的四大神器之一，其借助@import的帮助</span></span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123;</span></span><br><span class="line"><span class="meta">        @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span></span><br><span class="line"><span class="meta">        @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span> <span class="comment">//// 扫描路径设置</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码可以看出，这个注解是<strong>@SpringBootConfiguration</strong>，<strong>@EnableAutoConfiguration</strong>以及<strong>@ComponentScan</strong>这三个注解的组合</p>
<h3 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootConfiguration &#123;</span><br><span class="line">	<span class="meta">@AliasFor(annotation = Configuration.class)</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">proxyBeanMethods</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>Spring Boot的配置类；标注在某个类上，表示一个类提供了Spring Boot应用程序</em></p>
<p>看SpringBootConfiguration的源码可以看出来，他其实继承与<strong>@Configuration</strong>，二者功能也一样，标注当前类是配置类，并且会将当前类声明的一个或多个@Bean注解标记的方法的实例纳入到spring容器中，并且实例名就是方法名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Configuration &#123;</span><br><span class="line">    <span class="meta">@AliasFor(</span></span><br><span class="line"><span class="meta">        annotation = Component.class</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">proxyBeanMethods</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置类相当于配置文件；配置类也是容器中的一个组件，它使用了@Component这个注解。</p>
<p>@Configuration注解使用了@Component注解，但两个注解还是有区别的。</p>
<h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">    String ENABLED_OVERRIDE_PROPERTY = <span class="string">&quot;spring.boot.enableautoconfiguration&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><em>告诉SpringBoot开启自动配置功能，这样自动配置才能生效，最为重要</em></p>
<p>&lt;u&gt;使用@EnableAutoConfiguration这个注解开启自动扫描，然后使用select选择挑选满足条件的文件，并且使用SpringFactoriesLoader进行实例化。最后加载到IOC容器里面，即ApplicationContext中。&lt;/u&gt;</p>
<p>@Import注解，它会加载AutoConfigurationImportSelector类，然后就会触发这个类的selectImports()方法。根据返回的String数组(配置类的Class的名称)加载配置类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoConfigurationImportSelector</span> <span class="keyword">implements</span> <span class="title">DeferredImportSelector</span>, <span class="title">BeanClassLoaderAware</span>,</span></span><br><span class="line"><span class="class"><span class="title">ResourceLoaderAware</span>, <span class="title">BeanFactoryAware</span>, <span class="title">EnvironmentAware</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回的String[]数组，是配置类Class的类名</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">            <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">        &#125;</span><br><span class="line">        AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line">        <span class="comment">//返回配置类的类名</span></span><br><span class="line">        <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们一直点下去，就可以找到最后的幕后英雄，就是SpringFactoriesLoader类，通过loadSpringFactories()方法加载META-INF/spring.factories中的配置类。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/09/EaiL64.jpg" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/09/HbEGa5.jpg" alt=""></p>
<p>这里使用了spring.factories文件的方式加载配置类，提供了很好的扩展性。</p>
<p>所以@EnableAutoConfiguration注解的作用其实就是开启自动配置，自动配置主要则依靠这种加载方式来实现。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/09/9AKjzk.jpg" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Import(&#123;Registrar.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AutoConfigurationPackage &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://xuemingde.com/pages/image/2022/03/09/K5nsWR.png" alt=""></p>
<h3 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h3><p>@ComponentScan就是自动扫描并加载符合条件的组件（比如@Component和@Repository等）或者bean定义，最终将这些bean定义加载到IOC容器中去 </p>
<p>所以<strong>启动类最好定义在Root package下</strong>，因为一般我们在使用@SpringBootApplication时，都不指定basePackages的。</p>
<h2 id="SpringApplication类"><a href="#SpringApplication类" class="headerlink" title="SpringApplication类"></a>SpringApplication类</h2><p>SpringApplication类实例化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new &#123;<span class="doctag">@link</span> SpringApplication&#125; instance. The application context will load</span></span><br><span class="line"><span class="comment"> * beans from the specified primary sources (see &#123;<span class="doctag">@link</span> SpringApplication class-level&#125;</span></span><br><span class="line"><span class="comment"> * documentation for details. The instance can be customized before calling</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #run(String...)&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resourceLoader the resource loader to use</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> primarySources the primary bean sources</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #run(Class, String[])</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #setSources(Set)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;</span><br><span class="line"> 	<span class="comment">// 初始化资源加载器</span></span><br><span class="line">       <span class="keyword">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">       <span class="comment">// 资源加载类不能为 null</span></span><br><span class="line">	Assert.notNull(primarySources, <span class="string">&quot;PrimarySources must not be null&quot;</span>);</span><br><span class="line">       <span class="comment">// 初始化加载资源类集合并去重</span></span><br><span class="line">	<span class="keyword">this</span>.primarySources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">     <span class="comment">// 推断应用程序是不是web应用</span></span><br><span class="line">	<span class="keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">     <span class="comment">// 设置初始化器(Initializer)</span></span><br><span class="line">	setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">     <span class="comment">// 设置监听器 </span></span><br><span class="line">	setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">     <span class="comment">// 推断出主应用入口类</span></span><br><span class="line">	<span class="keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>参考文章</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuaHVhd2VpLmNvbS9jb25zdW1lci9jbi9mb3J1bS90b3BpYy8wMjAyNDk0MDgxOTM3MzAwMjU0">深入剖析Springboot启动原理的底层源码，再也不怕面试官问了<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC85NDM2NTBhYjdkZmQ=">一文搞懂springboot启动原理<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODk1MzQxMTIzODE2OTE0OTU4I2hlYWRpbmctNg==">SpringBoot启动流程是怎样的？<i class="fa fa-external-link-alt"></i></span></li>
<li><a href=""></a></li>
</ul>
]]></content>
      <categories>
        <category>框架</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>Spring</tag>
        <tag>SpringBoot</tag>
        <tag>集合</tag>
        <tag>数组</tag>
        <tag>面试</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>BeanFactory和ApplicationContext有什么区别</title>
    <url>/posts/11TFME1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="相同"><a href="#相同" class="headerlink" title="相同"></a>相同</h2><ul>
<li><p>spring提供了两种不同的IOC容器，一个是BeanFactory，另外一个就是ApplocationContext，他们都是java 接口,ApplicationContext 继承于BeanFactory。</p>
</li>
<li><p>他们都可以用来配置XML属性，也支持属性的自动注入。</p>
</li>
<li><p>而 ListableBeanFactory 继承于BeanFactory。BeanFactory和ApplocationContext都是提供了一种方式，使用getBean(“bean name”)获取bean。</p>
</li>
</ul>
<h2 id="不同"><a href="#不同" class="headerlink" title="不同"></a>不同</h2><ul>
<li>当你调用getBean()方法时，BeanFactory仅实例化bean，而ApplocationContext在启动容器的时候实例化单例bean，不会等调用getBean时才实例化。</li>
<li>BeanFactory不支持国际化，即i18n，但ApplocationContext提供了支持。</li>
<li>BeanFactory于ApplocationContext之间的另一个区别是能够将事件发布到注册为监听的bean。</li>
<li>BeanFactory的一个核心实现是XMLBeanFactory，而ApplocationContext的一个核心实现是classPathXmlApplocationContext，Web容器的环境我们使用WebApplocationContext并且添加了getServietContext方法。</li>
<li>如果使用自动注入并使用BeanFactory，则需要使用API注册AutoWiredBeanPostProcessor，如果使用ApplocationContext则可以使用XML进行配置。</li>
<li>简而言之，BeanFactory提供了基本的IOC和DI功能，而ApplocationContext提供了高级的功能，BeanFactory可以用于测试和非生产，单ApplocationContext是功能更丰富的容器实现，应该优先于BeanFactory。</li>
</ul>
]]></content>
      <categories>
        <category>框架</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>C</tag>
        <tag>Spring</tag>
        <tag>容器</tag>
      </tags>
  </entry>
</search>
