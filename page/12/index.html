<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://cdn.baomitu.com/index/fonts/css?family=Ma Shan Zheng:300,300italic,400,400italic,700,700italic|Noto Sans Simplified Chinese:300,300italic,400,400italic,700,700italic|Noto Serif SC:300,300italic,400,400italic,700,700italic|Monaco:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="//lib.baomitu.com/font-awesome/5.15.4/css/all.min.css">
  <link rel="stylesheet" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css">
  <link rel="stylesheet" href="//lib.baomitu.com/pace/1.0.2/themes/blue/pace-theme-minimal.min.css">
  <script src="//lib.baomitu.com/pace/1.0.2/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xuemingde.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":true,"sidebar":{"position":"left","width":300,"display":"always","padding":18,"offset":10,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":true,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="我的愿望，世界和平">
<meta property="og:type" content="website">
<meta property="og:title" content="Middle&#39;s blog">
<meta property="og:url" content="https://xuemingde.com/page/12/index.html">
<meta property="og:site_name" content="Middle&#39;s blog">
<meta property="og:description" content="我的愿望，世界和平">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="meadel">
<meta property="article:tag" content="meadel">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://xuemingde.com/page/12/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Middle's blog - 一位程序员的成长之路</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Middle's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">一位程序员的成长之路</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-notepad">

    <a href="/notepad/" rel="section"><i class="fa fa-book fa-fw"></i>备忘录</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="fa fa-download fa-fw"></i>资源库</a>

  </li>
        <li class="menu-item menu-item-collect">

    <a href="/collect/" rel="section"><i class="fa fa-star fa-fw"></i>收藏夹</a>

  </li>
        <li class="menu-item menu-item-links">

    <a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>友链</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

           <div id="container-1">
            <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xuemingde.com/posts/HRQWG9.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.jpeg">
      <meta itemprop="name" content="meadel">
      <meta itemprop="description" content="我的愿望，世界和平">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Middle's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/HRQWG9.html" class="post-title-link" itemprop="url">Transactional 注解失效的3种原因及解决办法 </a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-17 00:00:00" itemprop="dateCreated datePublished" datetime="2022-04-17T00:00:00+08:00">2022-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-13 16:46:48" itemprop="dateModified" datetime="2022-08-13T16:46:48+08:00">2022-08-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/BUG/" itemprop="url" rel="index"><span itemprop="name">BUG</span></a>
                </span>
            </span>

          
            <span id="/posts/HRQWG9.html" class="post-meta-item leancloud_visitors" data-flag-title="Transactional 注解失效的3种原因及解决办法 " title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/posts/HRQWG9.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/posts/HRQWG9.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.5k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>原文：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvWnpwN2lKelVZRFJ0cFloWVVaeEZOQQ==">@Transactional 注解失效的3种原因及解决办法<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>讲解@Transactional的三种失效场景及解决办法</p>
<h2 id="Transactional失效场景介绍"><a href="#Transactional失效场景介绍" class="headerlink" title="Transactional失效场景介绍"></a>Transactional失效场景介绍</h2><h3 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h3><p>Transactional注解标注方法修饰符为非public时，<code>@Transactional</code>注解将会不起作用。例如以下代码。</p>
<p>定义一个错误的<code>@Transactional</code>标注实现，修饰一个默认访问符的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhoujy  </span></span><br><span class="line"><span class="comment"> **/</span>  </span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Resource</span>  </span><br><span class="line">    TestMapper testMapper;  </span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Transactional</span>  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertTestWrongModifier</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> re = testMapper.insert(<span class="keyword">new</span> Test(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>));  </span><br><span class="line">        <span class="keyword">if</span> (re &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NeedToInterceptException(<span class="string">&quot;need intercept&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        testMapper.insert(<span class="keyword">new</span> Test(<span class="number">210</span>,<span class="number">20</span>,<span class="number">30</span>));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>在同一个包内，新建调用对象，进行访问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InvokcationService</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Resource</span>  </span><br><span class="line">    <span class="keyword">private</span> TestServiceImpl testService;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeInsertTestWrongModifier</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="comment">//调用@Transactional标注的默认访问符方法  </span></span><br><span class="line">        testService.insertTestWrongModifier();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>测试用例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span>  </span><br><span class="line"><span class="meta">@SpringBootTest</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplicationTests</span> </span>&#123;  </span><br><span class="line">   <span class="meta">@Resource</span>  </span><br><span class="line">   InvokcationService invokcationService;  </span><br><span class="line">  </span><br><span class="line">   <span class="meta">@Test</span>  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">testInvoke</span><span class="params">()</span></span>&#123;  </span><br><span class="line">      invokcationService.invokeInsertTestWrongModifier();  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>以上的访问方式，导致事务没开启，因此在方法抛出异常时，<code>testMapper.insert(new Test(10,20,30));</code>操作不会进行回滚。如果<code>TestServiceImpl#insertTestWrongModifier</code>方法改为public的话将会正常开启事务，<code>testMapper.insert(new Test(10,20,30));</code>将会进行回滚。</p>
<h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><p>在类内部调用调用类内部<code>@Transactional</code>标注的方法。这种情况下也会导致事务不开启。示例代码如下。</p>
<p>设置一个内部调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhoujy  </span></span><br><span class="line"><span class="comment"> **/</span>  </span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> <span class="keyword">implements</span> <span class="title">TestService</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Resource</span>  </span><br><span class="line">    TestMapper testMapper;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Transactional</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertTestInnerInvoke</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//正常public修饰符的事务方法  </span></span><br><span class="line">        <span class="keyword">int</span> re = testMapper.insert(<span class="keyword">new</span> Test(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>));  </span><br><span class="line">        <span class="keyword">if</span> (re &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NeedToInterceptException(<span class="string">&quot;need intercept&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        testMapper.insert(<span class="keyword">new</span> Test(<span class="number">210</span>,<span class="number">20</span>,<span class="number">30</span>));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInnerInvoke</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="comment">//类内部调用@Transactional标注的方法。  </span></span><br><span class="line">        insertTestInnerInvoke();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>测试用例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span>  </span><br><span class="line"><span class="meta">@SpringBootTest</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplicationTests</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">   <span class="meta">@Resource</span>  </span><br><span class="line">   TestServiceImpl testService;  </span><br><span class="line">  </span><br><span class="line">   <span class="comment">/**  </span></span><br><span class="line"><span class="comment">    * 测试内部调用<span class="doctag">@Transactional</span>标注方法  </span></span><br><span class="line"><span class="comment">    */</span>  </span><br><span class="line">   <span class="meta">@Test</span>  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">testInnerInvoke</span><span class="params">()</span></span>&#123;  </span><br><span class="line">       <span class="comment">//测试外部调用事务方法是否正常  </span></span><br><span class="line">      <span class="comment">//testService.insertTestInnerInvoke();  </span></span><br><span class="line">       <span class="comment">//测试内部调用事务方法是否正常  </span></span><br><span class="line">      testService.testInnerInvoke();  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>上面就是使用的测试代码，运行测试知道，外部调用事务方法能够征程开启事务，<code>testMapper.insert(new Test(10,20,30))</code>操作将会被回滚；</p>
<p>然后运行另外一个测试用例，调用一个方法在类内部调用内部被<code>@Transactional</code>标注的事务方法，运行结果是事务不会正常开启，<code>testMapper.insert(new Test(10,20,30))</code>操作将会保存到数据库不会进行回滚。</p>
<h3 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h3><p>事务方法内部捕捉了异常，没有抛出新的异常，导致事务操作不会进行回滚。示例代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhoujy  </span></span><br><span class="line"><span class="comment"> **/</span>  </span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> <span class="keyword">implements</span> <span class="title">TestService</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Resource</span>  </span><br><span class="line">    TestMapper testMapper;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Transactional</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertTestCatchException</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="keyword">int</span> re = testMapper.insert(<span class="keyword">new</span> Test(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>));  </span><br><span class="line">            <span class="keyword">if</span> (re &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                <span class="comment">//运行期间抛异常  </span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NeedToInterceptException(<span class="string">&quot;need intercept&quot;</span>);  </span><br><span class="line">            &#125;  </span><br><span class="line">            testMapper.insert(<span class="keyword">new</span> Test(<span class="number">210</span>,<span class="number">20</span>,<span class="number">30</span>));  </span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;  </span><br><span class="line">            System.out.println(<span class="string">&quot;i catch exception&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>测试用例代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span>  </span><br><span class="line"><span class="meta">@SpringBootTest</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplicationTests</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">   <span class="meta">@Resource</span>  </span><br><span class="line">   TestServiceImpl testService;  </span><br><span class="line">  </span><br><span class="line">   <span class="meta">@Test</span>  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCatchException</span><span class="params">()</span></span>&#123;  </span><br><span class="line">      testService.insertTestCatchException();  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>运行测试用例发现，虽然抛出异常，但是异常被捕捉了，没有抛出到方法 外， <code>testMapper.insert(new Test(210,20,30))</code>操作并没有回滚。</p>
<p>以上三种就是<code>@Transactional</code>注解不起作用，<code>@Transactional</code>注解失效的主要原因。下面结合spring中对于<code>@Transactional</code>的注解实现源码分析为何导致<code>@Transactional</code>注解不起作用。</p>
<h2 id="Transactional注解不起作用原理分析"><a href="#Transactional注解不起作用原理分析" class="headerlink" title="@Transactional注解不起作用原理分析"></a>@Transactional注解不起作用原理分析</h2><h3 id="第一种-1"><a href="#第一种-1" class="headerlink" title="第一种"></a>第一种</h3><p><code>@Transactional</code>注解标注方法修饰符为非public时，<code>@Transactional</code>注解将会不起作用。这里分析 的原因是，<code>@Transactional</code>是基于动态代理实现的，<code>@Transactional</code>注解实现原理中分析了实现方法，在bean初始化过程中，对含有<code>@Transactional</code>标注的bean实例创建代理对象，这里就存在一个spring扫描<code>@Transactional</code>注解信息的过程，不幸的是源码中体现，标注<code>@Transactional</code>的方法如果修饰符不是public，那么就默认方法的<code>@Transactional</code>信息为空，那么将不会对bean进行代理对象创建或者不会对方法进行代理调用</p>
<p><code>@Transactional</code>注解实现原理中，介绍了如何判定一个bean是否创建代理对象，大概逻辑是。根据spring创建好一个aop切点<code>BeanFactoryTransactionAttributeSourceAdvisor</code>实例，遍历当前bean的class的方法对象，判断方法上面的注解信息是否包含<code>@Transactional</code>，如果bean任何一个方法包含<code>@Transactional</code>注解信息，那么就是适配这个<code>BeanFactoryTransactionAttributeSourceAdvisor</code>切点。则需要创建代理对象，然后代理逻辑为我们管理事务开闭逻辑。</p>
<p>spring源码中，在拦截bean的创建过程，寻找bean适配的切点时，运用到下面的方法，目的就是寻找方法上面的@<code>Transactional</code>信息，如果有，就表示切点<code>BeanFactoryTransactionAttributeSourceAdvisor</code>能够应用（canApply）到bean中，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">AopUtils#canApply(org.springframework.aop.Pointcut, java.lang.Class&lt;?&gt;, boolean)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canApply</span><span class="params">(Pointcut pc, Class&lt;?&gt; targetClass, <span class="keyword">boolean</span> hasIntroductions)</span> </span>&#123;  </span><br><span class="line">   Assert.notNull(pc, <span class="string">&quot;Pointcut must not be null&quot;</span>);  </span><br><span class="line">   <span class="keyword">if</span> (!pc.getClassFilter().matches(targetClass)) &#123;  </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   MethodMatcher methodMatcher = pc.getMethodMatcher();  </span><br><span class="line">   <span class="keyword">if</span> (methodMatcher == MethodMatcher.TRUE) &#123;  </span><br><span class="line">      <span class="comment">// No need to iterate the methods if we&#x27;re matching any method anyway...  </span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   IntroductionAwareMethodMatcher introductionAwareMethodMatcher = <span class="keyword">null</span>;  </span><br><span class="line">   <span class="keyword">if</span> (methodMatcher <span class="keyword">instanceof</span> IntroductionAwareMethodMatcher) &#123;  </span><br><span class="line">      introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//遍历class的方法对象  </span></span><br><span class="line">   Set&lt;Class&lt;?&gt;&gt; classes = <span class="keyword">new</span> LinkedHashSet&lt;Class&lt;?&gt;&gt;(ClassUtils.getAllInterfacesForClassAsSet(targetClass));  </span><br><span class="line">   classes.add(targetClass);  </span><br><span class="line">   <span class="keyword">for</span> (Class&lt;?&gt; clazz : classes) &#123;  </span><br><span class="line">      Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz);  </span><br><span class="line">      <span class="keyword">for</span> (Method method : methods) &#123;  </span><br><span class="line">         <span class="keyword">if</span> ((introductionAwareMethodMatcher != <span class="keyword">null</span> &amp;&amp;  </span><br><span class="line">               introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||  </span><br><span class="line">             <span class="comment">//适配查询方法上的@Transactional注解信息    </span></span><br><span class="line">             methodMatcher.matches(method, targetClass)) &#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">         &#125;  </span><br><span class="line">      &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>我们可以在上面的方法打断点，一步一步调试跟踪代码，最终上面的代码还会调用如下方法来判断。在下面的方法上断点，回头看看方法调用堆栈也是不错的方式跟踪。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AbstractFallbackTransactionAttributeSource#getTransactionAttribute</span><br></pre></td></tr></table></figure>
<ul>
<li><code>AbstractFallbackTransactionAttributeSource#computeTransactionAttribute</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">computeTransactionAttribute</span><span class="params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;  </span><br><span class="line">   <span class="comment">// Don&#x27;t allow no-public methods as required.  </span></span><br><span class="line">   <span class="comment">//非public 方法，返回@Transactional信息一律是null  </span></span><br><span class="line">   <span class="keyword">if</span> (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;  </span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">//后面省略.......  </span></span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure>
<p><strong>不创建代理对象</strong></p>
<p>所以，如果所有方法上的修饰符都是非public的时候，那么将不会创建代理对象。以一开始的测试代码为例，如果正常的修饰符的testService是下面图片中的，经过cglib创建的代理对象。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/17/1016-kIvrdM.png" alt="图片"></p>
<p>如果class中的方法都是非public的那么将不是代理对象。</p>
<p><strong>不进行代理调用</strong></p>
<p>考虑一种情况，如下面代码所示。两个方法都被<code>@Transactional</code>注解标注，但是一个有public修饰符一个没有，那么这种情况我们可以预见的话，一定会创建代理对象，因为至少有一个public修饰符的<code>@Transactional</code>注解标注方法。</p>
<p>创建了代理对象，<code>insertTestWrongModifier</code>就会开启事务吗？答案是不会。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhoujy  </span></span><br><span class="line"><span class="comment"> **/</span>  </span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> <span class="keyword">implements</span> <span class="title">TestService</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Resource</span>  </span><br><span class="line">    TestMapper testMapper;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="meta">@Transactional</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertTest</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> re = testMapper.insert(<span class="keyword">new</span> Test(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>));  </span><br><span class="line">        <span class="keyword">if</span> (re &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NeedToInterceptException(<span class="string">&quot;need intercept&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        testMapper.insert(<span class="keyword">new</span> Test(<span class="number">210</span>,<span class="number">20</span>,<span class="number">30</span>));  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="meta">@Transactional</span>  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertTestWrongModifier</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> re = testMapper.insert(<span class="keyword">new</span> Test(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>));  </span><br><span class="line">        <span class="keyword">if</span> (re &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NeedToInterceptException(<span class="string">&quot;need intercept&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        testMapper.insert(<span class="keyword">new</span> Test(<span class="number">210</span>,<span class="number">20</span>,<span class="number">30</span>));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>原因是在动态代理对象进行代理逻辑调用时，在cglib创建的代理对象的拦截函数中<code>CglibAopProxy.DynamicAdvisedInterceptor#intercept</code>，有一个逻辑如下，目的是获取当前被代理对象的当前需要执行的method适配的aop逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);  </span><br></pre></td></tr></table></figure>
<p>而针对@Transactional注解查找aop逻辑过程，相似地，也是执行一次</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AbstractFallbackTransactionAttributeSource#getTransactionAttribute</span><br></pre></td></tr></table></figure>
<ul>
<li><code>AbstractFallbackTransactionAttributeSource#computeTransactionAttribute</code></li>
</ul>
<p>也就是说还需要找一个方法上的<code>@Transactional</code>注解信息，没有的话就不执行代理<code>@Transactional</code>对应的代理逻辑，直接执行方法。没有了<code>@Transactional</code>注解代理逻辑，就无法开启事务，这也是上一篇已经讲到的。</p>
<h3 id="第二种-1"><a href="#第二种-1" class="headerlink" title="第二种"></a>第二种</h3><p>在类内部调用调用类内部<code>@Transactional</code>标注的方法。这种情况下也会导致事务不开启。</p>
<p>经过对第一种的详细分析，对这种情况为何不开启事务管理，原因应该也能猜到；</p>
<blockquote>
<p>既然事务管理是基于动态代理对象的代理逻辑实现的，那么如果在类内部调用类内部的事务方法，这个调用事务方法的过程并不是通过代理对象来调用的，而是直接通过this对象来调用方法，绕过的代理对象，肯定就是没有代理逻辑了。</p>
</blockquote>
<p>其实我们可以这样玩，内部调用也能实现开启事务，代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zhoujy  </span></span><br><span class="line"><span class="comment"> **/</span>  </span><br><span class="line"><span class="meta">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServiceImpl</span> <span class="keyword">implements</span> <span class="title">TestService</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Resource</span>  </span><br><span class="line">    TestMapper testMapper;  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Resource</span>  </span><br><span class="line">    TestServiceImpl testServiceImpl;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Transactional</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertTestInnerInvoke</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> re = testMapper.insert(<span class="keyword">new</span> Test(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>));  </span><br><span class="line">        <span class="keyword">if</span> (re &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NeedToInterceptException(<span class="string">&quot;need intercept&quot;</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        testMapper.insert(<span class="keyword">new</span> Test(<span class="number">210</span>,<span class="number">20</span>,<span class="number">30</span>));  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInnerInvoke</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="comment">//内部调用事务方法  </span></span><br><span class="line">        testServiceImpl.insertTestInnerInvoke();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>上面就是使用了代理对象进行事务调用，所以能够开启事务管理，但是实际操作中，没人会闲的蛋疼这样子玩~</p>
<h3 id="第三种-1"><a href="#第三种-1" class="headerlink" title="第三种"></a>第三种</h3><p>事务方法内部捕捉了异常，没有抛出新的异常，导致事务操作不会进行回滚。</p>
<p>这种的话，可能我们比较常见，问题就出在代理逻辑中，我们先看看源码里卖弄动态代理逻辑是如何为我们管理事务的。</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TransactionAspectSupport<span class="meta">#invokeWithinTransaction</span></span><br></pre></td></tr></table></figure>
<p>代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">invokeWithinTransaction</span><span class="params">(Method method, Class&lt;?&gt; targetClass, <span class="keyword">final</span> InvocationCallback invocation)</span>  </span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> Throwable </span>&#123;  </span><br><span class="line">  </span><br><span class="line">   <span class="comment">// If the transaction attribute is null, the method is non-transactional.  </span></span><br><span class="line">   <span class="keyword">final</span> TransactionAttribute txAttr = getTransactionAttributeSource().getTransactionAttribute(method, targetClass);  </span><br><span class="line">   <span class="keyword">final</span> PlatformTransactionManager tm = determineTransactionManager(txAttr);  </span><br><span class="line">   <span class="keyword">final</span> String joinpointIdentification = methodIdentification(method, targetClass);  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">if</span> (txAttr == <span class="keyword">null</span> || !(tm <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;  </span><br><span class="line">      <span class="comment">// Standard transaction demarcation with getTransaction and commit/rollback calls.  </span></span><br><span class="line">       <span class="comment">//开启事务  </span></span><br><span class="line">      TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);  </span><br><span class="line">      Object retVal = <span class="keyword">null</span>;  </span><br><span class="line">      <span class="keyword">try</span> &#123;  </span><br><span class="line">         <span class="comment">// This is an around advice: Invoke the next interceptor in the chain.  </span></span><br><span class="line">         <span class="comment">// This will normally result in a target object being invoked.  </span></span><br><span class="line">          <span class="comment">//反射调用业务方法  </span></span><br><span class="line">         retVal = invocation.proceedWithInvocation();  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">catch</span> (Throwable ex) &#123;  </span><br><span class="line">         <span class="comment">// target invocation exception  </span></span><br><span class="line">          <span class="comment">//异常时，在catch逻辑中回滚事务  </span></span><br><span class="line">         completeTransactionAfterThrowing(txInfo, ex);  </span><br><span class="line">         <span class="keyword">throw</span> ex;  </span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="keyword">finally</span> &#123;  </span><br><span class="line">         cleanupTransactionInfo(txInfo);  </span><br><span class="line">      &#125;  </span><br><span class="line">       <span class="comment">//提交事务  </span></span><br><span class="line">      commitTransactionAfterReturning(txInfo);  </span><br><span class="line">      <span class="keyword">return</span> retVal;  </span><br><span class="line">   &#125;  </span><br><span class="line">  </span><br><span class="line">   <span class="keyword">else</span> &#123;  </span><br><span class="line">     <span class="comment">//....................  </span></span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>所以看了上面的代码就一目了然了，事务想要回滚，必须能够在这里捕捉到异常才行，如果异常中途被捕捉掉，那么事务将不会回滚。</p>
<p>总结了以上几种情况。</p>

      
    </div>
   <div>
        
    </div>

   
    
    
    
      

      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>

  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xuemingde.com/posts/J71QTX.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.jpeg">
      <meta itemprop="name" content="meadel">
      <meta itemprop="description" content="我的愿望，世界和平">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Middle's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/J71QTX.html" class="post-title-link" itemprop="url">秒杀系统设计</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-16 00:00:00" itemprop="dateCreated datePublished" datetime="2022-04-16T00:00:00+08:00">2022-04-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-13 16:46:48" itemprop="dateModified" datetime="2022-08-13T16:46:48+08:00">2022-08-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/" itemprop="url" rel="index"><span itemprop="name">功能实现方案</span></a>
                </span>
            </span>

          
            <span id="/posts/J71QTX.html" class="post-meta-item leancloud_visitors" data-flag-title="秒杀系统设计" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/posts/J71QTX.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/posts/J71QTX.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>5.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>5 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>原文：<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC82ODYxNzQ5MjM4NDY2NTc2Mzk3">秒杀系统设计 - 掘金<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>带着大家看看一个秒杀的设计细节以及中间各种解决方案的利弊，以下就是我设计的秒杀系统，几乎涵盖了市面上所有秒杀的实现细节：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/16/1203-rbO6wl.jpg" alt="img"></p>
<p>首先设计一个系统之前，我们需要先确认我们的业务场景是怎么样子的，我就<strong>带着大家一起假设一个场景</strong>好吧。</p>
<p>我们现场要卖1000件下面这个<strong>婴儿纸尿裤</strong>，然后我们根据以往这样秒杀活动的数据经验来看，目测来抢这100件纸尿裤的人足足有10万人。（南极人打钱！）</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/16/1204-sjhL3N.jpg" alt="img"></p>
<p>你一听，完了呀，这我们的服务器哪里顶得住啊！说真的直接打DB肯定挂，但是别急嘛，有<strong>暖男</strong>敖丙在，任何系统我们开始设计之前我们都应该去思考<strong>会出现哪些问题</strong>？这里我罗列了几个非常经典的问题：</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h3><p>是的<strong>高并发</strong>这个是我们想都不用想的一个点，一瞬间这么多人进来这不是高并发什么时候是呢？</p>
<p>是吧，秒杀的特点就是这样<strong>时间极短</strong>、 <strong>瞬间用户量大</strong>。</p>
<p>正常的店铺营销都是用极低的价格配合上短信、APP的精准推送，吸引特别多的用户来参与这场秒杀，<strong>爽了商家苦了开发呀</strong>。</p>
<p>秒杀大家都知道如果真的营销到位，价格诱人，几十万的流量我觉得完全不是问题，那单机的<strong>Redis</strong>我感觉3-4W的QPS还是能顶得住的，但是再高了就没办法了，那这个数据随便搞个热销商品的秒杀可能都不止了。</p>
<p>大量的请求进来，我们需要考虑的点就很多了，<strong>缓存雪崩</strong>，<strong>缓存击穿</strong>，<strong>缓存穿透</strong>这些我之前提到的点都是有可能发生的，出现问题打挂DB那就很难受了，活动失败用户体验差，活动人气没了，最后背锅的还是<strong>开发</strong>。</p>
<h3 id="超卖"><a href="#超卖" class="headerlink" title="超卖"></a>超卖</h3><p>但凡是个秒杀，都怕<strong>超卖</strong>，我这里举例的只是尿不湿，要是换成100个MacBook Pro，商家的预算经费卖100个可以赚点还可以造势，结果你写错程序多卖出去200个，你不发货用户<strong>投诉你</strong>，平台<strong>封你店</strong>，你发货就<strong>血亏</strong>，你怎么办？ （没事看了敖丙的文章直接不怕）</p>
<p>那最后只能<strong>杀个开发祭天</strong>解气了，秒杀的价格本来就低了，基本上都是不怎么赚钱的，超卖了就恐怖了呀，所以超卖也是很关键的一个点。</p>
<h3 id="恶意请求"><a href="#恶意请求" class="headerlink" title="恶意请求"></a>恶意请求</h3><p>你这么低的价格，假如我抢到了，我转手卖掉我不是<strong>血赚</strong>？就算我不卖我也不亏啊，那用户知道，你知道，别的别有用心的人（黑客、黄牛…）肯定也知道的。</p>
<p>那简单啊，我知道你什么时候抢，我搞个几十台机器搞点脚本，我也模拟出来十几万个人左右的请求，那我是不是意味着我基本上有80%的成功率了。</p>
<p>真实情况可能远远不止，因为机器请求的速度比人的手速往往快太多了，在贵州的敖丙我每年回家抢高铁票都是<strong>秒光</strong>的，我也不知道有没有黄牛的功劳，我要Diss你，黄牛。杰伦演唱会门票抢不到，我也Diss你。</p>
<p>Tip：科普下，小道消息了解到的，黄牛的抢票系统，比国内很多小公司的系统还吊很多，架构设计都是顶级的，我用<strong>顶配的服务</strong>加上<strong>顶配的架构设计</strong>，你还想看演唱会？还想回家？</p>
<p>不过不用黄牛我回家都难，我们云贵川跟我一样要回家过年的仔太多了555！</p>
<h3 id="链接暴露"><a href="#链接暴露" class="headerlink" title="链接暴露"></a>链接暴露</h3><p>前面几个问题大家可能都很好理解，一看到这个有的小伙伴可能会比较疑惑，啥是<strong>链接暴露</strong>呀？</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/16/1209-DpmkpH.jpg" alt="img"></p>
<p>相信是个开发同学都对这个画面一点都不陌生吧，懂点行的仔都可以打开谷歌的<strong>开发者模式</strong>，然后看看你的网页代码，有的就有URL，但是我写VUE的时候是事件触发然后去调用文件里面的接口看源码看不到，但是我可以点击一下<strong>查看你的请求地址</strong>啊，不过你好像可以对按钮在秒杀前置灰。</p>
<p>不管怎么样子都有危险，撇开外面的所有的东西你都挡住了，你卖这个东西实在便宜得过分，有诱惑力，你能保证<strong>开发不动心</strong>？开发知道地址，在秒杀的时候自己提前请求。。。（开发：怎么TM又是我）</p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>每秒上万甚至十几万的<strong>QPS</strong>（每秒请求数）直接打到<strong>数据库</strong>，基本上都要把库打挂掉，而且你服务不单单是做秒杀的还涉及其他的业务，你没做<strong>降级、限流、熔断</strong>啥的，别的一起挂，小公司的话可能<strong>全站崩溃404</strong>。</p>
<p>反正不管你秒杀怎么挂，你别把别的搞挂了对吧，搞挂了就不是杀一个程序员能搞定的。</p>
<p>程序员：我TM好难啊！</p>
<p><strong>问题都列出来了，那怎么设计，怎么解决这些问题就是接下去要考虑的了，我们对症下药。</strong></p>
<p>我会从我设计的秒杀系统从上到下去给大家介绍我们正常电商秒杀系统在每一层做了些什么，每一层存在的问题，难点等。</p>
<p>我们从前端开始：</p>
<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>秒杀系统普遍都是商城网页、H5、APP、小程序这几项。</p>
<p>在前端这一层其实我们可以做的事情有很多，如果用node去做，甚至能直接处理掉整个秒杀，但是node其实应该属于后端，所以我不讨论node Service了。</p>
<h3 id="资源静态化"><a href="#资源静态化" class="headerlink" title="资源静态化"></a>资源静态化</h3><p>秒杀一般都是特定的商品还有页面模板，现在一般都是前后端分离的，页面一般都是不会经过后端的，但是前端也要自己的服务器啊，那就把能提前放入<strong>cdn服务器</strong>的东西都放进去，反正把所有能提升效率的步骤都做一下，减少真正秒杀时候服务器的压力。</p>
<h3 id="秒杀链接加盐"><a href="#秒杀链接加盐" class="headerlink" title="秒杀链接加盐"></a>秒杀链接加盐</h3><p>我们上面说了链接要是提前暴露出去可能有人直接访问url就提前秒杀了，那又有小伙伴要说了我做个时间的校验就好了呀，那我告诉你，知道链接的地址比起页面人工点击的还是有<strong>很大优势</strong>。</p>
<p>我知道url了，那我通过程序不断获取最新的北京时间，可以达到<strong>毫秒级别</strong>的，我就在00毫秒的时候请求，我敢说绝对比你人工点的成功率大太多了，而且我可以一毫秒发送N次请求，搞不好你卖100个产品我全拿了。</p>
<p><strong>那这种情况怎么避免？</strong></p>
<p>简单，把<strong>URL动态化</strong>，就连写代码的人都不知道，你就通过MD5之类的摘要算法加密随机的字符串去做url，然后通过前端代码获取url后台校验才能通过。</p>
<p>这个只能防止一部分没耐心继续破解下去的黑客，有耐心的人研究出来还是能破解，在电商场景存在很多这样的羊毛党，那怎么做呢？</p>
<p>后面我会说。</p>
<h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><p>限流这里我觉得应该分为<strong>前端限流</strong>和<strong>后端限流</strong>。</p>
<p><strong>物理控制：</strong></p>
<p>大家有没有发现没到秒杀前，一般按钮都是<strong>置灰</strong>的，只有时间到了，才能点击。</p>
<p>这是因为怕大家在时间快到的最后几秒秒疯狂请求服务器，然后还没到秒杀的时候基本上服务器就挂了。</p>
<p>这个时候就需要前端的配合，定时去请求你的后端服务器，获取最新的北京时间，到时间点再给按钮可用状态。</p>
<p>按钮可以点击之后也得给他置灰几秒，不然他一样在开始之后一直点的。</p>
<p><strong>你敢说你们秒杀的时候不是这样的？</strong></p>
<p><strong>前端限流</strong>：这个很简单，一般秒杀不会让你一直点的，一般都是点击一下或者两下然后几秒之后才可以继续点击，这也是保护服务器的一种手段。</p>
<p><strong>后端限流</strong>：秒杀的时候肯定是涉及到后续的订单生成和支付等操作，但是都只是成功的幸运儿才会走到那一步，那一旦100个产品卖光了，return了一个false，前端直接秒杀结束，然后你后端也关闭后续无效请求的介入了。</p>
<p>Tip：真正的限流还会有限流组件的加入例如：阿里的Sentinel、Hystrix等。我这里就不展开了，就说一下物理的限流。</p>
<p>我们卖1000件商品，请求有10W，我们不需要把十万都放进来，你可以放1W请求进来，然后再进行操作，因为秒杀对于用户本身就是黑盒的，所以你怎么做的他们是没感知的，至于为啥放1W进来，而不是刚好1000，是因为会丢掉一些薅羊毛的用户，至于怎么判断，后面的风控阶段我会说。</p>
<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p><strong>Nginx</strong>大家想必都不陌生了吧，这玩意是<strong>高性能的web服务器</strong>，并发也随便顶几万不是梦，但是我们的<strong>Tomcat</strong>只能顶几百的并发呀，那简单呀<strong>负载均衡</strong>嘛，一台服务几百，那就多搞点，在秒杀的时候多租点<strong>流量机</strong>。</p>
<p>Tip：据我所知国内某大厂就是在去年春节活动期间租光了亚洲所有的服务器，小公司也很喜欢在双十一期间买流量机来顶住压力。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/16/1212-GXp2le.jpg" alt="img"></p>
<p><strong>这样一对比是不是觉得你的集群能顶很多了。</strong></p>
<p><strong>恶意请求拦截</strong>也需要用到它，一般单个用户请求次数太夸张，不像人为的请求在网关那一层就得拦截掉了，不然请求多了他抢不抢得到是一回事，服务器压力上去了，可能占用网络带宽或者把<strong>服务器打崩、缓存击穿</strong>等等。</p>
<h2 id="风控"><a href="#风控" class="headerlink" title="风控"></a>风控</h2><p>我可以明确的告诉大家，前面的所有措施还是拦不住很多羊毛党，因为他们是专业的团队，他们可以注册很多账号来薅你的羊毛，而且不用机器请求，就用群控，操作几乎跟真实用户一模一样。</p>
<p><strong>那怎么办，是不是无解了？</strong></p>
<p>这个时候就需要风控同学的介入了，在请求到达后端之前，风控可以根据账号行为分析出这个账号机器人的概率大不大，我现在负责公司的某些特殊系统，每个用户的行为都是会送到我们大数据团队进行分析处理，给你打上对应标签的。</p>
<p>那黑客其实也有办法：<strong>养号</strong></p>
<p>他们去黑市买真实用户有过很多记录的账号，买到了还不闲着，帮他们去购物啥的，让系统无法识别他们是黑号还是真实用户的号。</p>
<p><strong>怎么办？</strong></p>
<p>通杀！是的没有办法，只能通杀了，通杀的意思就是，我们通过风管分析出来这个用户是真实用户的概率没有其他用户概率大，那就认为他是机器了，丢弃他的请求。</p>
<p>之前的限流我们放进来10000个请求，但是我们真正的库存只有1000个，那我们就算出最有可能是真实用户的1000人进行秒杀，丢弃其他请求，因为秒杀本来就是黑盒操作的，用户层面是无感知的，这样设计能让真实的用户买到东西，还可以减少自己被薅羊毛的概率。</p>
<p>风控可以说是流量进入的最后一道门槛了，所以很多公司的风控是很强的，蚂蚁金服的风控大家如果了解过就知道了，你的资金在支付宝被盗了，他们是能做到全款补偿是有原因的。</p>
<h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><h3 id="服务单一职责"><a href="#服务单一职责" class="headerlink" title="服务单一职责"></a>服务单一职责</h3><p>设计个能抗住高并发的系统，我觉得还是得<strong>单一职责</strong>。</p>
<p>什么意思呢，大家都知道现在设计都是<strong>微服务的设计思想</strong>，然后再用<strong>分布式的部署方式</strong>。</p>
<p>也就是我们下单是有个订单服务，用户登录管理等有个用户服务等等，那为啥我们不给秒杀也开个服务，我们把秒杀的代码业务逻辑放一起。</p>
<p>单一职责的好处就是就算秒杀没抗住，秒杀库崩了，服务挂了，也不会影响到其他的服务。（高可用）</p>
<h3 id="Redis集群"><a href="#Redis集群" class="headerlink" title="Redis集群"></a>Redis集群</h3><p>之前不是说单机的<strong>Redis</strong>顶不住嘛，那简单多找几个兄弟啊，秒杀本来就是读多写少，那你们是不是瞬间想起来我之前跟你们提到过的，<strong>Redis集群</strong>，<strong>主从同步</strong>、<strong>读写分离</strong>，我们还搞点<strong>哨兵</strong>，开启<strong>持久化</strong>直接无敌高可用！</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/16/1214-7Eeoyi.jpg" alt="img"></p>
<h3 id="库存预热"><a href="#库存预热" class="headerlink" title="库存预热"></a>库存预热</h3><p><strong>秒杀的本质，就是对库存的抢夺</strong>，每个秒杀的用户来你都去数据库查询库存校验库存，然后扣减库存，撇开性能因数，你不觉得这样好繁琐，对业务开发人员都不友好，而且数据库顶不住啊。</p>
<p><strong>开发：你tm总算为我着想一次了。</strong></p>
<h4 id="那怎么办？"><a href="#那怎么办？" class="headerlink" title="那怎么办？"></a>那怎么办？</h4><p>我们都知道数据库顶不住但是他的兄弟非关系型的数据库<strong>Redis</strong>能顶啊！</p>
<p>那不简单了，我们要开始秒杀前你通过定时任务或者运维同学<strong>提前把商品的库存加载到Redis中</strong>去，让整个流程都在Redis里面去做，然后等秒杀介绍了，再异步的去修改库存就好了。</p>
<p>但是用了Redis就有一个问题了，我们上面说了我们采用<strong>主从</strong>，就是我们会去读取库存然后再判断然后有库存才去减库存，正常情况没问题，但是高并发的情况问题就很大了。</p>
<p><strong>多品几遍！！！</strong>就比如现在库存只剩下1个了，我们高并发嘛，4个服务器一起查询了发现都是还有1个，那大家都觉得是自己抢到了，就都去扣库存，那结果就变成了-3，是的只有一个是真的抢到了，别的都是超卖的。咋办？</p>
<h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>Redis本身是支持事务的，而且他有很多原子命令的，大家也可以用LUA，还可以用他的管道，乐观锁他也知支持。</p>
<h5 id="限流-amp-降级-amp-熔断-amp-隔离"><a href="#限流-amp-降级-amp-熔断-amp-隔离" class="headerlink" title="限流&amp;降级&amp;熔断&amp;隔离"></a>限流&amp;降级&amp;熔断&amp;隔离</h5><p>这个为啥要做呢，不怕一万就怕万一，万一你真的顶不住了，<strong>限流</strong>，顶不住就挡一部分出去但是不能说不行，<strong>降级</strong>，降级了还是被打挂了，<strong>熔断</strong>，至少不要影响别的系统，<strong>隔离</strong>，你本身就独立的，但是你会调用其他的系统嘛，你快不行了你别拖累兄弟们啊。</p>
<h5 id="消息队列（削峰填谷）"><a href="#消息队列（削峰填谷）" class="headerlink" title="消息队列（削峰填谷）"></a>消息队列（削峰填谷）</h5><p>一说到这个名词，很多小伙伴就知道了，对的<strong>MQ</strong>，你买东西少了你直接100个请求改库我觉得没问题，但是万一秒杀一万个，10万个呢？服务器挂了，<strong>程序员又要背锅的</strong>。</p>
<p>秒杀就是这种瞬间流量很高，但是平时又没有流量的场景，那消息队列完全契合这样的场景了呀，削峰填谷。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/16/1217-Dt9Uqe.jpg" alt="img"></p>
<p>Tip：<strong>可能小伙伴说我们业务达不到这个量级，没必要。但是我想说我们写代码，就不应该写出有逻辑漏洞的代码，至少以后公司体量上去了，别人一看居然不用改代码，一看代码作者是敖丙？有点东西！</strong></p>
<p>你可以把它放消息队列，然后一点点消费去改库存就好了嘛，不过单个商品其实一次修改就够了，我这里说的是<strong>某个点多个商品</strong>一起秒杀的场景，像极了双十一零点。</p>
<h2 id="数据库-1"><a href="#数据库-1" class="headerlink" title="数据库"></a>数据库</h2><p>数据库用MySQL只要连接池设置合理一般问题是不大的，不过一般大公司不缺钱而且秒杀这样的活动十分频繁，我之前所在的公司就是这样秒杀特卖这样的场景一直都是不间断的。</p>
<p>单独给秒杀建立一个数据库，为秒杀服务，表的设计也是竟可能的简单点，现在的互联网架构部署都是<strong>分库</strong>的。</p>
<p>至于表就看大家怎么设计了，该设置索引的地方还是要设置索引的，建完后记得用<strong>explain</strong>看看<strong>SQL</strong>的执行计划。（不了解的小伙伴也没事，MySQL章节去康康）</p>
<h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><p><strong>这为啥我不放在后端而放到最后来讲呢？</strong></p>
<p>因为上面的任何一步都是可能出错的，而且我们是在不同的服务里面出错的，那就涉及分布式事务了，但是分布式事务大家想的是一定要成功什么的那就不对了，还是那句话，几个请求丢了就丢了，要保证时效和服务的可用可靠。</p>
<p>所以<strong>TCC</strong>和<strong>最终一致性</strong>其实不是很适合，TCC开发成本很大，所有接口都要写三次，因为涉及TCC的三个阶段。</p>
<p>最终一致性基本上都是靠轮训的操作去保证一个操作一定成功，那时效性就大打折扣了。</p>
<p>大家觉得不那么可靠的<strong>两段式（2PC）</strong>和<strong>三段式（3PC）</strong>就派上用场了，他们不一定能保证数据最终一致，但是效率上还算ok。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里我想我已经基本上把该考虑的点还有对应的解决方案也都说了一下，不知道还有没有没考虑到的，但是就算没考虑到我想我这个设计，应该也能撑住一个完整的秒杀流程。</p>
<p>最后大家再看看这个秒杀系统或许会有新的感悟，是不是一个系统真的没有大家想的那么简单，而且我还是有漏掉的细节，这是一定的。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/16/1218-JVbQcu.jpg" alt="img"></p>
<p>秒杀不一定是每个同学都会问到的，至少肯定没<strong>Redis基础</strong>那样常问，但是一旦问到，大家一定要回答到点上。</p>
<p>至少你得说出<strong>可能出现的情况</strong>，<strong>需要注意的情况</strong>，以及对于的<strong>解决思路和方案</strong>，因为这才是一个coder的基本素养，这些你不考虑你也很难去进步。</p>
<p>最后就是需要对整个链路比较熟悉，注意是一个完整的链路，前端怎么设计的呀，网关的作用呀，怎么<strong>解决Redis的并发竞争</strong>啊，<strong>数据的同步方式</strong>呀，<strong>MQ的作用</strong>啊等等，相信你会有不错的收获。</p>
<p>不知道这是一次成功还是失败的二创，我里面所有提到的技术细节我都写了对应的文章，大家可以关注我去历史文章看看，天色已晚，我溜了。</p>

      
    </div>
   <div>
        
    </div>

   
    
    
    
      

      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>

  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xuemingde.com/posts/2XZ2VHA.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.jpeg">
      <meta itemprop="name" content="meadel">
      <meta itemprop="description" content="我的愿望，世界和平">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Middle's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/2XZ2VHA.html" class="post-title-link" itemprop="url">Sentinel 万字教程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-15 00:00:00" itemprop="dateCreated datePublished" datetime="2022-04-15T00:00:00+08:00">2022-04-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-13 16:46:48" itemprop="dateModified" datetime="2022-08-13T16:46:48+08:00">2022-08-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
                </span>
            </span>

          
            <span id="/posts/2XZ2VHA.html" class="post-meta-item leancloud_visitors" data-flag-title="Sentinel 万字教程" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/posts/2XZ2VHA.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/posts/2XZ2VHA.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>原文：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvM2NDUDFKWUJWUHVBSU9SSzBwQlpaUQ==">Sentinel 万字教程<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>限流作为现在微服务中常见的稳定性措施，在面试中肯定也是经常会被问到的，我在面试的时候也经常喜欢问一下你对限流算法知道哪一些？有看过源码吗？实现原理是什么？</p>
<p>第一部分先讲讲限流算法，最后再讲讲源码的实现原理。</p>
<h1 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h1><p>关于限流的算法大体上可以分为四类：固定窗口计数器、滑动窗口计数器、漏桶(也有称漏斗，英文Leaky bucket)、令牌桶(英文Token bucket)。</p>
<h2 id="固定窗口"><a href="#固定窗口" class="headerlink" title="固定窗口"></a>固定窗口</h2><p>固定窗口，相比其他的限流算法，这应该是最简单的一种。</p>
<p>它简单地对一个固定的时间窗口内的请求数量进行计数，如果超过请求数量的阈值，将被直接丢弃。</p>
<p>这个简单的限流算法优缺点都很明显。优点的话就是简单，缺点举个例子来说。</p>
<p>比如我们下图中的黄色区域就是固定时间窗口，默认时间范围是60s，限流数量是100。</p>
<p>如图中括号内所示，前面一段时间都没有流量，刚好后面30秒内来了100个请求，此时因为没有超过限流阈值，所以请求全部通过，然后下一个窗口的20秒内同样通过了100个请求。</p>
<p>所以变相的相当于在这个括号的40秒的时间内就通过了200个请求，超过了我们限流的阈值。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/15/1020-ePDnVA.jpeg" alt="图片"></p>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>为了优化这个问题，于是有了滑动窗口算法，顾名思义，滑动窗口就是时间窗口在随着时间推移不停地移动。</p>
<p>滑动窗口把一个固定时间窗口再继续拆分成N个小窗口，然后对每个小窗口分别进行计数，所有小窗口请求之和不能超过我们设定的限流阈值。</p>
<p>以下图举例子来说，假设我们的窗口拆分成了3个小窗口，小窗口都是20s，同样基于上面的例子，当在第三个20s的时候来了100个请求，可以通过。</p>
<p>然后时间窗口滑动，下一个20s请求又来了100个请求，此时我们滑动窗口的60s范围内请求数量肯定就超过100了啊，所以请求被拒绝。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/15/1020-CGNSUR.jpeg" alt="图片"></p>
<h2 id="漏桶Leaky-bucket"><a href="#漏桶Leaky-bucket" class="headerlink" title="漏桶Leaky bucket"></a>漏桶Leaky bucket</h2><p>漏桶算法，人如其名，他就是一个漏的桶，不管请求的数量有多少，最终都会以固定的出口流量大小匀速流出，如果请求的流量超过漏桶大小，那么超出的流量将会被丢弃。</p>
<p>也就是说流量流入的速度是不定的，但是流出的速度是恒定的。</p>
<p>这个和MQ削峰填谷的思想比较类似，在面对突然激增的流量的时候，通过漏桶算法可以做到匀速排队，固定速度限流。</p>
<p>漏桶算法的优势是匀速，匀速是优点也是缺点，很多人说漏桶不能处理突增流量，这个说法并不准确。</p>
<p>漏桶本来就应该是为了处理间歇性的突增流量，流量一下起来了，然后系统处理不过来，可以在空闲的时候去处理，防止了突增流量导致系统崩溃，保护了系统的稳定性。</p>
<p>但是，换一个思路来想，其实这些突增的流量对于系统来说完全没有压力，你还在慢慢地匀速排队，其实是对系统性能的浪费。</p>
<p>所以，对于这种有场景来说，令牌桶算法比漏桶就更有优势。</p>
<h2 id="令牌桶token-bucket"><a href="#令牌桶token-bucket" class="headerlink" title="令牌桶token bucket"></a>令牌桶token bucket</h2><p>令牌桶算法是指系统以一定地速度往令牌桶里丢令牌，当一个请求过来的时候，会去令牌桶里申请一个令牌，如果能够获取到令牌，那么请求就可以正常进行，反之被丢弃。</p>
<p>现在的令牌桶算法，像Guava和Sentinel的实现都有冷启动/预热的方式，为了避免在流量激增的同时把系统打挂，令牌桶算法会在最开始一段时间内<strong>冷启动</strong>，随着流量的增加，系统会根据流量大小动态地调整生成令牌的速度，最终直到请求达到系统的阈值。</p>
<h1 id="源码举例"><a href="#源码举例" class="headerlink" title="源码举例"></a>源码举例</h1><p>我们以sentinel举例，sentinel中统计用到了滑动窗口算法，然后也有用到漏桶、令牌桶算法。</p>
<h2 id="滑动窗口-1"><a href="#滑动窗口-1" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p><code>sentinel</code>中就使用到了滑动窗口算法来进行统计，不过他的实现和我上面画的图有点不一样，实际上sentinel中的滑动窗口用一个圆形来描述更合理一点。</p>
<p>前期就是创建节点，然后slot串起来就是一个责任链模式，StatisticSlot通过滑动窗口来统计数据，FlowSlot是真正限流的逻辑，还有一些降级、系统保护的措施，最终形成了整个sentinel的限流方式。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/15/1022-Wi0ok6.jpeg" alt="图片">就看看官方图吧，这圆形画起来好恶心</p>
<p>滑动窗口的实现主要可以看<code>LeapArray</code>的代码，默认的话定义了时间窗口的相关参数。</p>
<p>对于sentinel来说其实窗口分为<strong>秒</strong>和<strong>分钟</strong>两个级别，秒的话窗口数量是2，分钟则是60个窗口，每个窗口的时间长度是1s，总的时间周期就是60s，分成60个窗口，这里我们就以分钟级别的统计来说。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LeapArray</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//窗口时间长度，毫秒数，默认1000ms</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> windowLengthInMs;</span><br><span class="line">    <span class="comment">//窗口数量，默认60</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> sampleCount;</span><br><span class="line">    <span class="comment">//毫秒时间周期，默认60*1000</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> intervalInMs;</span><br><span class="line">    <span class="comment">//秒级时间周期，默认60</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> intervalInSecond;</span><br><span class="line">    <span class="comment">//时间窗口数组</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> AtomicReferenceArray&lt;WindowWrap&lt;T&gt;&gt; array;</span><br></pre></td></tr></table></figure>
<p>然后我们要看的就是它是怎么计算出当前窗口的，其实源码里写的听清楚的，但是如果你按照之前想象把他当做一条直线延伸去想的话估计不太好理解。</p>
<p>首先计算数组索引下标和时间窗口时间这个都比较简单，难点应该大部分在于第三点窗口大于old这个是什么鬼，详细说下这几种情况。</p>
<ol>
<li>数组中的时间窗口是是空的，这个说明时间走到了我们初始化的时间之后了，此时new一个新的窗口通过CAS的方式去更新，然后返回这个新的窗口就好了。</li>
<li>第二种情况是刚好时间窗口的时间相等，那么直接返回，没啥好说的</li>
<li>第三种情况就是比较难以理解的，可以参看两条时间线的图，就比较好理解了，第一次时间窗口走完了达到1200，然后圆形时间窗口开始循环，新的时间起始位置还是1200，然后时间窗口的时间来到1676，B2的位置如果还是老的窗口那么就是600，所以我们要重置之前的时间窗口的时间为当前的时间。</li>
<li>最后一种一般情况不太可能发生，除非时钟回拨这样子</li>
</ol>
<p>从这个我们可以发现就是针对每个<code>WindowWrap</code>时间窗口都进行了统计，最后实际上在后面的几个地方都会用到时间窗口统计的QPS结果，这里就不再赘述了，知道即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">calculateTimeIdx</span><span class="params">(<span class="comment">/*@Valid*/</span> <span class="keyword">long</span> timeMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> timeId = timeMillis / windowLengthInMs;</span><br><span class="line">    <span class="comment">// Calculate current index so we can map the timestamp to the leap array.</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) (timeId % array.length());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">calculateWindowStart</span><span class="params">(<span class="comment">/*@Valid*/</span> <span class="keyword">long</span> timeMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> timeMillis - timeMillis % windowLengthInMs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> WindowWrap&lt;T&gt; <span class="title">currentWindow</span><span class="params">(<span class="keyword">long</span> timeMillis)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当前时间如果小于0，返回空</span></span><br><span class="line">    <span class="keyword">if</span> (timeMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算时间窗口的索引</span></span><br><span class="line">    <span class="keyword">int</span> idx = calculateTimeIdx(timeMillis);</span><br><span class="line">    <span class="comment">// 计算当前时间窗口的开始时间</span></span><br><span class="line">    <span class="keyword">long</span> windowStart = calculateWindowStart(timeMillis);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">//在窗口数组中获得窗口</span></span><br><span class="line">        WindowWrap&lt;T&gt; old = array.get(idx);</span><br><span class="line">        <span class="keyword">if</span> (old == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *     B0       B1      B2    NULL      B4</span></span><br><span class="line"><span class="comment">             * ||_______|_______|_______|_______|_______||___</span></span><br><span class="line"><span class="comment">             * 200     400     600     800     1000    1200  timestamp</span></span><br><span class="line"><span class="comment">             *                             ^</span></span><br><span class="line"><span class="comment">             *                          time=888</span></span><br><span class="line"><span class="comment">             * 比如当前时间是888，根据计算得到的数组窗口位置是个空，所以直接创建一个新窗口就好了</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            WindowWrap&lt;T&gt; window = <span class="keyword">new</span> WindowWrap&lt;T&gt;(windowLengthInMs, windowStart, newEmptyBucket(timeMillis));</span><br><span class="line">            <span class="keyword">if</span> (array.compareAndSet(idx, <span class="keyword">null</span>, window)) &#123;</span><br><span class="line">                <span class="comment">// Successfully updated, return the created bucket.</span></span><br><span class="line">                <span class="keyword">return</span> window;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Contention failed, the thread will yield its time slice to wait for bucket available.</span></span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (windowStart == old.windowStart()) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *     B0       B1      B2     B3      B4</span></span><br><span class="line"><span class="comment">             * ||_______|_______|_______|_______|_______||___</span></span><br><span class="line"><span class="comment">             * 200     400     600     800     1000    1200  timestamp</span></span><br><span class="line"><span class="comment">             *                             ^</span></span><br><span class="line"><span class="comment">             *                          time=888</span></span><br><span class="line"><span class="comment">             * 这个更好了，刚好等于，直接返回就行</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> old;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (windowStart &gt; old.windowStart()) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             *     B0       B1      B2     B3      B4</span></span><br><span class="line"><span class="comment">             * |_______|_______|_______|_______|_______||___</span></span><br><span class="line"><span class="comment">             * 200     400     600     800     1000    1200  timestamp</span></span><br><span class="line"><span class="comment">             *             B0       B1      B2    NULL      B4</span></span><br><span class="line"><span class="comment">             * |_______||_______|_______|_______|_______|_______||___</span></span><br><span class="line"><span class="comment">             * ...    1200     1400    1600    1800    2000    2200  timestamp</span></span><br><span class="line"><span class="comment">             *                              ^</span></span><br><span class="line"><span class="comment">             *                           time=1676</span></span><br><span class="line"><span class="comment">             * 这个要当成圆形理解就好了，之前如果是1200一个完整的圆形，然后继续从1200开始，如果现在时间是1676，落在在B2的位置，</span></span><br><span class="line"><span class="comment">             * 窗口开始时间是1600，获取到的old时间其实会是600，所以肯定是过期了，直接重置窗口就可以了</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (updateLock.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Successfully get the update lock, now we reset the bucket.</span></span><br><span class="line">                    <span class="keyword">return</span> resetWindowTo(old, windowStart);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    updateLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (windowStart &lt; old.windowStart()) &#123;</span><br><span class="line">            <span class="comment">// 这个不太可能出现，嗯。。时钟回拨</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> WindowWrap&lt;T&gt;(windowLengthInMs, windowStart, newEmptyBucket(timeMillis));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="漏桶"><a href="#漏桶" class="headerlink" title="漏桶"></a>漏桶</h2><p>sentinel主要根据<code>FlowSlot</code>中的流控进行流量控制，其中<code>RateLimiterController</code>就是漏桶算法的实现，这个实现相比其他几个还是简单多了，稍微看一下应该就明白了。</p>
<ol>
<li>首先计算出当前请求平摊到1s内的时间花费，然后去计算这一次请求预计时间</li>
<li>如果小于当前时间的话，那么以当前时间为主，返回即可</li>
<li>反之如果超过当前时间的话，这时候就要进行排队等待了，等待的时候要判断是否超过当前最大的等待时间，超过就直接丢弃</li>
<li>没有超过就更新上一次的通过时间，然后再比较一次是否超时，还超时就重置时间，反之在等待时间范围之内的话就等待，如果都不是那就可以通过了</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimiterController</span> <span class="keyword">implements</span> <span class="title">TrafficShapingController</span> </span>&#123;</span><br><span class="line">  <span class="comment">//最大等待超时时间，默认500ms</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxQueueingTimeMs;</span><br><span class="line">  <span class="comment">//限流数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> count;</span><br><span class="line">  <span class="comment">//上一次的通过时间</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong latestPassedTime = <span class="keyword">new</span> AtomicLong(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPass</span><span class="params">(Node node, <span class="keyword">int</span> acquireCount, <span class="keyword">boolean</span> prioritized)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Pass when acquire count is less or equal than 0.</span></span><br><span class="line">      <span class="keyword">if</span> (acquireCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Reject when count is less or equal than 0.</span></span><br><span class="line">      <span class="comment">// Otherwise,the costTime will be max of long and waitTime will overflow in some cases.</span></span><br><span class="line">      <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">long</span> currentTime = TimeUtil.currentTimeMillis();</span><br><span class="line">      <span class="comment">//时间平摊到1s内的花费</span></span><br><span class="line">      <span class="keyword">long</span> costTime = Math.round(<span class="number">1.0</span> * (acquireCount) / count * <span class="number">1000</span>); <span class="comment">// 1 / 100 * 1000 = 10ms</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//计算这一次请求预计的时间</span></span><br><span class="line">      <span class="keyword">long</span> expectedTime = costTime + latestPassedTime.get();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//花费时间小于当前时间，pass，最后通过时间 = 当前时间</span></span><br><span class="line">      <span class="keyword">if</span> (expectedTime &lt;= currentTime) &#123;</span><br><span class="line">          latestPassedTime.set(currentTime);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//预计通过的时间超过当前时间，要进行排队等待，重新获取一下，避免出现问题，差额就是需要等待的时间</span></span><br><span class="line">          <span class="keyword">long</span> waitTime = costTime + latestPassedTime.get() - TimeUtil.currentTimeMillis();</span><br><span class="line">          <span class="comment">//等待时间超过最大等待时间，丢弃</span></span><br><span class="line">          <span class="keyword">if</span> (waitTime &gt; maxQueueingTimeMs) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//反之，可以更新最后一次通过时间了</span></span><br><span class="line">              <span class="keyword">long</span> oldTime = latestPassedTime.addAndGet(costTime);</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  waitTime = oldTime - TimeUtil.currentTimeMillis();</span><br><span class="line">                  <span class="comment">//更新后再判断，还是超过最大超时时间，那么就丢弃，时间重置</span></span><br><span class="line">                  <span class="keyword">if</span> (waitTime &gt; maxQueueingTimeMs) &#123;</span><br><span class="line">                      latestPassedTime.addAndGet(-costTime);</span><br><span class="line">                      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">//在时间范围之内的话，就等待</span></span><br><span class="line">                  <span class="keyword">if</span> (waitTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                      Thread.sleep(waitTime);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="令牌桶"><a href="#令牌桶" class="headerlink" title="令牌桶"></a>令牌桶</h2><p>最后是令牌桶，这个不在于实现的复制，而是你看源码会发现都算的些啥玩意儿。。。sentinel的令牌桶实现基于Guava，代码在<code>WarmUpController</code>中。</p>
<p>这个算法那些各种计算逻辑其实我们可以不管（因为我也没看懂。。），但是流程上我们是清晰的就可以了。</p>
<p>几个核心的参数看注释，构造方法里那些计算逻辑暂时不管他是怎么算的（我也没整明白，但是不影响我们理解），关键看<code>canPass</code>是怎么做的。</p>
<ol>
<li>拿到当前窗口和上一个窗口的QPS</li>
<li>填充令牌，也就是往桶里丢令牌，然后我们先看填充令牌的逻辑</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WarmUpController</span> <span class="keyword">implements</span> <span class="title">TrafficShapingController</span> </span>&#123;</span><br><span class="line">    <span class="comment">//限流QPS</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">double</span> count;</span><br><span class="line">    <span class="comment">//冷启动系数，默认=3</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> coldFactor;</span><br><span class="line">    <span class="comment">//警戒的令牌数</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> warningToken = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//最大令牌数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxToken;</span><br><span class="line">    <span class="comment">//斜率，产生令牌的速度</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">double</span> slope;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储的令牌数量</span></span><br><span class="line">    <span class="keyword">protected</span> AtomicLong storedTokens = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//最后一次填充令牌时间</span></span><br><span class="line">    <span class="keyword">protected</span> AtomicLong lastFilledTime = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WarmUpController</span><span class="params">(<span class="keyword">double</span> count, <span class="keyword">int</span> warmUpPeriodInSec, <span class="keyword">int</span> coldFactor)</span> </span>&#123;</span><br><span class="line">        construct(count, warmUpPeriodInSec, coldFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WarmUpController</span><span class="params">(<span class="keyword">double</span> count, <span class="keyword">int</span> warmUpPeriodInSec)</span> </span>&#123;</span><br><span class="line">        construct(count, warmUpPeriodInSec, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">(<span class="keyword">double</span> count, <span class="keyword">int</span> warmUpPeriodInSec, <span class="keyword">int</span> coldFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (coldFactor &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Cold factor should be larger than 1&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">        <span class="keyword">this</span>.coldFactor = coldFactor;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//stableInterval 稳定产生令牌的时间周期，1/QPS</span></span><br><span class="line">        <span class="comment">//warmUpPeriodInSec 预热/冷启动时间 ,默认 10s</span></span><br><span class="line">        warningToken = (<span class="keyword">int</span>)(warmUpPeriodInSec * count) / (coldFactor - <span class="number">1</span>);</span><br><span class="line">        maxToken = warningToken + (<span class="keyword">int</span>)(<span class="number">2</span> * warmUpPeriodInSec * count / (<span class="number">1.0</span> + coldFactor));</span><br><span class="line">    <span class="comment">//斜率的计算参考Guava，当做一个固定改的公式</span></span><br><span class="line">        slope = (coldFactor - <span class="number">1.0</span>) / count / (maxToken - warningToken);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPass</span><span class="params">(Node node, <span class="keyword">int</span> acquireCount, <span class="keyword">boolean</span> prioritized)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//当前时间窗口通过的QPS</span></span><br><span class="line">        <span class="keyword">long</span> passQps = (<span class="keyword">long</span>) node.passQps();</span><br><span class="line">        <span class="comment">//上一个时间窗口QPS</span></span><br><span class="line">        <span class="keyword">long</span> previousQps = (<span class="keyword">long</span>) node.previousPassQps();</span><br><span class="line">        <span class="comment">//填充令牌</span></span><br><span class="line">        syncToken(previousQps);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始计算它的斜率</span></span><br><span class="line">        <span class="comment">// 如果进入了警戒线，开始调整他的qps</span></span><br><span class="line">        <span class="keyword">long</span> restToken = storedTokens.get();</span><br><span class="line">        <span class="keyword">if</span> (restToken &gt;= warningToken) &#123;</span><br><span class="line">            <span class="comment">//当前的令牌超过警戒线，获得超过警戒线的令牌数</span></span><br><span class="line">            <span class="keyword">long</span> aboveToken = restToken - warningToken;</span><br><span class="line">            <span class="comment">// 消耗的速度要比warning快，但是要比慢</span></span><br><span class="line">            <span class="comment">// current interval = restToken*slope+1/count</span></span><br><span class="line">            <span class="keyword">double</span> warningQps = Math.nextUp(<span class="number">1.0</span> / (aboveToken * slope + <span class="number">1.0</span> / count));</span><br><span class="line">            <span class="keyword">if</span> (passQps + acquireCount &lt;= warningQps) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (passQps + acquireCount &lt;= count) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>填充令牌的逻辑如下：</p>
<ol>
<li>拿到当前的时间，然后去掉毫秒数，得到的就是秒级时间</li>
<li>判断时间小于这里就是为了控制每秒丢一次令牌</li>
<li>然后就是<code>coolDownTokens</code>去计算我们的冷启动/预热是怎么计算填充令牌的</li>
<li>后面计算当前剩下的令牌数这个就不说了，减去上一次消耗的就是桶里剩下的令牌</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">syncToken</span><span class="params">(<span class="keyword">long</span> passQps)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> currentTime = TimeUtil.currentTimeMillis();</span><br><span class="line">  <span class="comment">//去掉当前时间的毫秒</span></span><br><span class="line">  currentTime = currentTime - currentTime % <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">long</span> oldLastFillTime = lastFilledTime.get();</span><br><span class="line">  <span class="comment">//控制每秒填充一次令牌</span></span><br><span class="line">  <span class="keyword">if</span> (currentTime &lt;= oldLastFillTime) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//当前的令牌数量</span></span><br><span class="line">  <span class="keyword">long</span> oldValue = storedTokens.get();</span><br><span class="line">  <span class="comment">//获取新的令牌数量，包含添加令牌的逻辑，这就是预热的逻辑</span></span><br><span class="line">  <span class="keyword">long</span> newValue = coolDownTokens(currentTime, passQps);</span><br><span class="line">  <span class="keyword">if</span> (storedTokens.compareAndSet(oldValue, newValue)) &#123;</span><br><span class="line">    <span class="comment">//存储的令牌数量当然要减去上一次消耗的令牌</span></span><br><span class="line">    <span class="keyword">long</span> currentValue = storedTokens.addAndGet(<span class="number">0</span> - passQps);</span><br><span class="line">    <span class="keyword">if</span> (currentValue &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      storedTokens.set(<span class="number">0L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    lastFilledTime.set(currentTime);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>最开始的事实因为<code>lastFilledTime</code>和<code>oldValue</code>都是0，所以根据当前时间戳会得到一个非常大的数字，最后和<code>maxToken</code>取小的话就得到了最大的令牌数，所以第一次初始化的时候就会生成<code>maxToken</code>的令牌</li>
<li>之后我们假设系统的QPS一开始很低，然后突然飙高。所以开始的时候回一直走到高于警戒线的逻辑里去，然后<code>passQps</code>又很低，所以会一直处于把令牌桶填满的状态（<code>currentTime - lastFilledTime.get()</code>会一直都是1000，也就是1秒），所以每次都会填充最大QPS<code>count</code>数量的令牌</li>
<li>然后突增流量来了，QPS瞬间很高，慢慢地令牌数量就会消耗到警戒线之下，走到我们<code>if</code>的逻辑里去，然后去按照<code>count</code>数量增加令牌</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">coolDownTokens</span><span class="params">(<span class="keyword">long</span> currentTime, <span class="keyword">long</span> passQps)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> oldValue = storedTokens.get();</span><br><span class="line">  <span class="keyword">long</span> newValue = oldValue;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//水位低于警戒线，就生成令牌</span></span><br><span class="line">  <span class="keyword">if</span> (oldValue &lt; warningToken) &#123;</span><br><span class="line">    <span class="comment">//如果桶中令牌低于警戒线，根据上一次的时间差，得到新的令牌数，因为去掉了毫秒，1秒生成的令牌就是阈值count</span></span><br><span class="line">    <span class="comment">//第一次都是0的话，会生成count数量的令牌</span></span><br><span class="line">    newValue = (<span class="keyword">long</span>)(oldValue + (currentTime - lastFilledTime.get()) * count / <span class="number">1000</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldValue &gt; warningToken) &#123;</span><br><span class="line">    <span class="comment">//反之，如果是高于警戒线，要判断QPS。因为QPS越高，生成令牌就要越慢，QPS低的话生成令牌要越快</span></span><br><span class="line">    <span class="keyword">if</span> (passQps &lt; (<span class="keyword">int</span>)count / coldFactor) &#123;</span><br><span class="line">      newValue = (<span class="keyword">long</span>)(oldValue + (currentTime - lastFilledTime.get()) * count / <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//不要超过最大令牌数</span></span><br><span class="line">  <span class="keyword">return</span> Math.min(newValue, maxToken);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的逻辑理顺之后，我们就可以继续看限流的部分逻辑：</p>
<ol>
<li>令牌计算的逻辑完成，然后判断是不是超过警戒线，按照上面的说法，低QPS的状态肯定是一直超过的，所以会根据斜率来计算出一个<code>warningQps</code>，因为我们处于冷启动的状态，所以这个阶段就是要根据斜率来计算出一个QPS数量，让流量慢慢地达到系统能承受的峰值。举个例子，如果<code>count</code>是100，那么在QPS很低的情况下，令牌桶一直处于满状态，但是系统会控制QPS，实际通过的QPS就是<code>warningQps</code>，根据算法可能只有10或者20（怎么算的不影响理解）。QPS主键提高的时候，<code>aboveToken</code>再逐渐变小，整个<code>warningQps</code>就在逐渐变大，直到走到警戒线之下，到了<code>else</code>逻辑里。</li>
<li>流量突增的情况，就是<code>else</code>逻辑里低于警戒线的情况，我们令牌桶在不停地根据<code>count</code>去增加令牌，这时候消耗令牌的速度超过我们生成令牌的速度，可能就会导致一直处于警戒线之下，这时候判断当然就需要根据最高QPS去判断限流了。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> restToken = storedTokens.get();</span><br><span class="line"><span class="keyword">if</span> (restToken &gt;= warningToken) &#123;</span><br><span class="line"> <span class="comment">//当前的令牌超过警戒线，获得超过警戒线的令牌数</span></span><br><span class="line"> <span class="keyword">long</span> aboveToken = restToken - warningToken;</span><br><span class="line"> <span class="comment">// 消耗的速度要比warning快，但是要比慢</span></span><br><span class="line"> <span class="comment">// current interval = restToken*slope+1/count</span></span><br><span class="line"> <span class="keyword">double</span> warningQps = Math.nextUp(<span class="number">1.0</span> / (aboveToken * slope + <span class="number">1.0</span> / count));</span><br><span class="line"> <span class="keyword">if</span> (passQps + acquireCount &lt;= warningQps) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (passQps + acquireCount &lt;= count) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，按照低QPS到突增高QPS的流程，来想象一下这个过程：</p>
<ol>
<li>刚开始，系统的QPS非常低，初始化我们就直接把令牌桶塞满了</li>
<li>然后这个低QPS的状态持续了一段时间，因为我们一直会填充最大QPS数量的令牌（因为取最小值，所以其实桶里令牌基本不会有变化），所以令牌桶一直处于满的状态，整个系统的限流也处于一个比较低的水平</li>
</ol>
<blockquote>
<p>这以上的部分一直处于警戒线之上，实际上就是叫做冷启动/预热的过程。</p>
</blockquote>
<ol>
<li><p>接着系统的QPS突然激增，令牌消耗速度太快，就算我们每次增加最大QPS数量的令牌任然无法维持消耗，所以桶里的令牌在不断低减少，这个时候，冷启动阶段的限制QPS也在不断地提高，最后直到桶里的令牌低于警戒线</p>
</li>
<li><p>低于警戒线之后，系统就会按照最高QPS去限流，这个过程就是系统在逐渐达到最高限流的过程</p>
</li>
</ol>
<blockquote>
<p>那这样一来，实际就达到了我们处理突增流量的目的，整个系统在漫漫地适应突然飙高的QPS，然后最终达到系统的QPS阈值。</p>
</blockquote>
<ol>
<li>最后，如果QPS回复正常，那么又会逐渐回到警戒线之上，就回到了最开始的过程。</li>
</ol>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/15/1023-CBruaZ.jpeg" alt="图片"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>因为算法如果单独说的话都比较简单，一说大家都可以听明白，不需要几个字就能说明白，所以还是得弄点源码看看别人是怎么玩的，所以尽管我很讨厌放源码，但是还是不得不干。</p>
<p>光靠别人说一点其实有点看不明白，按照顺序读一遍的话心里就有数了。</p>
<p>那源码的话最难以理解的就是令牌桶的实现了，说实话那几个计算的逻辑我看了好几遍不知道他算的什么鬼，但是思想我们理解就行了，其他的逻辑相对来说就比较容易理解。</p>

      
    </div>
   <div>
        
    </div>

   
    
    
    
      

      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>

  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xuemingde.com/posts/5HB0NA.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.jpeg">
      <meta itemprop="name" content="meadel">
      <meta itemprop="description" content="我的愿望，世界和平">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Middle's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/5HB0NA.html" class="post-title-link" itemprop="url">分布式锁的多种实现</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-14 00:00:00" itemprop="dateCreated datePublished" datetime="2022-04-14T00:00:00+08:00">2022-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-13 16:46:48" itemprop="dateModified" datetime="2022-08-13T16:46:48+08:00">2022-08-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">分布式</span></a>
                </span>
            </span>

          
            <span id="/posts/5HB0NA.html" class="post-meta-item leancloud_visitors" data-flag-title="分布式锁的多种实现" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/posts/5HB0NA.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/posts/5HB0NA.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.7k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>原文：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MveFFrbmQ2eHNWRFBCcjRUYkVUVGsyQQ==">聊聊分布式锁的多种实现！<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>今天跟大家探讨一下分布式锁的设计与实现。希望对大家有帮助，如果有不正确的地方，欢迎指出。</p>
<h2 id="分布式锁概述"><a href="#分布式锁概述" class="headerlink" title="分布式锁概述"></a>分布式锁概述</h2><p>我们的系统都是分布式部署的，日常开发中，<strong>秒杀下单、抢购商品</strong>等等业务场景，为了防⽌库存超卖，都需要用到<strong>分布式锁</strong>。</p>
<blockquote>
<p>分布式锁其实就是，控制分布式系统不同进程共同访问共享资源的一种锁的实现。如果不同的系统或同一个系统的不同主机之间共享了某个临界资源，往往需要互斥来防止彼此干扰，以保证一致性。</p>
</blockquote>
<p>业界流行的分布式锁实现，一般有这3种方式：</p>
<ul>
<li>基于数据库实现的分布式锁</li>
<li>基于Redis实现的分布式锁</li>
<li>基于Zookeeper实现的分布式锁</li>
</ul>
<h2 id="基于数据库的分布式锁"><a href="#基于数据库的分布式锁" class="headerlink" title="基于数据库的分布式锁"></a>基于数据库的分布式锁</h2><h3 id="数据库悲观锁实现的分布式锁"><a href="#数据库悲观锁实现的分布式锁" class="headerlink" title="数据库悲观锁实现的分布式锁"></a>数据库悲观锁实现的分布式锁</h3><p>可以使用<code>select ... for update</code>来实现分布式锁。我们自己的项目，<strong>分布式定时任务</strong>，就使用类似的实现方案，我给大家来展示个<strong>简单版的哈</strong></p>
<p>表结构如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `t_resource_lock` (</span><br><span class="line">  `key_resource` varchar(<span class="number">45</span>) COLLATE utf8_bin NOT NULL DEFAULT <span class="string">&#x27;资源主键&#x27;</span>,</span><br><span class="line">  `status` <span class="keyword">char</span>(<span class="number">1</span>) COLLATE utf8_bin NOT NULL DEFAULT <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;S,F,P&#x27;</span>,</span><br><span class="line">  `lock_flag` <span class="keyword">int</span>(<span class="number">10</span>) unsigned NOT NULL DEFAULT <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;1是已经锁 0是未锁&#x27;</span>,</span><br><span class="line">  `begin_time` datetime DEFAULT NULL COMMENT <span class="string">&#x27;开始时间&#x27;</span>,</span><br><span class="line">  `end_time` datetime DEFAULT NULL COMMENT <span class="string">&#x27;结束时间&#x27;</span>,</span><br><span class="line">  `client_ip` varchar(<span class="number">45</span>) COLLATE utf8_bin NOT NULL DEFAULT <span class="string">&#x27;抢到锁的IP&#x27;</span>,</span><br><span class="line">  `time` <span class="keyword">int</span>(<span class="number">10</span>) unsigned NOT NULL DEFAULT <span class="string">&#x27;60&#x27;</span> COMMENT <span class="string">&#x27;方法生命周期内只允许一个结点获取一次锁，单位：分钟&#x27;</span>,</span><br><span class="line">  <span class="function">PRIMARY <span class="title">KEY</span> <span class="params">(`key_resource`)</span> USING BTREE</span></span><br><span class="line"><span class="function">) ENGINE</span>=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin</span><br></pre></td></tr></table></figure>
<p>加锁<code>lock</code>方法的伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transcational</span> <span class="comment">//一定要加事务</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String keyResource，<span class="keyword">int</span> time)</span></span>&#123;</span><br><span class="line">   resourceLock = &#x27;select * from t_resource_lock where key_resource =&#x27;#&#123;keySource&#125;&#x27; for update&#x27;;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(resourceLock==<span class="keyword">null</span>)&#123;</span><br><span class="line">      <span class="comment">//插入锁的数据</span></span><br><span class="line">      resourceLock = <span class="keyword">new</span> ResourceLock();</span><br><span class="line">      resourceLock.setTime(time);</span><br><span class="line">      resourceLock.setLockFlag(<span class="number">1</span>);  <span class="comment">//上锁</span></span><br><span class="line">      resourceLock.setStatus(P); <span class="comment">//处理中</span></span><br><span class="line">      resourceLock.setBeginTime(<span class="keyword">new</span> Date());</span><br><span class="line">      <span class="keyword">int</span> count = <span class="string">&quot;insert into resourceLock&quot;</span>; </span><br><span class="line">      <span class="keyword">if</span>(count==<span class="number">1</span>)&#123;</span><br><span class="line">         <span class="comment">//获取锁成功</span></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;<span class="keyword">catch</span>(Exception x)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//没上锁并且锁已经超时，即可以获取锁成功</span></span><br><span class="line">   <span class="keyword">if</span>(resourceLock.getLockFlag==<span class="string">&#x27;0&#x27;</span>&amp;&amp;<span class="string">&#x27;S&#x27;</span>.equals(resourceLock.getstatus)</span><br><span class="line">    &amp;&amp; <span class="keyword">new</span> Date()&gt;=resourceLock.addDateTime(resourceLock.getBeginTime(,time))&#123;</span><br><span class="line">      resourceLock.setLockFlag(<span class="number">1</span>);  <span class="comment">//上锁</span></span><br><span class="line">      resourceLock.setStatus(P); <span class="comment">//处理中</span></span><br><span class="line">      resourceLock.setBeginTime(<span class="keyword">new</span> Date());</span><br><span class="line">      <span class="comment">//update resourceLock;</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">new</span> Date()&gt;=resourceLock.addDateTime(resourceLock.getBeginTime(,time))&#123;</span><br><span class="line">     <span class="comment">//超时未正常执行结束,获取锁失败</span></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解锁<code>unlock</code>方法的伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">(String v，status)</span></span>&#123;</span><br><span class="line">      resourceLock.setLockFlag(<span class="number">0</span>);  <span class="comment">//解锁</span></span><br><span class="line">      resourceLock.setStatus(status); S:表示成功，F表示失败</span><br><span class="line">      <span class="comment">//update resourceLock;</span></span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(lock(keyResource,time))&#123; <span class="comment">//加锁</span></span><br><span class="line">   status = process();<span class="comment">//你的业务逻辑处理。</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">    unlock(keyResource,status); <span class="comment">//释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实这个悲观锁实现的分布式锁，整体的流程还是比较清晰的。就是先<code>select ... for update</code>锁住主键<code>key_resource</code>那个记录，如果为空，则可以插入一条记录，如果已有记录判断下<strong>状态和时间</strong>，<strong>是否已经超时</strong>。这里需要注意一下哈，必须要加<strong>事务</strong>哈。</p>
<h3 id="数据库乐观锁实现的分布式锁"><a href="#数据库乐观锁实现的分布式锁" class="headerlink" title="数据库乐观锁实现的分布式锁"></a>数据库乐观锁实现的分布式锁</h3><p>除了悲观锁，还可以用<strong>乐观锁实现分布式锁</strong>。乐观锁，顾名思义，就是很乐观，每次更新操作，都觉得不会存在并发冲突，只有更新失败后，才重试。它是基于CAS思想实现的。我以前的公司，<strong>扣减余额</strong>就是用这种方案。</p>
<blockquote>
<p>搞个version字段，每次更新修改，都会自增加一，然后去更新余额时，把查出来的那个版本号，带上条件去更新，如果是上次那个版本号，就更新，如果不是，表示别人并发修改过了，就继续重试。</p>
</blockquote>
<p>大概流程如下：</p>
<ol>
<li>查询版本号和余额</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> version,balance <span class="keyword">from</span> account <span class="keyword">where</span> user_id <span class="operator">=</span><span class="string">&#x27;666&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>假设查到版本号是oldVersion=1.</p>
<ol>
<li>逻辑处理，判断余额</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(balance&lt;扣减金额)&#123;</span><br><span class="line">   <span class="keyword">return</span>；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">left_balance = balance - 扣减金额;</span><br></pre></td></tr></table></figure>
<ol>
<li>进行扣减余额</li>
</ol>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update account set balance = #&#123;left_balance&#125; ,version = version+1 where version </span><br><span class="line">= #&#123;oldVersion&#125; and balance&gt;= #&#123;left_balance&#125; and user_id =&#x27;666&#x27;;</span><br></pre></td></tr></table></figure>
<p>大家可以看下这个流程图哈：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/14/1045-RjWzaR.png" alt="图片"></p>
<p>这种方式适合<strong>并发不高</strong>的场景，一般需要设置一下重试的次数</p>
<h2 id="基于Redis实现的分布式锁"><a href="#基于Redis实现的分布式锁" class="headerlink" title="基于Redis实现的分布式锁"></a>基于Redis实现的分布式锁</h2><p>Redis分布式锁一般有以下这几种实现方式：</p>
<ul>
<li>setnx + expire</li>
<li>setnx + value值是过期时间</li>
<li>set的扩展命令（set ex px nx）</li>
<li>set ex px nx + 校验唯一随机值,再删除</li>
<li>Redisson</li>
<li>Redisson + RedLock</li>
</ul>
<h3 id="setnx-expire"><a href="#setnx-expire" class="headerlink" title="setnx + expire"></a>setnx + expire</h3><p>聊到Redis分布式锁，很多小伙伴反手就是<code>setnx + expire</code>，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>（jedis.setnx(key,lock_value) == <span class="number">1</span>）&#123; <span class="comment">//setnx加锁</span></span><br><span class="line">    expire（key，<span class="number">100</span>）; <span class="comment">//设置过期时间</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> something  <span class="comment">//业务处理</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">       jedis.del(key); <span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码是可以加锁成功，但是你有没有发现问题，<strong>加锁操作和设置超时时间是分开的</strong>。假设在执行完<code>setnx</code>加锁后，正要执行<code>expire</code>设置过期时间时，进程<code>crash</code>掉或者要重启维护了，那这个锁就<strong>长生不老</strong>了，别的线程永远获取不到锁啦，所以<strong>分布式锁不能这么实现</strong>！</p>
<h3 id="setnx-value值是过期时间"><a href="#setnx-value值是过期时间" class="headerlink" title="setnx + value值是过期时间"></a>setnx + value值是过期时间</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> expires = System.currentTimeMillis() + expireTime; <span class="comment">//系统时间+设置的过期时间</span></span><br><span class="line">String expiresStr = String.valueOf(expires);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果当前锁不存在，返回加锁成功</span></span><br><span class="line"><span class="keyword">if</span> (jedis.setnx(key, expiresStr) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 如果锁已经存在，获取锁的过期时间</span></span><br><span class="line">String currentValueStr = jedis.get(key);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果获取到的过期时间，小于系统当前时间，表示已经过期</span></span><br><span class="line"><span class="keyword">if</span> (currentValueStr != <span class="keyword">null</span> &amp;&amp; Long.parseLong(currentValueStr) &lt; System.currentTimeMillis()) &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 锁已过期，获取上一个锁的过期时间，并设置现在锁的过期时间（不了解redis的getSet命令的小伙伴，可以去官网看下哈）</span></span><br><span class="line">    String oldValueStr = jedis.getSet(key, expiresStr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (oldValueStr != <span class="keyword">null</span> &amp;&amp; oldValueStr.equals(currentValueStr)) &#123;</span><br><span class="line">         <span class="comment">// 考虑多线程并发的情况，只有一个线程的设置值和当前值相同，它才可以加锁</span></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//其他情况，均返回加锁失败</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>日常开发中，有些小伙伴就是这么实现分布式锁的，但是会有这些<strong>缺点</strong>：</p>
<ul>
<li>过期时间是客户端自己生成的，分布式环境下，<strong>每个客户端的时间必须同步。</strong></li>
<li>没有保存持有者的唯一标识，<strong>可能被别的客户端释放/解锁</strong>。</li>
<li>锁过期的时候，并发多个客户端同时请求过来，都执行了<code>jedis.getSet()</code>，最终只能有一个客户端加锁成功，但是该客户端锁的过期时间，<strong>可能被别的客户端覆盖。</strong></li>
</ul>
<h3 id="set的扩展命令-set-ex-px-nx"><a href="#set的扩展命令-set-ex-px-nx" class="headerlink" title="set的扩展命令(set ex px nx)"></a>set的扩展命令(set ex px nx)</h3><p>这个命令的几个参数分别表示什么意思呢？跟大家复习一下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET key value <span class="selector-attr">[EX seconds]</span> <span class="selector-attr">[PX milliseconds]</span> <span class="selector-attr">[NX|XX]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>EX second ：设置键的过期时间为<code>second</code>秒。</li>
<li>PX millisecond ：设置键的过期时间为<code>millisecond</code>毫秒。</li>
<li>NX ：只在键不存在时，才对键进行设置操作。</li>
<li>XX ：只在键已经存在时，才对键进行设置操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>（jedis.set(key, lock_value, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;EX&quot;</span>, 100s) == <span class="number">1</span>）&#123; <span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> something  <span class="comment">//业务处理</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">       jedis.del(key); <span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方案可能存在这样的问题：</p>
<ul>
<li>锁过期释放了，业务还没执行完。</li>
<li>锁被别的线程误删。</li>
</ul>
<p>有些伙伴可能会有个疑问，就是<strong>锁为什么会被别的线程误删</strong>呢？假设并发多线程场景下，<strong>线程A获得了锁，但是它没释放锁的话，线程B是获取不到锁的</strong>，所以按道理它是执行不到加锁下面的代码滴，怎么会导致锁被别的线程误删呢？</p>
<blockquote>
<p>假设线程A和B，都想用<code>key</code>加锁，最后A抢到锁加锁成功，但是由于执行业务逻辑的耗时很长，超过了设置的超时时间<code>100s</code>。这时候，Redis就自动释放了<code>key</code>锁。这时候线程B就可以加锁成功了，接下啦，它也执行业务逻辑处理。假设碰巧这时候，A执行完自己的业务逻辑，它就去释放锁，但是它就把B的锁给释放了。</p>
</blockquote>
<h3 id="set-ex-px-nx-校验唯一随机值-再删除"><a href="#set-ex-px-nx-校验唯一随机值-再删除" class="headerlink" title="set ex px nx + 校验唯一随机值,再删除"></a>set ex px nx + 校验唯一随机值,再删除</h3><p>为了解决<strong>锁被别的线程误删</strong>问题。可以在<code>set ex px nx</code>的基础上，加上个校验的唯一随机值，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>（jedis.set(key, uni_request_id, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;EX&quot;</span>, 100s) == <span class="number">1</span>）&#123; <span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> something  <span class="comment">//业务处理</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">       <span class="comment">//判断是不是当前线程加的锁,是才释放</span></span><br><span class="line">       <span class="keyword">if</span> (uni_request_id.equals(jedis.get(key))) &#123;</span><br><span class="line">          jedis.del(key); <span class="comment">//释放锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，判断当前线程加的锁和释放锁<strong>不是一个原子操作</strong>。如果调用<code>jedis.del()</code>释放锁的时候，可能<strong>这把锁已经不属于当前客户端</strong>，会解除他人加的锁。</p>
<p>一般可以用lua脚本来包一下。lua脚本如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&#x27;get&#x27;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] then </span><br><span class="line">   <span class="keyword">return</span> redis.call(<span class="string">&#x27;del&#x27;</span>,KEYS[<span class="number">1</span>]) </span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
<p>这种方式比较不错了，一般情况下，已经可以使用这种实现方式。但是还是存在：<strong>锁过期释放了，业务还没执行完的问题</strong>。</p>
<h3 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h3><p>对于可能存在<strong>锁过期释放，业务没执行完</strong>的问题。我们可以稍微把锁过期时间设置长一些，大于正常业务处理时间就好啦。如果你觉得不是很稳，还可以给获得锁的线程，开启一个定时守护线程，每隔一段时间检查锁是否还存在，存在则对锁的过期时间延长，防止锁过期提前释放。</p>
<p>当前开源框架Redisson解决了这个问题。可以看下Redisson底层原理图：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/14/1048-36291O.png" alt="图片"></p>
<p>只要线程一加锁成功，就会启动一个<code>watch dog</code>看门狗，它是一个后台线程，会每隔10秒检查一下，如果线程1还持有锁，那么就会不断的延长锁key的生存时间。因此，Redisson就是使用<code>watch dog</code>解决了<strong>锁过期释放，业务没执行完问题</strong>。</p>
<h3 id="Redisson-RedLock"><a href="#Redisson-RedLock" class="headerlink" title="Redisson + RedLock"></a>Redisson + RedLock</h3><p>前面六种方案都只是基于<strong>Redis单机版</strong>的分布式锁讨论，还不是很完美。因为<strong>Redis</strong>一般都是集群部署的：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/14/1049-gDgwyU.png" alt="图片"></p>
<p>如果线程一在<code>Redis</code>的<code>master</code>节点上拿到了锁，但是加锁的<code>key</code>还没同步到<code>slave</code>节点。恰好这时，<code>master</code>节点发生故障，一个<code>slave</code>节点就会升级为<code>master</code>节点。线程二就可以顺理成章获取同个<code>key</code>的锁啦，但线程一也已经拿到锁了，锁的安全性就没了。</p>
<p>为了解决这个问题，Redis作者antirez提出一种高级的分布式锁算法：<strong>Redlock</strong>。它的核心思想是这样的：</p>
<blockquote>
<p>部署多个Redis master，以保证它们不会同时宕掉。并且这些master节点是完全相互独立的，相互之间不存在数据同步。同时，需要确保在这多个master实例上，是与在Redis单实例，使用相同方法来获取和释放锁。</p>
</blockquote>
<p>我们假设当前有5个Redis master节点，在5台服务器上面运行这些Redis实例。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/14/1049-Haarab.png" alt="图片">RedLock的实现步骤:</p>
<ol>
<li>获取当前时间，以毫秒为单位。</li>
<li>按顺序向5个master节点请求加锁。客户端设置网络连接和响应超时时间，并且超时时间要小于锁的失效时间。（假设锁自动失效时间为10秒，则超时时间一般在5-50毫秒之间,我们就假设超时时间是50ms吧）。如果超时，跳过该master节点，尽快去尝试下一个master节点。</li>
<li>客户端使用当前时间减去开始获取锁时间（即步骤1记录的时间），得到获取锁使用的时间。当且仅当超过一半（N/2+1，这里是5/2+1=3个节点）的Redis master节点都获得锁，并且使用的时间小于锁失效时间时，锁才算获取成功。（如上图，10s&gt;  30ms+40ms+50ms+4m0s+50ms）</li>
<li>如果取到了锁，key的真正有效时间就变啦，需要减去获取锁所使用的时间。</li>
<li>如果获取锁失败（没有在至少N/2+1个master实例取到锁，有或者获取锁时间已经超过了有效时间），客户端要在所有的master节点上解锁（即便有些master节点根本就没有加锁成功，也需要解锁，以防止有些漏网之鱼）。</li>
</ol>
<p>简化下步骤就是：</p>
<ul>
<li>按顺序向5个master节点请求加锁</li>
<li>根据设置的超时时间来判断，是不是要跳过该master节点。</li>
<li>如果大于等于3个节点加锁成功，并且使用的时间小于锁的有效期，即可认定加锁成功啦。</li>
<li>如果获取锁失败，解锁！</li>
</ul>
<p><strong>Redisson实现了redLock版本的锁</strong>，有兴趣的小伙伴，可以去了解一下哈~</p>
<h2 id="Zookeeper分布式锁"><a href="#Zookeeper分布式锁" class="headerlink" title="Zookeeper分布式锁"></a>Zookeeper分布式锁</h2><p>在学习Zookeeper分布式锁之前，我们复习一下Zookeeper的节点哈。</p>
<p>Zookeeper的节点Znode有四种类型：</p>
<ul>
<li><strong>持久节点</strong>：默认的节点类型。创建节点的客户端与zookeeper断开连接后，该节点依旧存在。</li>
<li><strong>持久节点顺序节点</strong>：所谓顺序节点，就是在创建节点时，Zookeeper根据创建的时间顺序给该节点名称进行编号，持久节点顺序节点就是有顺序的持久节点。</li>
<li><strong>临时节点</strong>：和持久节点相反，当创建节点的客户端与zookeeper断开连接后，临时节点会被删除。</li>
<li><strong>临时顺序节点</strong>：有顺序的临时节点。</li>
</ul>
<p>Zookeeper分布式锁实现应用了<strong>临时顺序节点</strong>。这里不贴代码啦，来讲下zk分布式锁的实现原理吧。</p>
<h3 id="zk获取锁过程"><a href="#zk获取锁过程" class="headerlink" title="zk获取锁过程"></a>zk获取锁过程</h3><p>当第一个客户端请求过来时，Zookeeper客户端会创建一个持久节点<code>locks</code>。如果它（Client1）想获得锁，需要在<code>locks</code>节点下创建一个顺序节点<code>lock1</code>.如图</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/14/1050-2C4s2m.png" alt="图片"></p>
<p>接着，客户端Client1会查找<code>locks</code>下面的所有临时顺序子节点，判断自己的节点<code>lock1</code>是不是排序最小的那一个，如果是，则成功获得锁。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/14/1050-gQdpgQ.png" alt="图片"></p>
<p>这时候如果又来一个客户端client2前来尝试获得锁，它会在locks下再创建一个临时节点<code>lock2</code></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/14/1050-PdvZVL.png" alt="图片"></p>
<p>客户端client2一样也会查找locks下面的所有临时顺序子节点，判断自己的节点lock2是不是最小的，此时，发现lock1才是最小的，于是获取锁失败。获取锁失败，它是不会甘心的，client2向它排序靠前的节点lock1注册Watcher事件，用来监听lock1是否存在，也就是说client2抢锁失败进入等待状态。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/14/1050-LLJtgZ.png" alt="图片"></p>
<p>此时，如果再来一个客户端Client3来尝试获取锁，它会在locks下再创建一个临时节点lock3</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/14/1050-XF3UAP.png" alt="图片">同样的，client3一样也会查找locks下面的所有临时顺序子节点，判断自己的节点lock3是不是最小的，发现自己不是最小的，就获取锁失败。它也是不会甘心的，它会向在它前面的节点lock2注册Watcher事件，以监听lock2节点是否存在。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/14/1050-s2ziYm.png" alt="图片"></p>
<h3 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h3><p>我们再来看看释放锁的流程，Zookeeper的客户端业务完成或者发生故障，都会删除临时节点，释放锁。如果是任务完成，Client1会显式调用删除lock1的指令</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/14/1052-nsRn3o.png" alt="图片"></p>
<p>如果是客户端故障了，根据临时节点得特性，lock1是会自动删除的</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/14/1052-A6pioo.png" alt="图片"></p>
<p>lock1节点被删除后，Client2可开心了，因为它一直监听着lock1。lock1节点删除，Client2立刻收到通知，也会查找locks下面的所有临时顺序子节点，发下lock2是最小，就获得锁。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/14/1052-MUDBMt.png" alt="图片"></p>
<p>同理，Client2获得锁之后，Client3也对它虎视眈眈，啊哈哈~</p>
<ul>
<li>Zookeeper设计定位就是分布式协调，简单易用。如果获取不到锁，只需添加一个监听器即可，很适合做分布式锁。</li>
<li>Zookeeper作为分布式锁也缺点：如果有很多的客户端频繁的申请加锁、释放锁，对于Zookeeper集群的压力会比较大。</li>
</ul>
<h2 id="三种分布式锁对比"><a href="#三种分布式锁对比" class="headerlink" title="三种分布式锁对比"></a>三种分布式锁对比</h2><p><strong>数据库分布式锁实现</strong></p>
<p>优点：</p>
<ul>
<li>简单，使用方便，不需要引入<code>Redis、zookeeper</code>等中间件。</li>
</ul>
<p>缺点：</p>
<ul>
<li>不适合高并发的场景</li>
<li>db操作性能较差；</li>
</ul>
<p><strong>Redis分布式锁实现</strong></p>
<p>优点：</p>
<ul>
<li>性能好，适合高并发场景</li>
<li>较轻量级</li>
<li>有较好的框架支持，如Redisson</li>
</ul>
<p>缺点：</p>
<ul>
<li>过期时间不好控制</li>
<li>需要考虑锁被别的线程误删场景</li>
</ul>
<p><strong>Zookeeper分布式锁实现</strong></p>
<p>缺点：</p>
<ul>
<li>性能不如redis实现的分布式锁</li>
<li>比较重的分布式锁。</li>
</ul>
<p>优点：</p>
<ul>
<li>有较好的性能和可靠性</li>
<li>有封装较好的框架，如Curator</li>
</ul>
<p><strong>对比汇总</strong></p>
<blockquote>
<ul>
<li>从性能角度（从高到低）Redis &gt; Zookeeper &gt;= 数据库；</li>
<li>从理解的难易程度角度（从低到高）数据库 &gt; Redis &gt; Zookeeper；</li>
<li>从实现的复杂性角度（从低到高）Zookeeper &gt; Redis &gt; 数据库；</li>
<li>从可靠性角度（从高到低）Zookeeper &gt; Redis &gt; 数据库。</li>
</ul>
</blockquote>

      
    </div>
   <div>
        
    </div>

   
    
    
    
      

      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>

  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xuemingde.com/posts/1F4BTHB.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.jpeg">
      <meta itemprop="name" content="meadel">
      <meta itemprop="description" content="我的愿望，世界和平">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Middle's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/1F4BTHB.html" class="post-title-link" itemprop="url">搞懂 Nginx 高性能网络工作原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-04-13 00:00:00" itemprop="dateCreated datePublished" datetime="2022-04-13T00:00:00+08:00">2022-04-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-07 09:14:52" itemprop="dateModified" datetime="2023-06-07T09:14:52+08:00">2023-06-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/" itemprop="url" rel="index"><span itemprop="name">网络通信</span></a>
                </span>
            </span>

          
            <span id="/posts/1F4BTHB.html" class="post-meta-item leancloud_visitors" data-flag-title="搞懂 Nginx 高性能网络工作原理" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/posts/1F4BTHB.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/posts/1F4BTHB.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>13k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>12 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在单进程的网络编程模型中。所有的网络相关的动作都是在一个进程里完成的，如监听 socket 的创建， bind、listen。再比如 epoll 的创建、要监听事件的添加，以及 epoll_wait 等待时间发生。这些统统都是在一个进程里搞定。</p>
<p>一个客户端和使用了 epoll 的服务端的交互过程如下图所示。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/13/1053-dlCnp7.png" alt="图片"></p>
<p>以下是其大概的代码示例（没耐心看的同学可以先）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="comment">//监听</span></span><br><span class="line"> lfd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line"> bind(lfd, ...)</span><br><span class="line"> listen(lfd, ...);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//创建epoll对象，并把 listen socket的事件管理起来</span></span><br><span class="line"> efd = epoll_create(...);</span><br><span class="line"> epoll_ctl(efd, EPOLL_CTL_ADD, lfd, ...);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//事件循环</span></span><br><span class="line"> <span class="keyword">for</span> (;;)</span><br><span class="line"> &#123;</span><br><span class="line">  size_t nready = epoll_wait(efd, ep, ...);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nready; ++i)&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span>(ep[i].data.fd == lfd)&#123;</span><br><span class="line">    <span class="comment">//lfd上发生事件表示都连接到达，accept接收它</span></span><br><span class="line">    fd = accept(listenfd, ...);</span><br><span class="line">    epoll_ctl(efd, EPOLL_CTL_ADD, fd, ...);</span><br><span class="line">   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//其它socket发生的事件都是读写请求、或者关闭连接</span></span><br><span class="line">    ...</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在单进程模型中，不管有多少的连接，是几万还是几十万，服务器都是通过 epoll 来监控这些连接 socket 上的可读和可写事件。当某个 socket 上有数据发生的时候，再以非阻塞的方式对 socket 进行读写操作。</p>
<p>事实上，Redis 5.0 及以前的版本中，它的网络部分去掉对 handler 的封装，去掉时间事件以后，代码基本和上述 demo 非常接近。而且因为 Redis 的业务特点只需要内存 IO，且 CPU 计算少，所以可以达到数万的 QPS。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/13/1053-CALz1l.png" alt="图片"></p>
<p>但是单进程的问题也是显而易见的，没有办法充分发挥多核的优势。所以目前业界绝大部分的后端服务还都是需要基于多进程的方式来进行开发的。到了多进程的时候，更复杂的问题多进程之间的配合和协作问题就产生了。比如</p>
<ul>
<li>哪个进程执行监听 listen ，以及 accept 接收新连接？</li>
<li>哪个进程负责发现用户连接上的读写事件？</li>
<li>当有用户请求到达的时候，如何均匀地将请求分散到不同的进程中？</li>
<li>需不需要单独搞一部分进程执行计算工作</li>
<li>…</li>
</ul>
<p>事实上，以上这些问题并没有标准答案。各大应用或者网络框架都有自己不同的实现方式。为此业界还专门总结出了两类网络设计模式 - Reactor 和 Proactor。不过今天我不想讨论这种抽象模式，而是想带大家看一个具体的 Case - Nginx  是如何在多进程下使用 epoll 的。</p>
<h1 id="Nginx-Master-进程初始化"><a href="#Nginx-Master-进程初始化" class="headerlink" title="Nginx Master 进程初始化"></a>Nginx Master 进程初始化</h1><p>在 Nginx 中，将进程分成了两类。一类是 Master 进程，一类是 Worker 进程。</p>
<p>在 Master 进程中，主要的任务是负责启动整个程序、读取配置文件、监听和处理各种信号，并对 Worker 进程进行统筹管理。</p>
<p>不过今天我们要查看的重点问题是看网络。在 Master 进程中，和网络相关的操作非常简单就是创建了 socket 并对其进行 bind 和 监听。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/13/1054-9Pe9UT.png" alt="图片"></p>
<p>具体细节我们来看 Main 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/core/nginx.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> ngx_cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *<span class="keyword">const</span> *argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">ngx_cycle_t</span>      *cycle, init_cycle;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//1.1 ngx_init_cycle 中开启监听</span></span><br><span class="line"> cycle = ngx_init_cycle(&amp;init_cycle);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//1.2 启动主进程循环</span></span><br><span class="line"> ngx_master_process_cycle(cycle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Nginx 中，ngx_cycle_t 是非常核心的一个结构体。这个结构体存储了很多东西，也贯穿了好多的函数。其中对端口的 bind 和 listen 就是在它执行时完成的。</p>
<p>ngx_master_process_cycle 是 Master 进程的主事件循环。它先是根据配置启动指定数量的 Worker 进程，然后就开始关注和处理重启、退出等信号。接下来我们分两个小节来更详细地看。</p>
<h2 id="Nginx-的服务端口监听"><a href="#Nginx-的服务端口监听" class="headerlink" title="Nginx 的服务端口监听"></a>Nginx 的服务端口监听</h2><p>我们看下 ngx_init_cycle 中是如何执行 bind 和 listen 的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/core/ngx_cycle.c</span></span><br><span class="line"><span class="function"><span class="keyword">ngx_cycle_t</span> *<span class="title">ngx_init_cycle</span><span class="params">(<span class="keyword">ngx_cycle_t</span> *old_cycle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> ......</span><br><span class="line"> <span class="keyword">if</span> (ngx_open_listening_sockets(cycle) != NGX_OK) &#123;</span><br><span class="line">  <span class="keyword">goto</span> failed;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>真正的监听还是在 ngx_open_listening_sockets 函数中，继续看它的源码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/core/ngx_connection.c</span></span><br><span class="line"><span class="function"><span class="keyword">ngx_int_t</span> <span class="title">ngx_open_listening_sockets</span><span class="params">(<span class="keyword">ngx_cycle_t</span> *cycle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> ......</span><br><span class="line"></span><br><span class="line"> <span class="comment">//要监听的 socket 对象</span></span><br><span class="line"> ls = cycle-&gt;listening.elts;</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cycle-&gt;listening.nelts; i++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取第i个socket</span></span><br><span class="line">  s = ngx_socket(ls[i].sockaddr-&gt;sa_family, ls[i].type, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//绑定</span></span><br><span class="line">  bind(s, ls[i].sockaddr, ls[i].socklen)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//监听</span></span><br><span class="line">  listen(s, ls[i].backlog)</span><br><span class="line">  ls[i].listen = <span class="number">1</span>;</span><br><span class="line">  ls[i].fd = s;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个函数中，遍历要监听的 socket。如果是启用了 REUSEPORT 配置，那先把 socket 设置上 SO_REUSEPORT 选项。然后接下来就是大家都熟悉的 bind 和 listen。<code>所以，bind 和 listen 是在 Master 进程中完成的。</code></p>
<h2 id="Master-进程的主循环"><a href="#Master-进程的主循环" class="headerlink" title="Master 进程的主循环"></a>Master 进程的主循环</h2><p>在 ngx_master_process_cycle 中主要完成两件事。</p>
<ul>
<li>启动 Worker 进程</li>
<li>将 Master 进程推入事件循环</li>
</ul>
<p>在创建 Worker 进程的时候，是通过 fork 系统调用让 Worker 进程完全复制自己的资源，包括 listen 状态的 socket 句柄。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/13/1055-fjVRZT.png" alt="图片"></p>
<p>我们接下来看详细的代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/os/unix/ngx_process_cycle.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_master_process_cycle</span><span class="params">(<span class="keyword">ngx_cycle_t</span> *cycle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> ......</span><br><span class="line"> ngx_start_worker_processes(cycle, ccf-&gt;worker_processes,</span><br><span class="line">          NGX_PROCESS_RESPAWN);</span><br><span class="line"> <span class="comment">//进入主循环,等待接收各种信号</span></span><br><span class="line"> <span class="keyword">for</span> ( ;; ) &#123;</span><br><span class="line">  <span class="comment">//ngx_quit</span></span><br><span class="line">  <span class="comment">//ngx_reconfigure</span></span><br><span class="line">  <span class="comment">//ngx_restart</span></span><br><span class="line">  ...</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主进程在配置中读取到了 Worker 进程的数量 <code>ccf-&gt;worker_processes</code>。通过 ngx_start_worker_processes 来启动指定数量的 Worker。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file:src/os/unix/ngx_process_cycle.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ngx_start_worker_processes</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">  ngx_spawn_process(cycle, ngx_worker_process_cycle,</span><br><span class="line">        (<span class="keyword">void</span> *) (<span class="keyword">intptr_t</span>) i, <span class="string">&quot;worker process&quot;</span>, type);</span><br><span class="line">  ...</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中值得注意的是，在调用 ngx_spawn_process 时的几个参数</p>
<ul>
<li>cycle：nginx 的核心数据结构</li>
<li>ngx_worker_process_cycle：worker 进程的入口函数</li>
<li>i: 当前 worker 的序号</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/os/unix/ngx_process.c</span></span><br><span class="line"><span class="function"><span class="keyword">ngx_pid_t</span> <span class="title">ngx_spawn_process</span><span class="params">(<span class="keyword">ngx_cycle_t</span> *cycle, ngx_spawn_proc_pt proc,...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> pid = fork();</span><br><span class="line"> <span class="keyword">switch</span> (pid) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">-1</span>: <span class="comment">//出错了</span></span><br><span class="line">   ... </span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//子进程创建成功</span></span><br><span class="line">   ngx_parent = ngx_pid;</span><br><span class="line">   ngx_pid = ngx_getpid();</span><br><span class="line">   proc(cycle, data);</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 ngx_spawn_process 中调用 fork 来创建进程，创建成功后 Worker 进程就将进入 ngx_worker_process_cycle 来进行处理了。</p>
<p><strong>总结：</strong> 在网络上，master 进程其实只是 listen 了一下。listen 过后的 socket 存到 cycle-&gt;listening 这里了。剩下的网络操作都是在 Worker 中完成的。</p>
<h1 id="Worker-进程处理"><a href="#Worker-进程处理" class="headerlink" title="Worker 进程处理"></a>Worker 进程处理</h1><p>在上面小节中看到，Master 进程关于网络其实做的事情不多，只是 bind 和 listen 了一下。epoll 相关的函数调用一个也没见着，更别说 accept  接收连接，以及 read 、 write 函数处理了。那这些细节一定都是在 Worker 进程中完成的。</p>
<p>事实的确如此，epoll_create、epoll_ctl、epoll_wait 都是在 Worker 进程中执行的。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/13/1056-4w6vng.png" alt="图片"></p>
<p>在 Worker 进程中，创建了一个 epoll 内核对象，通过 epoll_ctl 将其想监听的事件注册上去，然后调用 epoll_wait 进入事件循环。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/os/unix/ngx_process_cycle.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ngx_worker_process_cycle</span><span class="params">(<span class="keyword">ngx_cycle_t</span> *cycle, <span class="keyword">void</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//2.2 Worker进程初始化编译进来的各个模块</span></span><br><span class="line"> ngx_worker_process_init(cycle, worker);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//进入事件循环</span></span><br><span class="line"> <span class="keyword">for</span> ( ;; ) &#123;</span><br><span class="line">  <span class="comment">//2.3 进入 epollwait</span></span><br><span class="line">  ngx_process_events_and_timers(cycle);</span><br><span class="line">  ......</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们分别来细看。</p>
<h2 id="Nginx-的-网络相关-module"><a href="#Nginx-的-网络相关-module" class="headerlink" title="Nginx 的 网络相关 module"></a>Nginx 的 网络相关 module</h2><p>撇开 Worker 的工作流程不提，咱们先来了解一个背景知识 - Nginx module。</p>
<p>Nginx 采用的是一种模块化的架构，它的模块包括核心模块、标准HTTP模块、可选HTTP模块、邮件服务模块和第三方模块等几大类。每一个模块都以一个  module 的形式存在，都对应一个 ngx_module_s 结构体。通过这种方式来实现软件可拔插，是一种非常优秀的软件架构。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/13/1057-yQvFVi.png" alt="图片"></p>
<p>每个 module 根据自己的需求来实现各种 init_xxx, exit_xxx 方法来供 Nginx 在合适的时机调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/core/ngx_module.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ngx_module_s</span> &#123;</span></span><br><span class="line"> ......</span><br><span class="line"></span><br><span class="line"> <span class="keyword">ngx_uint_t</span>            version;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">void</span>                 *ctx;</span><br><span class="line"> <span class="keyword">ngx_command_t</span>        *commands;</span><br><span class="line"> <span class="keyword">ngx_uint_t</span>            type;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">ngx_int_t</span>           (*init_master)(<span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>);</span><br><span class="line"> <span class="keyword">ngx_int_t</span>           (*init_module)(<span class="keyword">ngx_cycle_t</span> *cycle);</span><br><span class="line"> <span class="keyword">ngx_int_t</span>           (*init_process)(<span class="keyword">ngx_cycle_t</span> *cycle);</span><br><span class="line"> <span class="keyword">ngx_int_t</span>           (*init_thread)(<span class="keyword">ngx_cycle_t</span> *cycle);</span><br><span class="line"> <span class="keyword">void</span>                (*exit_thread)(<span class="keyword">ngx_cycle_t</span> *cycle);</span><br><span class="line"> <span class="keyword">void</span>                (*exit_process)(<span class="keyword">ngx_cycle_t</span> *cycle);</span><br><span class="line"> <span class="keyword">void</span>                (*exit_master)(<span class="keyword">ngx_cycle_t</span> *cycle);</span><br><span class="line"></span><br><span class="line"> ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中和网络相关的 module 有 ngx_events_module 、ngx_event_core_module 和具体的网络底层模块 ngx_epoll_module、ngx_kqueue_module等。</p>
<p>对于 ngx_epoll_module 来说，它在其上下文 ngx_epoll_module_ctx 中定义了各种 actions 方法（添加事件、删除事件、添加连接等）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file:src/event/ngx_event.h</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"> <span class="keyword">ngx_str_t</span>              *name;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">void</span>                 *(*create_conf)(<span class="keyword">ngx_cycle_t</span> *cycle);</span><br><span class="line"> <span class="keyword">char</span>                 *(*init_conf)(<span class="keyword">ngx_cycle_t</span> *cycle, <span class="keyword">void</span> *conf);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">ngx_event_actions_t</span>     actions;</span><br><span class="line">&#125; <span class="keyword">ngx_event_module_t</span>;</span><br><span class="line"><span class="comment">//file:src/event/modules/ngx_epoll_module.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">ngx_event_module_t</span>  ngx_epoll_module_ctx = &#123;</span><br><span class="line"> &amp;epoll_name,</span><br><span class="line"> ngx_epoll_create_conf,               <span class="comment">/* create configuration */</span></span><br><span class="line"> ngx_epoll_init_conf,                 <span class="comment">/* init configuration */</span></span><br><span class="line"></span><br><span class="line"> &#123;</span><br><span class="line">  ngx_epoll_add_event,             <span class="comment">/* add an event */</span></span><br><span class="line">  ngx_epoll_del_event,             <span class="comment">/* delete an event */</span></span><br><span class="line">  ngx_epoll_add_event,             <span class="comment">/* enable an event */</span></span><br><span class="line">  ngx_epoll_del_event,             <span class="comment">/* disable an event */</span></span><br><span class="line">  ngx_epoll_add_connection,        <span class="comment">/* add an connection */</span></span><br><span class="line">  ngx_epoll_del_connection,        <span class="comment">/* delete an connection */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (NGX_HAVE_EVENTFD)</span></span><br><span class="line">  ngx_epoll_notify,                <span class="comment">/* trigger a notify */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="literal">NULL</span>,                            <span class="comment">/* trigger a notify */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  ngx_epoll_process_events,        <span class="comment">/* process the events */</span></span><br><span class="line">  ngx_epoll_init,                  <span class="comment">/* init the events */</span></span><br><span class="line">  ngx_epoll_done,                  <span class="comment">/* done the events */</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中有一个 init 方法是 ngx_epoll_init，在这个 init 中会进行 epoll 对象的创建，以及 ngx_event_actions 方法的设置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file:src/event/modules/ngx_epoll_module.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">ngx_int_t</span></span><br><span class="line">ngx_epoll_init(<span class="keyword">ngx_cycle_t</span> *cycle, <span class="keyword">ngx_msec_t</span> timer)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">//创建一个 epoll 句柄</span></span><br><span class="line"> ep = epoll_create(cycle-&gt;connection_n / <span class="number">2</span>);</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> ngx_event_actions = ngx_epoll_module_ctx.actions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Worker-进程初始化各个模块"><a href="#Worker-进程初始化各个模块" class="headerlink" title="Worker 进程初始化各个模块"></a>Worker 进程初始化各个模块</h2><p>Worker 进程初始化的时候，在 ngx_worker_process_init 中读取配置信息进行一些设置，然后调用所有模块的 init_process 方法。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/13/1057-ip58U0.png" alt="图片"></p>
<p>来看详细代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/os/unix/ngx_process_cycle.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">ngx_worker_process_init(<span class="keyword">ngx_cycle_t</span> *cycle, <span class="keyword">ngx_int_t</span> worker)</span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> <span class="comment">//获取配置</span></span><br><span class="line"> ccf = (<span class="keyword">ngx_core_conf_t</span> *) ngx_get_conf(cycle-&gt;conf_ctx, ngx_core_module);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//设置优先级</span></span><br><span class="line"> setpriority(PRIO_PROCESS, <span class="number">0</span>, ccf-&gt;priority)</span><br><span class="line"></span><br><span class="line"> <span class="comment">//设置文件描述符限制</span></span><br><span class="line"> setrlimit(RLIMIT_NOFILE, &amp;rlmt)</span><br><span class="line"> setrlimit(RLIMIT_CORE, &amp;rlmt)</span><br><span class="line"></span><br><span class="line"> <span class="comment">//group 和 uid 设置</span></span><br><span class="line"> initgroups(ccf-&gt;username, ccf-&gt;group)</span><br><span class="line"> setuid(ccf-&gt;user)</span><br><span class="line"></span><br><span class="line"> <span class="comment">//CPU亲和性</span></span><br><span class="line"> cpu_affinity = ngx_get_cpu_affinity(worker)</span><br><span class="line"> <span class="keyword">if</span> (cpu_affinity) &#123;</span><br><span class="line">  ngx_setaffinity(cpu_affinity, cycle-&gt;<span class="built_in">log</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> ......</span><br><span class="line"></span><br><span class="line"> <span class="comment">//调用各个模块的init_process进行模块初始化</span></span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; cycle-&gt;modules[i]; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (cycle-&gt;modules[i]-&gt;init_process) &#123;</span><br><span class="line">   <span class="keyword">if</span> (cycle-&gt;modules[i]-&gt;init_process(cycle) == NGX_ERROR) &#123;</span><br><span class="line">    <span class="comment">/* fatal */</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面我们说过 ngx_event_core_module ，它的 init_process 方法是 ngx_event_process_init。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/event/ngx_event.c</span></span><br><span class="line"><span class="keyword">ngx_module_t</span>  ngx_event_core_module = &#123;</span><br><span class="line"> ...</span><br><span class="line"> ngx_event_process_init,                <span class="comment">/* init process */</span></span><br><span class="line"> ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 ngx_event_core_module 的 ngx_event_process_init 中，我们将看到 <code>Worker 进程使用 epoll_create 来创建 epoll 对象，使用epoll_ctl 来监听 listen socket 上的连接请求</code>。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/13/1057-xlLVNH.png" alt="图片"></p>
<p>来详细看 ngx_event_process_init 的代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/event/ngx_event.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ngx_int_t</span> <span class="title">ngx_event_process_init</span><span class="params">(<span class="keyword">ngx_cycle_t</span> *cycle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//调用模块的init，创建 epoll 对象</span></span><br><span class="line"> <span class="keyword">for</span> (m = <span class="number">0</span>; cycle-&gt;modules[m]; m++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (cycle-&gt;modules[m]-&gt;type != NGX_EVENT_MODULE) &#123;</span><br><span class="line">   <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">module</span>-&gt;actions.init(cycle, ngx_timer_resolution)</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line"></span><br><span class="line"> <span class="comment">//获取自己监听的sokcet，将它们都添加到 epoll 中</span></span><br><span class="line"> <span class="keyword">ngx_event_t</span>         *rev</span><br><span class="line"> ls = cycle-&gt;listening.elts;</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; cycle-&gt;listening.nelts; i++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取一个 ngx_connection_t</span></span><br><span class="line">  c = ngx_get_connection(ls[i].fd, cycle-&gt;<span class="built_in">log</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//设置回调函数为 ngx_event_accept</span></span><br><span class="line">  rev-&gt;handler = ngx_event_accept </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ngx_add_event(rev, NGX_READ_EVENT, <span class="number">0</span>) == NGX_ERROR) &#123;</span><br><span class="line">   <span class="keyword">return</span> NGX_ERROR;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 ngx_add_event 注册的 READ 事件的处理函数。ngx_add_event 就是一个抽象，对于 epoll 来说就是对 epoll_ctl 的封装而已。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/event/ngx_event.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_add_event        ngx_event_actions.add</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//file: src/event/modules/ngx_epoll_module.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ngx_int_t</span> <span class="title">ngx_epoll_add_event</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (epoll_ctl(ep, op, c-&gt;fd, &amp;ee) == <span class="number">-1</span>) &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>TODO</code>: epoll_create 还没解决呢。</p>
<h2 id="进入-epollwait"><a href="#进入-epollwait" class="headerlink" title="进入 epollwait"></a>进入 epollwait</h2><p>在 ngx_worker_process_init 中， epoll_create 和 epoll_ctl 都已经完成了。接下来就是进入事件循环，执行 epoll_wait 来处理。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/13/1058-q96euT.png" alt="图片"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/event/ngx_event.c</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">ngx_process_events_and_timers(<span class="keyword">ngx_cycle_t</span> *cycle)</span><br><span class="line">&#123;</span><br><span class="line"> ...</span><br><span class="line"> <span class="comment">// 防accept惊群锁</span></span><br><span class="line"> <span class="keyword">if</span> (ngx_use_accept_mutex) &#123;</span><br><span class="line">  <span class="comment">//尝试获取锁，获取失败直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (ngx_trylock_accept_mutex(cycle) == NGX_ERROR) &#123;</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取锁成功，则设置 NGX_POST_EVENTS 标记。</span></span><br><span class="line">  <span class="keyword">if</span> (ngx_accept_mutex_held) &#123;</span><br><span class="line">   flags |= NGX_POST_EVENTS;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//处理各种事件</span></span><br><span class="line"> (<span class="keyword">void</span>) ngx_process_events(cycle, timer, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 ngx_process_events_and_timers 开头处，判断是否使用 accpet_mutext  锁。这是一个防止惊群的解决办法。如果使用的话，先调用 ngx_trylock_accept_mutex  获取锁，获取失败则直接返回，过段时间再来尝试。获取成功是则设置 NGX_POST_EVENTS 的标志位。</p>
<p>接下来调用 ngx_process_events 来处理各种网络和 timer 事件。对于 epoll 来说，这个函数就是对 epoll_wait 的封装。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/event/ngx_event.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_process_events   ngx_event_actions.process_events</span></span><br><span class="line"><span class="comment">//file: src/event/modules/ngx_epoll_module.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">ngx_int_t</span> <span class="title">ngx_epoll_process_events</span><span class="params">(<span class="keyword">ngx_cycle_t</span> *cycle, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> events = epoll_wait(ep, event_list, (<span class="keyword">int</span>) nevents, timer);</span><br><span class="line"> <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; events; i++) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (flags &amp; NGX_POST_EVENTS) &#123;</span><br><span class="line">   ...</span><br><span class="line">   ngx_post_event(rev, <span class="built_in">queue</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   <span class="comment">//调用回调函数</span></span><br><span class="line">   rev-&gt;handler(rev);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，在 ngx_epoll_process_events 是调用 epoll_wait 等待各种事件的发生。如果没有 NGX_POST_EVENTS  标志，则直接回调 rev-&gt;handler 进行处理。使用了 accept_mutex 锁的话，先把这个事件保存起来，等后面合适的时机再去 accpet。</p>
<p>简单对本节内容汇总一下。在 Master 进程中只是做了 socket 的 bind 和 listen。 而在 Worker 进程中所做的事情比较多，创建了  epoll，使用 epoll_ctl 将 listen 状态的 socket 的事件监控起来。最后调用 epoll_wait  进入了事件循环，开始处理各种网络和 timer 事件。 本节流程总结如图。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/13/1058-ZcmK2t.png" alt="图片"></p>
<h1 id="用户连接来啦"><a href="#用户连接来啦" class="headerlink" title="用户连接来啦"></a>用户连接来啦</h1><p>现在假设用户的连接请求已经到了，这时候 epoll_wait 返回后会执行其对应的 handler 函数 ngx_add_event。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/13/1059-8ka7r8.png" alt="图片"></p>
<p>在该回调函数中被执行到的时候，表示 listen 状态的 socket 上面有连接到了。所以这个函数主要做了三件事。</p>
<ul>
<li>1.调用 accept 获取用户连接</li>
<li>2.获取 connection 对象，其回调函数为 ngx_http_init_connection</li>
<li>3.将新连接 socket 通过 epoll_ctl 添加到 epoll 中进行管理</li>
</ul>
<p>我们来看 ngx_event_accept 详细代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/event/ngx_event_accept.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_event_accept</span><span class="params">(<span class="keyword">ngx_event_t</span> *ev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="comment">//接收建立好的连接</span></span><br><span class="line">  s = accept(lc-&gt;fd, &amp;sa.sockaddr, &amp;socklen);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> s &#123;</span><br><span class="line">   <span class="comment">//3.1 获取 connection</span></span><br><span class="line">   c = ngx_get_connection(s, ev-&gt;<span class="built_in">log</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//3.2 添加新连接</span></span><br><span class="line">   <span class="keyword">if</span> (ngx_add_conn(c) == NGX_ERROR) &#123;</span><br><span class="line">    ngx_close_accepted_connection(c);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125; </span><br><span class="line"> &#125; <span class="keyword">while</span> (ev-&gt;available);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>listen socket 上的读事件发生的时候，就意味着有用户连接就绪了。所以可以直接通过 accept 将其取出来。取出连接以后，再获取一个空闲的 connection对象，通过 ngx_add_conn 将其添加到 epoll 中进行管理。</p>
<h2 id="获取-connection"><a href="#获取-connection" class="headerlink" title="获取 connection"></a>获取 connection</h2><p>我们说一下 ngx_get_connection，这个函数本身倒是没有啥可说的。就是从 ngx_cycle 的 free_connections 中获取一个 connection 出来。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/core/ngx_connection.c</span></span><br><span class="line"><span class="function"><span class="keyword">ngx_connection_t</span> *<span class="title">ngx_get_connection</span><span class="params">(<span class="keyword">ngx_socket_t</span> s, <span class="keyword">ngx_log_t</span> *<span class="built_in">log</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> c = ngx_cycle-&gt;free_connections;</span><br><span class="line"> c-&gt;read = rev;</span><br><span class="line"> c-&gt;write = wev;</span><br><span class="line"> c-&gt;fd = s;</span><br><span class="line"> c-&gt;<span class="built_in">log</span> = <span class="built_in">log</span>;</span><br><span class="line"> <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得说的是 free_connections 中的连接，对于 HTTP 服务来说，会经过 ngx_http_init_connection  的初始化处理。它会设置该连接读写事件的回调函数 c-&gt;read-&gt;handler 和  c-&gt;write-&gt;handler。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/http/ngx_http_request.c</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ngx_http_init_connection</span><span class="params">(<span class="keyword">ngx_connection_t</span> *c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> ...</span><br><span class="line"> rev = c-&gt;read;</span><br><span class="line"> rev-&gt;handler = ngx_http_wait_request_handler;</span><br><span class="line"> c-&gt;write-&gt;handler = ngx_http_empty_handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="添加新连接"><a href="#添加新连接" class="headerlink" title="添加新连接"></a>添加新连接</h2><p>我们再来看 ngx_add_conn，对于 epoll module 来说，它就是 ngx_epoll_add_connection 这个函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//file: src/event/ngx_event.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ngx_add_conn         ngx_event_actions.add_conn</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//file: src/event/modules/ngx_epoll_module.c</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">ngx_int_t</span></span><br><span class="line">ngx_epoll_add_connection(<span class="keyword">ngx_connection_t</span> *c)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>  <span class="title">ee</span>;</span></span><br><span class="line"> ee.events = EPOLLIN|EPOLLOUT|EPOLLET|EPOLLRDHUP;</span><br><span class="line"> ee.data.ptr = (<span class="keyword">void</span> *) ((<span class="keyword">uintptr_t</span>) c | c-&gt;read-&gt;instance);</span><br><span class="line"></span><br><span class="line"> epoll_ctl(ep, EPOLL_CTL_ADD, c-&gt;fd, &amp;ee)</span><br><span class="line"> c-&gt;read-&gt;active = <span class="number">1</span>;</span><br><span class="line"> c-&gt;write-&gt;active = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> NGX_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见这只是 epoll_ctl 的一个封装而已。这里再补充说一下，如果这个客户端连接 socket 上有数据到达的时候，就会进入到上面 3.1 节中注册的 ngx_http_wait_request_handler 函数进行处理。后面就是 HTTP 的处理逻辑了。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Nginx 的 Master 中做的网络相关动作不多，仅仅只是创建了 socket、然后 bind 并 listen 了一下。接着就是用自己 fork  出来多个 Worker 进程来。由于每个进程都一样，所以每个 Worker 都有 Master 创建出来的 listen 状态的 socket  句柄。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/13/1100-taQ3DS.png" alt="图片"></p>
<p>Worker 进程处理的网络相关工作就比较多了。epoll_create、epoll_ctl、epoll_wait 都是在 Worker 进程中执行的，也包括用户连接上的数据 read、处理 和 write。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/13/1100-le5RfF.png" alt="图片"></p>
<ul>
<li>1.先是使用 epoll_create 创建一个 epoll 对象出来</li>
<li>2.设置回调为 ngx_event_accept</li>
<li>3.通过 epoll_ctl 将所有 listen 状态的 socket 的事件都管理起来</li>
<li>4.执行 epoll_wait 等待 listen socket 上的连接到来</li>
<li>5.新连接到来是 epoll_wait 返回，进入 ngx_event_accept 回调</li>
<li>6.ngx_event_accept 回调中将新连接也添加到 epoll 中进行管理（其回调为ngx_http_init_connection）</li>
<li>7.继续进入 epoll_wait 等待事件</li>
<li>8.用户数据请求到达时进入 http 回调函数进行处理</li>
</ul>
<p>讲到这里，你可以觉得咱们已经讨论完了。实际上有一个点我们还没有考虑到。我们上面讨论的流程是一个 Worker 在工作的情况。那么在多 Worker 的情况下，Nginx 的全貌咱们还没展开说过。通过上文我们可以看到以下几个细节：</p>
<ul>
<li>1.每个 Worker 都会有一个属于自己的 epoll 对象</li>
<li>2.每个 Worker 会关注所有的 listen 状态上的新连接事件</li>
<li>3.对于用户连接，只有一个 Worker 会处理，其它 Worker 不会持有该用户连接的 socket。</li>
</ul>
<p>根据这三条结论，我们再画一个 Nginx 的全貌图。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/04/13/1100-ZuryGp.png" alt="图片"></p>
<p>好了，今天关于 Nginx 网络原理的分享就到此结束。希望通过这个优秀的软件能给你的工作带去一些启发和思考，助力你的工作提升。能阅读到这里的同学们都是好样的，晚餐回去都给自己加个鸡腿！</p>
<p>最后学学极客时间，留一道思考题。</p>
<p><strong>思考题：</strong>“上面这个图中每个 Worker 里的 epoll 对象会监听同一批 listen 状态的 socket，那么当有用户连接到来的时候，Nginx 和 Linux  是如何保证没有惊群问题的呢（只有一个 Worker 来响应该请求）？欢迎你把你的思考留在评论区。”</p>
<hr>
<blockquote>
<p>原文： <span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvQVg2RnZhbDhSd2tnenB0ZGpsVTVrZw==">万字多图，搞懂 Nginx 高性能网络工作原理！<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>

      
    </div>
   <div>
        
    </div>

   
    
    
    
      

      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>

  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/11/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><span class="space">&hellip;</span><a class="page-number" href="/page/31/">31</a><a class="extend next" rel="next" href="/page/13/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



           </div>
          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

          
        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="meadel"
      src="/images/touxiang.jpeg">
  <p class="site-author-name" itemprop="name">meadel</p>
  <div class="site-description" itemprop="description">我的愿望，世界和平</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">154</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci80MDE5NDcwMjQ0MjU4NTUyL3Bvc3Rz" title="掘金 → https:&#x2F;&#x2F;juejin.cn&#x2F;user&#x2F;4019470244258552&#x2F;posts"><i class="fa fa-share-alt fa-fw"></i>掘金</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1ZV9taW5k" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;xue_mind"><i class="fa fa-th-list fa-fw"></i>CSDN</span>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-star"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">meadel</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">846k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">12:49</span>
</div>
  <div class="powered-by">这个世界会好吗？我是那么热爱这个世界。  </div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="js/canvas-ribbon.js"></script>
  <script src="//lib.baomitu.com/animejs/3.2.1/anime.min.js"></script>
  <script src="//lib.baomitu.com/next-theme-pjax/0.5.0/pjax.min.js"></script>
  <script src="//lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script>
  <script src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js"></script>
  <script src="//lib.baomitu.com/medium-zoom/1.0.6/medium-zoom.min.js"></script>
  <script src="https://lib.baomitu.com/lozad.js/1.16.0/lozad.min.js"></script>
  <script src="https://lib.baomitu.com/pangu/4.0.7/pangu.min.js"></script>
  <script src="//lib.baomitu.com/velocity/1.5.2/velocity.min.js"></script>
  <script src="//lib.baomitu.com/velocity/1.5.2/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>


  <script defer src="js/three.min.js"></script>


  
  <script data-pjax>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>



  <script data-pjax>
  if (CONFIG.page.isPost) {
    wpac_init = window.wpac_init || [];
    wpac_init.push({
      widget: 'Rating',
      id    : 34163,
      el    : 'wpac-rating',
      color : 'fc6423'
    });
    (function() {
      if ('WIDGETPACK_LOADED' in window) return;
      WIDGETPACK_LOADED = true;
      var mc = document.createElement('script');
      mc.type = 'text/javascript';
      mc.async = true;
      mc.src = '//embed.widgetpack.com/widget.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
    })();
  }
  </script>

  
<script src="/js/local-search.js"></script>









<script data-pjax>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




    <div id="pjax">
  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//lib.baomitu.com/valine/1.4.17/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'xOnoKG9QyBMz9vYupNusn9fn-gzGzoHsz',
      appKey     : 'RfiNClAkp7Ewe9rlzrjAQEXC',
      placeholder: "吐槽一下...",
      avatar     : 'monsterid',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : '',
      requiredFields : ['nick','mail']
    });
  }, window.Valine);
});
</script>

    </div>
  <link rel="stylesheet" href="/dist/APlayer.min.css">
  <div id="aplayer"></div>
  <script type="text/javascript" src="/dist/APlayer.min.js"></script>
  <script type="text/javascript" src="/dist/music.js"></script>
</body>
</html>
