<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://cdn.baomitu.com/index/fonts/css?family=Ma Shan Zheng:300,300italic,400,400italic,700,700italic|Noto Sans Simplified Chinese:300,300italic,400,400italic,700,700italic|Noto Serif SC:300,300italic,400,400italic,700,700italic|Monaco:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="//lib.baomitu.com/font-awesome/5.15.4/css/all.min.css">
  <link rel="stylesheet" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css">
  <link rel="stylesheet" href="//lib.baomitu.com/pace/1.0.2/themes/blue/pace-theme-minimal.min.css">
  <script src="//lib.baomitu.com/pace/1.0.2/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xuemingde.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":true,"sidebar":{"position":"left","width":300,"display":"always","padding":18,"offset":10,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":true,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="我的愿望，世界和平">
<meta property="og:type" content="website">
<meta property="og:title" content="Middle&#39;s blog">
<meta property="og:url" content="https://xuemingde.com/page/9/index.html">
<meta property="og:site_name" content="Middle&#39;s blog">
<meta property="og:description" content="我的愿望，世界和平">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="meadel">
<meta property="article:tag" content="meadel">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://xuemingde.com/page/9/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Middle's blog - 一位程序员的成长之路</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Middle's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">一位程序员的成长之路</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-notepad">

    <a href="/notepad/" rel="section"><i class="fa fa-book fa-fw"></i>备忘录</a>

  </li>
        <li class="menu-item menu-item-resources">

    <a href="/resources/" rel="section"><i class="fa fa-download fa-fw"></i>资源库</a>

  </li>
        <li class="menu-item menu-item-collect">

    <a href="/collect/" rel="section"><i class="fa fa-star fa-fw"></i>收藏夹</a>

  </li>
        <li class="menu-item menu-item-links">

    <a href="/links/" rel="section"><i class="fa fa-link fa-fw"></i>友链</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

           <div id="container-1">
            <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xuemingde.com/posts/2GN96QM.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.jpeg">
      <meta itemprop="name" content="meadel">
      <meta itemprop="description" content="我的愿望，世界和平">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Middle's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/2GN96QM.html" class="post-title-link" itemprop="url">谈谈你对 JVM 方法区的理解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-02 00:00:00" itemprop="dateCreated datePublished" datetime="2022-06-02T00:00:00+08:00">2022-06-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-13 16:46:48" itemprop="dateModified" datetime="2022-08-13T16:46:48+08:00">2022-08-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a>
                </span>
            </span>

          
            <span id="/posts/2GN96QM.html" class="post-meta-item leancloud_visitors" data-flag-title="谈谈你对 JVM 方法区的理解" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/posts/2GN96QM.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/posts/2GN96QM.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>原文：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvdS03T2pfQk5tdlFzdWwtZEVkeFJvZw==">面试官：谈谈你对 JVM 方法区的理解<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>运行时数据区”包括程序计数器、虚拟机栈、本地方法栈和堆空间，今天我们就来了解一下方法区。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/0811nMChKa.png" alt=""></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>创建对象时内存分配简图</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/08128OLLNU.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/08139cSMvE.png" alt=""></p>
<p>《Java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。</p>
<p>虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。所以，方法区可以看作是一块<strong>独立</strong>于 Java 堆的内存空间。</p>
<p>方法区与 Java 堆一样，是各个线程共享的内存区域。方法区在 JVM 启动时就会被创建，并且它的实际的物理内存空间是可以<strong>不连续</strong>的，关闭 JVM 就会释放这个区域的内存。</p>
<h2 id="永久代、元空间"><a href="#永久代、元空间" class="headerlink" title="永久代、元空间"></a>永久代、元空间</h2><p>《java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEA JRockit/IBM J9 中不存在永久代的概念。而对于 HotSpot 来说，在 jdk7 及以前，习惯上把方法区的实现称为<strong>永久代</strong>，而从 jdk8 开始，使用<strong>元空间</strong>取代了永久代。</p>
<blockquote>
<p>方法区是 Java 虚拟机规范中的概念，而永久代和元空间是 HotSpot 虚拟机对方法区的一种实现。通俗点讲：如果把方法区比作接口的话，那永久代和元空间可以比作实现该接口的实现类。</p>
</blockquote>
<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>永久代、元空间并不只是名字变了，内部结构也进行了调整。永久代使用的是 JVM 的内存，而元空间使用的是本地的直接内存。</p>
<p>直接内存并不是 JVM 运行时数据区的一部分，因此不会受到 Java 堆的限制。但是它会受到本机总内存大小以及处理器寻址空间的限制，所以如果这部分内存也被频繁的使用，依然会导致 OOM 错误的出现。</p>
<h3 id="方法区的大小"><a href="#方法区的大小" class="headerlink" title="方法区的大小"></a>方法区的大小</h3><p>方法区的大小是可以进行设置的，可以选择固定大小也可以进行扩展。</p>
<h4 id="jdk7-及以前"><a href="#jdk7-及以前" class="headerlink" title="jdk7 及以前"></a>jdk7 及以前</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:PermSize=N //方法区 (永久代) 初始分配空间，默认值为 20.75M</span><br><span class="line">-XX:MaxPermSize=N //方法区 (永久代) 最大可分配空间。32位机器默认是64M，64位机器默认是82M</span><br></pre></td></tr></table></figure>
<h4 id="jdk8及以后"><a href="#jdk8及以后" class="headerlink" title="jdk8及以后"></a>jdk8及以后</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:MetaspaceSize=N //方法区 (元空间) 初始分配空间，如果未指定此标志，则元空间将根据运行时的应用程序需求动态地重新调整大小。</span><br><span class="line">-XX:MaxMetaspaceSize=N //方法区 (元空间) 最大可分配空间，默认值为 -1，即没有限制</span><br></pre></td></tr></table></figure>
<p>与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。</p>
<p>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，比如：加载大量的第三方 jar 包、Tomcat 部署的工程过多、大量动态生成反射类等都会导致方法区溢出，抛出内存溢出错误。</p>
<ul>
<li>永久代：OutOfMemoryError:PermGen space</li>
<li>元空间：OutOfMemoryError:Metaspace</li>
</ul>
<p><strong>至于如何解决 OOM 异常，将在以后的文章中讲解！</strong></p>
<h3 id="jvisualvm"><a href="#jvisualvm" class="headerlink" title="jvisualvm"></a>jvisualvm</h3><p>我们可以通过 JDK 自带的 <strong>jvisualvm</strong> 工具来查看程序加载的类文件：</p>
<p><strong>例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;end...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行程序，可以看到一个简单的程序就需要加载这么多的类文件。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/08172fHLHQ.png" alt=""></p>
<h3 id="高水位线"><a href="#高水位线" class="headerlink" title="高水位线"></a>高水位线</h3><p>对于一个64位的服务器端 JVM 来说，<code>XX：MetaspaceSize=21</code> 就是初始的高水位线，一旦触及这个水位线，Full GC 将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。</p>
<p>新的高水位线的值取决于 GC 后释放了多少元空间：</p>
<ul>
<li>如果释放的空间不足，那么在不超过 MaxMetaspaceSize 时，适当提高该值；</li>
<li>如果释放空间过多，则适当降低该值。</li>
</ul>
<blockquote>
<p>如果初始化的高水位线设置过低，高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到 Full GC 多次调用。为了避免频繁地GC，建议将 <code>-XX ：MetaspaceSize</code> 设置为一个相对较高的值。</p>
</blockquote>
<h2 id="内部结构"><a href="#内部结构" class="headerlink" title="内部结构"></a>内部结构</h2><p>《深入理解Java虚拟机》书中对方法区存储内容描述如下：它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。接下来我们就一起来看一下它的内部结构。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/0818BTvM7A.png" alt=""></p>
<h3 id="类型信息"><a href="#类型信息" class="headerlink" title="类型信息"></a>类型信息</h3><p>对每个加载的类型（ 类 class、接口 interface、枚举 enum、注解 annotation），JVM 必须在方法区中存储以下类型信息：</p>
<ol>
<li>这个类型的完整有效名称（全名=包名.类名）</li>
<li>这个类型直接父类的完整有效名（对于 interface 或是 java. lang.Object ，都没有父类）</li>
<li>这个类型的修饰符（ public ， abstract， final 的某个子集）</li>
<li>这个类型直接接口的一个有序列表</li>
</ol>
<h3 id="域（Field）信息"><a href="#域（Field）信息" class="headerlink" title="域（Field）信息"></a>域（Field）信息</h3><ul>
<li>JVM必须在方法区中保存类型的所有域（field，也称为属性）的相关信息以及域的声明顺序；</li>
<li>域的相关信息包括：域名称、 域类型、域修饰符（public， private，protected， static， final， volatile， transient 的某个子集）</li>
</ul>
<h3 id="方法（Method）信息"><a href="#方法（Method）信息" class="headerlink" title="方法（Method）信息"></a>方法（Method）信息</h3><p>JVM 必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p>
<ul>
<li>方法名称</li>
<li>方法的返回类型（或void）</li>
<li>方法参数的数量和类型（按顺序）</li>
<li>方法的修饰符（public， private， protected， static， final，synchronized， native ， abstract 的一个子集）</li>
<li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（ abstract 和 native 方法除外）</li>
<li>异常表（ abstract 和 native 方法除外）每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li>
</ul>
<h3 id="non-final-的类变量"><a href="#non-final-的类变量" class="headerlink" title="non-final 的类变量"></a>non-final 的类变量</h3><ul>
<li>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</li>
<li>类变量被类的所有实例所共享，即使没有类实例你也可以访问它。</li>
</ul>
<p>我们可以通过例子来查看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Order order = <span class="keyword">null</span>;</span><br><span class="line">        order.hello();</span><br><span class="line">        System.out.println(order.count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> number = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello!</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>可以打开 IDEA 的 Terminal 窗口，在 MethodAreaDemo2.class 所在的路径下，输入 <code>javap -v -p MethodAreaDemo2.class</code> 命令</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/0820D8dllV.png" alt=""></p>
<p>通过图片我们可以看出被声明为 final 的类变量的处理方法是不一样的，全局常量在编译的时候就被分配了。</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>说到运行时常量池，我们先来了解一下什么是常量池表。</p>
<h4 id="常量池表"><a href="#常量池表" class="headerlink" title="常量池表"></a>常量池表</h4><p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表（Constant Pool Table），里边存储着<strong>数量值</strong>、<strong>字符串值</strong>、<strong>类引用</strong>、<strong>字段引用</strong>和<strong>方法引用</strong>。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/0821NLzPMe.png" alt="图片"></p>
<h4 id="为什么字节码文件需要常量池？"><a href="#为什么字节码文件需要常量池？" class="headerlink" title="为什么字节码文件需要常量池？"></a>为什么字节码文件需要常量池？</h4><p>java 源文件中的类、接口，编译后会产生一个字节码文件。而字节码文件需要数据支持，通常这种数据会很大，以至于不能直接存放到字节码中。换一种方式，可以将指向这些数据的<strong>符号引用</strong>存到字节码文件的常量池中，这样字节码只需使用常量池就可以在运行时通过<strong>动态链接</strong>找到相应的数据并使用。</p>
<h4 id="运行时常量池-1"><a href="#运行时常量池-1" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>运行时常量池（ <code>Runtime Constant Pool</code>）是方法区的一部分，类加载器加载字节码文件时，将常量池表加载进方法区的运行时常量池。运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为<strong>真实</strong>地址。</p>
<blockquote>
<p>运行时常量池，相对于 Class 文件常量池的另一重要特征是：具备动态性，比如 <code>String.intern()</code>。</p>
</blockquote>
<h2 id="演进细节"><a href="#演进细节" class="headerlink" title="演进细节"></a>演进细节</h2><p>针对的是 <strong>Hotspot</strong> 的虚拟机：</p>
<ul>
<li>jdk1.6 及之前：有<strong>永久代</strong> ，静态变量存放在永久代上；</li>
<li>jdk1.7：有<strong>永久代</strong>，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中；</li>
<li>jdk1.8及之后：无永久代，类型信息、字段、方法、常量保存在本地内存的<strong>元空间</strong>，但字符串常量池、静态变量仍在堆中；</li>
</ul>
<h3 id="演变示例图"><a href="#演变示例图" class="headerlink" title="演变示例图"></a>演变示例图</h3><p><img data-src="https://xuemingde.com/pages/image/2022/06/02/0822Hj7z0e.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/0822u3jIxG.png" alt=""></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/0823bbxVIm.png" alt=""></p>
<h3 id="为什么要将永久代替换为元空间呢"><a href="#为什么要将永久代替换为元空间呢" class="headerlink" title="为什么要将永久代替换为元空间呢?"></a>为什么要将永久代替换为元空间呢?</h3><ol>
<li>永久代使用的是 JVM 的内存，受 JVM 设置的内存大小限制；元空间使用的是本地直接内存，它的最大可分配空间是系统可用内存的空间。因为元空间里存放的是类的<strong>元数据</strong>，所以随着内存空间的增大，能加载的类就更多了，相应的溢出的机率会大大减小。</li>
<li>在 JDK8，合并 HotSpot 和 JRockit 的代码时，JRockit 从来没有一个叫永久代的东西，合并之后就没有必要额外的设置这么一个永久代的地方了。</li>
<li>对永久代进行调优是很困难的。</li>
</ol>
<h3 id="StringTable-为什么要调整"><a href="#StringTable-为什么要调整" class="headerlink" title="StringTable 为什么要调整"></a>StringTable 为什么要调整</h3><p>因为永久代的回收效率很低，在 full gc 的时候才会触发。而 full GC 是老年代的空间不足、永久代不足时才会触发。这就导致了<code>StringTable</code> 回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p>
<h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。方法区的垃圾收集主要回收两部分内容：常量池中废奔的<strong>常量</strong>和不再使用的<strong>类型</strong>。</p>
<p>方法区内常量池中主要存放字面量和符号引用两大类常量：</p>
<ul>
<li>字面量比较接近 Java 语言层次的常量概念，如文本字符串、被声明为 final 的常量值等。</li>
<li>符号引用则属于编译原理方面的概念，包括类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。</li>
</ul>
<p>HotSpot 虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p>
<h3 id="类型判定"><a href="#类型判定" class="headerlink" title="类型判定"></a>类型判定</h3><p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p>
<ul>
<li>该类所有的<strong>实例</strong>都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例；</li>
<li>加载该类的<strong>类加载器</strong>已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的；</li>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>Java 虛拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。</p>

      
    </div>
   <div>
        
    </div>

   
    
    
    
      

      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>

  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xuemingde.com/posts/3WWPT6W.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.jpeg">
      <meta itemprop="name" content="meadel">
      <meta itemprop="description" content="我的愿望，世界和平">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Middle's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/3WWPT6W.html" class="post-title-link" itemprop="url">聊聊ConcurrentHashMap</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-02 00:00:00" itemprop="dateCreated datePublished" datetime="2022-06-02T00:00:00+08:00">2022-06-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-13 16:46:48" itemprop="dateModified" datetime="2022-08-13T16:46:48+08:00">2022-08-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9B%86%E5%90%88%E6%95%B0%E7%BB%84/" itemprop="url" rel="index"><span itemprop="name">集合数组</span></a>
                </span>
            </span>

          
            <span id="/posts/3WWPT6W.html" class="post-meta-item leancloud_visitors" data-flag-title="聊聊ConcurrentHashMap" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/posts/3WWPT6W.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/posts/3WWPT6W.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>4.3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>原文：<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3MvcFctbWhkZlBtODJKeEtwUkY5anJOZw==">聊聊ConcurrentHashMap<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>本文汇总了常考的 ConcurrentHashMap 面试题，面试 ConcurrentHashMap，看这一篇就够了！为帮助大家高效复习，专门用”★ “表示面试中出现的频率，”★ “越多，代表越高频！</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/10318bUq3E.png" alt=""></p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><blockquote>
<p>ConcurrentHashMap 的实现原理是什么？★★★★★</p>
</blockquote>
<p>ConcurrentHashMap  在 JDK1.7 和 JDK1.8  的实现方式是不同的。</p>
<p><strong>先来看下JDK1.7</strong></p>
<p>JDK1.7 中的 ConcurrentHashMap 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成，即 ConcurrentHashMap 把哈希桶数组切分成小数组（Segment ），每个小数组有 n 个 HashEntry 组成。</p>
<p>如下图所示，首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一段数据时，其他段的数据也能被其他线程访问，实现了真正的并发访问。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/1032qwe0jW.png" alt=""></p>
<p>Segment 是 ConcurrentHashMap 的一个内部类，主要的组成如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/1034TwAp6g.png" alt=""></p>
<p>Segment 继承了 ReentrantLock，所以 Segment 是一种可重入锁，扮演锁的角色。Segment 默认为 16，也就是并发度为 16。</p>
<p>存放元素的 HashEntry，也是一个静态内部类，主要的组成如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/1034mlVtdv.png" alt=""></p>
<p>其中，用 volatile 修饰了 HashEntry 的数据 value 和 下一个节点 next，保证了多线程环境下数据获取时的<strong>可见性</strong>！</p>
<p><strong>再来看下JDK1.8</strong></p>
<p>在数据结构上， JDK1.8  中的ConcurrentHashMap  选择了与 HashMap 相同的<strong>Node数组+链表+红黑树</strong>结构；在锁的实现上，抛弃了原有的 Segment 分段锁，采用<code>CAS + synchronized</code>实现更加细粒度的锁。</p>
<p>将锁的级别控制在了更细粒度的哈希桶数组元素级别，也就是说只需要锁住这个链表头节点（红黑树的根节点），就不会影响其他的哈希桶数组元素的读写，大大提高了并发度。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/1035IaVcP4.png" alt=""></p>
<blockquote>
<p>JDK1.8  中为什么使用内置锁 synchronized替换 可重入锁 ReentrantLock？★★★★★</p>
</blockquote>
<ul>
<li>在 JDK1.6 中，对 synchronized 锁的实现引入了大量的优化，并且 synchronized 有多种锁状态，会从无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁一步步转换。</li>
<li>减少内存开销 。假设使用可重入锁来获得同步支持，那么每个节点都需要通过继承 AQS 来获得同步支持。但并不是每个节点都需要获得同步支持的，只有链表的头节点（红黑树的根节点）需要同步，这无疑带来了巨大内存浪费。</li>
</ul>
<h2 id="存取"><a href="#存取" class="headerlink" title="存取"></a>存取</h2><blockquote>
<p>ConcurrentHashMap  的 put 方法执行逻辑是什么？★★★★</p>
</blockquote>
<p><strong>先来看JDK1.7</strong></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/1036mwo1VB.png" alt=""></p>
<p>先定位到相应的 Segment ，然后再进行 put 操作。</p>
<p>源代码如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/1037MkDJZI.png" alt=""></p>
<p>首先会尝试获取锁，如果获取失败肯定就有其他线程存在竞争，则利用 <code>scanAndLockForPut()</code> 自旋获取锁。</p>
<ol>
<li>尝试自旋获取锁。</li>
<li>如果重试的次数达到了 <code>MAX_SCAN_RETRIES</code> 则改为阻塞锁获取，保证能获取成功。</li>
</ol>
<p><strong>再来看JDK1.8</strong></p>
<p>大致可以分为以下步骤：</p>
<ol>
<li><p>根据 key 计算出 hash 值；</p>
</li>
<li><p>判断是否需要进行初始化；</p>
</li>
<li><p>定位到 Node，拿到首节点 f，判断首节点 f：</p>
</li>
<li><ul>
<li>如果为  null  ，则通过 CAS 的方式尝试添加；</li>
<li>如果为 <code>f.hash = MOVED = -1</code> ，说明其他线程在扩容，参与一起扩容；</li>
<li>如果都不满足 ，synchronized 锁住 f 节点，判断是链表还是红黑树，遍历插入；</li>
</ul>
</li>
<li><p>当在链表长度达到 8 的时候，数组扩容或者将链表转换为红黑树。</p>
</li>
</ol>
<p>源代码如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/1038xjZFOh.png" alt=""></p>
<blockquote>
<p>ConcurrentHashMap  的 get 方法执行逻辑是什么？★★★★</p>
</blockquote>
<p>同样，<strong>先来看JDK1.7</strong></p>
<p>首先，根据 key 计算出 hash 值定位到具体的 Segment ，再根据 hash 值获取定位 HashEntry 对象，并对 HashEntry 对象进行链表遍历，找到对应元素。</p>
<p>由于 HashEntry 涉及到的共享变量都使用 volatile 修饰，volatile 可以保证内存可见性，所以每次获取时都是最新值。</p>
<p>源代码如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/1038nmFxF6.png" alt=""></p>
<p><strong>再来看JDK1.8</strong></p>
<p>大致可以分为以下步骤：</p>
<ol>
<li>根据 key 计算出 hash 值，判断数组是否为空；</li>
<li>如果是首节点，就直接返回；</li>
<li>如果是红黑树结构，就从红黑树里面查询；</li>
<li>如果是链表结构，循环遍历判断。</li>
</ol>
<p>源代码如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/1039VisPxv.png" alt=""></p>
<blockquote>
<p>ConcurrentHashMap 的 get 方法是否要加锁，为什么？★★★</p>
</blockquote>
<p>get 方法不需要加锁。因为 Node 的元素 value 和指针 next 是用 volatile 修饰的，在多线程环境下线程A修改节点的 value 或者新增节点的时候是对线程B可见的。</p>
<p>这也是它比其他并发集合比如 Hashtable、用 Collections.synchronizedMap()包装的 HashMap 效率高的原因之一。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/1039dvKas4.png" alt=""></p>
<blockquote>
<p>get 方法不需要加锁与 volatile 修饰的哈希桶数组有关吗？★★★</p>
</blockquote>
<p>没有关系。哈希桶数组<code>table</code>用 volatile 修饰主要是保证在数组扩容的时候保证可见性。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/1040RIFKvY.png" alt="图片"></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><blockquote>
<p>ConcurrentHashMap  不支持 key 或者 value 为  null  的原因？★★★</p>
</blockquote>
<p>我们先来说value 为什么不能为 null。因为 ConcurrentHashMap 是用于多线程的 ，如果<code>ConcurrentHashMap.get(key)</code>得到了 null ，这就无法判断，是映射的value是 null ，还是没有找到对应的key而为 null ，就有了二义性。</p>
<p>而用于单线程状态的 HashMap 却可以用<code>containsKey(key)</code> 去判断到底是否包含了这个 null 。</p>
<p>我们用<strong>反证法</strong>来推理：</p>
<p>假设 ConcurrentHashMap 允许存放值为 null 的 value，这时有A、B两个线程，线程A调用<code>ConcurrentHashMap.get(key)</code>方法，返回为 null ，我们不知道这个 null 是没有映射的 null ，还是存的值就是 null 。</p>
<p>假设此时，返回为 null 的真实情况是没有找到对应的 key。那么，我们可以用 <code>ConcurrentHashMap.containsKey(key)</code>来验证我们的假设是否成立，我们期望的结果是返回 false 。</p>
<p>但是在我们调用 <code>ConcurrentHashMap.get(key)</code>方法之后，<code>containsKey</code>方法之前，线程B执行了<code>ConcurrentHashMap.put(key, null)</code>的操作。那么我们调用<code>containsKey</code>方法返回的就是 true 了，这就与我们的假设的真实情况不符合了，这就有了二义性。</p>
<p>至于 ConcurrentHashMap 中的 key 为什么也不能为 null  的问题，源码就是这样写的，哈哈。如果面试官不满意，就回答因为作者Doug不喜欢 null ，所以在设计之初就不允许了 null 的 key  存在。想要深入了解的小伙伴，可以看这篇文章<span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpJeE5UUTRNekUxTkE9PSZhbXA7bWlkPTIyNDc0ODQzNTQmYW1wO2lkeD0xJmFtcDtzbj04MGM5Mjg4MWI0N2E1ODZlYmE5YzYzM2ViNzhkMzZmNiZhbXA7Y2hrc209OTc5NmQ1YmZhMGUxNWNhOTcxM2ZmOWRjNmUxMDA1OTNlMGVmMDZlZDdlYTJmNjBjYjk4NGU0OTJjNGVkNDM4ZDI0MDVmYmIyYzRmZiZhbXA7c2NlbmU9MjEjd2VjaGF0X3JlZGlyZWN0">这道面试题我真不知道面试官想要的回答是什么<i class="fa fa-external-link-alt"></i></span></p>
<blockquote>
<p>ConcurrentHashMap 的并发度是什么？★★</p>
</blockquote>
<p>并发度可以理解为程序运行时能够同时更新 ConccurentHashMap且不产生锁竞争的最大线程数。在JDK1.7中，实际上就是ConcurrentHashMap中的分段锁个数，即Segment[]的数组长度，默认是16，这个值可以在构造函数中设置。</p>
<p>如果自己设置了并发度，ConcurrentHashMap 会使用大于等于该值的最小的2的幂指数作为实际并发度，也就是比如你设置的值是17，那么实际并发度是32。</p>
<p>如果并发度设置的过小，会带来严重的锁竞争问题；如果并发度设置的过大，原本位于同一个Segment内的访问会扩散到不同的Segment中，CPU cache命中率会下降，从而引起程序性能下降。</p>
<p>在JDK1.8中，已经摒弃了Segment的概念，选择了Node数组+链表+红黑树结构，并发度大小依赖于数组的大小。</p>
<blockquote>
<p>ConcurrentHashMap 迭代器是强一致性还是弱一致性？★★</p>
</blockquote>
<p>与 HashMap 迭代器是强一致性不同，ConcurrentHashMap 迭代器是弱一致性。</p>
<p>ConcurrentHashMap 的迭代器创建后，就会按照哈希表结构遍历每个元素，但在遍历过程中，内部元素可能会发生变化，如果变化发生在已遍历过的部分，迭代器就不会反映出来，而如果变化发生在未遍历过的部分，迭代器就会发现并反映出来，这就是弱一致性。</p>
<p>这样迭代器线程可以使用原来老的数据，而写线程也可以并发的完成改变，更重要的，这保证了多个线程并发执行的连续性和扩展性，是性能提升的关键。想要深入了解的小伙伴，可以看这篇文章：<span class="exturl" data-url="aHR0cDovL2lmZXZlLmNvbS9Db25jdXJyZW50SGFzaE1hcC13ZWFrbHktY29uc2lzdGVudC8=">http://ifeve.com/ConcurrentHashMap-weakly-consistent/<i class="fa fa-external-link-alt"></i></span></p>
<blockquote>
<h4 id="JDK1-7-与-JDK1-8-中ConcurrentHashMap-的区别？★★★★★"><a href="#JDK1-7-与-JDK1-8-中ConcurrentHashMap-的区别？★★★★★" class="headerlink" title="JDK1.7 与 JDK1.8 中ConcurrentHashMap 的区别？★★★★★"></a>JDK1.7 与 JDK1.8 中ConcurrentHashMap 的区别？★★★★★</h4></blockquote>
<ul>
<li>数据结构：取消了 Segment 分段锁的数据结构，取而代之的是数组+链表+红黑树的结构。</li>
<li>保证线程安全机制：JDK1.7 采用 Segment 的分段锁机制实现线程安全，其中 Segment 继承自 ReentrantLock 。JDK1.8 采用<code>CAS+synchronized</code>保证线程安全。</li>
<li>锁的粒度：JDK1.7 是对需要进行数据操作的 Segment 加锁，JDK1.8 调整为对每个数组元素加锁（Node）。</li>
<li>链表转化为红黑树：定位节点的 hash 算法简化会带来弊端，hash 冲突加剧，因此在链表节点数量大于 8（且数据总量大于等于 64）时，会将链表转化为红黑树进行存储。</li>
<li>查询时间复杂度：从 JDK1.7的遍历链表O(n)， JDK1.8 变成遍历红黑树O(logN)。</li>
</ul>
<blockquote>
<p>ConcurrentHashMap 和 Hashtable 的效率哪个更高？为什么？★★★★★</p>
</blockquote>
<p>ConcurrentHashMap 的效率要高于 Hashtable，因为 Hashtable  给整个哈希表加了一把大锁从而实现线程安全。而ConcurrentHashMap 的锁粒度更低，在 JDK1.7 中采用分段锁实现线程安全，在  JDK1.8 中采用<code>CAS+synchronized</code>实现线程安全。</p>
<blockquote>
<p>具体说一下Hashtable的锁机制 ★★★★★</p>
</blockquote>
<p>Hashtable 是使用 synchronized来实现线程安全的，给整个哈希表加了一把大锁，多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞等待需要的锁被释放，在竞争激烈的多线程场景中性能就会非常差！</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/1042BHfuE2.png" alt=""></p>
<blockquote>
<p>多线程下安全的操作 map还有其他方法吗？★★★</p>
</blockquote>
<p>还可以使用<code>Collections.synchronizedMap</code>方法，对方法进行加同步锁。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/06/02/1043OUgPJd.png" alt=""></p>
<p>如果传入的是 HashMap 对象，其实也是对 HashMap 做的方法做了一层包装，里面使用对象锁来保证多线程场景下，线程安全，本质也是对 HashMap 进行全表锁。<strong>在竞争激烈的多线程环境下性能依然也非常差，不推荐使用！</strong></p>

      
    </div>
   <div>
        
    </div>

   
    
    
    
      

      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>

  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xuemingde.com/posts/39ZYWX3.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.jpeg">
      <meta itemprop="name" content="meadel">
      <meta itemprop="description" content="我的愿望，世界和平">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Middle's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/39ZYWX3.html" class="post-title-link" itemprop="url">Redis高可用集群原理和实践</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-31 00:00:00" itemprop="dateCreated datePublished" datetime="2022-05-31T00:00:00+08:00">2022-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-13 16:46:48" itemprop="dateModified" datetime="2022-08-13T16:46:48+08:00">2022-08-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
            </span>

          
            <span id="/posts/39ZYWX3.html" class="post-meta-item leancloud_visitors" data-flag-title="Redis高可用集群原理和实践" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/posts/39ZYWX3.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/posts/39ZYWX3.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>原文：<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MTAzNTUxNzE0ODc5MzQwNTgw">Redis 高可用集群原理和实践 - 掘金<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>Redis 集群是 Redis 提供的分布式数据库方案，集群痛殴分片（sharding）来进行数据共享，并提供复制和故障转移能力。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/31104759.jpg" alt="31104759"></p>
<h1 id="集群环境搭建"><a href="#集群环境搭建" class="headerlink" title="集群环境搭建"></a>集群环境搭建</h1><p>Redis 集群最少需要 3 个 master 节点，这里我们搭建 3 个master 节点，3 个 slave 及节点（由于我机器配置受限，直接通过端口的方式模拟集群搭建，本处只是实验方便，<strong>生产环境不可采取此方案</strong>）。<br>环境搭建步骤如下：</p>
<ol>
<li><p>简单说明，首先我们先要定义集群节点的端口 <code>7000-7005</code> 然后配置文件复制 redis.conf 到对应的配置文件名。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/31104954.png" alt="31104954"></p>
</li>
</ol>
<ol>
<li>编辑 redis.conf 文件，主要修改以下的几个配置（如果需要设置密码需要配置 <code>requirepass</code>和  <code>masterauth</code>）</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">daemonize yes</span><br><span class="line"><span class="meta">#</span><span class="bash"> 这个端口和上面的配置清单一致即可</span></span><br><span class="line">port 7000 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动集群模式</span></span><br><span class="line">cluster-enabled yes</span><br><span class="line"><span class="meta">#</span><span class="bash"> 集群节点信息文件，这里700x最好和port对应上</span></span><br><span class="line">cluster-config-file nodes-7000.conf</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">appendonly yes</span><br></pre></td></tr></table></figure>
<ol>
<li><p>服务启动，注意我们需要启动所有的节点，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动所有的服务 7000-7005</span></span><br><span class="line">cd 7000</span><br><span class="line">redis-server ./redis-7000.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化集群，通过 <code>redis-cli --cluster create</code>命令初始化集群，命令如下(如果是生产环境，需要节点间 IP 以及端口是否可互相访问)：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 \</span><br><span class="line">127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 \</span><br><span class="line">--cluster-replicas 1</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>集群状态查询  </p>
<ul>
<li>登录节点 <code>redis-cli -c -h 127.0.0.1 -p 7000</code>, 注意一定要加 <code>-c</code> 表示集群模式。</li>
<li>查询集群状态  <code>cluster info</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">➜  etc redis-cli -c -h 127.0.0.1 -p 7000                         </span><br><span class="line">127.0.0.1:7000&gt; </span><br><span class="line">127.0.0.1:7000&gt; cluster info  </span><br><span class="line">cluster_state:ok</span><br><span class="line">cluster_slots_assigned:16384</span><br><span class="line">cluster_slots_ok:16384</span><br><span class="line">cluster_slots_pfail:0</span><br><span class="line">cluster_slots_fail:0</span><br><span class="line">cluster_known_nodes:6</span><br><span class="line">cluster_size:3</span><br><span class="line">cluster_current_epoch:6</span><br><span class="line">cluster_my_epoch:1</span><br><span class="line">cluster_stats_messages_ping_sent:263</span><br><span class="line">cluster_stats_messages_pong_sent:270</span><br><span class="line">cluster_stats_messages_sent:533</span><br><span class="line">cluster_stats_messages_ping_received:270</span><br><span class="line">cluster_stats_messages_pong_received:263</span><br><span class="line">cluster_stats_messages_received:533</span><br><span class="line">127.0.0.1:7000&gt; </span><br></pre></td></tr></table></figure>
<p>其他的集群创建方案 <code>utils/create-cluster</code>我们可以在参考资料中找到创建方式（参考文档：<span class="exturl" data-url="aHR0cHM6Ly9saW5rLmp1ZWppbi5jbj90YXJnZXQ9aHR0cHMlM0ElMkYlMkZyZWRpcy5pbyUyRmRvY3MlMkZtYW51YWwlMkZzY2FsaW5nJTJGJTIzcmVkaXMtY2x1c3Rlci0xMDE=">redis.io/docs/manual…<i class="fa fa-external-link-alt"></i></span>）</p>
</li>
</ol>
<h1 id="集群原理"><a href="#集群原理" class="headerlink" title="集群原理"></a>集群原理</h1><h2 id="槽指派机制"><a href="#槽指派机制" class="headerlink" title="槽指派机制"></a>槽指派机制</h2><p>Redis Cluster 将所有数据划分为 16384 个 slots(槽位)，每个节点负责其中一部分槽位。槽位的信息存储于每个节点中。<br>当 Redis Cluster 的客户端来连接集群时，它也会得到一份集群的槽位配置信息并将其缓存在客户端本地。这样当客户端要查找某个 key 时，可以直接定位到目标节点。同时因为槽位的信息可能会存在客户端与服务器不一致的情况，还需要纠正机制来实现槽位信息的校验调整。</p>
<h3 id="槽位定位算法"><a href="#槽位定位算法" class="headerlink" title="槽位定位算法"></a>槽位定位算法</h3><p>Cluster 默认会对 key 值使用 crc16 算法进行 hash 得到一个整数值，然后用这个整数值对 16384 进行与操作来得到具体槽位。<br>源码位置 <code>src/cluster.c</code> 中的 keyHashSlot 方法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crc16(key,keylen) &amp; <span class="number">0x3FFF</span></span><br></pre></td></tr></table></figure>
<p>为什是 16384 可以看看这篇文章 ：<span class="exturl" data-url="aHR0cHM6Ly9saW5rLmp1ZWppbi5jbj90YXJnZXQ9aHR0cHMlM0ElMkYlMkZ3d3cuY3Nkbi5uZXQlMkZ0YWdzJTJGTXR6YWtnNXNORGczTnpjdFlteHZad08wTzBPTzBPME8uaHRtbA==">Redis 为什么是 16384 个槽 ？<i class="fa fa-external-link-alt"></i></span></p>
<p>查询某个 key 那个节点上，方法如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查询 key 所在的槽位</span></span><br><span class="line">127.0.0.1:7000&gt; cluster keyslot wahaha</span><br><span class="line">(integer) 12318</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查询所有的 槽分布信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以得出结论： wahaha 这个 key 在 7002 这个节点上</span></span><br><span class="line">127.0.0.1:7000&gt; cluster slots</span><br><span class="line">1) 1) (integer) 10923</span><br><span class="line">   2) (integer) 16383</span><br><span class="line">   3) 1) &quot;127.0.0.1&quot;</span><br><span class="line">      2) (integer) 7002</span><br><span class="line">      3) &quot;de631f8ac9649f5d9fb12013dc01407f953c3299&quot;</span><br><span class="line">   4) 1) &quot;127.0.0.1&quot;</span><br><span class="line">      2) (integer) 7004</span><br><span class="line">      3) &quot;6ac6065d07eb44b674a181da897401ec4cea9571&quot;</span><br><span class="line">2) 1) (integer) 5461</span><br><span class="line">   2) (integer) 10922</span><br><span class="line">   3) 1) &quot;127.0.0.1&quot;</span><br><span class="line">      2) (integer) 7001</span><br><span class="line">      3) &quot;e36fc81472afb04b9c88af1504a8e02647de1b13&quot;</span><br><span class="line">   4) 1) &quot;127.0.0.1&quot;</span><br><span class="line">      2) (integer) 7003</span><br><span class="line">      3) &quot;a89dcff90147f6cc9425ff0c6e4bead7017dc1e1&quot;</span><br><span class="line">3) 1) (integer) 0</span><br><span class="line">   2) (integer) 5460</span><br><span class="line">   3) 1) &quot;127.0.0.1&quot;</span><br><span class="line">      2) (integer) 7000</span><br><span class="line">      3) &quot;0acfc8b3dd2223333a03bbcf856dd2a839d2e072&quot;</span><br><span class="line">   4) 1) &quot;127.0.0.1&quot;</span><br><span class="line">      2) (integer) 7005</span><br><span class="line">      3) &quot;57ddd19f38d8b748386944d15d32671fb5cb1570&quot;</span><br><span class="line">127.0.0.1:7000&gt; </span><br></pre></td></tr></table></figure>
<p>其实没有这么麻烦，集群模式支持 <strong>跳转重定位</strong> 我们直接 get 就可以跳转过去。</p>
<h3 id="跳转重定位"><a href="#跳转重定位" class="headerlink" title="跳转重定位"></a>跳转重定位</h3><p>当客户端向一个错误的节点发出了指令，该节点会发现指令的 key 所在的槽位并不归自己管理，这时它会向客户端发送一个特殊的跳转指令携带目标操作的节点地址，告诉客户端去连这个节点去获取数据。客户端收到指令后除了跳转到正确的节点上去操作，还会同步更新纠正本地的槽位映射表缓存，后续所有 key 将使用新的槽位映射表。</p>
<blockquote>
<p>大白话说：就是如果当前 key 是自己的节点的槽位就自己处理，如果不是自己的槽位，就转向目标槽位的节点。</p>
</blockquote>
<p>演示一下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set abc sdl</span><br><span class="line">set sbc sdl</span><br></pre></td></tr></table></figure>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/31105832.jpg" alt="31105832"></p>
<h2 id="集群通讯机制"><a href="#集群通讯机制" class="headerlink" title="集群通讯机制"></a>集群通讯机制</h2><p>redis cluster 节点间采取 gossip 协议进行通信<br>维护集群的元数据(集群节点信息，主从角色，节点数量，各节点共享的数据等)有两种方式：</p>
<ul>
<li>集中式</li>
<li>gossip</li>
</ul>
<h3 id="集中式"><a href="#集中式" class="headerlink" title="集中式"></a>集中式</h3><p>优点在于元数据的更新和读取，时效性非常好，一旦元数据出现变更立即就会更新到集中式的存储中，其他节点读取的时候立即就可以立即感知到；不足在于所有的元数据的更新压力全部集中在一个地方，可能导致元数据的存储压力。 很多中间件都会借助 zookeeper 集中式存储元数据。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/31105938.jpg" alt="31105938"></p>
<h3 id="gossip"><a href="#gossip" class="headerlink" title="gossip"></a>gossip</h3><p><img data-src="https://xuemingde.com/pages/image/2022/05/31110007.jpg" alt="31110007"></p>
<p>gossip 协议包含多种消息，包括ping，pong，meet，fail等等。<br>meet：某个节点发送meet给新加入的节点，让新节点加入集群中，然后新节点就会开始与其他节点进行通信；<br>ping：每个节点都会频繁给其他节点发送ping，其中包含自己的状态还有自己维护的集群元数据，互相通过ping交换元数据(类似自己感知到的集群节点增加和移除，hash slot信息等)；<br>pong: 对ping和meet消息的返回，包含自己的状态和其他信息，也可以用于信息广播和更新；<br>fail: 某个节点判断另一个节点fail之后，就发送fail给其他节点，通知其他节点，指定的节点宕机了。</p>
<p><strong>gossip协议的优点在于元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续，打到所有节点上去更新，有一定的延时，降低了压力；缺点在于元数据更新有延时可能导致集群的一些操作会有一些滞后。</strong></p>
<h4 id="gossip-通信的-10000-端口"><a href="#gossip-通信的-10000-端口" class="headerlink" title="gossip 通信的 10000 端口"></a>gossip 通信的 10000 端口</h4><p>每个节点都有一个专门用于节点间gossip通信的端口，就是自己提供服务的端口号+10000，比如7001，那么用于节点间通信的就是17001端口。 每个节点每隔一段时间都会往另外几个节点发送ping消息，同时其他几点接收到ping消息之后返回pong消息。</p>
<h4 id="网络抖动"><a href="#网络抖动" class="headerlink" title="网络抖动"></a>网络抖动</h4><p>真实世界的机房网络往往并不是风平浪静的，它们经常会发生各种各样的小问题。比如网络抖动就是非常常见的一种现象，突然之间部分连接变得不可访问，然后很快又恢复正常。<br>为解决这种问题，Redis Cluster 提供了一种选项cluster-node-timeout，表示当某个节点持续 timeout 的时间失联时，才可以认定该节点出现故障，需要进行主从切换。如果没有这个选项，网络抖动会导致主从频繁切换 (数据的重新复制)。</p>
<h2 id="集群选举原理"><a href="#集群选举原理" class="headerlink" title="集群选举原理"></a>集群选举原理</h2><p>当slave发现自己的master变为FAIL状态时，便尝试进行Failover，以期成为新的master。由于挂掉的master可能会有多个slave，从而存在多个slave竞争成为master节点的过程， 其过程如下：</p>
<ol>
<li>slave发现自己的master变为FAIL</li>
<li>将自己记录的集群currentEpoch加1，并广播FAILOVER_AUTH_REQUEST 信息</li>
<li>其他节点收到该信息，只有master响应，判断请求者的合法性，并发送FAILOVER_AUTH_ACK，对每一个epoch只发送一次ack</li>
<li>尝试failover的slave收集master返回的FAILOVER_AUTH_ACK</li>
<li>slave收到超过半数master的ack后变成新Master(这里解释了集群为什么至少需要三个主节点，如果只有两个，当其中一个挂了，只剩一个主节点是不能选举成功的)</li>
<li>slave广播Pong消息通知其他集群节点。</li>
</ol>
<p>从节点并不是在主节点一进入 FAIL 状态就马上尝试发起选举，而是有一定延迟，一定的延迟确保我们等待FAIL状态在集群中传播，slave如果立即尝试选举，其它masters或许尚未意识到FAIL状态，可能会拒绝投票</p>
<p>延迟计算公式：</p>
<blockquote>
<p>DELAY = 500ms + random(0 ~ 500ms) + SLAVE_RANK * 1000ms</p>
</blockquote>
<p>SLAVE_RANK表示此slave已经从master复制数据的总量的rank。Rank越小代表已复制的数据越新。这种方式下，持有最新数据的slave将会首先发起选举（理论上）。</p>
<h3 id="集群脑裂数据丢失问题"><a href="#集群脑裂数据丢失问题" class="headerlink" title="集群脑裂数据丢失问题"></a>集群脑裂数据丢失问题</h3><p>Redis 集群没有过半机制会有脑裂问题，网络分区导致脑裂后多个主节点对外提供写服务，一旦网络分区恢复，会将其中一个主节点变为从节点，这时会有大量数据丢失。</p>
<p>规避方法可以在 redis 配置里加上参数(这种方法不可能百分百避免数据丢失，参考集群leader选举机制)：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 写数据成功最少同步的slave数量，这个数量可以模仿大于半数机制配置，</span><br><span class="line">// 比如集群总共三个节点可以配置1，加上leader就是2，超过了半数</span><br><span class="line">min-replicas-to-write 1  </span><br></pre></td></tr></table></figure>
<p>注意：这个配置在一定程度上会影响集群的可用性，比如slave要是少于1个，这个集群就算leader正常也不能提供服务了，需要具体场景权衡选择。</p>
<h3 id="集群是否完整才能对外提供服务"><a href="#集群是否完整才能对外提供服务" class="headerlink" title="集群是否完整才能对外提供服务"></a>集群是否完整才能对外提供服务</h3><p>当redis.conf的配置cluster-require-full-coverage为no时，表示当负责一个插槽的主库下线<br>且没有相应的从库进行故障恢复时，集群仍然可用，如果为yes则集群不可用(默认为 yes)。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/31110357.jpg" alt="31110357"></p>
<h3 id="Redis-集群为什么至少需要三个master节点，并且推荐节点数为奇数？"><a href="#Redis-集群为什么至少需要三个master节点，并且推荐节点数为奇数？" class="headerlink" title="Redis 集群为什么至少需要三个master节点，并且推荐节点数为奇数？"></a>Redis 集群为什么至少需要三个master节点，并且推荐节点数为奇数？</h3><p>因为新master的选举需要大于半数的集群master节点同意才能选举成功，如果只有两个master节点，当其中一个挂了，是达不到选举新master的条件的。</p>
<p>奇数个master节点可以在满足选举该条件的基础上节省一个节点，比如三个master节点和四个master节点的集群相比，大家如果都挂了一个master节点都能选举新master节点，如果都挂了两个master节点都没法选举新master节点了，所以奇数的master节点更多的是<strong>从节省机器资源角度出发</strong>说的。</p>
<h3 id="Redis-集群对批量操作命令的支持"><a href="#Redis-集群对批量操作命令的支持" class="headerlink" title="Redis 集群对批量操作命令的支持"></a>Redis 集群对批量操作命令的支持</h3><p><img data-src="https://xuemingde.com/pages/image/2022/05/31110442.jpg" alt="31110442"></p>
<p>如何让多个 key 落到一个槽里面 ？<br>对于类似mset，mget这样的多个key的原生批量操作命令，redis集群只支持所有key落在同一slot的情况，如果有多个key<strong>一定要用mset命令在redis集群上操作，则可以在key的前面加上{XX}，这样参数数据分片hash计算的只会是大括号里的值，这样能确保不同的key能落到同一slot里去</strong>，示例如下：</p>
<blockquote>
<p>mset {user1}:1:name zhangsan {user1}:1:age 18</p>
</blockquote>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/31110518.jpg" alt="31110518"></p>
<p>假设name和age计算的hash slot值不一样，但是这条命令在集群下执行，redis只会用大括号里的 user1 做hash slot计算，所以算出来的slot值肯定相同，最后都能落在同一slot。</p>
<h3 id="对比-哨兵leader选举流程"><a href="#对比-哨兵leader选举流程" class="headerlink" title="对比: 哨兵leader选举流程"></a>对比: 哨兵leader选举流程</h3><p>当一个master服务器被某sentinel视为下线状态后，该sentinel会与其他sentinel协商选出sentinel的leader进行故障转移工作。每个发现master服务器进入下线的sentinel都可以要求其他sentinel选自己为sentinel的leader，选举是先到先得。同时每个sentinel每次选举都会自增配置纪元(选举周期)，每个纪元中只会选择一个sentinel的leader。如果所有超过一半的sentinel选举某sentinel作为leader。之后该sentinel进行故障转移操作，从存活的slave中选举出新的master，这个选举过程跟集群的master选举很类似。</p>
<p>哨兵集群只有一个哨兵节点，redis的主从也能正常运行以及选举master，如果master挂了，那唯一的那个哨兵节点就是哨兵leader了，可以正常选举新master。</p>
<p>不过为了高可用一般都推荐至少部署三个哨兵节点。为什么推荐奇数个哨兵节点原理跟集群奇数个master节点类似。</p>
<h1 id="集群故障转移"><a href="#集群故障转移" class="headerlink" title="集群故障转移"></a>集群故障转移</h1><p>Redis 集群中的节点分为主节点（master）和从节点（slave）,其中主节点用于处理槽，而从节点则用于复制某个主节点，并且在复制主节点下线时，代替主节点继续处理命令请求。</p>
<h2 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h2><p>集群中的每个节点都会<strong>定期</strong>地向集群中的其他节点发送PING消息，以此来检测对方是否在线，如果接收PING消息的节点没有在规定的时间内，向发送PING消息的节点返回PONG消息，那么发送PING消息的节点就会将接收PING消息的节点标记为<strong>疑似下线（probable fail，PFAIL）</strong>。</p>
<p>如果在一个集群里面，半数以上负责处理槽的主节点都将某个主节点x报告为疑似下线，那么这个主节点x将被标记为<strong>已下线（FAIL）</strong>，将主节点x标记为已下线的节点会向集群广播一条关于主节点x的FAIL消息，所有收到这条FAIL消息的节点都会立即将主节点x标记为已下线。</p>
<p>举个例子，主节点7002和主节点7003都认为主节点7000进入了下线状态，并且主节点7001也认为主节点7000进入了疑似下线状态，在集群四个负责处理槽的主节点里面，有三个都将主节点7000标记为下线，数量已经超过了半数，所以主节点7001会将主节点7000标记为已下线，并向集群广播一条关于主节点7000的FAIL消息，如图所示：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/31110629.jpg" alt="31110629"></p>
<h2 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h2><p>当一个从节点发现自己正在复制的主节点进入了已下线状态时，从节点将开始对下线主节点进行故障转移，以下是故障转移的执行步骤：</p>
<ol>
<li>复制下线主节点的所有从节点里面，会有一个从节点被选中。</li>
<li>被选中的从节点会执行<code>SLAVEOF no one</code>命令，成为新的主节点。</li>
<li>新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己。</li>
<li>新的主节点向集群广播一条PONG消息，这条PONG消息可以让集群中的其他节点立即知道这个节点已经由从节点变成了主节点，并且这个主节点已经接管了原本由已下线节点负责处理的槽。</li>
<li>新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成。</li>
</ol>
<h2 id="重新选择新节点"><a href="#重新选择新节点" class="headerlink" title="重新选择新节点"></a>重新选择新节点</h2><p>新的主节点是通过选举产生的。以下是集群选举新的主节点的方法：</p>
<ol>
<li>集群的配置纪元是一个自增计数器，它的初始值为0。</li>
<li>当集群里的某个节点开始一次故障转移操作时，集群配置纪元的值会被增一。</li>
<li>对于每个配置纪元，集群里每个负责处理槽的主节点都有一次投票的机会，而第一个向主节点要求投票的从节点将获得主节点的投票。</li>
<li>当从节点发现自己正在复制的主节点进入已下线状态时，从节点会向集群广播一条CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST消息，要求所有收到这条消息、并且具有投票权的主节点向这个从节点投票。</li>
<li>如果一个主节点具有投票权（它正在负责处理槽），并且这个主节点尚未投票给其他从节点，那么主节点将向要求投票的从节点返回一条CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息，表示这个主节点支持从节点成为新的主节点。</li>
<li>每个参与选举的从节点都会接收CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK消息，并根据自己收到了多少条这种消息来统计自己获得了多少主节点的支持。</li>
<li>如果集群里有N个具有投票权的主节点，那么当一个从节点收集到大于等于N/2+1张支持票时，这个从节点就会当选为新的主节点。</li>
<li>因为在每一个配置纪元里面，每个具有投票权的主节点只能投一次票，所以如果有N个主节点进行投票，那么具有大于等于N/2+1张支持票的从节点只会有一个，这确保了新的主节点只会有一个。</li>
<li>如果在一个配置纪元里面没有从节点能收集到足够多的支持票，那么集群进入一个新的配置纪元，并再次进行选举，直到选出新的主节点为止。</li>
</ol>
<p>Cluster 选举新主节点的方法和 Sentinel 的方法非常相似，因为两者都是基于 Raft 算法的领头选举（leader election）方法来实现的。</p>
<h1 id="水平拓展"><a href="#水平拓展" class="headerlink" title="水平拓展"></a>水平拓展</h1><h2 id="拓展主节点"><a href="#拓展主节点" class="headerlink" title="拓展主节点"></a>拓展主节点</h2><p>集群状态查询</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:7000&gt; cluster nodes </span><br><span class="line">6ac6065d07eb44b674a181da897401ec4cea9571 127.0.0.1:7004@17004 slave de631f8ac9649f5d9fb12013dc01407f953c3299 0 1653897401000 3 connected</span><br><span class="line">de631f8ac9649f5d9fb12013dc01407f953c3299 127.0.0.1:7002@17002 master - 0 1653897402475 3 connected 10923-16383</span><br><span class="line">a89dcff90147f6cc9425ff0c6e4bead7017dc1e1 127.0.0.1:7003@17003 slave e36fc81472afb04b9c88af1504a8e02647de1b13 0 1653897401956 2 connected</span><br><span class="line">e36fc81472afb04b9c88af1504a8e02647de1b13 127.0.0.1:7001@17001 master - 0 1653897401541 2 connected 5461-10922</span><br><span class="line">0acfc8b3dd2223333a03bbcf856dd2a839d2e072 127.0.0.1:7000@17000 myself,master - 0 1653897400000 1 connected 0-5460</span><br><span class="line">57ddd19f38d8b748386944d15d32671fb5cb1570 127.0.0.1:7005@17005 slave 0acfc8b3dd2223333a03bbcf856dd2a839d2e072 0 1653897401000 1 connected</span><br><span class="line">127.0.0.1:7000&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="拓展规划"><a href="#拓展规划" class="headerlink" title="拓展规划"></a>拓展规划</h3><p>我们在原始集群基础上再增加一主(7006)一从(7007)</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/31110722.png" alt="31110722"></p>
<p>启动节点</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis-7006.conf</span><br><span class="line">redis-server redis-7007.conf        </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="集群中加入节点"><a href="#集群中加入节点" class="headerlink" title="集群中加入节点"></a>集群中加入节点</h3><p>加入集群</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">➜  etc redis-cli --cluster add-node 127.0.0.1:7006 127.0.0.1:7001</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Adding node 127.0.0.1:7006 to cluster 127.0.0.1:7001</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7001)</span></span><br><span class="line">M: e36fc81472afb04b9c88af1504a8e02647de1b13 127.0.0.1:7001</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: a89dcff90147f6cc9425ff0c6e4bead7017dc1e1 127.0.0.1:7003</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates e36fc81472afb04b9c88af1504a8e02647de1b13</span><br><span class="line">S: 6ac6065d07eb44b674a181da897401ec4cea9571 127.0.0.1:7004</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates de631f8ac9649f5d9fb12013dc01407f953c3299</span><br><span class="line">S: 57ddd19f38d8b748386944d15d32671fb5cb1570 127.0.0.1:7005</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 0acfc8b3dd2223333a03bbcf856dd2a839d2e072</span><br><span class="line">M: de631f8ac9649f5d9fb12013dc01407f953c3299 127.0.0.1:7002</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 0acfc8b3dd2223333a03bbcf856dd2a839d2e072 127.0.0.1:7000</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Check <span class="keyword">for</span> open slots...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Check slots coverage...</span></span><br><span class="line">[OK] All 16384 slots covered.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Send CLUSTER MEET to node 127.0.0.1:7006 to make it join the cluster.</span></span><br><span class="line">[OK] New node added correctly.</span><br><span class="line">➜  etc </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如下，7006加入了集群，并且默认是一个master节点：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  etc redis-cli -p 7001 cluster nodes</span><br><span class="line">2109c2832177e8514174c6ef8fefd681076e28df 127.0.0.1:7006@17006 master - 0 1653919429534 0 connected</span><br><span class="line">a89dcff90147f6cc9425ff0c6e4bead7017dc1e1 127.0.0.1:7003@17003 slave e36fc81472afb04b9c88af1504a8e02647de1b13 0 1653919430000 2 connected</span><br><span class="line">6ac6065d07eb44b674a181da897401ec4cea9571 127.0.0.1:7004@17004 slave de631f8ac9649f5d9fb12013dc01407f953c3299 0 1653919430549 3 connected</span><br><span class="line">57ddd19f38d8b748386944d15d32671fb5cb1570 127.0.0.1:7005@17005 slave 0acfc8b3dd2223333a03bbcf856dd2a839d2e072 0 1653919430549 1 connected</span><br><span class="line">de631f8ac9649f5d9fb12013dc01407f953c3299 127.0.0.1:7002@17002 master - 0 1653919429129 3 connected 10923-16383</span><br><span class="line">0acfc8b3dd2223333a03bbcf856dd2a839d2e072 127.0.0.1:7000@17000 master - 0 1653919430549 1 connected 0-5460</span><br><span class="line">e36fc81472afb04b9c88af1504a8e02647de1b13 127.0.0.1:7001@17001 myself,master - 0 1653919429000 2 connected 5461-10922</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="设置和迁移分片"><a href="#设置和迁移分片" class="headerlink" title="设置和迁移分片"></a>设置和迁移分片</h3><p>为集群分配分片</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster reshard 127.0.0.1:7001</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在执行过程中会询问，计划迁移槽数，迁移数据目标，以及迁移数据来源。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/31110818.jpg" alt="31110818"></p>
<p>重新分配后的结果查询 <code>redis-cli -p 7001 cluster nodes</code></p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/31110858.jpg" alt="31110858"></p>
<p>配置从 7006 的从节点 7007,  同样也是先执行加入集群的命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster add-node 127.0.0.1:7007 127.0.0.1:7001</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="设置从节点"><a href="#设置从节点" class="headerlink" title="设置从节点"></a>设置从节点</h3><p>我们需要执行 replicate 命令来指定当前节点(从节点)的主节点id为哪个,首先需要连接新加的7007节点的客户端，然后使用集群命令进行操作，把当前的7007(slave)节点指定到一个主节点下(这里使用之前创建的7006主节点)</p>
<p>具体的命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查询集群节点</span></span><br><span class="line">➜  etc redis-cli -p 7001 cluster nodes                           </span><br><span class="line">2109c2832177e8514174c6ef8fefd681076e28df 127.0.0.1:7006@17006 master - 0 1653920562718 7 connected 0-1332 5461-6794 10923-12255</span><br><span class="line">a89dcff90147f6cc9425ff0c6e4bead7017dc1e1 127.0.0.1:7003@17003 slave e36fc81472afb04b9c88af1504a8e02647de1b13 0 1653920561710 2 connected</span><br><span class="line">6ac6065d07eb44b674a181da897401ec4cea9571 127.0.0.1:7004@17004 slave de631f8ac9649f5d9fb12013dc01407f953c3299 0 1653920562000 3 connected</span><br><span class="line">57ddd19f38d8b748386944d15d32671fb5cb1570 127.0.0.1:7005@17005 slave 0acfc8b3dd2223333a03bbcf856dd2a839d2e072 0 1653920562516 1 connected</span><br><span class="line">8d935918d877a63283e1f3a1b220cdc8cb73c414 127.0.0.1:7007@17007 master - 0 1653920563000 0 connected</span><br><span class="line">de631f8ac9649f5d9fb12013dc01407f953c3299 127.0.0.1:7002@17002 master - 0 1653920563000 3 connected 12256-16383</span><br><span class="line">0acfc8b3dd2223333a03bbcf856dd2a839d2e072 127.0.0.1:7000@17000 master - 0 1653920561506 1 connected 1333-5460</span><br><span class="line">e36fc81472afb04b9c88af1504a8e02647de1b13 127.0.0.1:7001@17001 myself,master - 0 1653920562000 2 connected 6795-10922</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 登录到新加节点</span></span><br><span class="line">➜  etc redis-cli -p 7007</span><br><span class="line">127.0.0.1:7007&gt; </span><br><span class="line"><span class="meta">#</span><span class="bash"> 制定当前当前节点的主节点 7006</span></span><br><span class="line">127.0.0.1:7007&gt; cluster replicate 2109c2832177e8514174c6ef8fefd681076e28df</span><br><span class="line">OK</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重新查询集群状态</span></span><br><span class="line">127.0.0.1:7007&gt; cluster nodes</span><br><span class="line">57ddd19f38d8b748386944d15d32671fb5cb1570 127.0.0.1:7005@17005 slave 0acfc8b3dd2223333a03bbcf856dd2a839d2e072 0 1653920688403 1 connected</span><br><span class="line">8d935918d877a63283e1f3a1b220cdc8cb73c414 127.0.0.1:7007@17007 myself,slave 2109c2832177e8514174c6ef8fefd681076e28df 0 1653920685000 7 connected</span><br><span class="line">2109c2832177e8514174c6ef8fefd681076e28df 127.0.0.1:7006@17006 master - 0 1653920688000 7 connected 0-1332 5461-6794 10923-12255</span><br><span class="line">de631f8ac9649f5d9fb12013dc01407f953c3299 127.0.0.1:7002@17002 master - 0 1653920687000 3 connected 12256-16383</span><br><span class="line">0acfc8b3dd2223333a03bbcf856dd2a839d2e072 127.0.0.1:7000@17000 master - 0 1653920687000 1 connected 1333-5460</span><br><span class="line">6ac6065d07eb44b674a181da897401ec4cea9571 127.0.0.1:7004@17004 slave de631f8ac9649f5d9fb12013dc01407f953c3299 0 1653920688099 3 connected</span><br><span class="line">a89dcff90147f6cc9425ff0c6e4bead7017dc1e1 127.0.0.1:7003@17003 slave e36fc81472afb04b9c88af1504a8e02647de1b13 0 1653920688504 2 connected</span><br><span class="line">e36fc81472afb04b9c88af1504a8e02647de1b13 127.0.0.1:7001@17001 master - 0 1653920687392 2 connected 6795-10922</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后我们再次查询，发现 7007 成功变成了 7008 的主节点</p>
<h2 id="主节点下线"><a href="#主节点下线" class="headerlink" title="主节点下线"></a>主节点下线</h2><p>彻底删除主节点，因为主节点中存在数据，所以我们可以分为两个步骤操作</p>
<ul>
<li>数据迁移</li>
<li>节点下线</li>
</ul>
<p>为了方便验证，我先设置一个数据</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:7001&gt; set sdl 123</span><br><span class="line"><span class="meta">-&gt;</span><span class="bash"> Redirected to slot [11164] located at 127.0.0.1:7006</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:7006&gt; get sdl</span><br><span class="line">&quot;123&quot;</span><br></pre></td></tr></table></figure>
<p>先下先从节点, 执行一下命令：<br><code>redis-cli --cluster del-node 127.0.0.1:7007 8d935918d877a63283e1f3a1b220cdc8cb73c414</code></p>
<h3 id="数据迁出"><a href="#数据迁出" class="headerlink" title="数据迁出"></a>数据迁出</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">➜  etc redis-cli --cluster reshard 127.0.0.1:7001</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Performing Cluster Check (using node 127.0.0.1:7001)</span></span><br><span class="line">M: e36fc81472afb04b9c88af1504a8e02647de1b13 127.0.0.1:7001</span><br><span class="line">   slots:[10212-10922] (711 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 2109c2832177e8514174c6ef8fefd681076e28df 127.0.0.1:7006</span><br><span class="line">   slots:[11471-12255] (785 slots) master</span><br><span class="line">S: a89dcff90147f6cc9425ff0c6e4bead7017dc1e1 127.0.0.1:7003</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates e36fc81472afb04b9c88af1504a8e02647de1b13</span><br><span class="line">S: 6ac6065d07eb44b674a181da897401ec4cea9571 127.0.0.1:7004</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates de631f8ac9649f5d9fb12013dc01407f953c3299</span><br><span class="line">S: 57ddd19f38d8b748386944d15d32671fb5cb1570 127.0.0.1:7005</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 0acfc8b3dd2223333a03bbcf856dd2a839d2e072</span><br><span class="line">M: de631f8ac9649f5d9fb12013dc01407f953c3299 127.0.0.1:7002</span><br><span class="line">   slots:[15624-16383] (760 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 0acfc8b3dd2223333a03bbcf856dd2a839d2e072 127.0.0.1:7000</span><br><span class="line">   slots:[0-10211],[10923-11470],[12256-15623] (14128 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Check <span class="keyword">for</span> open slots...</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; Check slots coverage...</span></span><br><span class="line">[OK] All 16384 slots covered.</span><br><span class="line">How many slots do you want to move (from 1 to 16384)? 785</span><br><span class="line">What is the receiving node ID? 0acfc8b3dd2223333a03bbcf856dd2a839d2e072</span><br><span class="line">Please enter all the source node IDs.</span><br><span class="line">  Type &#x27;all&#x27; to use all the nodes as source nodes for the hash slots.</span><br><span class="line">  Type &#x27;done&#x27; once you entered all the source nodes IDs.</span><br><span class="line">Source node #1: 2109c2832177e8514174c6ef8fefd681076e28df</span><br><span class="line">Source node #2: done</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查询节点槽信息<br><img data-src="https://xuemingde.com/pages/image/2022/05/31111010.jpg" alt="31111010"></p>
<p>节点下线</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster del-node 127.0.0.1:7006 2109c2832177e8514174c6ef8fefd681076e28df</span><br></pre></td></tr></table></figure>
<p>执行后结果如下：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/31111039.jpg" alt="31111039"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>《Redis 设计与实现》黄健宏</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9saW5rLmp1ZWppbi5jbj90YXJnZXQ9aHR0cHMlM0ElMkYlMkZ3d3cuY3Nkbi5uZXQlMkZ0YWdzJTJGTXR6YWtnNXNORGczTnpjdFlteHZad08wTzBPTzBPME8uaHRtbA==">Redis 为什么是 16384 个槽 ？<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9saW5rLmp1ZWppbi5jbj90YXJnZXQ9aHR0cHMlM0ElMkYlMkZibG9nLmNzZG4ubmV0JTJGd2FuZGVyc3RhcnJ5c2t5JTJGYXJ0aWNsZSUyRmRldGFpbHMlMkYxMTgxNTc3NTE=">blog.csdn.net/wanderstarr…<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9saW5rLmp1ZWppbi5jbj90YXJnZXQ9aHR0cHMlM0ElMkYlMkZzZWdtZW50ZmF1bHQuY29tJTJGYSUyRjExOTAwMDAwMzgzNzM1NDY=">segmentfault.com/a/119000003…<i class="fa fa-external-link-alt"></i></span></li>
<li>部分图片来源于网络，如有侵权请留言</li>
</ul>

      
    </div>
   <div>
        
    </div>

   
    
    
    
      

      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>

  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xuemingde.com/posts/12A6AMS.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.jpeg">
      <meta itemprop="name" content="meadel">
      <meta itemprop="description" content="我的愿望，世界和平">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Middle's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/12A6AMS.html" class="post-title-link" itemprop="url">四种WebSocket 使用方式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-10 00:00:00" itemprop="dateCreated datePublished" datetime="2022-05-10T00:00:00+08:00">2022-05-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-06-07 09:12:47" itemprop="dateModified" datetime="2023-06-07T09:12:47+08:00">2023-06-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/" itemprop="url" rel="index"><span itemprop="name">网络通信</span></a>
                </span>
            </span>

          
            <span id="/posts/12A6AMS.html" class="post-meta-item leancloud_visitors" data-flag-title="四种WebSocket 使用方式" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/posts/12A6AMS.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/posts/12A6AMS.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>13 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MDk1OTQwMDgyMTg3NjMyNjc3">一文搞懂四种 WebSocket 使用方式，建议收藏！ - 掘金<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>在上家公司做IM消息系统的时候，一直是使用 WebSocket 作为收发消息的基础组件，今天就和大家聊聊在 Java 中，使用 WebSocket 所常见的四种姿势，如果大家以后或者现在碰到有要使用 WebSoocket 的情况可以做个参考。</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/11/0752-Sf6CD4.awebp" alt="img"></p>
<p>上面的思维导图已经给大家列出了三种使用 WebSocket 的方式，下文会对它们的特点进行一一解读，不同的方式具有不同的特点，我们先按下不表。</p>
<p>在这里，我想让大家思考一下我在思维导图中列举的第四种做 WebScoket 支持的方案可能是什么？不知道大家能不能猜对，后文将会给出答案。</p>
<h2 id="WS简介"><a href="#WS简介" class="headerlink" title="WS简介"></a>WS简介</h2><p>在正式开始之前，我觉得有必要简单介绍一下 WebSocket 协议，引入任何一个东西之前都有必要知道我们为什么需要它？</p>
<p>在 Web 开发领域，我们最常用的协议是 HTTP，HTTP 协议和 WS 协议都是基于 TCP 所做的封装，但是 HTTP 协议从一开始便被设计成请求 -&gt; 响应的模式，所以在很长一段时间内 HTTP 都是只能从客户端发向服务端，并不具备从服务端主动推送消息的功能，这也导致在浏览器端想要做到服务器主动推送的效果只能用一些轮询和长轮询的方案来做，但因为它们并不是真正的全双工，所以在消耗资源多的同时，实时性也没理想中那么好。</p>
<p>既然市场有需求，那肯定也会有对应的新技术出现，WebSocket 就是这样的背景下被开发与制定出来的，并且它作为 HTML5 规范的一部分，得到了所有主流浏览器的支持，同时它还兼容了 HTTP 协议，默认使用 HTTP 的80端口和443端口，同时使用 HTTP header 进行协议升级。</p>
<p>和 HTTP 相比，WS 至少有以下几个优点：</p>
<ol>
<li>使用的资源更少：因为它的头更小。</li>
<li>实时性更强：服务端可以通过连接主动向客户端推送消息。</li>
<li>有状态：开启链接之后可以不用每次都携带状态信息。</li>
</ol>
<p>除了这几个优点以外，我觉得对于 WS 我们开发人员起码还要了解它的握手过程和协议帧的意义，这就像学习 TCP 的时候需要了解 TCP 头每个字节帧对应的意义一样。</p>
<p>像握手过程我就不说了，因为它复用了 HTTP 头只需要在<span class="exturl" data-url="aHR0cHM6Ly9saW5rLmp1ZWppbi5jbj90YXJnZXQ9aHR0cHMlM0ElMkYlMkZ6aC53aWtpcGVkaWEub3JnJTJGd2lraSUyRldlYlNvY2tldA==">维基百科<i class="fa fa-external-link-alt"></i></span>（阮一峰的文章讲的也很明白）上面看一下就明白了，像协议帧的话无非就是：标识符、操作符、数据、数据长度这些协议通用帧，基本都没有深入了解的必要，我认为一般只需要关心 WS 的操作符就可以了。</p>
<p>WS 的操作符代表了 WS 的消息类型，它的消息类型主要有如下六种：</p>
<ol>
<li><strong>文本消息</strong></li>
<li><strong>二进制消息</strong></li>
<li><strong>分片消息</strong>（分片消息代表此消息是一个某个消息中的一部分，想想大文件分片）</li>
<li><strong>连接关闭消息</strong></li>
<li><strong>PING 消息</strong></li>
<li><strong>PONG 消息</strong>（PING的回复就是PONG）</li>
</ol>
<p>那我们既然知道了 WS 主要有以上六种操作，那么一个正常的 WS 框架应当可以很轻松的处理以上这几种消息，所以接下来就是本文的中心内容，看看以下这几种 WS 框架能不能很方便的处理这几种 WS 消息。</p>
<h2 id="J2EE-方式"><a href="#J2EE-方式" class="headerlink" title="J2EE 方式"></a>J2EE 方式</h2><p>先来 J2EE，一般我把 javax 包里面对 JavaWeb 的扩展都叫做 J2EE，这个定义是否完全正确我觉得没必要深究，只是一种个人习惯，而本章节所介绍的 J2EE 方式则是指 Tomcat 为 WS 所做的支持，这套代码的包名前缀叫做：<code>javax.websocket</code>。</p>
<p>这套代码中定义了一套适用于 WS 开发的注解和相关支持，我们可以利用它和 Tomcat 进行WS 开发，由于现在更多的都是使用 SpringBoot 的内嵌容器了，所以这次我们就来按照 SpringBoot 内嵌容器的方式来演示。</p>
<p>首先是引入 <code>SpringBoot - Web</code> 的依赖，因为这个依赖中引入了内嵌式容器 Tomcat：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>接着就是将一个类定义为 WS 服务器，这一步也很简单，只需要为这个类加上<code>@ServerEndpoint</code>注解就可以了，在这个注解中比较常用的有三个参数：WS路径、序列化处理类、反序列化处理类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ServerEndpoint &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    String[] subprotocols() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Decoder&gt;[] decoders() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Encoder&gt;[] encoders() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Configurator&gt; configurator() <span class="keyword">default</span> Configurator.class;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>接下来我们来看具体的一个 WS 服务器类示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ServerEndpoint(&quot;/j2ee-ws/&#123;msg&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建立连接成功调用</span></span><br><span class="line">    <span class="meta">@OnOpen</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(Session session, <span class="meta">@PathParam(value = &quot;msg&quot;)</span> String msg)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WebSocketServer 收到连接: &quot;</span> + session.getId() + <span class="string">&quot;, 当前消息：&quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//收到客户端信息</span></span><br><span class="line">    <span class="meta">@OnMessage</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Session session, String message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        message = <span class="string">&quot;WebSocketServer 收到连接：&quot;</span> + session.getId() +  <span class="string">&quot;，已收到消息：&quot;</span> + message;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">        session.getBasicRemote().sendText(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接关闭</span></span><br><span class="line">    <span class="meta">@OnClose</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onclose</span><span class="params">(Session session)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在以上代码中，我们着重关心 WS 相关的注解，主要有以下四个：</p>
<ol>
<li><code>@ServerEndpoint</code> ： 这里就像 RequestMapping 一样，放入一个 WS 服务器监听的 URL。</li>
<li><code>@OnOpen</code> ：这个注解修饰的方法会在 WS 连接开始时执行。</li>
<li><code>@OnClose</code> ：这个注解修饰的方法则会在 WS 关闭时执行。</li>
<li><code>@OnMessage</code> ：这个注解则是修饰消息接受的方法，并且由于消息有文本和二进制两种方式，所以此方法参数上可以使用 String 或者二进制数组的方式，就像下面这样：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OnMessage</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Session session, String message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@OnMessage</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Session session, <span class="keyword">byte</span>[] message)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>除了以上这几个以外，常用的功能方面还差一个分片消息、Ping 消息 和 Pong 消息，对于这三个功能我并没有查到相关用法，只在源码的接口列表中看到了一个 PongMessage 接口，有知道的读者朋友们有知道的可以在评论区指出。</p>
<p>细心的小伙伴们可能发现了，示例中的 WebSocketServer 类还有一个 <code>@Component 注解</code>，这是由于我们使用的是内嵌容器，而内嵌容器需要被 Spring 管理并初始化，所以需要给 WebSocketServer 类加上这么一个注解，所以代码中还需要有这么一个配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServerEndpointExporter <span class="title">serverEndpointExporter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServerEndpointExporter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>Tips</strong>：在不使用内嵌容器的时候可以不做以上步骤。</p>
<p>最后上个简陋的 WS 效果示例图，前端方面直接使用 HTML5 的 WebScoket 标准库，具体可以查看我的仓库代码：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/22/1005-A2Or0g.jpg" alt="img"></p>
<h2 id="Spring-方式"><a href="#Spring-方式" class="headerlink" title="Spring 方式"></a>Spring 方式</h2><p>第二部分来说 Spring 方式，Spring 作为 Java 开发界的老大哥，几乎封装了一切可以封装的，对于 WS 开发呢 Spring 也提供了一套相关支持，而且从使用方面我觉得要比 J2EE 的更易用。</p>
<p>使用它的第一步我们先引入 <code>SpringBoot - WS</code> 依赖，这个依赖包也会隐式依赖 SpringBoot - Web 包：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>第二步就是准备一个用来处理 WS 请求的 Handle了，Spring 为此提供了一个接口—— WebSocketHandler，我们可以通过实现此接口重写其接口方法的方式自定义逻辑，我们来看一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringSocketHandle</span> <span class="keyword">implements</span> <span class="title">WebSocketHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterConnectionEstablished</span><span class="params">(WebSocketSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SpringSocketHandle, 收到新的连接: &quot;</span> + session.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(WebSocketSession session, WebSocketMessage&lt;?&gt; message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String msg = <span class="string">&quot;SpringSocketHandle, 连接：&quot;</span> + session.getId() +  <span class="string">&quot;，已收到消息。&quot;</span>;</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">        session.sendMessage(<span class="keyword">new</span> TextMessage(msg));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleTransportError</span><span class="params">(WebSocketSession session, Throwable exception)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WS 连接发生错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterConnectionClosed</span><span class="params">(WebSocketSession session, CloseStatus closeStatus)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WS 关闭连接&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 支持分片消息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsPartialMessages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>上面这个例子很好的展示了 WebSocketHandler 接口中的五个函数，通过名字我们就应该知道它具有什么功能了：</p>
<ol>
<li><strong>afterConnectionEstablished</strong>：连接成功后调用。</li>
<li><strong>handleMessage</strong>：处理发送来的消息。</li>
<li><strong>handleTransportError：</strong> WS 连接出错时调用。</li>
<li><strong>afterConnectionClosed</strong>：连接关闭后调用。</li>
<li><strong>supportsPartialMessages</strong>：是否支持分片消息。</li>
</ol>
<p>以上这几个方法重点可以来看一下 handleMessage 方法，handleMessage 方法中有一个 <code>WebSocketMessage</code> 参数，这也是一个接口，我们一般不直接使用这个接口而是使用它的实现类，它有以下几个实现类：</p>
<ol>
<li><strong>BinaryMessage</strong>：二进制消息体</li>
<li><strong>TextMessage</strong>：文本消息体</li>
<li><strong>PingMessage：</strong> Ping <em>**</em>消息体</li>
<li><strong>PongMessage：</strong> Pong <em>**</em>消息体</li>
</ol>
<p>但是由于 <code>handleMessage</code> 这个方法参数是<code>WebSocketMessage</code>，所以我们实际使用中可能需要判断一下当前来的消息具体是它的哪个子类，比如这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(WebSocketSession session, WebSocketMessage&lt;?&gt; message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (message <span class="keyword">instanceof</span> TextMessage) &#123;</span><br><span class="line">            <span class="keyword">this</span>.handleTextMessage(session, (TextMessage)message);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message <span class="keyword">instanceof</span> BinaryMessage) &#123;</span><br><span class="line">            <span class="keyword">this</span>.handleBinaryMessage(session, (BinaryMessage)message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>但是总这样写也不是个事，为了避免这些重复性代码，Spring 给我们定义了一个 <code>AbstractWebSocketHandler</code>，它已经封装了这些重复劳动，我们可以直接继承这个类然后重写我们想要处理的消息类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handleTextMessage</span><span class="params">(WebSocketSession session, TextMessage message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handleBinaryMessage</span><span class="params">(WebSocketSession session, BinaryMessage message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">handlePongMessage</span><span class="params">(WebSocketSession session, PongMessage message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>上面这部分都是对于 Handle 的操作，有了 Handle 之后我们还需要将它绑定在某个 URL 上，或者说监听某个 URL，那么必不可少的需要以下配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocket</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringSocketConfig</span> <span class="keyword">implements</span> <span class="title">WebSocketConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SpringSocketHandle springSocketHandle;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerWebSocketHandlers</span><span class="params">(WebSocketHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addHandler(springSocketHandle, <span class="string">&quot;/spring-ws&quot;</span>).setAllowedOrigins(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>这里我把我的自定义 Handle 注册到 <code>&quot;/spring-ws&quot;</code> 上面并设置了一下跨域，在整个配置类上还要打上<code>@EnableWebSocket</code> 注解，用于开启 WS 监听。</p>
<p>Spring 的方式也就以上这些内容了，不知道大家是否感觉 Spring 所提供的 WS 封装要比 J2EE 的更方便也更全面一些，起码我只要看 <strong>WebSocketHandler</strong> 接口就能知道所有常用功能的用法，所以对于 WS 开发来说我是比较推荐 Spring 方式的。</p>
<p>最后上个简陋的 WS 效果示例图，前端方面直接使用 HTML5 的 WebScoket 标准库，具体可以查看我的仓库代码：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/11/0800-wDUc79.awebp" alt="img"></p>
<h2 id="SocketIO-方式"><a href="#SocketIO-方式" class="headerlink" title="SocketIO 方式"></a>SocketIO 方式</h2><p>SocketIO 方式和上面两种有点不太一样，因为 SocketIO 诞生初就是为了兼容性作为考量的，前端的读者们应该对它更熟悉，因为它是一个 JS 库，我们先来看一下维基百科对它的定义：</p>
<p>Socket.IO 是一个面向实时 web 应用的 JavaScript 库。它使得服务器和客户端之间实时双向的通信成为可能。他有两个部分：在浏览器中运行的客户端库，和一个面向Node.js的服务端库，两者有着几乎一样的API。</p>
<p>Socket.IO 主要使用WebSocket协议。但是如果需要的话，Socket.io可以回退到几种其它方法，例如Adobe Flash Sockets，JSONP拉取，或是传统的AJAX拉取，并且在同时提供完全相同的接口。</p>
<p>所以我觉得使用它更多是因为兼容性，因为 HTML5 之后原生的 WS 应该也够用了，然而它是一个前端库，所以 Java 语言这块并没有官方支持，好在民间大神已经以 Netty 为基础开发了能与它对接的 Java 库： <code>netty-socketio</code>。</p>
<p>不过我要先给大家提个醒，不再建议使用它了，不是因为它很久没更新了，而是因为它支持的 Socket-Client 版本太老了，截止到 2022-04-29 日，SocketIO 已经更新到 4.X 了，但是 NettySocketIO 还只支持 2.X 的 Socket-Client 版本。</p>
<p>说了这么多，该教大家如何使用它了，第一步还是引入最新的依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.corundumstudio.socketio<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-socketio<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>第二步就是配置一个 WS 服务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketIoConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SocketIOServer <span class="title">socketIOServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        com.corundumstudio.socketio.Configuration config = <span class="keyword">new</span> com.corundumstudio.socketio.Configuration();</span><br><span class="line"></span><br><span class="line">        config.setHostname(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">        config.setPort(<span class="number">8001</span>);</span><br><span class="line">        config.setContext(<span class="string">&quot;/socketio-ws&quot;</span>);</span><br><span class="line">        SocketIOServer server = <span class="keyword">new</span> SocketIOServer(config);</span><br><span class="line">        server.start();</span><br><span class="line">        <span class="keyword">return</span> server;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SpringAnnotationScanner <span class="title">springAnnotationScanner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SpringAnnotationScanner(socketIOServer());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>大家在上文的配置中，可以看到设置了一些 Web 服务器参数，比如：端口号和监听的 path，并将这个服务启动起来，服务启动之后日志上会打印这样一句日志：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ntLoopGroup-<span class="number">2</span>-<span class="number">1</span>] c.c.socketio.SocketIOServer : SocketIO server started at port: <span class="number">8001</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>这就代表启动成功了，接下来就是要对 WS 消息做一些处理了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketIoHandle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 客户端连上socket服务器时执行此事件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> client</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnConnect</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConnect</span><span class="params">(SocketIOClient client)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SocketIoHandle 收到连接：&quot;</span> + client.getSessionId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 客户端断开socket服务器时执行此事件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> client</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@OnDisconnect</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDisconnect</span><span class="params">(SocketIOClient client)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前链接关闭：&quot;</span> + client.getSessionId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnEvent( value = &quot;onMsg&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(SocketIOClient client, AckRequest request, Object data)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;SocketIoHandle 收到消息：&quot;</span> + data);</span><br><span class="line">        request.isAckRequested();</span><br><span class="line">        client.sendEvent(<span class="string">&quot;chatMsg&quot;</span>, <span class="string">&quot;我是 NettySocketIO 后端服务，已收到连接：&quot;</span> + client.getSessionId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>我相信对于以上代码，前两个方法是很好懂的，但是对于第三个方法如果大家没有接触过 SocketIO 就比较难理解了，为什么<code>@OnEvent( value = &quot;onMsg&quot;)</code>里面这个值是自定义的，这就涉及到 SocketIO 里面发消息的机制了，通过 SocketIO 发消息是要发给某个事件的，所以这里的第三个方法就是监听 发给<code>onMsg</code>事件的所有消息，监听到之后我又给客户端发了一条消息，这次发给的事件是：<code>chatMsg</code>，客户端也需要监听此事件才能接收到这条消息。</p>
<p>最后再上一个简陋的效果图：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/11/0801-vF70Qs.awebp" alt="img"></p>
<p>由于前端代码不再是标准的 HTML5 的连接方式，所以我这里简要贴一下相关代码，具体更多内容可以看我的代码仓库：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function">function <span class="title">changeSocketStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        let element = document.getElementById(<span class="string">&quot;socketStatus&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (socketStatus) &#123;</span><br><span class="line">            element.textContent = <span class="string">&quot;关闭WebSocket&quot;</span>;</span><br><span class="line">            <span class="keyword">const</span> socketUrl=<span class="string">&quot;ws://127.0.0.1:8001&quot;</span>;</span><br><span class="line">            socket = io.connect(socketUrl, &#123;</span><br><span class="line">                transports: [<span class="string">&#x27;websocket&#x27;</span>],</span><br><span class="line">                path: <span class="string">&quot;/socketio-ws&quot;</span></span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//打开事件</span></span><br><span class="line">            socket.on(<span class="string">&#x27;connect&#x27;</span>, () =&gt; &#123;</span><br><span class="line">                console.log(<span class="string">&quot;websocket已打开&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//获得消息事件</span></span><br><span class="line">            socket.on(<span class="string">&#x27;chatMsg&#x27;</span>, (msg) =&gt; &#123;</span><br><span class="line">                <span class="keyword">const</span> serverMsg = <span class="string">&quot;收到服务端信息：&quot;</span> + msg;</span><br><span class="line">                pushContent(serverMsg, <span class="number">2</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//关闭事件</span></span><br><span class="line">            socket.on(<span class="string">&#x27;disconnect&#x27;</span>, () =&gt; &#123;</span><br><span class="line">                console.log(<span class="string">&quot;websocket已关闭&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">//发生了错误事件</span></span><br><span class="line">            socket.on(<span class="string">&#x27;connect_error&#x27;</span>, () =&gt; &#123;</span><br><span class="line">                console.log(<span class="string">&quot;websocket发生了错误&quot;</span>);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<h2 id="第四种方式？"><a href="#第四种方式？" class="headerlink" title="第四种方式？"></a>第四种方式？</h2><p>第四种方式其实就是 Netty 了，Netty 作为 Java 界大名鼎鼎的开发组件，对于常见协议也全部进行了封装，所以我们可以直接在 Netty 中去很方便的使用 WebSocket，接下来我们可以看看 Netty 怎么作为 WS 的服务器进行开发。</p>
<p>注意：以下内容如果没有 Netty 基础可能一脸蒙的进，一脸蒙的出，不过还是建议大家看看，Netty 其实很简单。</p>
<p>第一步需要先引入一个 Netty 开发包，我这里为了方便一般都是 All In：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.75.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>第二步的话就需要启动一个 Netty 容器了，配置很多，但是比较关键的也就那几个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSocketNettServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        NioEventLoopGroup boss = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        NioEventLoopGroup work = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            bootstrap</span><br><span class="line">                    .group(boss, work)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">//设置保持活动连接状态</span></span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                    .localAddress(<span class="number">8080</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.DEBUG))</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ch.pipeline()</span><br><span class="line">                                    <span class="comment">// HTTP 请求解码和响应编码</span></span><br><span class="line">                                    .addLast(<span class="keyword">new</span> HttpServerCodec())</span><br><span class="line">                                    <span class="comment">// HTTP 压缩支持</span></span><br><span class="line">                                    .addLast(<span class="keyword">new</span> HttpContentCompressor())</span><br><span class="line">                                    <span class="comment">// HTTP 对象聚合完整对象</span></span><br><span class="line">                                    .addLast(<span class="keyword">new</span> HttpObjectAggregator(<span class="number">65536</span>))</span><br><span class="line">                                    <span class="comment">// WebSocket支持</span></span><br><span class="line">                                    .addLast(<span class="keyword">new</span> WebSocketServerProtocolHandler(<span class="string">&quot;/ws&quot;</span>))</span><br><span class="line">                                    .addLast(WsTextInBoundHandle.INSTANCE);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//绑定端口号，启动服务端</span></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.bind().sync();</span><br><span class="line">            System.out.println(<span class="string">&quot;WebSocketNettServer启动成功&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//对关闭通道进行监听</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            boss.shutdownGracefully().syncUninterruptibly();</span><br><span class="line">            work.shutdownGracefully().syncUninterruptibly();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>以上代码我们主要关心端口号和重写的 <code>ChannelInitializer</code> 就行了，里面我们定义了五个过滤器（Netty 使用责任链模式），前面三个都是 HTTP 请求的常用过滤器（毕竟 WS 握手是使用 HTTP 头的所以也要配置 HTTP 支持），第四个则是 WS 的支持，它会拦截 <code>/ws</code> 路径，最关键的就是第五个了过滤器它是我们具体的业务逻辑处理类，效果基本和 Spring 那部门中的 Handle 差不多，我们来看看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WsTextInBoundHandle</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">TextWebSocketFrame</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">WsTextInBoundHandle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化 WsTextInBoundHandle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WsTextInBoundHandle 收到了连接&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, TextWebSocketFrame msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        String str = <span class="string">&quot;WsTextInBoundHandle 收到了一条消息, 内容为：&quot;</span> + msg.text();</span><br><span class="line"></span><br><span class="line">        System.out.println(str);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;-----------WsTextInBoundHandle 处理业务逻辑-----------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String responseStr = <span class="string">&quot;&#123;&quot;</span>status<span class="string">&quot;:200, &quot;</span>content<span class="string">&quot;:&quot;</span>收到<span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        ctx.channel().writeAndFlush(<span class="keyword">new</span> TextWebSocketFrame(responseStr));</span><br><span class="line">        System.out.println(<span class="string">&quot;-----------WsTextInBoundHandle 数据回复完毕-----------&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;WsTextInBoundHandle 消息收到完毕&quot;</span>);</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;WsTextInBoundHandle 连接逻辑中发生了异常&quot;</span>);</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>这里面的方法我都不说了，看名字就差不多知道了，主要是看一下这个类的泛型：<strong>TextWebSocketFrame</strong>，很明显这是一个 WS 文本消息的类，我们顺着它的定义去看发现它继承了 <strong>WebSocketFrame</strong>，接着我们去看它的子类：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/11/0801-THU9Ds.awebp" alt="img"></p>
<p>一图胜千言，我想不用多说大家也都知道具体的类是处理什么消息了把，在上文的示例中我们是一定了一个文本 WS 消息的处理类，如果你想处理其他数据类型的消息，可以将泛型中的 <strong>TextWebSocketFrame</strong> 换成其他 <strong>WebSocketFrame</strong> 类就可以了 <strong>。</strong></p>
<p>至于为什么没有连接成功后的处理，这个是和 Netty 的相关机制有关，可以在 <strong>channelActive</strong> 方法中处理，大家有兴趣的可以了解一下 Netty。</p>
<p>最后上个简陋的 WS 效果示例图，前端方面直接使用 HTML5 的 WebScoket 标准库，具体可以查看我的仓库代码：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/11/0803-UL861t.awebp" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>洋洋洒洒五千字，有了收获别忘赞。</strong></p>
<p>在上文中，我总共介绍了四种在 Java 中使用 WS 的方式，从我个人使用意向来说我感觉应该是这样的：<code>Spring 方式 &gt; Netty 方式 &gt; J2EE 方式 &gt; SocketIO 方式</code>，当然了，如果你的业务存在浏览器兼容性问题，其实只有一种选择：SocketIO。</p>
<p>最后，我估计某些读者会去具体拉代码看代码，所以我简单说一下代码结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">├─java</span><br><span class="line">│  └─com</span><br><span class="line">│      └─example</span><br><span class="line">│          └─springwebsocket</span><br><span class="line">│              │  SpringWebsocketApplication.java</span><br><span class="line">│              │  TestController.java</span><br><span class="line">│              │</span><br><span class="line">│              ├─j2ee</span><br><span class="line">│              │      WebSocketConfig.java</span><br><span class="line">│              │      WebSocketServer.java</span><br><span class="line">│              │</span><br><span class="line">│              ├─socketio</span><br><span class="line">│              │      SocketIoConfig.java</span><br><span class="line">│              │      SocketIoHandle.java</span><br><span class="line">│              │</span><br><span class="line">│              └─spring</span><br><span class="line">│                      SpringSocketConfig.java</span><br><span class="line">│                      SpringSocketHandle.java</span><br><span class="line">│</span><br><span class="line">└─resources</span><br><span class="line">    └─templates</span><br><span class="line">            J2eeIndex.html</span><br><span class="line">            SocketIoIndex.html</span><br><span class="line">            SpringIndex.html</span><br></pre></td></tr></table></figure>
<p>代码结构如上所示，应用代码分成了三个文件夹，分别放着三种方式的具体示例代码，在资源文件夹下的 <strong>templates</strong> 文件夹也有三个 HTML 文件，就是对应三种示例的 HTML 页面，里面的链接地址和端口我都预设好了，拉下来直接单独编译此模块运行即可。</p>
<p>我没有往里面放 Netty 的代码，是因为感觉 Netty 部分内容很少，文章示例中的代码直接复制就能用，后面如果写 Netty 的话会再开一个 Netty 模块用来放 Netty 相关的代码。</p>

      
    </div>
   <div>
        
    </div>

   
    
    
    
      

      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>

  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xuemingde.com/posts/9MAECS.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/touxiang.jpeg">
      <meta itemprop="name" content="meadel">
      <meta itemprop="description" content="我的愿望，世界和平">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Middle's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/9MAECS.html" class="post-title-link" itemprop="url">死锁产生的原因有哪些</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-09 00:00:00" itemprop="dateCreated datePublished" datetime="2022-05-09T00:00:00+08:00">2022-05-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-13 16:46:48" itemprop="dateModified" datetime="2022-08-13T16:46:48+08:00">2022-08-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99/" itemprop="url" rel="index"><span itemprop="name">面试资料</span></a>
                </span>
            </span>

          
            <span id="/posts/9MAECS.html" class="post-meta-item leancloud_visitors" data-flag-title="死锁产生的原因有哪些" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/posts/9MAECS.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/posts/9MAECS.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>原文：<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vcG9zdC83MDk2Mjg2OTQwMzQwNjgyNzY1">面试突击47：死锁产生的原因有哪些？ - 掘金<i class="fa fa-external-link-alt"></i></span></p>
</blockquote>
<p>死锁（Dead Lock）指的是两个或两个以上的运算单元（进程、线程或协程），都在等待对方释放资源，但没有一方提起释放资源，从而造成了一种阻塞的现象就称为死锁。</p>
<p>比如线程 1 拥有了锁 A 的情况下试图获取锁 B，而线程 2 又在拥有了锁 B 的情况下试图获取锁 A，这样双方就进入相互阻塞等待的情况，如下图所示：</p>
<p> <img data-src="https://xuemingde.com/pages/image/2022/05/12/0955-fqncX4.awebp" alt="img"> 死锁的代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object lockA = <span class="keyword">new</span> Object();</span><br><span class="line">        Object lockB = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="comment">// 创建线程 1</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 1.占有锁 A</span></span><br><span class="line">            <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1：获得锁A。&quot;</span>);</span><br><span class="line">                <span class="comment">// 休眠 1s（让线程 2 有时间先占有锁 B）</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 2.获取线程 2 的锁 B</span></span><br><span class="line">                <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程1：获得锁B。&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">// 创建线程 2</span></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 1.占有锁 B</span></span><br><span class="line">            <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2：获得锁B。&quot;</span>);</span><br><span class="line">                <span class="comment">// 休眠 1s（保证线程 1 能有充足的时间得到锁 A）</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 2.获取线程 1 的锁 A</span></span><br><span class="line">                <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程2：获得锁A。&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上程序的执行结果如下图所示：</p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/12/0956-DCgUAx.awebp" alt="image.png"> </p>
<p>从上述结果可以看出，线程 1 和线程 2 都在等待对方释放锁，这样就造成了死锁问题。</p>
<h2 id="死锁产生原因"><a href="#死锁产生原因" class="headerlink" title="死锁产生原因"></a>死锁产生原因</h2><p>死锁的产生需要满足以下 4 个条件：</p>
<ol>
<li><strong>互斥条件</strong>：指运算单元（进程、线程或协程）对所分配到的资源具有排它性，也就是说在一段时间内某个锁资源只能被一个运算单元所占用。</li>
<li><strong>请求和保持条件</strong>：指运算单元已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它运算单元占有，此时请求运算单元阻塞，但又对自己已获得的其它资源保持不放。</li>
<li><strong>不可剥夺条件</strong>：指运算单元已获得的资源，在未使用完之前，不能被剥夺。</li>
<li><strong>环路等待条件</strong>：指在发生死锁时，必然存在运算单元和资源的环形链，即运算单元正在等待另一个运算单元占用的资源，而对方又在等待自己占用的资源，从而造成环路等待的情况。</li>
</ol>
<p>只有以上 4 个条件同时满足，才会造成死锁。</p>
<h2 id="解决死锁"><a href="#解决死锁" class="headerlink" title="解决死锁"></a>解决死锁</h2><p>死锁产生要满足以上 4 个必要条件，那么我们只需要改变其中的 1 个或多个条件就可以解决死锁的问题了，比如我们可以通过修改获取锁的顺序来改变环路等待条件。</p>
<p>在未修改获取锁的顺序前，程序的执行流程是这样的：</p>
<p> <img data-src="https://xuemingde.com/pages/image/2022/05/12/0956-sCDNd1.awebp" alt="image.png"> 其中 ① 表示先执行，② 表示后执行。 而改变锁的获取顺序之后的执行流程是这样的： </p>
<p><img data-src="https://xuemingde.com/pages/image/2022/05/12/0956-AaAM59.awebp" alt="image.png"> 此时线程 1 和线程 2 获取锁的顺序是一致的，都是先获取锁 A，再获取锁 B，此时它们的执行流程如下：</p>
<ol>
<li>线程 1 先获取到锁 A；</li>
<li>线程 1 获取到锁 B；</li>
<li>线程 1 释放了锁 B；</li>
<li>线程 1 释放了锁 A；</li>
<li>线程 2 获取到了锁 A；</li>
<li>线程 2 获取到了锁 B；</li>
<li>线程 2 释放了锁 B；</li>
<li>线程 2 释放了锁 A。</li>
</ol>
<p>对应的实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeadLockTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object lockA = <span class="keyword">new</span> Object();</span><br><span class="line">        Object lockB = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="comment">// 创建线程 1</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 1.获取锁 A</span></span><br><span class="line">            <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1：获得锁A。&quot;</span>);</span><br><span class="line">                <span class="comment">// 休眠 1s</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 2.获取锁 B</span></span><br><span class="line">                <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程1：获得锁B。&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程1：释放锁B。&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程1：释放锁A。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">// 创建线程 2</span></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 1.获取锁 A</span></span><br><span class="line">            <span class="keyword">synchronized</span> (lockA) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2：获得锁A。&quot;</span>);</span><br><span class="line">                <span class="comment">// 2.获取锁</span></span><br><span class="line">                <span class="keyword">synchronized</span> (lockB) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程2：获得锁B。&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程2：释放锁B。&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程2：释放锁A。&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上程序的执行结果如下图所示：</p>
<p> <img data-src="https://xuemingde.com/pages/image/2022/05/12/0956-FtqaT9.awebp" alt="image.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>死锁（Dead Lock）指的是两个或两个以上的运算单元（进程、线程或协程），都在等待对方释放资源，但没有一方提前释放资源，从而造成了一种阻塞的现象就称为死锁。<strong>产生死锁需要同时满足 4 个条件：互斥条件、请求和保持条件、不可剥夺条件、环路等待条件，因此我们只需要破坏其中 1 个或多个条件就可以解决死锁的问题了</strong>。</p>

      
    </div>
   <div>
        
    </div>

   
    
    
    
      

      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>

  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/31/">31</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



           </div>
          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

          
        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="meadel"
      src="/images/touxiang.jpeg">
  <p class="site-author-name" itemprop="name">meadel</p>
  <div class="site-description" itemprop="description">我的愿望，世界和平</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">154</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uY24vdXNlci80MDE5NDcwMjQ0MjU4NTUyL3Bvc3Rz" title="掘金 → https:&#x2F;&#x2F;juejin.cn&#x2F;user&#x2F;4019470244258552&#x2F;posts"><i class="fa fa-share-alt fa-fw"></i>掘金</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3h1ZV9taW5k" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;xue_mind"><i class="fa fa-th-list fa-fw"></i>CSDN</span>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-star"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">meadel</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">846k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">12:49</span>
</div>
  <div class="powered-by">这个世界会好吗？我是那么热爱这个世界。  </div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="js/canvas-ribbon.js"></script>
  <script src="//lib.baomitu.com/animejs/3.2.1/anime.min.js"></script>
  <script src="//lib.baomitu.com/next-theme-pjax/0.5.0/pjax.min.js"></script>
  <script src="//lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script>
  <script src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js"></script>
  <script src="//lib.baomitu.com/medium-zoom/1.0.6/medium-zoom.min.js"></script>
  <script src="https://lib.baomitu.com/lozad.js/1.16.0/lozad.min.js"></script>
  <script src="https://lib.baomitu.com/pangu/4.0.7/pangu.min.js"></script>
  <script src="//lib.baomitu.com/velocity/1.5.2/velocity.min.js"></script>
  <script src="//lib.baomitu.com/velocity/1.5.2/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>


  <script defer src="js/three.min.js"></script>


  
  <script data-pjax>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>



  <script data-pjax>
  if (CONFIG.page.isPost) {
    wpac_init = window.wpac_init || [];
    wpac_init.push({
      widget: 'Rating',
      id    : 34163,
      el    : 'wpac-rating',
      color : 'fc6423'
    });
    (function() {
      if ('WIDGETPACK_LOADED' in window) return;
      WIDGETPACK_LOADED = true;
      var mc = document.createElement('script');
      mc.type = 'text/javascript';
      mc.async = true;
      mc.src = '//embed.widgetpack.com/widget.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
    })();
  }
  </script>

  
<script src="/js/local-search.js"></script>









<script data-pjax>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




    <div id="pjax">
  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//lib.baomitu.com/valine/1.4.17/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'xOnoKG9QyBMz9vYupNusn9fn-gzGzoHsz',
      appKey     : 'RfiNClAkp7Ewe9rlzrjAQEXC',
      placeholder: "吐槽一下...",
      avatar     : 'monsterid',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : true,
      serverURLs : '',
      requiredFields : ['nick','mail']
    });
  }, window.Valine);
});
</script>

    </div>
  <link rel="stylesheet" href="/dist/APlayer.min.css">
  <div id="aplayer"></div>
  <script type="text/javascript" src="/dist/APlayer.min.js"></script>
  <script type="text/javascript" src="/dist/music.js"></script>
</body>
</html>
